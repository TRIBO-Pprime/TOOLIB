var tipuesearch = {"pages":[{"title":" TOOLIB ","text":"TOOLIB Developer Info Arthur Francisco","tags":"home","loc":"index.html"},{"title":"pikaia_class – TOOLIB ","text":"type, public :: pikaia_class Main class for using the Pikaia algorithm.\nINIT and SOLVE are the only public methods. Inherits type~~pikaia_class~~InheritsGraph type~pikaia_class pikaia_class type~mt19937 mt19937 type~pikaia_class->type~mt19937 rand Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=wp), private :: bestft = huge(1.0_wp) real(kind=wp), private :: convergence_tol = 0.0001_wp integer, private :: convergence_window = 20 real(kind=wp), private, dimension(:), allocatable :: del real(kind=wp), private :: fdif = 1.0_wp integer, private :: ielite = 1 integer, private :: imut = 2 real(kind=wp), private :: initial_guess_frac = 0.1_wp integer, private :: irep = 1 integer, private :: iseed = 999 procedure( iter_func ), private, pointer :: iter_f => null() reporting function (best member of population) integer, private :: ivrb = 0 integer, private :: n = 0 integer, private :: nd = 5 integer, private :: ngen = 500 integer, private :: np = 100 real(kind=wp), private :: pcross = 0.85_wp real(kind=wp), private :: pmut = -huge(1.0_wp) real(kind=wp), private :: pmuti = 0.005_wp initial value of pmut real(kind=wp), private :: pmutmn = 0.0005_wp real(kind=wp), private :: pmutmx = 0.25_wp real(kind=wp), private :: pmutpv = huge(1.0_wp) type( mt19937 ), private :: rand random number generator procedure( pikaia_func ), private, pointer :: user_f => null() fitness function real(kind=wp), private, dimension(:), allocatable :: xl lower bounds of x real(kind=wp), private, dimension(:), allocatable :: xu upper bound of x Type-Bound Procedures procedure, public, non_overridable :: adjmut private  subroutine adjmut (me, oldph, fitns, ifit) Dynamical adjustment of mutation rate: Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit procedure, public, non_overridable :: cross private  subroutine cross (me, gn1, gn2) breeds two parent chromosomes into two offspring chromosomes.\n  breeding occurs through crossover. If the crossover probability\n  test yields true (crossover taking place), either one-point or\n  two-point crossover is used, with equal probabilities. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn1 integer, intent(inout), dimension(me%n*me%nd) :: gn2 procedure, public, non_overridable :: decode private  subroutine decode (me, gn, ph) decode genotype into phenotype parameters\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me integer, intent(in), dimension(me%n*me%nd) :: gn real(kind=wp), intent(out), dimension(me%n) :: ph procedure, public, non_overridable :: encode private  subroutine encode (me, ph, gn) Encode phenotype parameters into integer genotype\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me real(kind=wp), intent(in), dimension(me%n) :: ph integer, intent(out), dimension(me%n*me%nd) :: gn procedure, public, non_overridable :: ff => func_wrapper internal pikaia function (x:[0,1]) private  subroutine func_wrapper (me, x, f) Author Jacob Williams Wrapper for the user’s function that is used by the main pikaia routine\nThe x input to this function comes from pikaia, and will be between [0,1]. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out) :: f procedure, public, non_overridable :: genrep private  subroutine genrep (me, ip, ph, newph) Full generational replacement: accumulate offspring into new\npopulation array Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in) :: ip real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(out), dimension(me%n,me%np) :: newph procedure, public, non_overridable :: init => set_inputs private  subroutine set_inputs (me, n, xl, xu, f, status, iter_f, np, ngen, nd, pcross, pmutmn, pmutmx, pmut, imut, fdif, irep, ielite, ivrb, convergence_tol, convergence_window, initial_guess_frac, iseed) Author Jacob Williams Constructor for the pikaia_class .\n  The routine must be called before the solve routine can be used. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(out) :: me pikaia class integer, intent(in) :: n the parameter space dimension, i.e., the number\nof adjustable parameters (size of the x vector). real(kind=wp), intent(in), dimension(n) :: xl vector of lower bounds for x real(kind=wp), intent(in), dimension(n) :: xu vector of upper bounds for x procedure( pikaia_func ) :: f user-supplied scalar function of n variables,\nwhich must have the pikaia_func procedure interface.\nBy convention, f should return higher values for more optimal\nparameter values (i.e., individuals which are more “fit”).\nFor example, in fitting a function through data points, f\ncould return the inverse of chi**2. integer, intent(out) :: status status output flag (0 if there were no errors) procedure( iter_func ), optional :: iter_f user-supplied subroutine that will report the\nbest solution for each generation.\nIt must have the iter_func procedure interface.  If not present,\nthen it is not used.  (note: this is independent of ivrb). integer, intent(in), optional :: np number of individuals in a population (default is 100) integer, intent(in), optional :: ngen maximum number of iterations integer, intent(in), optional :: nd number of significant digits (i.e., number of\ngenes) retained in chromosomal encoding (default is 6). real(kind=wp), intent(in), optional :: pcross crossover probability; must be  <= 1.0 (default\nis 0.85). If crossover takes place, either one\nor two splicing points are used, with equal\nprobabilities real(kind=wp), intent(in), optional :: pmutmn minimum mutation rate; must be >= 0.0 (default is 0.0005) real(kind=wp), intent(in), optional :: pmutmx maximum mutation rate; must be <= 1.0 (default is 0.25) real(kind=wp), intent(in), optional :: pmut initial mutation rate; should be small (default\nis 0.005) (Note: the mutation rate is the probability\nthat any one gene locus will mutate in\nany one generation.) integer, intent(in), optional :: imut mutation mode; 1/2/3/4/5 (default is 2).\n 1=one-point mutation, fixed rate.\n 2=one-point, adjustable rate based on fitness.\n 3=one-point, adjustable rate based on distance.\n 4=one-point+creep, fixed rate.\n 5=one-point+creep, adjustable rate based on fitness.\n 6=one-point+creep, adjustable rate based on distance. real(kind=wp), intent(in), optional :: fdif relative fitness differential; range from 0\n(none) to 1 (maximum).  (default is 1.0) integer, intent(in), optional :: irep reproduction plan; 1/2/3=Full generational\nreplacement/Steady-state-replace-random/Steady-\nstate-replace-worst (default is 3) integer, intent(in), optional :: ielite elitism flag; 0/1=off/on (default is 0)\n(Applies only to reproduction plans 1 and 2) integer, intent(in), optional :: ivrb printed output 0/1/2=None/Minimal/Verbose\n(default is 0) real(kind=wp), intent(in), optional :: convergence_tol convergence tolerance; must be > 0.0 (default is 0.0001) integer, intent(in), optional :: convergence_window convergence window; must be >= 0\nThis is the number of consecutive solutions\nwithin the tolerance for convergence to\nbe declared (default is 20) real(kind=wp), intent(in), optional :: initial_guess_frac fraction of the initial population\nto set equal to the initial guess.  Range from 0\n(none) to 1.0 (all). (default is 0.1 or 10%). integer, intent(in), optional :: iseed random seed value; must be > 0 (default is 999) procedure, public, non_overridable :: mutate private  subroutine mutate (me, gn) Introduces random mutation in a genotype.\n  Mutations occur at rate pmut at all gene loci. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn procedure, public, non_overridable :: newpop private  subroutine newpop (me, oldph, newph, ifit, jfit, fitns, nnew) Replaces old population by new; recomputes fitnesses & ranks Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%n,me%np) :: newph integer, intent(out), dimension(me%np) :: ifit integer, intent(out), dimension(me%np) :: jfit real(kind=wp), intent(out), dimension(me%np) :: fitns integer, intent(out) :: nnew procedure, public, non_overridable :: pikaia private  subroutine pikaia (me, x, f, status, omp) Optimization (maximization) of user-supplied “fitness” function\n  over n-dimensional parameter space x using a basic genetic\n  algorithm method. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x Input - initial guess for solution vector.\nOutput - the “fittest” (optimal) solution found,\ni.e., the solution which maximizes the fitness function. real(kind=wp), intent(out) :: f the (scalar) value of the fitness function at x integer, intent(out) :: status an indicator of the success or failure\nof the call to pikaia (0=success; non-zero=failure) logical, intent(in), optional :: omp if OpenMP is being used procedure, public, non_overridable :: report private  subroutine report (me, oldph, fitns, ifit, ig, nnew) Write generation report to standard output Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit integer, intent(in) :: ig integer, intent(in) :: nnew procedure, public, non_overridable :: rninit private  subroutine rninit (me) Initialize the random number generator with the input seed value. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me procedure, public, non_overridable :: rnkpop private  subroutine rnkpop (me, arrin, indx, rank) Ranks initial population.\nCalls external sort routine to produce key index and rank order\nof input array arrin (which is not altered). Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%np) :: arrin integer, intent(out), dimension(me%np) :: indx integer, intent(out), dimension(me%np) :: rank procedure, public, non_overridable :: select_parents private  subroutine select_parents (me, jfit, imom, idad) Selects two parents from the population, using roulette wheel\n  algorithm with the relative fitnesses of the phenotypes as\n  the “hit” probabilities. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in), dimension(me%np) :: jfit integer, intent(out) :: imom integer, intent(out) :: idad procedure, public, non_overridable :: solve => solve_with_pikaia private  subroutine solve_with_pikaia (me, x, f, status, omp) Author Jacob Williams Main pikaia wrapper used by the class. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(out) :: f integer, intent(out) :: status logical, intent(in), optional :: omp if OpenMP is being used procedure, public, non_overridable :: stdrep private  subroutine stdrep (me, ph, fits, oldph, fitns, ifit, jfit, nnew) Steady-state reproduction: insert offspring pair into population\nonly if they are fit enough (replace-random if irep=2 or\nreplace-worst if irep=3). Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(in), dimension(2) :: fits real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%np) :: fitns integer, intent(inout), dimension(me%np) :: ifit integer, intent(inout), dimension(me%np) :: jfit integer, intent(out) :: nnew procedure, public, non_overridable :: urand private  function urand (me) result(r) Return the next pseudo-random deviate from a sequence which is\nuniformly distributed in the interval [0,1] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me Return Value real(kind=wp) Source Code type , public :: pikaia_class !! Main class for using the Pikaia algorithm. !! INIT and SOLVE are the only public methods. private integer :: n = 0 !number of solution variables real ( wp ), dimension (:), allocatable :: xl !! lower bounds of `x` real ( wp ), dimension (:), allocatable :: xu !! upper bound of `x` real ( wp ), dimension (:), allocatable :: del !other solution inputs (with default values): integer :: np = 100 integer :: ngen = 500 integer :: nd = 5 real ( wp ) :: pcross = 0.85_wp integer :: imut = 2 real ( wp ) :: pmuti = 0.005_wp !! initial value of `pmut` real ( wp ) :: pmutmn = 0.0005_wp real ( wp ) :: pmutmx = 0.25_wp real ( wp ) :: fdif = 1.0_wp integer :: irep = 1 integer :: ielite = 1 integer :: ivrb = 0 real ( wp ) :: convergence_tol = 0.0001_wp integer :: convergence_window = 20 integer :: iseed = 999 real ( wp ) :: initial_guess_frac = 0.1_wp !used internally: real ( wp ) :: pmut = - huge ( 1.0_wp ) real ( wp ) :: bestft = huge ( 1.0_wp ) real ( wp ) :: pmutpv = huge ( 1.0_wp ) type ( mt19937 ) :: rand !! random number generator !user-supplied procedures: procedure ( pikaia_func ), pointer :: user_f => null () !! fitness function procedure ( iter_func ), pointer :: iter_f => null () !! reporting function (best member of population) contains !public routines: procedure , non_overridable , public :: init => set_inputs procedure , non_overridable , public :: solve => solve_with_pikaia !private routines: procedure , non_overridable :: ff => func_wrapper !! internal pikaia function (x:[0,1]) procedure , non_overridable :: newpop procedure , non_overridable :: stdrep procedure , non_overridable :: genrep procedure , non_overridable :: adjmut procedure , non_overridable :: cross procedure , non_overridable :: encode procedure , non_overridable :: mutate procedure , non_overridable :: decode procedure , non_overridable :: select_parents procedure , non_overridable :: report procedure , non_overridable :: rnkpop procedure , non_overridable :: pikaia procedure , non_overridable :: rninit procedure , non_overridable :: urand end type pikaia_class","tags":"","loc":"type/pikaia_class.html"},{"title":"fftw_iodim – TOOLIB ","text":"type, private, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: is integer(kind=C_INT), public :: n integer(kind=C_INT), public :: os","tags":"","loc":"type/fftw_iodim.html"},{"title":"fftw_iodim64 – TOOLIB ","text":"type, private, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftw_iodim64.html"},{"title":"fftwf_iodim – TOOLIB ","text":"type, private, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: is integer(kind=C_INT), public :: n integer(kind=C_INT), public :: os","tags":"","loc":"type/fftwf_iodim.html"},{"title":"fftwf_iodim64 – TOOLIB ","text":"type, private, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: os","tags":"","loc":"type/fftwf_iodim64.html"},{"title":"tab_fftw – TOOLIB ","text":"type, private :: tab_fftw Note Because FFTW3 is built so that it works on the same memory zone, for concurrent executions,\n  a zone per thread is created. Components Type Visibility Attributes Name Initial complex(kind=C_DOUBLE_COMPLEX), public, dimension(:,:), pointer :: tab Source Code type tab_fftw complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: tab endtype tab_fftw","tags":"","loc":"type/tab_fftw.html"},{"title":"tab_fftw_real – TOOLIB ","text":"type, private :: tab_fftw_real Note Because FFTW3 is built so that it works on the same memory zone, for concurrent executions,\n  a zone per thread is created. Components Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, dimension(:,:), pointer :: tab Source Code type tab_fftw_real real ( C_DOUBLE ), dimension (:,:), pointer :: tab endtype tab_fftw_real","tags":"","loc":"type/tab_fftw_real.html"},{"title":"tborne – TOOLIB ","text":"type, public :: tborne Components Type Visibility Attributes Name Initial integer(kind=I4), public :: lb1 lower bound 1 integer(kind=I4), public :: lb2 lower bound 2 integer(kind=I4), public :: ub1 upper bound 1 integer(kind=I4), public :: ub2 upper bound 2 Source Code type tborne integer ( kind = I4 ) :: lb1 !! lower bound 1 integer ( kind = I4 ) :: ub1 !! upper bound 1 integer ( kind = I4 ) :: lb2 !! lower bound 2 integer ( kind = I4 ) :: ub2 !! upper bound 2 endtype tborne","tags":"","loc":"type/tborne.html"},{"title":"moment_stat – TOOLIB ","text":"type :: moment_stat Statistical moment type Components Type Visibility Attributes Name Initial real(kind=R8), public :: ku kurtosis real(kind=R8), public :: mu mean real(kind=R8), public :: si standard deviation real(kind=R8), public :: sk skewness real(kind=R8), public :: va variance Source Code type moment_stat !! <span style=\"color:green\">Statistical moment type</span> real ( kind = R8 ) :: mu !! *mean* real ( kind = R8 ) :: va !! *variance* real ( kind = R8 ) :: si !! *standard deviation* real ( kind = R8 ) :: sk !! *skewness* real ( kind = R8 ) :: ku !! *kurtosis* endtype moment_stat","tags":"","loc":"type/moment_stat.html"},{"title":"pCSC_ci – TOOLIB ","text":"type, public :: pCSC_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) complex(kind=r8), public, pointer :: Ax (:)","tags":"","loc":"type/pcsc_ci.html"},{"title":"pCSC_di – TOOLIB ","text":"type, public :: pCSC_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:)","tags":"","loc":"type/pcsc_di.html"},{"title":"pCSC_zi – TOOLIB ","text":"type, public :: pCSC_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","tags":"","loc":"type/pcsc_zi.html"},{"title":"pCSR_ci – TOOLIB ","text":"type, public :: pCSR_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) complex(kind=r8), public, pointer :: Ax (:)","tags":"","loc":"type/pcsr_ci.html"},{"title":"pCSR_di – TOOLIB ","text":"type, public :: pCSR_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:)","tags":"","loc":"type/pcsr_di.html"},{"title":"pCSR_zi – TOOLIB ","text":"type, public :: pCSR_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:)","tags":"","loc":"type/pcsr_zi.html"},{"title":"pVec_zi – TOOLIB ","text":"type, public :: pVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:)","tags":"","loc":"type/pvec_zi.html"},{"title":"tCSC_ci – TOOLIB ","text":"type, public :: tCSC_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) complex(kind=r8), public, allocatable :: Ax (:)","tags":"","loc":"type/tcsc_ci.html"},{"title":"tCSC_di – TOOLIB ","text":"type, public :: tCSC_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:)","tags":"","loc":"type/tcsc_di.html"},{"title":"tCSC_zi – TOOLIB ","text":"type, public :: tCSC_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","tags":"","loc":"type/tcsc_zi.html"},{"title":"tCSR_ci – TOOLIB ","text":"type, public :: tCSR_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) complex(kind=r8), public, allocatable :: Ax (:)","tags":"","loc":"type/tcsr_ci.html"},{"title":"tCSR_di – TOOLIB ","text":"type, public :: tCSR_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:)","tags":"","loc":"type/tcsr_di.html"},{"title":"tCSR_zi – TOOLIB ","text":"type, public :: tCSR_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:)","tags":"","loc":"type/tcsr_zi.html"},{"title":"tVec_zi – TOOLIB ","text":"type, public :: tVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:)","tags":"","loc":"type/tvec_zi.html"},{"title":"OBJ_SURF – TOOLIB ","text":"type, public :: OBJ_SURF C like surface object: header and heights Note Fortran surface object, adapted from ‘surffile.c’, ‘gwyddion’ software, Copyright (C) 2005 David Necas, Petr Klapetek. Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: XOffset real(kind=C_FLOAT), public :: YOffset real(kind=C_FLOAT), public :: ZOffset integer(kind=C_SHORT), public :: absolute integer(kind=C_SHORT), public :: acquisition character(kind=C_CHAR, len=1), public, dimension(128) :: client_zone integer(kind=C_SHORT), public :: comment_size integer(kind=C_SHORT), public :: day integer(kind=C_SHORT), public :: dayof real(kind=C_FLOAT), public :: dx character(kind=C_CHAR, len=1), public, dimension( 16) :: dx_unit real(kind=C_FLOAT), public :: dy character(kind=C_CHAR, len=1), public, dimension( 16) :: dy_unit real(kind=C_FLOAT), public :: dz character(kind=C_CHAR, len=1), public, dimension( 16) :: dz_unit integer(kind=C_SHORT), public :: format integer(kind=C_SHORT), public :: hours integer(kind=C_SHORT), public :: imprint integer(kind=C_SHORT), public :: inversion integer(kind=C_SHORT), public :: leveling integer(kind=C_SHORT), public :: material_code real(kind=C_FLOAT), public :: measurement_duration integer(kind=C_SHORT), public :: minutes integer(kind=C_SHORT), public :: month integer(kind=C_SHORT), public :: nobjects integer(kind=C_INT), public :: nofpoints character(kind=C_CHAR, len=1), public, dimension( 30) :: object_name character(kind=C_CHAR, len=1), public, dimension( 12) :: obsolete character(kind=C_CHAR, len=1), public, dimension( 10) :: obsolete2 character(kind=C_CHAR, len=1), public, dimension( 30) :: operator_name integer(kind=C_SHORT), public :: pointsize integer(kind=C_SHORT), public :: private_size integer(kind=C_SHORT), public :: range character(kind=C_CHAR, len=1), public, dimension(  8) :: reserved character(kind=C_CHAR, len=1), public, dimension( 34) :: reservedzone integer(kind=C_SHORT), public :: seconds character(kind=C_CHAR, len=1), public, dimension( 12) :: signature integer(kind=C_SHORT), public :: special_points integer(kind=C_SHORT), public :: type integer(kind=C_INT), public, allocatable :: val (:) heights integer(kind=C_SHORT), public :: version character(kind=C_CHAR, len=1), public, dimension( 16) :: xaxis character(kind=C_CHAR, len=1), public, dimension( 16) :: xlength_unit integer(kind=C_INT), public :: xres real(kind=C_FLOAT), public :: xunit_ratio character(kind=C_CHAR, len=1), public, dimension( 16) :: yaxis integer(kind=C_SHORT), public :: year character(kind=C_CHAR, len=1), public, dimension( 16) :: ylength_unit integer(kind=C_INT), public :: yres real(kind=C_FLOAT), public :: yunit_ratio character(kind=C_CHAR, len=1), public, dimension( 16) :: zaxis character(kind=C_CHAR, len=1), public, dimension( 16) :: zlength_unit integer(kind=C_INT), public :: zmax integer(kind=C_INT), public :: zmin real(kind=C_FLOAT), public :: zunit_ratio Source Code type OBJ_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( kind = C_CHAR ), dimension ( 12 ) :: signature character ( kind = C_CHAR ), dimension ( 16 ) :: xlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: ylength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: zlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: xaxis character ( kind = C_CHAR ), dimension ( 16 ) :: yaxis character ( kind = C_CHAR ), dimension ( 16 ) :: zaxis character ( kind = C_CHAR ), dimension ( 16 ) :: dx_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dy_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dz_unit character ( kind = C_CHAR ), dimension ( 30 ) :: object_name character ( kind = C_CHAR ), dimension ( 30 ) :: operator_name character ( kind = C_CHAR ), dimension ( 128 ) :: client_zone character ( kind = C_CHAR ), dimension ( 8 ) :: reserved character ( kind = C_CHAR ), dimension ( 34 ) :: reservedzone character ( kind = C_CHAR ), dimension ( 12 ) :: obsolete character ( kind = C_CHAR ), dimension ( 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = C_FLOAT ) :: dx real ( kind = C_FLOAT ) :: dy real ( kind = C_FLOAT ) :: dz real ( kind = C_FLOAT ) :: xunit_ratio real ( kind = C_FLOAT ) :: yunit_ratio real ( kind = C_FLOAT ) :: zunit_ratio real ( kind = C_FLOAT ) :: XOffset real ( kind = C_FLOAT ) :: YOffset real ( kind = C_FLOAT ) :: ZOffset real ( kind = C_FLOAT ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = C_INT ) :: zmin integer ( kind = C_INT ) :: zmax integer ( kind = C_INT ) :: xres integer ( kind = C_INT ) :: yres integer ( kind = C_INT ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = C_SHORT ) :: format integer ( kind = C_SHORT ) :: version integer ( kind = C_SHORT ) :: material_code integer ( kind = C_SHORT ) :: type integer ( kind = C_SHORT ) :: range integer ( kind = C_SHORT ) :: special_points integer ( kind = C_SHORT ) :: absolute integer ( kind = C_SHORT ) :: pointsize integer ( kind = C_SHORT ) :: imprint integer ( kind = C_SHORT ) :: inversion integer ( kind = C_SHORT ) :: leveling integer ( kind = C_SHORT ) :: seconds integer ( kind = C_SHORT ) :: minutes integer ( kind = C_SHORT ) :: hours integer ( kind = C_SHORT ) :: day integer ( kind = C_SHORT ) :: month integer ( kind = C_SHORT ) :: year integer ( kind = C_SHORT ) :: dayof integer ( kind = C_SHORT ) :: comment_size integer ( kind = C_SHORT ) :: private_size integer ( kind = C_SHORT ) :: nobjects integer ( kind = C_SHORT ) :: acquisition integer ( kind = C_INT ), allocatable :: val (:) !! *heights* endtype OBJ_SURF","tags":"","loc":"type/obj_surf.html"},{"title":"SCALE_SURF – TOOLIB ","text":"type, public :: SCALE_SURF Fortran typed surface object: header, dimensions, mean and std Note Fortran surface object, adapted from ‘surffile.c’, ‘gwyddion’ software, Copyright (C) 2005 David Necas, Petr Klapetek. Warning Must be 512 bytes long before length definition Components Type Visibility Attributes Name Initial real(kind=R4), public :: XOffset real(kind=R4), public :: YOffset real(kind=R4), public :: ZOffset integer(kind=2), public :: absolute integer(kind=2), public :: acquisition character(len=128), public :: client_zone integer(kind=2), public :: comment_size integer(kind=2), public :: day integer(kind=2), public :: dayof real(kind=R4), public :: dx character(len=16), public :: dx_unit real(kind=R4), public :: dy character(len=16), public :: dy_unit real(kind=R4), public :: dz character(len=16), public :: dz_unit integer(kind=2), public :: format integer(kind=2), public :: hours integer(kind=2), public :: imprint integer(kind=2), public :: inversion integer(kind=2), public :: leveling real(kind=R8), public :: lx surface length real(kind=R8), public :: ly surface width real(kind=R8), public :: lz surface height (max -min) integer(kind=2), public :: material_code real(kind=R4), public :: measurement_duration integer(kind=2), public :: minutes integer(kind=2), public :: month real(kind=R8), public :: mu surface mean height integer(kind=2), public :: nobjects integer(kind=I4), public :: nofpoints character(len=30), public :: object_name character(len=12), public :: obsolete character(len=10), public :: obsolete2 character(len=30), public :: operator_name integer(kind=2), public :: pointsize integer(kind=2), public :: private_size integer(kind=2), public :: range character(len=8), public :: reserved character(len=34), public :: reservedzone integer(kind=2), public :: seconds real(kind=R8), public :: si surface mean height character(len=12), public :: signature integer(kind=2), public :: special_points integer(kind=2), public :: type integer(kind=2), public :: version character(len=16), public :: xaxis character(len=16), public :: xlength_unit integer(kind=I4), public :: xres real(kind=R4), public :: xunit_ratio character(len=16), public :: yaxis integer(kind=2), public :: year character(len=16), public :: ylength_unit integer(kind=I4), public :: yres real(kind=R4), public :: yunit_ratio character(len=16), public :: zaxis character(len=16), public :: zlength_unit integer(kind=I4), public :: zmax integer(kind=I4), public :: zmin real(kind=R4), public :: zunit_ratio Source Code type SCALE_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( len = 12 ) :: signature character ( len = 16 ) :: xlength_unit character ( len = 16 ) :: ylength_unit character ( len = 16 ) :: zlength_unit character ( len = 16 ) :: xaxis character ( len = 16 ) :: yaxis character ( len = 16 ) :: zaxis character ( len = 16 ) :: dx_unit character ( len = 16 ) :: dy_unit character ( len = 16 ) :: dz_unit character ( len = 30 ) :: object_name character ( len = 30 ) :: operator_name character ( len = 128 ) :: client_zone character ( len = 8 ) :: reserved character ( len = 34 ) :: reservedzone character ( len = 12 ) :: obsolete character ( len = 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = R4 ) :: dx real ( kind = R4 ) :: dy real ( kind = R4 ) :: dz real ( kind = R4 ) :: xunit_ratio real ( kind = R4 ) :: yunit_ratio real ( kind = R4 ) :: zunit_ratio real ( kind = R4 ) :: XOffset real ( kind = R4 ) :: YOffset real ( kind = R4 ) :: ZOffset real ( kind = R4 ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = I4 ) :: zmin integer ( kind = I4 ) :: zmax integer ( kind = I4 ) :: xres integer ( kind = I4 ) :: yres integer ( kind = I4 ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = 2 ) :: format ! 0 integer ( kind = 2 ) :: version ! 1 integer ( kind = 2 ) :: material_code ! 1 integer ( kind = 2 ) :: type ! 2 integer ( kind = 2 ) :: range ! 0 integer ( kind = 2 ) :: special_points ! 0 integer ( kind = 2 ) :: absolute ! 1 integer ( kind = 2 ) :: pointsize ! 32 integer ( kind = 2 ) :: imprint ! 0 integer ( kind = 2 ) :: inversion ! 0 integer ( kind = 2 ) :: leveling ! 0 integer ( kind = 2 ) :: seconds ! 0 integer ( kind = 2 ) :: minutes ! 0 integer ( kind = 2 ) :: hours ! 0 integer ( kind = 2 ) :: day ! 0 integer ( kind = 2 ) :: month ! 0 integer ( kind = 2 ) :: year ! 0 integer ( kind = 2 ) :: dayof ! 0 integer ( kind = 2 ) :: comment_size ! 0 integer ( kind = 2 ) :: private_size ! 0 integer ( kind = 2 ) :: nobjects ! 1 integer ( kind = 2 ) :: acquisition ! 0 !------------- 512 bytes above real ( kind = R8 ) :: lx !! *surface length* real ( kind = R8 ) :: ly !! *surface width* real ( kind = R8 ) :: lz !! *surface height (max -min)* real ( kind = R8 ) :: mu !! *surface mean height* real ( kind = R8 ) :: si !! *surface mean height* endtype SCALE_SURF","tags":"","loc":"type/scale_surf.html"},{"title":"MAT_MA48 – TOOLIB ","text":"type, private :: MAT_MA48 All the stuff needed by HSL_MA48 Inherits type~~mat_ma48~~InheritsGraph type~mat_ma48 MAT_MA48 MA48_AINFO MA48_AINFO type~mat_ma48->MA48_AINFO ainf MA48_CONTROL MA48_CONTROL type~mat_ma48->MA48_CONTROL ctrl MA48_FACTORS MA48_FACTORS type~mat_ma48->MA48_FACTORS fact MA48_FINFO MA48_FINFO type~mat_ma48->MA48_FINFO finf MA48_SINFO MA48_SINFO type~mat_ma48->MA48_SINFO sinf ZD11_TYPE ZD11_TYPE type~mat_ma48->ZD11_TYPE zmat Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MA48_AINFO), public :: ainf type(MA48_CONTROL), public :: ctrl type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast type(MA48_FINFO), public :: finf real(kind=R8), public, dimension(2) :: resid type(MA48_SINFO), public :: sinf type(ZD11_TYPE), public :: zmat Source Code type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48","tags":"","loc":"type/mat_ma48.html"},{"title":"MAT_MA48 – TOOLIB ","text":"type, private :: MAT_MA48 Inherited by type~~mat_ma48~2~~InheritedByGraph type~mat_ma48~2 MAT_MA48 type~mat_solv MAT_SOLV type~mat_solv->type~mat_ma48~2 matma48 type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48","tags":"","loc":"type/mat_ma48~2.html"},{"title":"MAT_SOLV – TOOLIB ","text":"type, public :: MAT_SOLV MUSST high level system type Inherits type~~mat_solv~~InheritsGraph type~mat_solv MAT_SOLV MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu type~mat_ma48~2 MAT_MA48 type~mat_solv->type~mat_ma48~2 matma48 type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mat_solv~~InheritedByGraph type~mat_solv MAT_SOLV type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix logical(kind=I4), public :: ana = .false. the system is analyzed real(kind=R8), public, dimension(:), allocatable :: b right hand side vector integer(kind=I4), public :: code error code [not used yet] integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix logical(kind=I4), public :: end = .false. the system is closed real(kind=R8), public :: error error value [not used yet] logical(kind=I4), public :: fac = .false. the system is factorized logical(kind=I4), public :: fre = .false. the system is freed logical(kind=I4), public :: ini = .false. the system is initialized integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_MUMP), public :: matmump matrices for mumps solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver character(len=1024), public :: mess message [not used yet] integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: sol = .false. the system is solved real(kind=R8), public, dimension(:), allocatable :: x unknwon vector Source Code type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: ini = . false . !! *the system is initialized* logical ( kind = I4 ) :: ana = . false . !! *the system is analyzed* logical ( kind = I4 ) :: fac = . false . !! *the system is factorized* logical ( kind = I4 ) :: sol = . false . !! *the system is solved* logical ( kind = I4 ) :: fre = . false . !! *the system is freed* logical ( kind = I4 ) :: end = . false . !! *the system is closed* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV","tags":"","loc":"type/mat_solv.html"},{"title":"MAT_UMFP – TOOLIB ","text":"type, private :: MAT_UMFP All the stuff needed by UMFPACK Inherits type~~mat_umfp~~InheritsGraph type~mat_umfp MAT_UMFP c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~mat_umfp~~InheritedByGraph type~mat_umfp MAT_UMFP type~mat_solv MAT_SOLV type~mat_solv->type~mat_umfp matumfp type~ms_mat_solv MS_MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info type(c_ptr), public :: c_numeric type(c_ptr), public :: c_symbolic Source Code type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP","tags":"","loc":"type/mat_umfp.html"},{"title":"MS_MAT_SOLV – TOOLIB ","text":"type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Inherits type~~ms_mat_solv~~InheritsGraph type~ms_mat_solv MS_MAT_SOLV type~mat_solv MAT_SOLV type~ms_mat_solv->type~mat_solv ts_mat, bs_mat MAT_MUMP MAT_MUMP type~mat_solv->MAT_MUMP matmump MAT_SULU MAT_SULU type~mat_solv->MAT_SULU matsulu type~mat_ma48~2 MAT_MA48 type~mat_solv->type~mat_ma48~2 matma48 type~mat_umfp MAT_UMFP type~mat_solv->type~mat_umfp matumfp c_ptr c_ptr type~mat_umfp->c_ptr c_symbolic, c_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices Source Code type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* endtype ms_mat_solv","tags":"","loc":"type/ms_mat_solv.html"},{"title":"DMUMPS_L0OMPFAC_T – TOOLIB ","text":"type, public :: DMUMPS_L0OMPFAC_T sequence Inherited by type~~dmumps_l0ompfac_t~~InheritedByGraph type~dmumps_l0ompfac_t DMUMPS_L0OMPFAC_T type~dmumps_struc DMUMPS_STRUC type~dmumps_struc->type~dmumps_l0ompfac_t L0_OMP_FACTORS Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial double precision, public, POINTER, DIMENSION(:) :: A integer(kind=8), public :: LA","tags":"","loc":"type/dmumps_l0ompfac_t.html"},{"title":"DMUMPS_ROOT_STRUC – TOOLIB ","text":"type, public :: DMUMPS_ROOT_STRUC sequence Inherited by type~~dmumps_root_struc~~InheritedByGraph type~dmumps_root_struc DMUMPS_ROOT_STRUC type~dmumps_struc DMUMPS_STRUC type~dmumps_struc->type~dmumps_root_struc root Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer, public :: CNTXT_BLACS integer, public, DIMENSION( 9 ) :: DESCRIPTOR integer, public, DIMENSION(:), POINTER :: IPIV integer, public :: LPIV integer, public :: MBLOCK integer, public :: MYCOL integer, public :: MYROW integer, public :: NBLOCK integer, public :: NB_SINGULAR_VALUES integer, public :: NPCOL integer, public :: NPROW double precision, public :: QR_RCOND double precision, public, DIMENSION(:), POINTER :: QR_TAU integer, public, DIMENSION(:), POINTER :: RG2L_COL integer, public, DIMENSION(:), POINTER :: RG2L_ROW double precision, public, DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT integer, public :: RHS_NLOC double precision, public, DIMENSION(:,:), POINTER :: RHS_ROOT integer, public :: ROOT_SIZE integer, public :: SCHUR_LLD integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC double precision, public, DIMENSION(:), POINTER :: SCHUR_POINTER double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES double precision, public, DIMENSION(:,:), POINTER :: SVD_U double precision, public, DIMENSION(:,:), POINTER :: SVD_VT integer, public :: TOT_ROOT_SIZE logical, public :: gridinit_done double precision, public, DIMENSION(:,:), POINTER :: rootpad integer, public :: rootpad0 integer, public, DIMENSION(:), POINTER :: rootpad1 double precision, public, DIMENSION(:), POINTER :: rootpad2 double precision, public :: rootpad3 integer, public :: rootpad4 logical, public :: yes","tags":"","loc":"type/dmumps_root_struc.html"},{"title":"DMUMPS_STRUC – TOOLIB ","text":"type, public :: DMUMPS_STRUC sequence Inherits type~~dmumps_struc~~InheritsGraph type~dmumps_struc DMUMPS_STRUC type~dmumps_l0ompfac_t DMUMPS_L0OMPFAC_T type~dmumps_struc->type~dmumps_l0ompfac_t L0_OMP_FACTORS type~dmumps_root_struc DMUMPS_ROOT_STRUC type~dmumps_struc->type~dmumps_root_struc root Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial double precision, public, DIMENSION(:), POINTER :: A logical, public :: ASSOCIATED_OOC_FILES integer, public :: ASS_IRECV double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: A_loc integer, public, DIMENSION(:), POINTER :: BLKPTR integer, public, DIMENSION(:), POINTER :: BLKVAR character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public, DIMENSION(:,:), POINTER :: CANDIDATES double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE double precision, public :: CNTL (15) double precision, public, DIMENSION(:), POINTER :: COLSCA integer, public :: COMM integer, public :: COMM_LOAD integer, public :: COMM_NODES double precision, public :: COST_SUBTREES double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: CROIX_MANU integer, public, POINTER, DIMENSION(:) :: DAD_STEPS double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ double precision, public :: DKEEP (230) integer, public :: Deficiency integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: FRTELT integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: I4_L0_OMP integer(kind=8), public, DIMENSION(:,:), POINTER :: I8_L0_OMP integer, public :: ICNTL (60) integer, public :: INFO (80) integer, public :: INFOG (80) integer, public :: INSTANCE_NUMBER integer, public :: INST_Number integer, public, DIMENSION(:), POINTER :: INTARR integer, public, DIMENSION(:), POINTER :: IPOOL_A_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_B_L0_OMP integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_loc integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: JCN integer, public, DIMENSION(:), POINTER :: JCN_loc integer, public :: JOB integer, public :: KEEP (500) integer(kind=8), public :: KEEP8 (150) type( DMUMPS_L0OMPFAC_T ), public, DIMENSION(:), POINTER :: L0_OMP_FACTORS integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public :: LL0_OMP_FACTORS integer, public :: LL0_OMP_MAPPING integer, public :: LNA integer, public :: LPOOL_A_L0_OMP integer, public :: LPOOL_B_L0_OMP integer, public :: LREDRHS integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: LRHS integer, public :: LRHS_loc integer, public :: LSOL_loc integer, public :: LWK_USER integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: MAPPING integer(kind=8), public :: MAX_SURF_MASTER integer, public :: MBLOCK integer, public, DIMENSION(:), POINTER :: MEM_DIST double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE integer, public :: METIS_OPTIONS (40) integer, public, DIMENSION(:), POINTER :: MPITOOMP_PROCS_MAP integer, public :: MYID integer, public :: MYID_NODES integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public :: N integer, public, POINTER, DIMENSION(:) :: NA integer, public :: NBGRP integer, public :: NBLK integer, public :: NBLOCK integer, public :: NBSA integer, public :: NBSA_LOCAL integer, public :: NB_SINGULAR_VALUES integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public :: NELT integer, public :: NELT_loc integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer(kind=8), public :: NNZ integer(kind=8), public :: NNZ_loc integer, public :: NPCOL integer, public :: NPROCS integer, public :: NPROW integer, public :: NRHS integer, public :: NSLAVES integer, public :: NZ integer, public :: NZ_RHS integer, public :: NZ_loc integer, public :: Nloc_RHS character(len=1), public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE character(len=63), public :: OOC_PREFIX integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK character(len=255), public :: OOC_TMPDIR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public :: PAR integer, public, DIMENSION(:), POINTER :: PERM_IN integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL logical, public :: POSINRHSCOMP_COL_ALLOC integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: RHS_loc double precision, public :: RINFO (40) double precision, public :: RINFOG (40) double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: S character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public :: SCHUR_LLD integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, POINTER, DIMENSION(:) :: STEP integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public :: SYM integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: UNS_PERM character(len=30), public :: VERSION_NUMBER integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public, DIMENSION(:), POINTER :: WORKING character(len=255), public :: WRITE_PROBLEM double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: pad1 logical, public :: pad11 integer, public :: pad12 integer, public :: pad13 integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public :: pad16 double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: pad3 double precision, public, DIMENSION(:), POINTER :: pad4 integer, public :: pad5 integer, public :: pad6 character(len=7), public :: pad7 type( DMUMPS_ROOT_STRUC ), public :: root Source Code TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! !    ---------------- !    Format by blocks !    ---------------- INTEGER :: NBLK , pad5 INTEGER , DIMENSION (:), POINTER :: BLKPTR INTEGER , DIMENSION (:), POINTER :: BLKVAR ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_loc INTEGER :: LRHS , NRHS , NZ_RHS , Nloc_RHS , LRHS_loc , LREDRHS INTEGER :: LSOL_loc , pad6 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 60 ) INTEGER :: INFO ( 80 ) INTEGER :: INFOG ( 80 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) ! The options array for metis/parmetis INTEGER :: METIS_OPTIONS ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    Name of file to dump a matrix/rhs to disk !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad7 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !       PTLUST_S and PTRFAC are two pointer arrays computed during !       factorization and used by the solve INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER , DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER , DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore TYPE ( DMUMPS_L0OMPFAC_T ), DIMENSION (:), POINTER :: L0_OMP_FACTORS INTEGER :: LPOOL_A_L0_OMP , LPOOL_B_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , LL0_OMP_FACTORS INTEGER ( 8 ) :: THREAD_LA ! Estimates before L0_OMP INTEGER , DIMENSION (:,:), POINTER :: I4_L0_OMP INTEGER ( 8 ), DIMENSION (:,:), POINTER :: I8_L0_OMP ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_B_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_A_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! Mapping of amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP_MAPPING ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtree nodes INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! Mpi to omp - mumps agile INTEGER , DIMENSION (:), POINTER :: MPITOOMP_PROCS_MAP ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES INTEGER :: Deficiency , pad16 ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC","tags":"","loc":"type/dmumps_struc.html"},{"title":"mt19937 – TOOLIB ","text":"type, public :: mt19937 main class for random number generator Inherited by type~~mt19937~~InheritedByGraph type~mt19937 mt19937 type~pikaia_class pikaia_class type~pikaia_class->type~mt19937 rand Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=i8), private :: mt (nn) = 0_i8 array for the state vector integer, private :: mti = nn+1 mti==nn+1 means mt(nn) is not initialized Type-Bound Procedures procedure, public :: genrand64_int64 private  function genrand64_int64 (me) Generates a random number on [-2&#94;63, 2&#94;63-1]-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value integer(kind=r8) procedure, public :: genrand64_real1 private  function genrand64_real1 (me) Generates a random number on [0,1]-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) procedure, public :: genrand64_real2 private  function genrand64_real2 (me) Generates a random number on [0,1)-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) procedure, public :: genrand64_real3 private  function genrand64_real3 (me) Generates a random number on (0,1)-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) procedure, private :: init_by_array64 private  subroutine init_by_array64 (me, init_key) Initializes by an array with array-length init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: init_key (:) procedure, private :: init_genrand64 private  subroutine init_genrand64 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: seed procedure, private :: init_genrand64_i4 private  subroutine init_genrand64_i4 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i4), intent(in) :: seed generic, public :: initialize => init_genrand64_i4 , init_genrand64 , init_by_array64 call first to initialize private  subroutine init_genrand64_i4 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i4), intent(in) :: seed private  subroutine init_genrand64 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: seed private  subroutine init_by_array64 (me, init_key) Initializes by an array with array-length init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: init_key (:) Source Code type , public :: mt19937 !! main class for random number generator private integer ( i8 ) :: mt ( nn ) = 0_i8 !! array for the state vector integer :: mti = nn + 1 !! `mti==nn+1` means `mt(nn)` is not initialized contains private generic , public :: initialize => init_genrand64_i4 , & init_genrand64 , & init_by_array64 !! call first to initialize procedure :: init_genrand64 procedure :: init_by_array64 procedure :: init_genrand64_i4 procedure , public :: genrand64_real1 procedure , public :: genrand64_real2 procedure , public :: genrand64_real3 procedure , public :: genrand64_int64 end type mt19937","tags":"","loc":"type/mt19937.html"},{"title":"EXPHEADER – TOOLIB ","text":"type, private, bind(c) :: EXPHEADER Inherits type~~expheader~~InheritsGraph type~expheader EXPHEADER C_PTR C_PTR type~expheader->C_PTR mem Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~expheader~~InheritedByGraph type~expheader EXPHEADER type~globallu_t GLOBALLU_T type~globallu_t->type~expheader expanders type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(C_PTR), public :: mem integer(kind=C_INT), public :: size Source Code type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER","tags":"","loc":"type/expheader.html"},{"title":"GLOBALLU_T – TOOLIB ","text":"type, private, bind(c) :: GLOBALLU_T Inherits type~~globallu_t~~InheritsGraph type~globallu_t GLOBALLU_T C_PTR C_PTR type~globallu_t->C_PTR lusup, ucol type~expheader EXPHEADER type~globallu_t->type~expheader expanders type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack type~expheader->C_PTR mem type~lu_stack_t->C_PTR array Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~globallu_t~~InheritedByGraph type~globallu_t GLOBALLU_T type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: MemModel = 0 type( EXPHEADER ), public :: expanders integer(kind=C_INT), public :: lsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: num_expansions integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: nzumax type( LU_STACK_T ), public :: stack integer(kind=C_INT), public :: supno type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xlsub integer(kind=C_INT), public :: xlusup integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: xusub Source Code type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T","tags":"","loc":"type/globallu_t.html"},{"title":"LU_STACK_T – TOOLIB ","text":"type, private, bind(c) :: LU_STACK_T Inherits type~~lu_stack_t~~InheritsGraph type~lu_stack_t LU_STACK_T C_PTR C_PTR type~lu_stack_t->C_PTR array Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~lu_stack_t~~InheritedByGraph type~lu_stack_t LU_STACK_T type~globallu_t GLOBALLU_T type~globallu_t->type~lu_stack_t stack type~sulu_env SULU_ENV type~sulu_env->type~globallu_t Glu Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(C_PTR), public :: array integer(kind=C_INT), public :: size integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 integer(kind=C_INT), public :: used Source Code type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T","tags":"","loc":"type/lu_stack_t.html"},{"title":"MEM_USAGE_T – TOOLIB ","text":"type, private, bind(c) :: MEM_USAGE_T Inherited by type~~mem_usage_t~~InheritedByGraph type~mem_usage_t MEM_USAGE_T type~sulu_env SULU_ENV type~sulu_env->type~mem_usage_t mem_usage Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed Source Code type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T","tags":"","loc":"type/mem_usage_t.html"},{"title":"NCFORMAT – TOOLIB ","text":"type, private, bind(c) :: NCFORMAT Note Inherits type~~ncformat~~InheritsGraph type~ncformat NCFORMAT C_PTR C_PTR type~ncformat->C_PTR nzval, rowind, colptr Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros Source Code type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT","tags":"","loc":"type/ncformat.html"},{"title":"SULU_ENV – TOOLIB ","text":"type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Inherits type~~sulu_env~~InheritsGraph type~sulu_env SULU_ENV C_PTR C_PTR type~sulu_env->C_PTR work type~globallu_t GLOBALLU_T type~sulu_env->type~globallu_t Glu type~mem_usage_t MEM_USAGE_T type~sulu_env->type~mem_usage_t mem_usage type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env->type~superlu_options_t options type~superlustat_t SUPERLUSTAT_T type~sulu_env->type~superlustat_t stat type~supermatrix SUPERMATRIX type~sulu_env->type~supermatrix sma, smb, smx, sml, smu type~globallu_t->C_PTR lusup, ucol type~expheader EXPHEADER type~globallu_t->type~expheader expanders type~lu_stack_t LU_STACK_T type~globallu_t->type~lu_stack_t stack type~superlustat_t->C_PTR panel_histo, utime, ops type~supermatrix->C_PTR Store type~expheader->C_PTR mem type~lu_stack_t->C_PTR array Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution character(kind=C_CHAR, len=1), public :: equed form of equilibration integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector logical(kind=I4), public :: first if false the system has been factorized at least once integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr integer(kind=C_INT), public :: lwork size of workspace, not used here type( MEM_USAGE_T ), public :: mem_usage memory usage statistics integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries type( SUPERLU_OPTIONS_T ), public :: options LU controls integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type(C_PTR), public :: work User supplied workspace real(kind=R8), public, allocatable, dimension(:) :: x solution Source Code type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV","tags":"","loc":"type/sulu_env.html"},{"title":"SUPERLUSTAT_T – TOOLIB ","text":"type, private, bind(c) :: SUPERLUSTAT_T Inherits type~~superlustat_t~~InheritsGraph type~superlustat_t SUPERLUSTAT_T C_PTR C_PTR type~superlustat_t->C_PTR panel_histo, utime, ops Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~superlustat_t~~InheritedByGraph type~superlustat_t SUPERLUSTAT_T type~sulu_env SULU_ENV type~sulu_env->type~superlustat_t stat Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: expansions number of memory expansions type(C_PTR), public :: ops operation count at various phases type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases Source Code type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T","tags":"","loc":"type/superlustat_t.html"},{"title":"SUPERLU_OPTIONS_T – TOOLIB ","text":"type, private, bind(c) :: SUPERLU_OPTIONS_T = FACTORED: On entry, L, U, perm_r and perm_c contain the Inherited by type~~superlu_options_t~~InheritedByGraph type~superlu_options_t SUPERLU_OPTIONS_T type~sulu_env SULU_ENV type~sulu_env->type~superlu_options_t options Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: ConditionNumber real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ILU_Norm integer(kind=C_INT), public :: IterRefine integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: SymPattern symmetric factorization integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead Source Code type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T","tags":"","loc":"type/superlu_options_t.html"},{"title":"SUPERMATRIX – TOOLIB ","text":"type, private, bind(c) :: SUPERMATRIX Inherits type~~supermatrix~~InheritsGraph type~supermatrix SUPERMATRIX C_PTR C_PTR type~supermatrix->C_PTR Store Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~supermatrix~~InheritedByGraph type~supermatrix SUPERMATRIX type~sulu_env SULU_ENV type~sulu_env->type~supermatrix sma, smb, smx, sml, smu Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: ncol number of columns integer(kind=C_INT), public :: nrow number of rows Source Code type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX","tags":"","loc":"type/supermatrix.html"},{"title":"iter_func – TOOLIB","text":"interface private  subroutine iter_func(me, iter, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me pikaia class integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f fitness value Description The interface for the function that user can specify\nto report each iteration when pikaia is running.\nThe best (fittest) population member is passed to\nthis routine in each generation.","tags":"","loc":"interface/iter_func.html"},{"title":"pikaia_func – TOOLIB","text":"interface private  subroutine pikaia_func(me, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me pikaia class real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f fitness value Description The interface for the function that pikaia will be maximizing.","tags":"","loc":"interface/pikaia_func.html"},{"title":"get_unit – TOOLIB","text":"public  subroutine get_unit(iunit) Provide for a free unit, from here John Burkardt website Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit free unit to use Called by proc~~get_unit~~CalledByGraph proc~get_unit get_unit proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~get_unit proc~list_files list_files proc~list_files->proc~get_unit proc~open_surffile open_surffile proc~open_surffile->proc~get_unit proc~trans_surf_txt trans_surf_txt proc~open_surffile->proc~trans_surf_txt proc~read_surf read_surf proc~read_surf->proc~get_unit proc~read_surf->proc~open_surffile proc~read_surf~2 read_surf proc~read_surf~2->proc~get_unit proc~save_surf save_surf proc~save_surf->proc~get_unit proc~trans_surf_txt->proc~get_unit proc~write_surf write_surf proc~write_surf->proc~get_unit proc~write_surffile write_surffile proc~write_surf->proc~write_surffile proc~write_surffile->proc~get_unit program~main main program~main->proc~get_unit program~test_algen test_algen program~test_algen->proc~get_unit program~test_data_arch test_data_arch program~test_data_arch->proc~get_unit program~test_fftw3 test_fftw3 program~test_fftw3->proc~get_unit program~test_fftw3->proc~read_surf~2 program~test_fftw3->proc~save_surf program~test_solvers test_solvers program~test_solvers->proc~get_unit program~test_tchebychev test_tchebychev program~test_tchebychev->proc~get_unit program~test_tchebychev->proc~least_squares_tcheby program~test_files test_files program~test_files->proc~list_files program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_surfile->proc~trans_surf_txt program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine get_unit ( iunit ) !! Provide for a free unit, from here [John Burkardt website](https://people.sc.fsu.edu/~jburkardt/f_src) implicit none integer ( kind = I4 ), intent ( out ) :: iunit !! free unit to use integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OPU . and . i /= IPU . and . i /= ERU ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit","tags":"","loc":"proc/get_unit.html"},{"title":"progress_bar_terminal – TOOLIB","text":"public  subroutine progress_bar_terminal(val, max_val, init) Print a progress bar on the terminal Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: val actual position integer(kind=I4), intent(in) :: max_val maximum value reached logical(kind=I4), intent(in) :: init progress bar initialization Called by proc~~progress_bar_terminal~~CalledByGraph proc~progress_bar_terminal progress_bar_terminal program~test_data_arch test_data_arch program~test_data_arch->proc~progress_bar_terminal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine progress_bar_terminal ( val , max_val , init ) !! Print a progress bar on the terminal implicit none integer ( kind = I4 ), intent ( in ) :: val !! *actual position* integer ( kind = I4 ), intent ( in ) :: max_val !! *maximum value reached* logical ( kind = I4 ), intent ( in ) :: init !! *progress bar initialization* character ( len = 102 ) :: bar integer ( kind = I4 ) :: ival if ( init ) then write ( * , * ) write ( bar , '(a)' ) '[' // repeat ( '.' , 100 ) // ']' write ( * , '(a)' , advance = 'no' ) bar return endif ival = nint ( 9 9.99 * ( real ( val , kind = R8 ) / max_val ) ) write ( bar , '(a)' ) '[' // repeat ( '*' , ival ) // repeat ( '.' , 100 - ival ) // ']' write ( * , '(a)' , advance = 'no' ) repeat ( achar ( 8 ), 102 ) // bar if ( val == max_val ) then write ( * , * ) ' ... done' write ( * , * ) endif return endsubroutine progress_bar_terminal","tags":"","loc":"proc/progress_bar_terminal.html"},{"title":"trans_center2corner – TOOLIB","text":"public  subroutine trans_center2corner(tab_in, tab_out, long, larg) Generic subroutine for real or complex arrays that shift the center to the corners Arguments Type Intent Optional Attributes Name class(*), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform class(*), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Calls proc~~trans_center2corner~~CallsGraph proc~trans_center2corner trans_center2corner proc~trans_center2corner_cmpl trans_center2corner_cmpl proc~trans_center2corner->proc~trans_center2corner_cmpl proc~trans_center2corner_real trans_center2corner_real proc~trans_center2corner->proc~trans_center2corner_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trans_center2corner~~CalledByGraph proc~trans_center2corner trans_center2corner program~test_data_arch test_data_arch program~test_data_arch->proc~trans_center2corner Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_center2corner ( tab_in , tab_out , long , larg ) !! Generic subroutine for real or complex arrays that shift the center to the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* class ( * ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* class ( * ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* select type ( tab_in ) type is ( real ( kind = R8 ) ) select type ( tab_out ) type is ( real ( kind = R8 ) ) call trans_center2corner_real ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect type is ( complex ( kind = R8 ) ) select type ( tab_out ) type is ( complex ( kind = R8 ) ) call trans_center2corner_cmpl ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect endselect return endsubroutine trans_center2corner","tags":"","loc":"proc/trans_center2corner.html"},{"title":"trans_center2corner_cmpl – TOOLIB","text":"private  subroutine trans_center2corner_cmpl(tab_in, tab_out, long, larg) Subroutine to transform an array of complexes so that the center is in the corners Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Called by proc~~trans_center2corner_cmpl~~CalledByGraph proc~trans_center2corner_cmpl trans_center2corner_cmpl proc~trans_center2corner trans_center2corner proc~trans_center2corner->proc~trans_center2corner_cmpl program~test_data_arch test_data_arch program~test_data_arch->proc~trans_center2corner Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_center2corner_cmpl ( tab_in , tab_out , long , larg ) !! Subroutine to transform an array of complexes so that the center is in the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* complex ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* complex ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j , ii , jj ii = 0 jj = 0 if ( long == 2 * ( long / 2 ) ) ii = 1 if ( larg == 2 * ( larg / 2 ) ) jj = 1 do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - ii , long ) + 1 , & ! mod ( j + larg / 2 - jj , larg ) + 1 ) enddo enddo return endsubroutine trans_center2corner_cmpl","tags":"","loc":"proc/trans_center2corner_cmpl.html"},{"title":"trans_center2corner_real – TOOLIB","text":"private  subroutine trans_center2corner_real(tab_in, tab_out, long, larg) Subroutine to transform an array of reals so that the center is in the corners Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Called by proc~~trans_center2corner_real~~CalledByGraph proc~trans_center2corner_real trans_center2corner_real proc~trans_center2corner trans_center2corner proc~trans_center2corner->proc~trans_center2corner_real program~test_data_arch test_data_arch program~test_data_arch->proc~trans_center2corner Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_center2corner_real ( tab_in , tab_out , long , larg ) !! Subroutine to transform an array of reals so that the center is in the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j , ii , jj ii = 0 jj = 0 if ( long == 2 * ( long / 2 ) ) ii = 1 if ( larg == 2 * ( larg / 2 ) ) jj = 1 do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - ii , long ) + 1 , & ! mod ( j + larg / 2 - jj , larg ) + 1 ) enddo enddo return endsubroutine trans_center2corner_real","tags":"","loc":"proc/trans_center2corner_real.html"},{"title":"trans_corner2center – TOOLIB","text":"public  subroutine trans_corner2center(tab_in, tab_out, long, larg) Generic subroutine for real or complex arrays that shift the corners to the center Arguments Type Intent Optional Attributes Name class(*), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform class(*), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Calls proc~~trans_corner2center~~CallsGraph proc~trans_corner2center trans_corner2center proc~trans_corner2center_cmpl trans_corner2center_cmpl proc~trans_corner2center->proc~trans_corner2center_cmpl proc~trans_corner2center_real trans_corner2center_real proc~trans_corner2center->proc~trans_corner2center_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trans_corner2center~~CalledByGraph proc~trans_corner2center trans_corner2center program~test_data_arch test_data_arch program~test_data_arch->proc~trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_corner2center ( tab_in , tab_out , long , larg ) !! Generic subroutine for real or complex arrays that shift the corners to the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* class ( * ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* class ( * ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* select type ( tab_in ) type is ( real ( kind = R8 ) ) select type ( tab_out ) type is ( real ( kind = R8 ) ) call trans_corner2center_real ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect type is ( complex ( kind = R8 ) ) select type ( tab_out ) type is ( complex ( kind = R8 ) ) call trans_corner2center_cmpl ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect endselect return endsubroutine trans_corner2center","tags":"","loc":"proc/trans_corner2center.html"},{"title":"trans_corner2center_cmpl – TOOLIB","text":"private  subroutine trans_corner2center_cmpl(tab_in, tab_out, long, larg) Function to transform an acf complex array so that the acf maximum is in the center Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Called by proc~~trans_corner2center_cmpl~~CalledByGraph proc~trans_corner2center_cmpl trans_corner2center_cmpl proc~trans_corner2center trans_corner2center proc~trans_corner2center->proc~trans_corner2center_cmpl program~test_data_arch test_data_arch program~test_data_arch->proc~trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_corner2center_cmpl ( tab_in , tab_out , long , larg ) !! Function to transform an acf complex array so that the acf maximum is in the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* complex ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* complex ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - 1 , long ) + 1 , & ! mod ( j + larg / 2 - 1 , larg ) + 1 ) enddo enddo return endsubroutine trans_corner2center_cmpl","tags":"","loc":"proc/trans_corner2center_cmpl.html"},{"title":"trans_corner2center_real – TOOLIB","text":"private  subroutine trans_corner2center_real(tab_in, tab_out, long, larg) Function to transform an acf real array so that the acf maximum is in the center Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width Called by proc~~trans_corner2center_real~~CalledByGraph proc~trans_corner2center_real trans_corner2center_real proc~trans_corner2center trans_corner2center proc~trans_corner2center->proc~trans_corner2center_real program~test_data_arch test_data_arch program~test_data_arch->proc~trans_corner2center Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_corner2center_real ( tab_in , tab_out , long , larg ) !! Function to transform an acf real array so that the acf maximum is in the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - 1 , long ) + 1 , & ! mod ( j + larg / 2 - 1 , larg ) + 1 ) enddo enddo return endsubroutine trans_corner2center_real","tags":"","loc":"proc/trans_corner2center_real.html"},{"title":"enorm – TOOLIB","text":"public  function enorm(n, x) ENORM computes the Euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x (n) Return Value real(kind=8) Called by proc~~enorm~~CalledByGraph proc~enorm enorm proc~dogleg dogleg proc~dogleg->proc~enorm proc~hybrd hybrd proc~hybrd->proc~enorm proc~hybrd->proc~dogleg proc~qrfac qrfac proc~hybrd->proc~qrfac proc~hybrj hybrj proc~hybrj->proc~enorm proc~hybrj->proc~dogleg proc~hybrj->proc~qrfac proc~lmder lmder proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~lmder->proc~qrfac proc~lmdif lmdif proc~lmdif->proc~enorm proc~lmdif->proc~lmpar proc~lmdif->proc~qrfac proc~lmpar->proc~enorm proc~lmstr lmstr proc~lmstr->proc~enorm proc~lmstr->proc~lmpar proc~lmstr->proc~qrfac proc~qrfac->proc~enorm proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~qform_test qform_test proc~qform_test->proc~qrfac proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1 proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1 proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~qform_test program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function enorm ( n , x ) !*****************************************************************************80 ! !! ENORM computes the Euclidean norm of a vector. ! !  Discussion: ! !    This is an extremely simplified version of the original ENORM !    routine, which has been renamed to \"ENORM2\". ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the length of the vector. ! !    Input, real ( kind = 8 ) X(N), the vector whose norm is desired. ! !    Output, real ( kind = 8 ) ENORM, the Euclidean norm of the vector. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) x ( n ) real ( kind = 8 ) enorm enorm = sqrt ( sum ( x ( 1 : n ) ** 2 )) return endfunction enorm","tags":"","loc":"proc/enorm.html"},{"title":"enorm2 – TOOLIB","text":"public  function enorm2(n, x) ENORM2 computes the Euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x (n) Return Value real(kind=8) Source Code function enorm2 ( n , x ) !*****************************************************************************80 ! !! ENORM2 computes the Euclidean norm of a vector. ! !  Discussion: ! !    This routine was named ENORM.  It has been renamed \"ENORM2\", !    and a simplified routine has been substituted. ! !    The Euclidean norm is computed by accumulating the sum of !    squares in three different sums.  The sums of squares for the !    small and large components are scaled so that no overflows !    occur.  Non-destructive underflows are permitted.  Underflows !    and overflows do not occur in the computation of the unscaled !    sum of squares for the intermediate components. ! !    The definitions of small, intermediate and large components !    depend on two constants, RDWARF and RGIANT.  The main !    restrictions on these constants are that RDWARF&#94;2 not !    underflow and RGIANT&#94;2 not overflow. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1 !    Argonne National Laboratory, !    Argonne, Illinois. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the length of the vector. ! !    Input, real ( kind = 8 ) X(N), the vector whose norm is desired. ! !    Output, real ( kind = 8 ) ENORM2, the Euclidean norm of the vector. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) agiant real ( kind = 8 ) enorm2 integer ( kind = 4 ) i real ( kind = 8 ) rdwarf real ( kind = 8 ) rgiant real ( kind = 8 ) s1 real ( kind = 8 ) s2 real ( kind = 8 ) s3 real ( kind = 8 ) x ( n ) real ( kind = 8 ) xabs real ( kind = 8 ) x1max real ( kind = 8 ) x3max rdwarf = sqrt ( tiny ( rdwarf ) ) rgiant = sqrt ( huge ( rgiant ) ) s1 = 0.0D+00 s2 = 0.0D+00 s3 = 0.0D+00 x1max = 0.0D+00 x3max = 0.0D+00 agiant = rgiant / real ( n , kind = 8 ) do i = 1 , n xabs = abs ( x ( i ) ) if ( xabs <= rdwarf ) then if ( x3max < xabs ) then s3 = 1.0D+00 + s3 * ( x3max / xabs ) ** 2 x3max = xabs else if ( xabs /= 0.0D+00 ) then s3 = s3 + ( xabs / x3max ) ** 2 end if else if ( agiant <= xabs ) then if ( x1max < xabs ) then s1 = 1.0D+00 + s1 * ( x1max / xabs ) ** 2 x1max = xabs else s1 = s1 + ( xabs / x1max ) ** 2 end if else s2 = s2 + xabs ** 2 end if end do ! !  Calculation of norm. ! if ( s1 /= 0.0D+00 ) then enorm2 = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max ) else if ( s2 /= 0.0D+00 ) then if ( x3max <= s2 ) then enorm2 = sqrt ( s2 * ( 1.0D+00 + ( x3max / s2 ) * ( x3max * s3 ) ) ) else enorm2 = sqrt ( x3max * ( ( s2 / x3max ) + ( x3max * s3 ) ) ) end if else enorm2 = x3max * sqrt ( s3 ) end if return endfunction enorm2","tags":"","loc":"proc/enorm2.html"},{"title":"r8_uniform_01 – TOOLIB","text":"public  function r8_uniform_01(seed) R8_UNIFORM_01 returns a unit pseudorandom R8. Arguments Type Intent Optional Attributes Name integer(kind=4) :: seed Return Value real(kind=8) Source Code function r8_uniform_01 ( seed ) !*****************************************************************************80 ! !! R8_UNIFORM_01 returns a unit pseudorandom R8. ! !  Discussion: ! !    An R8 is a real ( kind = 8 ) value. ! !    For now, the input quantity SEED is an integer variable. ! !    This routine implements the recursion ! !      seed = 16807 * seed mod ( 2&#94;31 - 1 ) !      r8_uniform_01 = seed / ( 2&#94;31 - 1 ) ! !    The integer arithmetic never requires more than 32 bits, !    including a sign bit. ! !    If the initial seed is 12345, then the first three computations are ! !      Input     Output      R8_UNIFORM_01 !      SEED      SEED ! !         12345   207482415  0.096616 !     207482415  1790989824  0.833995 !    1790989824  2035175616  0.947702 ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    05 July 2006 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    Paul Bratley, Bennett Fox, Linus Schrage, !    A Guide to Simulation, !    Springer Verlag, pages 201-202, 1983. ! !    Pierre L'Ecuyer, !    Random Number Generation, !    in Handbook of Simulation, !    edited by Jerry Banks, !    Wiley Interscience, page 95, 1998. ! !    Bennett Fox, !    Algorithm 647: !    Implementation and Relative Efficiency of Quasirandom !    Sequence Generators, !    ACM Transactions on Mathematical Software, !    Volume 12, Number 4, pages 362-376, 1986. ! !    Peter Lewis, Allen Goodman, James Miller !    A Pseudo-Random Number Generator for the System/360, !    IBM Systems Journal, !    Volume 8, pages 136-143, 1969. ! !  Parameters: ! !    Input/output, integer ( kind = 4 ) SEED, the \"seed\" value, which should !    NOT be 0. On output, SEED has been updated. ! !    Output, real ( kind = 8 ) R8_UNIFORM_01, a new pseudorandom variate, !    strictly between 0 and 1. ! implicit none integer ( kind = 4 ), parameter :: i4_huge = 2147483647 integer ( kind = 4 ) k real ( kind = 8 ) r8_uniform_01 integer ( kind = 4 ) seed if ( seed == 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'R8_UNIFORM_01 - Fatal error!' write ( * , '(a)' ) '  Input value of SEED = 0.' stop 1 end if k = seed / 127773 seed = 16807 * ( seed - k * 127773 ) - k * 2836 if ( seed < 0 ) then seed = seed + i4_huge end if r8_uniform_01 = real ( seed , kind = 8 ) * 4.656612875D-10 return endfunction r8_uniform_01","tags":"","loc":"proc/r8_uniform_01.html"},{"title":"chkder – TOOLIB","text":"public  subroutine chkder(m, n, x, fvec, fjac, ldfjac, xp, fvecp, mode, err) CHKDER checks the gradients of M functions of N variables. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: xp (n) real(kind=8) :: fvecp (m) integer(kind=4) :: mode real(kind=8) :: err (m) Called by proc~~chkder~~CalledByGraph proc~chkder chkder proc~chkder_test chkder_test proc~chkder_test->proc~chkder program~test_minpack test_minpack program~test_minpack->proc~chkder_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) !*****************************************************************************80 ! !! CHKDER checks the gradients of M functions of N variables. ! !  Discussion: ! !    CHKDER checks the gradients of M nonlinear functions in N variables, !    evaluated at a point X, for consistency with the functions themselves. ! !    The user calls CHKDER twice, first with MODE = 1 and then with MODE = 2. ! !    MODE = 1. !      On input, !        X contains the point of evaluation. !      On output, !        XP is set to a neighboring point. ! !    Now the user must evaluate the function and gradients at X, and the !    function at XP.  Then the function is called again: ! !    MODE = 2. !      On input, !        FVEC contains the function values at X, !        FJAC contains the function gradients at X. !        FVECP contains the functions evaluated at XP. !      On output, !        ERR contains measures of correctness of the respective gradients. ! !    The function does not perform reliably if cancellation or !    rounding errors cause a severe loss of significance in the !    evaluation of a function.  Therefore, none of the components !    of X should be unusually small (in particular, zero) or any !    other value which may cause loss of significance. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. ! !    Input, real ( kind = 8 ) X(N), the point at which the jacobian is to be !    evaluated. ! !    Input, real ( kind = 8 ) FVEC(M), is used only when MODE = 2. !    In that case, it should contain the function values at X. ! !    Input, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  When MODE = 2, !    FJAC(I,J) should contain the value of dF(I)/dX(J). ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Output, real ( kind = 8 ) XP(N), on output with MODE = 1, is a neighboring !    point of X, at which the function is to be evaluated. ! !    Input, real ( kind = 8 ) FVECP(M), on input with MODE = 2, is the function !    value at XP. ! !    Input, integer ( kind = 4 ) MODE, should be set to 1 on the first call, and !    2 on the second. ! !    Output, real ( kind = 8 ) ERR(M).  On output when MODE = 2, ERR contains !    measures of correctness of the respective gradients.  If there is no !    severe loss of significance, then if ERR(I): !      = 1.0D+00, the I-th gradient is correct, !      = 0.0D+00, the I-th gradient is incorrect. !      > 0.5D+00, the I-th gradient is probably correct. !      < 0.5D+00, the I-th gradient is probably incorrect. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsf real ( kind = 8 ) epslog real ( kind = 8 ) epsmch real ( kind = 8 ) err ( m ) real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) fvecp ( m ) integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) mode real ( kind = 8 ) temp real ( kind = 8 ) x ( n ) real ( kind = 8 ) xp ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( epsmch ) ! !  MODE = 1. ! if ( mode == 1 ) then do j = 1 , n temp = eps * abs ( x ( j ) ) if ( temp == 0.0D+00 ) then temp = eps end if xp ( j ) = x ( j ) + temp end do ! !  MODE = 2. ! else if ( mode == 2 ) then epsf = 10 0.0D+00 * epsmch epslog = log10 ( eps ) err = 0.0D+00 do j = 1 , n temp = abs ( x ( j ) ) if ( temp == 0.0D+00 ) then temp = 1.0D+00 end if err ( 1 : m ) = err ( 1 : m ) + temp * fjac ( 1 : m , j ) end do do i = 1 , m temp = 1.0D+00 if ( fvec ( i ) /= 0.0D+00 . and . fvecp ( i ) /= 0.0D+00 . and . & abs ( fvecp ( i ) - fvec ( i )) >= epsf * abs ( fvec ( i ) ) ) then temp = eps * abs ( ( fvecp ( i ) - fvec ( i )) / eps - err ( i ) ) & / ( abs ( fvec ( i ) ) + abs ( fvecp ( i ) ) ) end if err ( i ) = 1.0D+00 if ( epsmch < temp . and . temp < eps ) then err ( i ) = ( log10 ( temp ) - epslog ) / epslog end if if ( eps <= temp ) then err ( i ) = 0.0D+00 end if end do end if return endsubroutine chkder","tags":"","loc":"proc/chkder.html"},{"title":"dogleg – TOOLIB","text":"public  subroutine dogleg(n, r, lr, diag, qtb, delta, x) DOGLEG finds the minimizing combination of Gauss-Newton and gradient steps. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: delta real(kind=8) :: x (n) Calls proc~~dogleg~~CallsGraph proc~dogleg dogleg proc~enorm enorm proc~dogleg->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dogleg~~CalledByGraph proc~dogleg dogleg proc~hybrd hybrd proc~hybrd->proc~dogleg proc~hybrj hybrj proc~hybrj->proc~dogleg proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dogleg ( n , r , lr , diag , qtb , delta , x ) !*****************************************************************************80 ! !! DOGLEG finds the minimizing combination of Gauss-Newton and gradient steps. ! !  Discussion: ! !    Given an M by N matrix A, an N by N nonsingular diagonal !    matrix D, an M-vector B, and a positive number DELTA, the !    problem is to determine the convex combination X of the !    Gauss-Newton and scaled gradient directions that minimizes !    (A*X - B) in the least squares sense, subject to the !    restriction that the euclidean norm of D*X be at most DELTA. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization of A.  That is, if A = Q*R, where Q has !    orthogonal columns and R is an upper triangular matrix, !    then DOGLEG expects the full upper triangle of R and !    the first N components of Q'*B. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix R. ! !    Input, real ( kind = 8 ) R(LR), the upper triangular matrix R stored !    by rows. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must be !    no less than (N*(N+1))/2. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'* B. ! !    Input, real ( kind = 8 ) DELTA, is a positive upper bound on the !    euclidean norm of D*X(1:N). ! !    Output, real ( kind = 8 ) X(N), the desired convex combination of the !    Gauss-Newton direction and the scaled gradient direction. ! implicit none integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) alpha real ( kind = 8 ) bnorm real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) gnorm integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) qnorm real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) sgnorm real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) ! !  Calculate the Gauss-Newton direction. ! jj = ( n * ( n + 1 ) ) / 2 + 1 do k = 1 , n j = n - k + 1 jj = jj - k l = jj + 1 sum2 = 0.0D+00 do i = j + 1 , n sum2 = sum2 + r ( l ) * x ( i ) l = l + 1 end do temp = r ( jj ) if ( temp == 0.0D+00 ) then l = j do i = 1 , j temp = max ( temp , abs ( r ( l )) ) l = l + n - i end do if ( temp == 0.0D+00 ) then temp = epsmch else temp = epsmch * temp end if end if x ( j ) = ( qtb ( j ) - sum2 ) / temp end do ! !  Test whether the Gauss-Newton direction is acceptable. ! wa1 ( 1 : n ) = 0.0D+00 wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) qnorm = enorm ( n , wa2 ) if ( qnorm <= delta ) then return end if ! !  The Gauss-Newton direction is not acceptable. !  Calculate the scaled gradient direction. ! l = 1 do j = 1 , n temp = qtb ( j ) do i = j , n wa1 ( i ) = wa1 ( i ) + r ( l ) * temp l = l + 1 end do wa1 ( j ) = wa1 ( j ) / diag ( j ) end do ! !  Calculate the norm of the scaled gradient. !  Test for the special case in which the scaled gradient is zero. ! gnorm = enorm ( n , wa1 ) sgnorm = 0.0D+00 alpha = delta / qnorm if ( gnorm /= 0.0D+00 ) then ! !  Calculate the point along the scaled gradient which minimizes the quadratic. ! wa1 ( 1 : n ) = ( wa1 ( 1 : n ) / gnorm ) / diag ( 1 : n ) l = 1 do j = 1 , n sum2 = 0.0D+00 do i = j , n sum2 = sum2 + r ( l ) * wa1 ( i ) l = l + 1 end do wa2 ( j ) = sum2 end do temp = enorm ( n , wa2 ) sgnorm = ( gnorm / temp ) / temp ! !  Test whether the scaled gradient direction is acceptable. ! alpha = 0.0D+00 ! !  The scaled gradient direction is not acceptable. !  Calculate the point along the dogleg at which the quadratic is minimized. ! if ( sgnorm < delta ) then bnorm = enorm ( n , qtb ) temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / delta ) temp = temp - ( delta / qnorm ) * ( sgnorm / delta ) ** 2 & + sqrt ( ( temp - ( delta / qnorm ) ) ** 2 & + ( 1.0D+00 - ( delta / qnorm ) ** 2 ) & * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) ) alpha = ( ( delta / qnorm ) * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) ) & / temp end if end if ! !  Form appropriate convex combination of the Gauss-Newton !  direction and the scaled gradient direction. ! temp = ( 1.0D+00 - alpha ) * min ( sgnorm , delta ) x ( 1 : n ) = temp * wa1 ( 1 : n ) + alpha * x ( 1 : n ) return endsubroutine dogleg","tags":"","loc":"proc/dogleg.html"},{"title":"fdjac1 – TOOLIB","text":"public  subroutine fdjac1(fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn) FDJAC1 estimates an N by N jacobian matrix using forward differences. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: iflag integer(kind=4) :: ml integer(kind=4) :: mu real(kind=8) :: epsfcn Called by proc~~fdjac1~~CalledByGraph proc~fdjac1 fdjac1 proc~hybrd hybrd proc~hybrd->proc~fdjac1 proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn ) !*****************************************************************************80 ! !! FDJAC1 estimates an N by N jacobian matrix using forward differences. ! !  Discussion: ! !    This function computes a forward-difference approximation !    to the N by N jacobian matrix associated with a specified !    problem of N functions in N variables. If the jacobian has !    a banded form, then function evaluations are saved by only !    approximating the nonzero terms. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated. ! !    Input, real ( kind = 8 ) FVEC(N), the functions evaluated at X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the N by N approximate !    jacobian matrix. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC, which !    must not be less than N. ! !    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN. !    If FCN returns a nonzero value of IFLAG, then this routine returns !    immediately to the calling program, with the value of IFLAG. ! !    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and !    superdiagonals within the band of the jacobian matrix.  If the !    jacobian is not banded, set ML and MU to N-1. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( n ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) ml integer ( kind = 4 ) msum integer ( kind = 4 ) mu real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( max ( epsfcn , epsmch ) ) msum = ml + mu + 1 ! !  Computation of dense approximate jacobian. ! if ( n <= msum ) then do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == 0.0D+00 ) then h = eps end if iflag = 1 x ( j ) = temp + h call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) then exit end if x ( j ) = temp fjac ( 1 : n , j ) = ( wa1 ( 1 : n ) - fvec ( 1 : n ) ) / h end do else ! !  Computation of banded approximate jacobian. ! do k = 1 , msum do j = k , n , msum wa2 ( j ) = x ( j ) h = eps * abs ( wa2 ( j ) ) if ( h == 0.0D+00 ) then h = eps end if x ( j ) = wa2 ( j ) + h end do iflag = 1 call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) then exit end if do j = k , n , msum x ( j ) = wa2 ( j ) h = eps * abs ( wa2 ( j ) ) if ( h == 0.0D+00 ) then h = eps end if fjac ( 1 : n , j ) = 0.0D+00 do i = 1 , n if ( j - mu <= i . and . i <= j + ml ) then fjac ( i , j ) = ( wa1 ( i ) - fvec ( i ) ) / h end if end do end do end do end if return endsubroutine fdjac1","tags":"","loc":"proc/fdjac1.html"},{"title":"fdjac2 – TOOLIB","text":"public  subroutine fdjac2(fcn, m, n, x, fvec, fjac, ldfjac, iflag, epsfcn) FDJAC2 estimates an M by N jacobian matrix using forward differences. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: iflag real(kind=8) :: epsfcn Called by proc~~fdjac2~~CalledByGraph proc~fdjac2 fdjac2 proc~lmdif lmdif proc~lmdif->proc~fdjac2 proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 program~test_minpack test_minpack program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fdjac2 ( fcn , m , n , x , fvec , fjac , ldfjac , iflag , epsfcn ) !*****************************************************************************80 ! !! FDJAC2 estimates an M by N jacobian matrix using forward differences. ! !  Discussion: ! !    This function computes a forward-difference approximation !    to the M by N jacobian matrix associated with a specified !    problem of M functions in N variables. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated. ! !    Input, real ( kind = 8 ) FVEC(M), the functions evaluated at X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the M by N approximate !    jacobian matrix. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC, !    which must not be less than M. ! !    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN. !    If FCN returns a nonzero value of IFLAG, then this routine returns !    immediately to the calling program, with the value of IFLAG. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable !    step length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) j real ( kind = 8 ) temp real ( kind = 8 ) wa ( m ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( max ( epsfcn , epsmch ) ) do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == 0.0D+00 ) then h = eps end if iflag = 1 x ( j ) = temp + h call fcn ( m , n , x , wa , iflag ) if ( iflag < 0 ) then exit end if x ( j ) = temp fjac ( 1 : m , j ) = ( wa ( 1 : m ) - fvec ( 1 : m ) ) / h end do return endsubroutine fdjac2","tags":"","loc":"proc/fdjac2.html"},{"title":"hybrd – TOOLIB","text":"public  subroutine hybrd(fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf) HYBRD seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: xtol integer(kind=4) :: maxfev integer(kind=4) :: ml integer(kind=4) :: mu real(kind=8) :: epsfcn real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: qtf (n) Calls proc~~hybrd~~CallsGraph proc~hybrd hybrd proc~dogleg dogleg proc~hybrd->proc~dogleg proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrd~~CalledByGraph proc~hybrd hybrd proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf ) !*****************************************************************************80 ! !! HYBRD seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRD finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  The user must provide a !    subroutine which calculates the functions. ! !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and !    superdiagonals within the band of the jacobian matrix.  If the jacobian !    is not banded, set ML and MU to at least n - 1. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of !    iterates if it is positive.  In this case, FCN is called with IFLAG = 0 at !    the beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. !    See the description of FCN. !    Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, relative error between two consecutive iterates is at most XTOL. !    2, number of calls to FCN has reached or exceeded MAXFEV. !    3, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, iteration is not making good progress, as measured by the improvement !       from the last five jacobian evaluations. !    5, iteration is not making good progress, as measured by the improvement !       from the last ten iterations. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains !    the orthogonal matrix Q produced by the QR factorization of the final !    approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced by !    the QR factorization of the final approximate jacobian, stored rowwise. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must be no !    less than (N*(N+1))/2. ! !    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) iter integer ( kind = 4 ) iwa ( 1 ) integer ( kind = 4 ) j logical jeval integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) ml integer ( kind = 4 ) mode integer ( kind = 4 ) msum integer ( kind = 4 ) mu integer ( kind = 4 ) ncfail integer ( kind = 4 ) nslow1 integer ( kind = 4 ) nslow2 integer ( kind = 4 ) ncsuc integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( n ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then return else if ( xtol < 0.0D+00 ) then return else if ( maxfev <= 0 ) then return else if ( ml < 0 ) then return else if ( mu < 0 ) then return else if ( factor <= 0.0D+00 ) then return else if ( ldfjac < n ) then return else if ( lr < ( n * ( n + 1 ) ) / 2 ) then return end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point !  and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( n , fvec ) ! !  Determine the number of calls to FCN needed to compute the jacobian matrix. ! msum = min ( ml + mu + 1 , n ) ! !  Initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !  Beginning of the outer loop. ! 30 continue jeval = . true . ! !  Calculate the jacobian matrix. ! iflag = 2 call fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn ) nfev = nfev + msum if ( iflag < 0 ) then go to 300 end if ! !  Compute the QR factorization of the jacobian. ! pivot = . false . call qrfac ( n , n , fjac , ldfjac , pivot , iwa , 1 , wa1 , wa2 ) ! !  On the first iteration, if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q' * FVEC and store in QTF. ! qtf ( 1 : n ) = fvec ( 1 : n ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then temp = - dot_product ( qtf ( j : n ), fjac ( j : n , j ) ) / fjac ( j , j ) qtf ( j : n ) = qtf ( j : n ) + fjac ( j : n , j ) * temp end if end do ! !  Copy the triangular factor of the QR factorization into R. ! sing = . false . do j = 1 , n l = j do i = 1 , j - 1 r ( l ) = fjac ( i , j ) l = l + n - i end do r ( l ) = wa1 ( j ) if ( wa1 ( j ) == 0.0D+00 ) then sing = . true . end if end do ! !  Accumulate the orthogonal factor in FJAC. ! call qform ( n , n , fjac , ldfjac ) ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 180 continue ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( n , x , fvec , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Determine the direction P. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( n , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 endif ! !  Compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum2 = 0.0D+00 do j = i , n sum2 = sum2 + r ( l ) * wa1 ( j ) l = l + 1 end do wa3 ( i ) = qtf ( i ) + sum2 end do temp = enorm ( n , wa3 ) prered = 0.0D+00 if ( temp < fnorm ) then prered = 1.0D+00 - ( temp / fnorm ) ** 2 end if ! !  Compute the ratio of the actual to the predicted reduction. ! ratio = 0.0D+00 if ( 0.0D+00 < prered ) then ratio = actred / prered end if ! !  Update the step bound. ! if ( ratio < 0.1D+00 ) then ncsuc = 0 ncfail = ncfail + 1 delta = 0.5D+00 * delta else ncfail = 0 ncsuc = ncsuc + 1 if ( 0.5D+00 <= ratio . or . 1 < ncsuc ) then delta = max ( delta , pnorm / 0.5D+00 ) end if if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then delta = pnorm / 0.5D+00 end if end if ! !  Test for successful iteration. ! !  Successful iteration. !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : n ) = wa4 ( 1 : n ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( 0.001D+00 <= actred ) then nslow1 = 0 end if if ( jeval ) then nslow2 = nslow2 + 1 end if if ( 0.1D+00 <= actred ) then nslow2 = 0 end if ! !  Test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == 0.0D+00 ) then info = 1 end if if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 2 end if if ( 0.1D+00 * max ( 0.1D+00 * delta , pnorm ) <= epsmch * xnorm ) then info = 3 end if if ( nslow2 == 5 ) then info = 4 end if if ( nslow1 == 10 ) then info = 5 end if if ( info /= 0 ) then go to 300 end if ! !  Criterion for recalculating jacobian approximation !  by forward differences. ! if ( ncfail == 2 ) then go to 290 end if ! !  Calculate the rank one modification to the jacobian !  and update QTF if necessary. ! do j = 1 , n sum2 = dot_product ( wa4 ( 1 : n ), fjac ( 1 : n , j ) ) wa2 ( j ) = ( sum2 - wa3 ( j ) ) / pnorm wa1 ( j ) = diag ( j ) * ( ( diag ( j ) * wa1 ( j ) ) / pnorm ) if ( 0.0001D+00 <= ratio ) then qtf ( j ) = sum2 end if end do ! !  Compute the QR factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !  End of the inner loop. ! jeval = . false . go to 180 290 continue ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , iflag ) end if return endsubroutine hybrd","tags":"","loc":"proc/hybrd.html"},{"title":"hybrd1 – TOOLIB","text":"public  subroutine hybrd1(fcn, n, x, fvec, tol, info) HYBRD1 seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: tol integer(kind=4) :: info Calls proc~~hybrd1~~CallsGraph proc~hybrd1 hybrd1 proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~dogleg dogleg proc~hybrd->proc~dogleg proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrd1~~CalledByGraph proc~hybrd1 hybrd1 proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hybrd1 ( fcn , n , x , fvec , tol , info ) !*****************************************************************************80 ! !! HYBRD1 seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRD1 finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  This is done by using the !    more general nonlinear equation solver HYBRD.  The user must provide a !    subroutine which calculates the functions.  The jacobian is then !    calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See the !    description of FCN. !    Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    2, number of calls to FCN has reached or exceeded 200*(N+1). !    3, TOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, the iteration is not making good progress. ! implicit none integer ( kind = 4 ) lwa integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) epsfcn real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( n , n ) real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) info integer ( kind = 4 ) j integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) maxfev integer ( kind = 4 ) ml integer ( kind = 4 ) mode integer ( kind = 4 ) mu integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r (( n * ( n + 1 )) / 2 ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol if ( n <= 0 ) then info = 0 return end if if ( tol < 0.0D+00 ) then info = 0 return end if xtol = tol maxfev = 200 * ( n + 1 ) ml = n - 1 mu = n - 1 epsfcn = 0.0D+00 diag ( 1 : n ) = 1.0D+00 mode = 2 factor = 10 0.0D+00 nprint = 0 info = 0 nfev = 0 fjac ( 1 : n , 1 : n ) = 0.0D+00 ldfjac = n r ( 1 :( n * ( n + 1 )) / 2 ) = 0.0D+00 lr = ( n * ( n + 1 ) ) / 2 qtf ( 1 : n ) = 0.0D+00 call hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf ) if ( info == 5 ) then info = 4 end if return endsubroutine hybrd1","tags":"","loc":"proc/hybrd1.html"},{"title":"hybrj – TOOLIB","text":"public  subroutine hybrj(fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf) HYBRJ seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: xtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: qtf (n) Calls proc~~hybrj~~CallsGraph proc~hybrj hybrj proc~dogleg dogleg proc~hybrj->proc~dogleg proc~enorm enorm proc~hybrj->proc~enorm proc~qform qform proc~hybrj->proc~qform proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~r1updt r1updt proc~hybrj->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrj~~CalledByGraph proc~hybrj hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 program~test_minpack test_minpack program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & factor , nprint , info , nfev , njev , r , lr , qtf ) !*****************************************************************************80 ! !! HYBRJ seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRJ finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  The user must provide a !    subroutine which calculates the functions and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: ! !      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N matrix, containing !    the orthogonal matrix Q produced by the QR factorization !    of the final approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of the !    array FJAC.  LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. !    See the description of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, relative error between two consecutive iterates is at most XTOL. !    2, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    3, XTOL is too small.  No further improvement in !       the approximate solution X is possible. !    4, iteration is not making good progress, as measured by the !       improvement from the last five jacobian evaluations. !    5, iteration is not making good progress, as measured by the !       improvement from the last ten iterations. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN !    with IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN !    with IFLAG = 2. ! !    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced !    by the QR factorization of the final approximate jacobian, stored rowwise. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must !    be no less than (N*(N+1))/2. ! !    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) iter integer ( kind = 4 ) iwa ( 1 ) integer ( kind = 4 ) j logical jeval integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) ncfail integer ( kind = 4 ) nslow1 integer ( kind = 4 ) nslow2 integer ( kind = 4 ) ncsuc integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( n ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if if ( ldfjac < n . or . & xtol < 0.0D+00 . or . & maxfev <= 0 . or . & factor <= 0.0D+00 . or . & lr < ( n * ( n + 1 ) ) / 2 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if fnorm = enorm ( n , fvec ) ! !  Initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !  Beginning of the outer loop. ! do jeval = . true . ! !  Calculate the jacobian matrix. ! iflag = 2 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Compute the QR factorization of the jacobian. ! pivot = . false . call qrfac ( n , n , fjac , ldfjac , pivot , iwa , 1 , wa1 , wa2 ) ! !  On the first iteration, if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q'*FVEC and store in QTF. ! qtf ( 1 : n ) = fvec ( 1 : n ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = 0.0D+00 do i = j , n sum2 = sum2 + fjac ( i , j ) * qtf ( i ) end do temp = - sum2 / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp end do end if end do ! !  Copy the triangular factor of the QR factorization into R. ! sing = . false . do j = 1 , n l = j do i = 1 , j - 1 r ( l ) = fjac ( i , j ) l = l + n - i end do r ( l ) = wa1 ( j ) if ( wa1 ( j ) == 0.0D+00 ) then sing = . true . end if end do ! !  Accumulate the orthogonal factor in FJAC. ! call qform ( n , n , fjac , ldfjac ) ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! do ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if end if ! !  Determine the direction P. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if fnorm1 = enorm ( n , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 end if ! !  Compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum2 = 0.0D+00 do j = i , n sum2 = sum2 + r ( l ) * wa1 ( j ) l = l + 1 end do wa3 ( i ) = qtf ( i ) + sum2 end do temp = enorm ( n , wa3 ) prered = 0.0D+00 if ( temp < fnorm ) then prered = 1.0D+00 - ( temp / fnorm ) ** 2 end if ! !  Compute the ratio of the actual to the predicted reduction. ! if ( 0.0D+00 < prered ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio < 0.1D+00 ) then ncsuc = 0 ncfail = ncfail + 1 delta = 0.5D+00 * delta else ncfail = 0 ncsuc = ncsuc + 1 if ( 0.5D+00 <= ratio . or . 1 < ncsuc ) then delta = max ( delta , pnorm / 0.5D+00 ) end if if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then delta = pnorm / 0.5D+00 end if end if ! !  Test for successful iteration. ! ! !  Successful iteration. !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : n ) = wa4 ( 1 : n ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( 0.001D+00 <= actred ) then nslow1 = 0 end if if ( jeval ) then nslow2 = nslow2 + 1 end if if ( 0.1D+00 <= actred ) then nslow2 = 0 end if ! !  Test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == 0.0D+00 ) then info = 1 end if if ( info /= 0 ) then iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 2 end if if ( 0.1D+00 * max ( 0.1D+00 * delta , pnorm ) <= epsmch * xnorm ) then info = 3 end if if ( nslow2 == 5 ) then info = 4 end if if ( nslow1 == 10 ) then info = 5 end if if ( info /= 0 ) then iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Criterion for recalculating jacobian. ! if ( ncfail == 2 ) then exit end if ! !  Calculate the rank one modification to the jacobian !  and update QTF if necessary. ! do j = 1 , n sum2 = dot_product ( wa4 ( 1 : n ), fjac ( 1 : n , j ) ) wa2 ( j ) = ( sum2 - wa3 ( j ) ) / pnorm wa1 ( j ) = diag ( j ) * ( ( diag ( j ) * wa1 ( j ) ) / pnorm ) if ( 0.0001D+00 <= ratio ) then qtf ( j ) = sum2 end if end do ! !  Compute the QR factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !  End of the inner loop. ! jeval = . false . end do ! !  End of the outer loop. ! end do endsubroutine hybrj","tags":"","loc":"proc/hybrj.html"},{"title":"hybrj1 – TOOLIB","text":"public  subroutine hybrj1(fcn, n, x, fvec, fjac, ldfjac, tol, info) HYBRJ1 seeks a zero of N equations in N variables by Powell’s method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info Calls proc~~hybrj1~~CallsGraph proc~hybrj1 hybrj1 proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~dogleg dogleg proc~hybrj->proc~dogleg proc~enorm enorm proc~hybrj->proc~enorm proc~qform qform proc~hybrj->proc~qform proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~r1updt r1updt proc~hybrj->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrj1~~CalledByGraph proc~hybrj1 hybrj1 proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 program~test_minpack test_minpack program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine hybrj1 ( fcn , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! HYBRJ1 seeks a zero of N equations in N variables by Powell's method. ! !  Discussion: ! !    HYBRJ1 finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  This is done by using the !    more general nonlinear equation solver HYBRJ.  The user !    must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains !    the orthogonal matrix Q produced by the QR factorization of the final !    approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of  FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates that the relative error between X and the solution is at most !    TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    2, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    3, TOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, iteration is not making good progress. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) info integer ( kind = 4 ) j integer ( kind = 4 ) lr integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r (( n * ( n + 1 )) / 2 ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( ldfjac < n ) then return else if ( tol < 0.0D+00 ) then return end if maxfev = 100 * ( n + 1 ) xtol = tol mode = 2 diag ( 1 : n ) = 1.0D+00 factor = 10 0.0D+00 nprint = 0 lr = ( n * ( n + 1 ) ) / 2 call hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & factor , nprint , info , nfev , njev , r , lr , qtf ) if ( info == 5 ) then info = 4 end if return endsubroutine hybrj1","tags":"","loc":"proc/hybrj1.html"},{"title":"lmder – TOOLIB","text":"public  subroutine lmder(fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf) LMDER minimizes M functions in N variables by the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) Calls proc~~lmder~~CallsGraph proc~lmder lmder proc~enorm enorm proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~qrfac qrfac proc~lmder->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmder~~CalledByGraph proc~lmder lmder proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1 proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1 program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmder ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) !*****************************************************************************80 ! !! LMDER minimizes M functions in N variables by the Levenberg-Marquardt method. ! !  Discussion: ! !    LMDER minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    The user must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix of FJAC contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that !      P' * ( JAC' * JAC ) * P = R' * R, !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual !    and predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, real ( kind = 8 ) GTOL.  Termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN with IFLAG = 1 is at least MAXFEV by the end of an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of !       squares are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares !       is possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN with !    IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN with !    IFLAG = 2. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P !    such that JAC*P = Q*R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular with diagonal !    elements of nonincreasing magnitude.  Column J of P is column !    IPVT(J) of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) xnorm real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then go to 300 end if if ( m < n ) then go to 300 end if if ( ldfjac < m & . or . ftol < 0.0D+00 . or . xtol < 0.0D+00 . or . gtol < 0.0D+00 & . or . maxfev <= 0 . or . factor <= 0.0D+00 ) then go to 300 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  Calculate the jacobian matrix. ! iflag = 2 call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) then go to 300 end if ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Compute the QR factorization of the jacobian. ! pivot = . true . call qrfac ( m , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) ! !  On the first iteration and if mode is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q'*FVEC and store the first N components in QTF. ! wa4 ( 1 : m ) = fvec ( 1 : m ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( wa4 ( j : m ), fjac ( j : m , j ) ) temp = - sum2 / fjac ( j , j ) wa4 ( j : m ) = wa4 ( j : m ) + fjac ( j : m , j ) * temp end if fjac ( j , j ) = wa1 ( j ) qtf ( j ) = wa4 ( j ) end do ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( 1 : j ), fjac ( 1 : j , j ) ) / fnorm gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 300 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 200 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction p and x + p. calculate the norm of p. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 end if ! !  Compute the scaled predicted reduction and !  the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! if ( prered /= 0.0D+00 ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( 0.0D+00 <= actred ) then temp = 0.5D+00 end if if ( actred < 0.0D+00 ) then temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = 2.0D+00 * pnorm par = 0.5D+00 * par end if end if ! !  Successful iteration. ! !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence. ! if ( abs ( actred ) <= ftol . and . & prered <= ftol . and . & 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) then info = 3 end if if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 300 end if ! !  End of the inner loop. repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 200 end if ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) end if return endsubroutine lmder","tags":"","loc":"proc/lmder.html"},{"title":"lmder1 – TOOLIB","text":"public  subroutine lmder1(fcn, m, n, x, fvec, fjac, ldfjac, tol, info) LMDER1 minimizes M functions in N variables by Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info Calls proc~~lmder1~~CallsGraph proc~lmder1 lmder1 proc~lmder lmder proc~lmder1->proc~lmder proc~enorm enorm proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~qrfac qrfac proc~lmder->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmder1~~CalledByGraph proc~lmder1 lmder1 proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1 proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1 program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmder1 ( fcn , m , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! LMDER1 minimizes M functions in N variables by Levenberg-Marquardt method. ! !  Discussion: ! !    LMDER1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    This is done by using the more general least-squares solver LMDER. !    The user must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that !      P' * ( JAC' * JAC ) * P = R' * R, !    where P is a permutation matrix and JAC is the final calculated !    jacobian.  Column J of P is column IPVT(J) of the identity matrix. !    The lower trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, is the leading dimension of FJAC, !    which must be no less than M. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares is !       possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( m < n ) then return else if ( ldfjac < m ) then return else if ( tol < 0.0D+00 ) then return end if factor = 10 0.0D+00 maxfev = 100 * ( n + 1 ) ftol = tol xtol = tol gtol = 0.0D+00 mode = 1 nprint = 0 call lmder ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmder1","tags":"","loc":"proc/lmder1.html"},{"title":"lmdif – TOOLIB","text":"public  subroutine lmdif(fcn, m, n, x, fvec, ftol, xtol, gtol, maxfev, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf) LMDIF minimizes M functions in N variables by the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: epsfcn real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) Calls proc~~lmdif~~CallsGraph proc~lmdif lmdif proc~enorm enorm proc~lmdif->proc~enorm proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~lmpar lmpar proc~lmdif->proc~lmpar proc~qrfac qrfac proc~lmdif->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmdif~~CalledByGraph proc~lmdif lmdif proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 program~test_minpack test_minpack program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmdif ( fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , & diag , mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf ) !*****************************************************************************80 ! !! LMDIF minimizes M functions in N variables by the Levenberg-Marquardt method. ! !  Discussion: ! !    LMDIF minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    The user must provide a subroutine which calculates the functions. !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual !    and predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  Therefore, XTOL !    measures the relative error desired in the approximate solution.  XTOL !    should be nonnegative. ! !    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound. !    This bound is set to the product of FACTOR and the euclidean norm of !    DIAG*X if nonzero, or else to FACTOR itself.  In most cases, FACTOR should !    lie in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of squares !       are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN has reached or exceeded MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares !       is possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix of FJAC contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such !    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular with diagonal !    elements of nonincreasing magnitude.  Column J of P is column IPVT(J) !    of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) iter integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 if ( n <= 0 ) then go to 300 else if ( m < n ) then go to 300 else if ( ldfjac < m ) then go to 300 else if ( ftol < 0.0D+00 ) then go to 300 else if ( xtol < 0.0D+00 ) then go to 300 else if ( gtol < 0.0D+00 ) then go to 300 else if ( maxfev <= 0 ) then go to 300 else if ( factor <= 0.0D+00 ) then go to 300 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  Calculate the jacobian matrix. ! iflag = 2 call fdjac2 ( fcn , m , n , x , fvec , fjac , ldfjac , iflag , epsfcn ) nfev = nfev + n if ( iflag < 0 ) then go to 300 end if ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Compute the QR factorization of the jacobian. ! pivot = . true . call qrfac ( m , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) ! !  On the first iteration and if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q' * FVEC and store the first N components in QTF. ! wa4 ( 1 : m ) = fvec ( 1 : m ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( wa4 ( j : m ), fjac ( j : m , j ) ) temp = - sum2 / fjac ( j , j ) wa4 ( j : m ) = wa4 ( j : m ) + fjac ( j : m , j ) * temp end if fjac ( j , j ) = wa1 ( j ) qtf ( j ) = wa4 ( j ) end do ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = 0.0D+00 do i = 1 , j sum2 = sum2 + fjac ( i , j ) * ( qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 300 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 200 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 else actred = - 1.0D+00 end if ! !  Compute the scaled predicted reduction and the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! ratio = 0.0D+00 if ( prered /= 0.0D+00 ) then ratio = actred / prered end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( actred >= 0.0D+00 ) then temp = 0.5D+00 endif if ( actred < 0.0D+00 ) then temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = 2.0D+00 * pnorm par = 0.5D+00 * par end if end if ! !  Test for successful iteration. ! ! !  Successful iteration. update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence. ! if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) info = 3 if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 300 end if ! !  End of the inner loop.  Repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 200 end if ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , iflag ) end if return endsubroutine lmdif","tags":"","loc":"proc/lmdif.html"},{"title":"lmdif1 – TOOLIB","text":"public  subroutine lmdif1(fcn, m, n, x, fvec, tol, info) LMDIF1 minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: tol integer(kind=4) :: info Calls proc~~lmdif1~~CallsGraph proc~lmdif1 lmdif1 proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~enorm enorm proc~lmdif->proc~enorm proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~lmpar lmpar proc~lmdif->proc~lmpar proc~qrfac qrfac proc~lmdif->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmdif1~~CalledByGraph proc~lmdif1 lmdif1 proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 program~test_minpack test_minpack program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmdif1 ( fcn , m , n , x , fvec , tol , info ) !*****************************************************************************80 ! !! LMDIF1 minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMDIF1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    This is done by using the more general least-squares solver LMDIF. !    The user must provide a subroutine which calculates the functions. !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN has reached or exceeded 200*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares !       is possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) epsfcn real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( m , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) ldfjac integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( m < n ) then return else if ( tol < 0.0D+00 ) then return end if factor = 10 0.0D+00 maxfev = 200 * ( n + 1 ) ftol = tol xtol = tol gtol = 0.0D+00 epsfcn = 0.0D+00 mode = 1 nprint = 0 ldfjac = m call lmdif ( fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , & diag , mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmdif1","tags":"","loc":"proc/lmdif1.html"},{"title":"lmpar – TOOLIB","text":"public  subroutine lmpar(n, r, ldr, ipvt, diag, qtb, delta, par, x, sdiag) LMPAR computes a parameter for the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr integer(kind=4) :: ipvt (n) real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: delta real(kind=8) :: par real(kind=8) :: x (n) real(kind=8) :: sdiag (n) Calls proc~~lmpar~~CallsGraph proc~lmpar lmpar proc~enorm enorm proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmpar~~CalledByGraph proc~lmpar lmpar proc~lmder lmder proc~lmder->proc~lmpar proc~lmdif lmdif proc~lmdif->proc~lmpar proc~lmstr lmstr proc~lmstr->proc~lmpar proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1 proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1 proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmpar ( n , r , ldr , ipvt , diag , qtb , delta , par , x , sdiag ) !*****************************************************************************80 ! !! LMPAR computes a parameter for the Levenberg-Marquardt method. ! !  Discussion: ! !    Given an M by N matrix A, an N by N nonsingular diagonal !    matrix D, an M-vector B, and a positive number DELTA, !    the problem is to determine a value for the parameter !    PAR such that if X solves the system ! !      A*X = B, !      sqrt ( PAR ) * D * X = 0, ! !    in the least squares sense, and DXNORM is the euclidean !    norm of D*X, then either PAR is zero and ! !      ( DXNORM - DELTA ) <= 0.1 * DELTA, ! !    or PAR is positive and ! !      abs ( DXNORM - DELTA) <= 0.1 * DELTA. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization, with column pivoting, of A.  That is, if !    A*P = Q*R, where P is a permutation matrix, Q has orthogonal !    columns, and R is an upper triangular matrix with diagonal !    elements of nonincreasing magnitude, then LMPAR expects !    the full upper triangle of R, the permutation matrix P, !    and the first N components of Q'*B.  On output !    LMPAR also provides an upper triangular matrix S such that ! !      P' * ( A' * A + PAR * D * D ) * P = S'* S. ! !    S is employed within LMPAR and may be of separate interest. ! !    Only a few iterations are generally needed for convergence !    of the algorithm. ! !    If, however, the limit of 10 iterations is reached, then the output !    PAR will contain the best value obtained so far. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    24 January 2014 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N),the N by N matrix.  The full !    upper triangle must contain the full upper triangle of the matrix R. !    On output the full upper triangle is unaltered, and the strict lower !    triangle contains the strict upper triangle (transposed) of the upper !    triangular matrix S. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of R.  LDR must be !    no less than N. ! !    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P !    such that A*P = Q*R.  Column J of P is column IPVT(J) of the !    identity matrix. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B. ! !    Input, real ( kind = 8 ) DELTA, an upper bound on the euclidean norm !    of D*X.  DELTA should be positive. ! !    Input/output, real ( kind = 8 ) PAR.  On input an initial estimate of the !    Levenberg-Marquardt parameter.  On output the final estimate. !    PAR should be nonnegative. ! !    Output, real ( kind = 8 ) X(N), the least squares solution of the system !    A*X = B, sqrt(PAR)*D*X = 0, for the output value of PAR. ! !    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper !    triangular matrix S. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dwarf real ( kind = 8 ) dxnorm !~   real ( kind = 8 ) enorm real ( kind = 8 ) gnorm real ( kind = 8 ) fp integer ( kind = 4 ) i integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) nsing real ( kind = 8 ) par real ( kind = 8 ) parc real ( kind = 8 ) parl real ( kind = 8 ) paru real ( kind = 8 ) qnorm real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) sdiag ( n ) real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) ! !  DWARF is the smallest positive magnitude. ! dwarf = tiny ( dwarf ) ! !  Compute and store in X the Gauss-Newton direction. ! !  If the jacobian is rank-deficient, obtain a least squares solution. ! nsing = n do j = 1 , n wa1 ( j ) = qtb ( j ) if ( r ( j , j ) == 0.0D+00 . and . nsing == n ) then nsing = j - 1 end if if ( nsing < n ) then wa1 ( j ) = 0.0D+00 end if end do do k = 1 , nsing j = nsing - k + 1 wa1 ( j ) = wa1 ( j ) / r ( j , j ) temp = wa1 ( j ) wa1 ( 1 : j - 1 ) = wa1 ( 1 : j - 1 ) - r ( 1 : j - 1 , j ) * temp end do do j = 1 , n l = ipvt ( j ) x ( l ) = wa1 ( j ) end do ! !  Initialize the iteration counter. !  Evaluate the function at the origin, and test !  for acceptance of the Gauss-Newton direction. ! iter = 0 wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) dxnorm = enorm ( n , wa2 ) fp = dxnorm - delta if ( fp <= 0.1D+00 * delta ) then if ( iter == 0 ) then par = 0.0D+00 end if return end if ! !  If the jacobian is not rank deficient, the Newton !  step provides a lower bound, PARL, for the zero of !  the function. ! !  Otherwise set this bound to zero. ! parl = 0.0D+00 if ( n <= nsing ) then do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do do j = 1 , n sum2 = dot_product ( wa1 ( 1 : j - 1 ), r ( 1 : j - 1 , j ) ) wa1 ( j ) = ( wa1 ( j ) - sum2 ) / r ( j , j ) end do temp = enorm ( n , wa1 ) parl = ( ( fp / delta ) / temp ) / temp end if ! !  Calculate an upper bound, PARU, for the zero of the function. ! do j = 1 , n sum2 = dot_product ( qtb ( 1 : j ), r ( 1 : j , j ) ) l = ipvt ( j ) wa1 ( j ) = sum2 / diag ( l ) end do gnorm = enorm ( n , wa1 ) paru = gnorm / delta if ( paru == 0.0D+00 ) then paru = dwarf / min ( delta , 0.1D+00 ) end if ! !  If the input PAR lies outside of the interval (PARL, PARU), !  set PAR to the closer endpoint. ! par = max ( par , parl ) par = min ( par , paru ) if ( par == 0.0D+00 ) then par = gnorm / dxnorm end if ! !  Beginning of an iteration. ! do iter = iter + 1 ! !  Evaluate the function at the current value of PAR. ! if ( par == 0.0D+00 ) then par = max ( dwarf , 0.001D+00 * paru ) end if wa1 ( 1 : n ) = sqrt ( par ) * diag ( 1 : n ) call qrsolv ( n , r , ldr , ipvt , wa1 , qtb , x , sdiag ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) dxnorm = enorm ( n , wa2 ) temp = fp fp = dxnorm - delta ! !  If the function is small enough, accept the current value of PAR. ! if ( abs ( fp ) <= 0.1D+00 * delta ) then exit end if ! !  Test for the exceptional cases where PARL !  is zero or the number of iterations has reached 10. ! if ( parl == 0.0D+00 . and . fp <= temp . and . temp < 0.0D+00 ) then exit else if ( iter == 10 ) then exit end if ! !  Compute the Newton correction. ! do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do do j = 1 , n wa1 ( j ) = wa1 ( j ) / sdiag ( j ) temp = wa1 ( j ) wa1 ( j + 1 : n ) = wa1 ( j + 1 : n ) - r ( j + 1 : n , j ) * temp end do temp = enorm ( n , wa1 ) parc = ( ( fp / delta ) / temp ) / temp ! !  Depending on the sign of the function, update PARL or PARU. ! if ( 0.0D+00 < fp ) then parl = max ( parl , par ) else if ( fp < 0.0D+00 ) then paru = min ( paru , par ) end if ! !  Compute an improved estimate for PAR. ! par = max ( parl , par + parc ) ! !  End of an iteration. ! end do ! !  Termination. ! if ( iter == 0 ) then par = 0.0D+00 end if return endsubroutine lmpar","tags":"","loc":"proc/lmpar.html"},{"title":"lmstr – TOOLIB","text":"public  subroutine lmstr(fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf) LMSTR minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) Calls proc~~lmstr~~CallsGraph proc~lmstr lmstr proc~enorm enorm proc~lmstr->proc~enorm proc~lmpar lmpar proc~lmstr->proc~lmpar proc~qrfac qrfac proc~lmstr->proc~qrfac proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmstr~~CalledByGraph proc~lmstr lmstr proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmstr ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) !*****************************************************************************80 ! !! LMSTR minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMSTR minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm !    which uses minimal storage. ! !    The user must provide a subroutine which calculates the functions and !    the rows of the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the rows of the jacobian. !    FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjrow, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjrow(n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of !    the jacobian at X, and return this vector in FJROW. !    To terminate the algorithm, set the output value of IFLAG negative. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper !    triangle of FJAC contains an upper triangular matrix R such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    triangular part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual and !    predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number !    of calls to FCN with IFLAG = 1 is at least MAXFEV by the end of !    an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See the !    description of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of squares !       are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares is !       possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN !    with IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN !    with IFLAG = 2. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such !    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular. !    Column J of P is column IPVT(J) of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then go to 340 else if ( m < n ) then go to 340 else if ( ldfjac < n ) then go to 340 else if ( ftol < 0.0D+00 ) then go to 340 else if ( xtol < 0.0D+00 ) then go to 340 else if ( gtol < 0.0D+00 ) then go to 340 else if ( maxfev <= 0 ) then go to 340 else if ( factor <= 0.0D+00 ) then go to 340 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 340 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , wa3 , iflag ) nfev = 1 if ( iflag < 0 ) then go to 340 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , wa3 , iflag ) end if if ( iflag < 0 ) then go to 340 end if end if ! !  Compute the QR factorization of the jacobian matrix calculated one row !  at a time, while simultaneously forming Q'* FVEC and storing !  the first N components in QTF. ! qtf ( 1 : n ) = 0.0D+00 fjac ( 1 : n , 1 : n ) = 0.0D+00 iflag = 2 do i = 1 , m call fcn ( m , n , x , fvec , wa3 , iflag ) if ( iflag < 0 ) then go to 340 end if temp = fvec ( i ) call rwupdt ( n , fjac , ldfjac , wa3 , qtf , temp , wa1 , wa2 ) iflag = iflag + 1 end do njev = njev + 1 ! !  If the jacobian is rank deficient, call QRFAC to !  reorder its columns and update the components of QTF. ! sing = . false . do j = 1 , n if ( fjac ( j , j ) == 0.0D+00 ) then sing = . true . end if ipvt ( j ) = j wa2 ( j ) = enorm ( j , fjac ( 1 , j ) ) end do if ( sing ) then pivot = . true . call qrfac ( n , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( j : n ), fjac ( j : n , j ) ) temp = - sum2 / fjac ( j , j ) qtf ( j : n ) = qtf ( j : n ) + fjac ( j : n , j ) * temp end if fjac ( j , j ) = wa1 ( j ) end do end if ! !  On the first iteration !    if mode is 1, !      scale according to the norms of the columns of the initial jacobian. !    calculate the norm of the scaled X, !    initialize the step bound delta. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( 1 : j ), fjac ( 1 : j , j ) ) / fnorm gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 340 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 240 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , wa3 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 340 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 else actred = - 1.0D+00 end if ! !  Compute the scaled predicted reduction and !  the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! if ( prered /= 0.0D+00 ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( actred >= 0.0D+00 ) then temp = 0.5D+00 else temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = pnorm / 0.5D+00 par = 0.5D+00 * par end if end if ! !  Test for successful iteration. ! if ( ratio >= 0.0001D+00 ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence, termination and stringent tolerances. ! if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) then info = 3 end if if ( info /= 0 ) then go to 340 end if if ( nfev >= maxfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 340 end if ! !  End of the inner loop.  Repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 240 end if ! !  End of the outer loop. ! go to 30 340 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , wa3 , iflag ) end if return endsubroutine lmstr","tags":"","loc":"proc/lmstr.html"},{"title":"lmstr1 – TOOLIB","text":"public  subroutine lmstr1(fcn, m, n, x, fvec, fjac, ldfjac, tol, info) LMSTR1 minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info Calls proc~~lmstr1~~CallsGraph proc~lmstr1 lmstr1 proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~enorm enorm proc~lmstr->proc~enorm proc~lmpar lmpar proc~lmstr->proc~lmpar proc~qrfac qrfac proc~lmstr->proc~qrfac proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmstr1~~CalledByGraph proc~lmstr1 lmstr1 proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine lmstr1 ( fcn , m , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! LMSTR1 minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMSTR1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm !    which uses minimal storage. ! !    This is done by using the more general least-squares solver !    LMSTR.  The user must provide a subroutine which calculates !    the functions and the rows of the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the rows of the jacobian. !    FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjrow, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjrow(n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of !    the jacobian at X, and return this vector in FJROW. !    To terminate the algorithm, set the output value of IFLAG negative. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper !    triangle contains an upper triangular matrix R such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated !    jacobian.  Column J of P is column IPVT(J) of the identity matrix. !    The lower triangular part of FJAC contains information generated !    during the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) TOL. Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares !       is possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol if ( n <= 0 ) then info = 0 return end if if ( m < n ) then info = 0 return end if if ( ldfjac < n ) then info = 0 return end if if ( tol < 0.0D+00 ) then info = 0 return end if fvec ( 1 : n ) = 0.0D+00 fjac ( 1 : ldfjac , 1 : n ) = 0.0D+00 ftol = tol xtol = tol gtol = 0.0D+00 maxfev = 100 * ( n + 1 ) diag ( 1 : n ) = 0.0D+00 mode = 1 factor = 10 0.0D+00 nprint = 0 info = 0 nfev = 0 njev = 0 ipvt ( 1 : n ) = 0 qtf ( 1 : n ) = 0.0D+00 call lmstr ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmstr1","tags":"","loc":"proc/lmstr1.html"},{"title":"qform – TOOLIB","text":"public  subroutine qform(m, n, q, ldq) QFORM produces the explicit QR factorization of a matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: q (ldq,m) integer(kind=4) :: ldq Called by proc~~qform~~CalledByGraph proc~qform qform proc~hybrd hybrd proc~hybrd->proc~qform proc~hybrj hybrj proc~hybrj->proc~qform proc~qform_test qform_test proc~qform_test->proc~qform proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj program~test_minpack test_minpack program~test_minpack->proc~qform_test proc~hybrd1_test hybrd1_test program~test_minpack->proc~hybrd1_test proc~hybrj1_test hybrj1_test program~test_minpack->proc~hybrj1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test->proc~hybrj1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine qform ( m , n , q , ldq ) !*****************************************************************************80 ! !! QFORM produces the explicit QR factorization of a matrix. ! !  Discussion: ! !    The QR factorization of a matrix is usually accumulated in implicit !    form, that is, as a series of orthogonal transformations of the !    original matrix.  This routine carries out those transformations, !    to explicitly exhibit the factorization constructed by QRFAC. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, is a positive integer input variable set !    to the number of rows of A and the order of Q. ! !    Input, integer ( kind = 4 ) N, is a positive integer input variable set !    to the number of columns of A. ! !    Input/output, real ( kind = 8 ) Q(LDQ,M).  Q is an M by M array. !    On input the full lower trapezoid in the first min(M,N) columns of Q !    contains the factored form. !    On output, Q has been accumulated into a square matrix. ! !    Input, integer ( kind = 4 ) LDQ, is a positive integer input variable !    not less than M which specifies the leading dimension of the array Q. ! implicit none integer ( kind = 4 ) ldq integer ( kind = 4 ) m integer ( kind = 4 ) n integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) minmn real ( kind = 8 ) q ( ldq , m ) real ( kind = 8 ) temp real ( kind = 8 ) wa ( m ) minmn = min ( m , n ) do j = 2 , minmn q ( 1 : j - 1 , j ) = 0.0D+00 end do ! !  Initialize remaining columns to those of the identity matrix. ! q ( 1 : m , n + 1 : m ) = 0.0D+00 do j = n + 1 , m q ( j , j ) = 1.0D+00 end do ! !  Accumulate Q from its factored form. ! do l = 1 , minmn k = minmn - l + 1 wa ( k : m ) = q ( k : m , k ) q ( k : m , k ) = 0.0D+00 q ( k , k ) = 1.0D+00 if ( wa ( k ) /= 0.0D+00 ) then do j = k , m temp = dot_product ( wa ( k : m ), q ( k : m , j ) ) / wa ( k ) q ( k : m , j ) = q ( k : m , j ) - temp * wa ( k : m ) end do end if end do return endsubroutine qform","tags":"","loc":"proc/qform.html"},{"title":"qrfac – TOOLIB","text":"public  subroutine qrfac(m, n, a, lda, pivot, ipvt, lipvt, rdiag, acnorm) QRFAC computes a QR factorization using Householder transformations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (lda,n) integer(kind=4) :: lda logical :: pivot integer(kind=4) :: ipvt (lipvt) integer(kind=4) :: lipvt real(kind=8) :: rdiag (n) real(kind=8) :: acnorm (n) Calls proc~~qrfac~~CallsGraph proc~qrfac qrfac proc~enorm enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qrfac~~CalledByGraph proc~qrfac qrfac proc~hybrd hybrd proc~hybrd->proc~qrfac proc~hybrj hybrj proc~hybrj->proc~qrfac proc~lmder lmder proc~lmder->proc~qrfac proc~lmdif lmdif proc~lmdif->proc~qrfac proc~lmstr lmstr proc~lmstr->proc~qrfac proc~qform_test qform_test proc~qform_test->proc~qrfac proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr program~test_minpack test_minpack program~test_minpack->proc~qform_test proc~hybrd1_test hybrd1_test program~test_minpack->proc~hybrd1_test proc~hybrj1_test hybrj1_test program~test_minpack->proc~hybrj1_test proc~lmder1_2_test lmder1_2_test program~test_minpack->proc~lmder1_2_test proc~lmder1_test lmder1_test program~test_minpack->proc~lmder1_test proc~lmdif1_2_test lmdif1_2_test program~test_minpack->proc~lmdif1_2_test proc~lmdif1_test lmdif1_test program~test_minpack->proc~lmdif1_test proc~lmstr1_2_test lmstr1_2_test program~test_minpack->proc~lmstr1_2_test proc~lmstr1_test lmstr1_test program~test_minpack->proc~lmstr1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test->proc~hybrj1 proc~lmder1_2_test->proc~lmder1 proc~lmder1_test->proc~lmder1 proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test->proc~lmdif1 proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test->proc~lmstr1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine qrfac ( m , n , a , lda , pivot , ipvt , lipvt , rdiag , acnorm ) !*****************************************************************************80 ! !! QRFAC computes a QR factorization using Householder transformations. ! !  Discussion: ! !    This function uses Householder transformations with optional column !    pivoting to compute a QR factorization of the !    M by N matrix A.  That is, QRFAC determines an orthogonal !    matrix Q, a permutation matrix P, and an upper trapezoidal !    matrix R with diagonal elements of nonincreasing magnitude, !    such that A*P = Q*R. ! !    The Householder transformation for column K, K = 1,2,...,min(M,N), !    is of the form ! !      I - ( 1 / U(K) ) * U * U' ! !    where U has zeros in the first K-1 positions. ! !    The form of this transformation and the method of pivoting first !    appeared in the corresponding LINPACK routine. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of A. ! !    Input, integer ( kind = 4 ) N, the number of columns of A. ! !    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array. !    On input, A contains the matrix for which the QR factorization is to !    be computed.  On output, the strict upper trapezoidal part of A contains !    the strict upper trapezoidal part of R, and the lower trapezoidal !    part of A contains a factored form of Q, the non-trivial elements of !    the U vectors described above. ! !    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must !    be no less than M. ! !    Input, logical PIVOT, is TRUE if column pivoting is to be carried out. ! !    Output, integer ( kind = 4 ) IPVT(LIPVT), defines the permutation matrix P !    such that A*P = Q*R.  Column J of P is column IPVT(J) of the identity !    matrix.  If PIVOT is false, IPVT is not referenced. ! !    Input, integer ( kind = 4 ) LIPVT, the dimension of IPVT, which should !    be N if pivoting is used. ! !    Output, real ( kind = 8 ) RDIAG(N), contains the diagonal elements of R. ! !    Output, real ( kind = 8 ) ACNORM(N), the norms of the corresponding !    columns of the input matrix A.  If this information is not needed, !    then ACNORM can coincide with RDIAG. ! implicit none integer ( kind = 4 ) lda integer ( kind = 4 ) lipvt integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( lda , n ) real ( kind = 8 ) acnorm ( n ) real ( kind = 8 ) ajnorm !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch integer ( kind = 4 ) i integer ( kind = 4 ) i4_temp integer ( kind = 4 ) ipvt ( lipvt ) integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) kmax integer ( kind = 4 ) minmn logical pivot real ( kind = 8 ) r8_temp ( m ) real ( kind = 8 ) rdiag ( n ) real ( kind = 8 ) temp real ( kind = 8 ) wa ( n ) epsmch = epsilon ( epsmch ) ! !  Compute the initial column norms and initialize several arrays. ! do j = 1 , n acnorm ( j ) = enorm ( m , a ( 1 : m , j ) ) end do rdiag ( 1 : n ) = acnorm ( 1 : n ) wa ( 1 : n ) = acnorm ( 1 : n ) if ( pivot ) then do j = 1 , n ipvt ( j ) = j end do end if ! !  Reduce A to R with Householder transformations. ! minmn = min ( m , n ) do j = 1 , minmn ! !  Bring the column of largest norm into the pivot position. ! if ( pivot ) then kmax = j do k = j , n if ( rdiag ( kmax ) < rdiag ( k ) ) then kmax = k end if end do if ( kmax /= j ) then r8_temp ( 1 : m ) = a ( 1 : m , j ) a ( 1 : m , j ) = a ( 1 : m , kmax ) a ( 1 : m , kmax ) = r8_temp ( 1 : m ) rdiag ( kmax ) = rdiag ( j ) wa ( kmax ) = wa ( j ) i4_temp = ipvt ( j ) ipvt ( j ) = ipvt ( kmax ) ipvt ( kmax ) = i4_temp end if end if ! !  Compute the Householder transformation to reduce the !  J-th column of A to a multiple of the J-th unit vector. ! ajnorm = enorm ( m - j + 1 , a ( j , j ) ) if ( ajnorm /= 0.0D+00 ) then if ( a ( j , j ) < 0.0D+00 ) then ajnorm = - ajnorm end if a ( j : m , j ) = a ( j : m , j ) / ajnorm a ( j , j ) = a ( j , j ) + 1.0D+00 ! !  Apply the transformation to the remaining columns and update the norms. ! do k = j + 1 , n temp = dot_product ( a ( j : m , j ), a ( j : m , k ) ) / a ( j , j ) a ( j : m , k ) = a ( j : m , k ) - temp * a ( j : m , j ) if ( pivot . and . rdiag ( k ) /= 0.0D+00 ) then temp = a ( j , k ) / rdiag ( k ) rdiag ( k ) = rdiag ( k ) * sqrt ( max ( 0.0D+00 , 1.0D+00 - temp ** 2 ) ) if ( 0.05D+00 * ( rdiag ( k ) / wa ( k ) ) ** 2 <= epsmch ) then rdiag ( k ) = enorm ( m - j , a ( j + 1 , k ) ) wa ( k ) = rdiag ( k ) end if end if end do end if rdiag ( j ) = - ajnorm end do return endsubroutine qrfac","tags":"","loc":"proc/qrfac.html"},{"title":"qrsolv – TOOLIB","text":"public  subroutine qrsolv(n, r, ldr, ipvt, diag, qtb, x, sdiag) QRSOLV solves a rectangular linear system A*x=b in the least squares sense. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr integer(kind=4) :: ipvt (n) real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: x (n) real(kind=8) :: sdiag (n) Called by proc~~qrsolv~~CalledByGraph proc~qrsolv qrsolv proc~lmpar lmpar proc~lmpar->proc~qrsolv proc~lmder lmder proc~lmder->proc~lmpar proc~lmdif lmdif proc~lmdif->proc~lmpar proc~lmstr lmstr proc~lmstr->proc~lmpar proc~lmder1 lmder1 proc~lmder1->proc~lmder proc~lmdif1 lmdif1 proc~lmdif1->proc~lmdif proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1 proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1 proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1 proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine qrsolv ( n , r , ldr , ipvt , diag , qtb , x , sdiag ) !*****************************************************************************80 ! !! QRSOLV solves a rectangular linear system A*x=b in the least squares sense. ! !  Discussion: ! !    Given an M by N matrix A, an N by N diagonal matrix D, !    and an M-vector B, the problem is to determine an X which !    solves the system ! !      A*X = B !      D*X = 0 ! !    in the least squares sense. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization, with column pivoting, of A.  That is, if !    Q*P = Q*R, where P is a permutation matrix, Q has orthogonal !    columns, and R is an upper triangular matrix with diagonal !    elements of nonincreasing magnitude, then QRSOLV expects !    the full upper triangle of R, the permutation matrix p, !    and the first N components of Q'*B. ! !    The system is then equivalent to ! !      R*Z = Q'*B !      P'*D*P*Z = 0 ! !    where X = P*Z.  If this system does not have full rank, !    then a least squares solution is obtained.  On output QRSOLV !    also provides an upper triangular matrix S such that ! !      P'*(A'*A + D*D)*P = S'*S. ! !    S is computed within QRSOLV and may be of separate interest. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N), the N by N matrix. !    On input the full upper triangle must contain the full upper triangle !    of the matrix R.  On output the full upper triangle is unaltered, and !    the strict lower triangle contains the strict upper triangle !    (transposed) of the upper triangular matrix S. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of R, which must be !    at least N. ! !    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P such !    that A*P = Q*R.  Column J of P is column IPVT(J) of the identity matrix. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B. ! !    Output, real ( kind = 8 ) X(N), the least squares solution. ! !    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper !    triangular matrix S. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) c real ( kind = 8 ) cotan real ( kind = 8 ) diag ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) nsing real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) qtbpj real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) s real ( kind = 8 ) sdiag ( n ) real ( kind = 8 ) sum2 real ( kind = 8 ) t real ( kind = 8 ) temp real ( kind = 8 ) wa ( n ) real ( kind = 8 ) x ( n ) ! !  Copy R and Q'*B to preserve input and initialize S. ! !  In particular, save the diagonal elements of R in X. ! do j = 1 , n r ( j : n , j ) = r ( j , j : n ) x ( j ) = r ( j , j ) end do wa ( 1 : n ) = qtb ( 1 : n ) ! !  Eliminate the diagonal matrix D using a Givens rotation. ! do j = 1 , n ! !  Prepare the row of D to be eliminated, locating the !  diagonal element using P from the QR factorization. ! l = ipvt ( j ) if ( diag ( l ) /= 0.0D+00 ) then sdiag ( j : n ) = 0.0D+00 sdiag ( j ) = diag ( l ) ! !  The transformations to eliminate the row of D !  modify only a single element of Q'*B !  beyond the first N, which is initially zero. ! qtbpj = 0.0D+00 do k = j , n ! !  Determine a Givens rotation which eliminates the !  appropriate element in the current row of D. ! if ( sdiag ( k ) /= 0.0D+00 ) then if ( abs ( r ( k , k ) ) < abs ( sdiag ( k ) ) ) then cotan = r ( k , k ) / sdiag ( k ) s = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) c = s * cotan else t = sdiag ( k ) / r ( k , k ) c = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * t ** 2 ) s = c * t end if ! !  Compute the modified diagonal element of R and !  the modified element of (Q'*B,0). ! r ( k , k ) = c * r ( k , k ) + s * sdiag ( k ) temp = c * wa ( k ) + s * qtbpj qtbpj = - s * wa ( k ) + c * qtbpj wa ( k ) = temp ! !  Accumulate the tranformation in the row of S. ! do i = k + 1 , n temp = c * r ( i , k ) + s * sdiag ( i ) sdiag ( i ) = - s * r ( i , k ) + c * sdiag ( i ) r ( i , k ) = temp end do end if end do end if ! !  Store the diagonal element of S and restore !  the corresponding diagonal element of R. ! sdiag ( j ) = r ( j , j ) r ( j , j ) = x ( j ) end do ! !  Solve the triangular system for Z.  If the system is !  singular, then obtain a least squares solution. ! nsing = n do j = 1 , n if ( sdiag ( j ) == 0.0D+00 . and . nsing == n ) then nsing = j - 1 end if if ( nsing < n ) then wa ( j ) = 0.0D+00 end if end do do j = nsing , 1 , - 1 sum2 = dot_product ( wa ( j + 1 : nsing ), r ( j + 1 : nsing , j ) ) wa ( j ) = ( wa ( j ) - sum2 ) / sdiag ( j ) end do ! !  Permute the components of Z back to components of X. ! do j = 1 , n l = ipvt ( j ) x ( l ) = wa ( j ) end do return endsubroutine qrsolv","tags":"","loc":"proc/qrsolv.html"},{"title":"r1mpyq – TOOLIB","text":"public  subroutine r1mpyq(m, n, a, lda, v, w) R1MPYQ computes A*Q, where Q is the product of Householder transformations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (lda,n) integer(kind=4) :: lda real(kind=8) :: v (n) real(kind=8) :: w (n) Called by proc~~r1mpyq~~CalledByGraph proc~r1mpyq r1mpyq proc~hybrd hybrd proc~hybrd->proc~r1mpyq proc~hybrj hybrj proc~hybrj->proc~r1mpyq proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine r1mpyq ( m , n , a , lda , v , w ) !*****************************************************************************80 ! !! R1MPYQ computes A*Q, where Q is the product of Householder transformations. ! !  Discussion: ! !    Given an M by N matrix A, this function computes A*Q where !    Q is the product of 2*(N - 1) transformations ! !      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1) ! !    and GV(I), GW(I) are Givens rotations in the (I,N) plane which !    eliminate elements in the I-th and N-th planes, respectively. !    Q itself is not given, rather the information to recover the !    GV, GW rotations is supplied. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of A. ! !    Input, integer ( kind = 4 ) N, the number of columns of A. ! !    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array. !    On input, the matrix A to be postmultiplied by the orthogonal matrix Q. !    On output, the value of A*Q. ! !    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must not !    be less than M. ! !    Input, real ( kind = 8 ) V(N), W(N), contain the information necessary !    to recover the Givens rotations GV and GW. ! implicit none integer ( kind = 4 ) lda integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( lda , n ) real ( kind = 8 ) c integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) s real ( kind = 8 ) temp real ( kind = 8 ) v ( n ) real ( kind = 8 ) w ( n ) ! !  Apply the first set of Givens rotations to A. ! do j = n - 1 , 1 , - 1 if ( 1.0D+00 < abs ( v ( j ) ) ) then c = 1.0D+00 / v ( j ) s = sqrt ( 1.0D+00 - c ** 2 ) else s = v ( j ) c = sqrt ( 1.0D+00 - s ** 2 ) end if do i = 1 , m temp = c * a ( i , j ) - s * a ( i , n ) a ( i , n ) = s * a ( i , j ) + c * a ( i , n ) a ( i , j ) = temp end do end do ! !  Apply the second set of Givens rotations to A. ! do j = 1 , n - 1 if ( abs ( w ( j ) ) > 1.0D+00 ) then c = 1.0D+00 / w ( j ) s = sqrt ( 1.0D+00 - c ** 2 ) else s = w ( j ) c = sqrt ( 1.0D+00 - s ** 2 ) end if do i = 1 , m temp = c * a ( i , j ) + s * a ( i , n ) a ( i , n ) = - s * a ( i , j ) + c * a ( i , n ) a ( i , j ) = temp end do end do return endsubroutine r1mpyq","tags":"","loc":"proc/r1mpyq.html"},{"title":"r1updt – TOOLIB","text":"public  subroutine r1updt(m, n, s, ls, u, v, w, sing) R1UPDT re-triangularizes a matrix after a rank one update. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: s (ls) integer(kind=4) :: ls real(kind=8) :: u (m) real(kind=8) :: v (n) real(kind=8) :: w (m) logical :: sing Called by proc~~r1updt~~CalledByGraph proc~r1updt r1updt proc~hybrd hybrd proc~hybrd->proc~r1updt proc~hybrj hybrj proc~hybrj->proc~r1updt proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1 proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrj1 program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine r1updt ( m , n , s , ls , u , v , w , sing ) !*****************************************************************************80 ! !! R1UPDT re-triangularizes a matrix after a rank one update. ! !  Discussion: ! !    Given an M by N lower trapezoidal matrix S, an M-vector U, and an !    N-vector V, the problem is to determine an orthogonal matrix Q such that ! !      (S + U * V' ) * Q ! !    is again lower trapezoidal. ! !    This function determines Q as the product of 2 * (N - 1) !    transformations ! !      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1) ! !    where GV(I), GW(I) are Givens rotations in the (I,N) plane !    which eliminate elements in the I-th and N-th planes, !    respectively.  Q itself is not accumulated, rather the !    information to recover the GV and GW rotations is returned. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of S. ! !    Input, integer ( kind = 4 ) N, the number of columns of S. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) S(LS).  On input, the lower trapezoidal !    matrix S stored by columns.  On output S contains the lower trapezoidal !    matrix produced as described above. ! !    Input, integer ( kind = 4 ) LS, the length of the S array.  LS must be at !    least (N*(2*M-N+1))/2. ! !    Input, real ( kind = 8 ) U(M), the U vector. ! !    Input/output, real ( kind = 8 ) V(N).  On input, V must contain the !    vector V.  On output V contains the information necessary to recover the !    Givens rotations GV described above. ! !    Output, real ( kind = 8 ) W(M), contains information necessary to !    recover the Givens rotations GW described above. ! !    Output, logical SING, is set to TRUE if any of the diagonal elements !    of the output S are zero.  Otherwise SING is set FALSE. ! implicit none integer ( kind = 4 ) ls integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) cos real ( kind = 8 ) cotan real ( kind = 8 ) giant integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) l real ( kind = 8 ) s ( ls ) real ( kind = 8 ) sin logical sing real ( kind = 8 ) tan real ( kind = 8 ) tau real ( kind = 8 ) temp real ( kind = 8 ) u ( m ) real ( kind = 8 ) v ( n ) real ( kind = 8 ) w ( m ) ! !  GIANT is the largest magnitude. ! giant = huge ( giant ) ! !  Initialize the diagonal element pointer. ! jj = ( n * ( 2 * m - n + 1 ) ) / 2 - ( m - n ) ! !  Move the nontrivial part of the last column of S into W. ! l = jj do i = n , m w ( i ) = s ( l ) l = l + 1 end do ! !  Rotate the vector V into a multiple of the N-th unit vector !  in such a way that a spike is introduced into W. ! do j = n - 1 , 1 , - 1 jj = jj - ( m - j + 1 ) w ( j ) = 0.0D+00 if ( v ( j ) /= 0.0D+00 ) then ! !  Determine a Givens rotation which eliminates the !  J-th element of V. ! if ( abs ( v ( n ) ) < abs ( v ( j ) ) ) then cotan = v ( n ) / v ( j ) sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) cos = sin * cotan tau = 1.0D+00 if ( abs ( cos ) * giant > 1.0D+00 ) then tau = 1.0D+00 / cos end if else tan = v ( j ) / v ( n ) cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) sin = cos * tan tau = sin end if ! !  Apply the transformation to V and store the information !  necessary to recover the Givens rotation. ! v ( n ) = sin * v ( j ) + cos * v ( n ) v ( j ) = tau ! !  Apply the transformation to S and extend the spike in W. ! l = jj do i = j , m temp = cos * s ( l ) - sin * w ( i ) w ( i ) = sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do end if end do ! !  Add the spike from the rank 1 update to W. ! w ( 1 : m ) = w ( 1 : m ) + v ( n ) * u ( 1 : m ) ! !  Eliminate the spike. ! sing = . false . do j = 1 , n - 1 if ( w ( j ) /= 0.0D+00 ) then ! !  Determine a Givens rotation which eliminates the !  J-th element of the spike. ! if ( abs ( s ( jj ) ) < abs ( w ( j ) ) ) then cotan = s ( jj ) / w ( j ) sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) cos = sin * cotan if ( 1.0D+00 < abs ( cos ) * giant ) then tau = 1.0D+00 / cos else tau = 1.0D+00 end if else tan = w ( j ) / s ( jj ) cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) sin = cos * tan tau = sin end if ! !  Apply the transformation to S and reduce the spike in W. ! l = jj do i = j , m temp = cos * s ( l ) + sin * w ( i ) w ( i ) = - sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do ! !  Store the information necessary to recover the Givens rotation. ! w ( j ) = tau end if ! !  Test for zero diagonal elements in the output S. ! if ( s ( jj ) == 0.0D+00 ) then sing = . true . end if jj = jj + ( m - j + 1 ) end do ! !  Move W back into the last column of the output S. ! l = jj do i = n , m s ( l ) = w ( i ) l = l + 1 end do if ( s ( jj ) == 0.0D+00 ) then sing = . true . end if return endsubroutine r1updt","tags":"","loc":"proc/r1updt.html"},{"title":"r8mat_print – TOOLIB","text":"public  subroutine r8mat_print(m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title Calls proc~~r8mat_print~~CallsGraph proc~r8mat_print r8mat_print proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~r8mat_print~~CalledByGraph proc~r8mat_print r8mat_print proc~qform_test qform_test proc~qform_test->proc~r8mat_print program~test_minpack test_minpack program~test_minpack->proc~qform_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows in A. ! !    Input, integer ( kind = 4 ) N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return endsubroutine r8mat_print","tags":"","loc":"proc/r8mat_print.html"},{"title":"r8mat_print_some – TOOLIB","text":"public  subroutine r8mat_print_some(m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title Called by proc~~r8mat_print_some~~CalledByGraph proc~r8mat_print_some r8mat_print_some proc~r8mat_print r8mat_print proc~r8mat_print->proc~r8mat_print_some proc~qform_test qform_test proc~qform_test->proc~r8mat_print program~test_minpack test_minpack program~test_minpack->proc~qform_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    10 September 2009 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print. ! !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) if ( m <= 0 . or . n <= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  (None)' return end if do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,a,5a14)' ) i , ':' , ( ctemp ( j ), j = 1 , inc ) end do end do return endsubroutine r8mat_print_some","tags":"","loc":"proc/r8mat_print_some.html"},{"title":"r8vec_print – TOOLIB","text":"public  subroutine r8vec_print(n, a, title) R8VEC_PRINT prints an R8VEC. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n) character(len=*) :: title Called by proc~~r8vec_print~~CalledByGraph proc~r8vec_print r8vec_print proc~chkder_test chkder_test proc~chkder_test->proc~r8vec_print proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~r8vec_print proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~r8vec_print proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~r8vec_print proc~lmder1_test lmder1_test proc~lmder1_test->proc~r8vec_print proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~r8vec_print proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~r8vec_print proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~r8vec_print proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~r8vec_print program~test_minpack test_minpack program~test_minpack->proc~chkder_test program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test program~test_minpack->proc~lmder1_2_test program~test_minpack->proc~lmder1_test program~test_minpack->proc~lmdif1_2_test program~test_minpack->proc~lmdif1_test program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine r8vec_print ( n , a , title ) !*****************************************************************************80 ! !! R8VEC_PRINT prints an R8VEC. ! !  Discussion: ! !    An R8VEC is a vector of R8's. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    22 August 2000 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the number of components of the vector. ! !    Input, real ( kind = 8 ) A(N), the vector to be printed. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n ) integer ( kind = 4 ) i character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) write ( * , '(a)' ) ' ' do i = 1 , n write ( * , '(2x,i8,2x,g16.8)' ) i , a ( i ) end do return endsubroutine r8vec_print","tags":"","loc":"proc/r8vec_print.html"},{"title":"rwupdt – TOOLIB","text":"public  subroutine rwupdt(n, r, ldr, w, b, alpha, c, s) RWUPDT computes the decomposition of triangular matrix augmented by one row. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr real(kind=8) :: w (n) real(kind=8) :: b (n) real(kind=8) :: alpha real(kind=8) :: c (n) real(kind=8) :: s (n) Called by proc~~rwupdt~~CalledByGraph proc~rwupdt rwupdt proc~lmstr lmstr proc~lmstr->proc~rwupdt proc~lmstr1 lmstr1 proc~lmstr1->proc~lmstr proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1 program~test_minpack test_minpack program~test_minpack->proc~lmstr1_2_test program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine rwupdt ( n , r , ldr , w , b , alpha , c , s ) !*****************************************************************************80 ! !! RWUPDT computes the decomposition of triangular matrix augmented by one row. ! !  Discussion: ! !    Given an N by N upper triangular matrix R, this function !    computes the QR decomposition of the matrix formed when a row !    is added to R.  If the row is specified by the vector W, then !    RWUPDT determines an orthogonal matrix Q such that when the !    N+1 by N matrix composed of R augmented by W is premultiplied !    by Q', the resulting matrix is upper trapezoidal. !    The matrix Q' is the product of N transformations ! !      G(N)*G(N-1)* ... *G(1) ! !    where G(I) is a Givens rotation in the (I,N+1) plane which eliminates !    elements in the (N+1)-st plane.  RWUPDT also computes the product !    Q'*C where C is the (N+1)-vector (B,ALPHA). ! !    Q itself is not accumulated, rather the information to recover the G !    rotations is supplied. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N).  On input the upper triangular !    part of R must contain the matrix to be updated.  On output R contains the !    updated triangular matrix. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of the array R. !    LDR must not be less than N. ! !    Input, real ( kind = 8 ) W(N), the row vector to be added to R. ! !    Input/output, real ( kind = 8 ) B(N).  On input, the first N elements !    of the vector C.  On output the first N elements of the vector Q'*C. ! !    Input/output, real ( kind = 8 ) ALPHA.  On input, the (N+1)-st element !    of the vector C.  On output the (N+1)-st element of the vector Q'*C. ! !    Output, real ( kind = 8 ) C(N), S(N), the cosines and sines of the !    transforming Givens rotations. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) alpha real ( kind = 8 ) b ( n ) real ( kind = 8 ) c ( n ) real ( kind = 8 ) cotan integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) rowj real ( kind = 8 ) s ( n ) real ( kind = 8 ) tan real ( kind = 8 ) temp real ( kind = 8 ) w ( n ) do j = 1 , n rowj = w ( j ) ! !  Apply the previous transformations to R(I,J), I=1,2,...,J-1, and to W(J). ! do i = 1 , j - 1 temp = c ( i ) * r ( i , j ) + s ( i ) * rowj rowj = - s ( i ) * r ( i , j ) + c ( i ) * rowj r ( i , j ) = temp end do ! !  Determine a Givens rotation which eliminates W(J). ! c ( j ) = 1.0D+00 s ( j ) = 0.0D+00 if ( rowj /= 0.0D+00 ) then if ( abs ( r ( j , j ) ) < abs ( rowj ) ) then cotan = r ( j , j ) / rowj s ( j ) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) c ( j ) = s ( j ) * cotan else tan = rowj / r ( j , j ) c ( j ) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) s ( j ) = c ( j ) * tan end if ! !  Apply the current transformation to R(J,J), B(J), and ALPHA. ! r ( j , j ) = c ( j ) * r ( j , j ) + s ( j ) * rowj temp = c ( j ) * b ( j ) + s ( j ) * alpha alpha = - s ( j ) * b ( j ) + c ( j ) * alpha b ( j ) = temp end if end do return endsubroutine rwupdt","tags":"","loc":"proc/rwupdt.html"},{"title":"timestamp – TOOLIB","text":"public  subroutine timestamp() TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None Called by proc~~timestamp~~CalledByGraph proc~timestamp timestamp program~test_minpack test_minpack program~test_minpack->proc~timestamp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return endsubroutine timestamp","tags":"","loc":"proc/timestamp.html"},{"title":"autocov_impo – TOOLIB","text":"function autocov_impo(xi, xj, tau1, tau2, alpha, ang) Note Function that returns Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) Called by proc~~autocov_impo~~CalledByGraph proc~autocov_impo autocov_impo proc~calc_imp_acf calc_imp_acf proc~calc_imp_acf->proc~autocov_impo proc~df df proc~df->proc~autocov_impo proc~f f proc~f->proc~autocov_impo proc~calc_jf calc_Jf proc~calc_jf->proc~df program~test_least test_least program~test_least->proc~calc_imp_acf program~test_least->proc~calc_jf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/autocov_impo.html"},{"title":"df – TOOLIB","text":"function df(xi, yi, var, nb_var, ivar, typ) Uses data_arch proc~~df~~UsesGraph proc~df df module~data_arch data_arch proc~df->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Kind of particular 2D autocorrelation function. Numerical derivatives. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi x coordinates real(kind=R8), intent(in) :: yi y coordinates real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameter vector integer(kind=I4), intent(in) :: nb_var number of parameters integer(kind=I4), intent(in) :: ivar ith parameter character(len=*), intent(in) :: typ not used here Return Value real(kind=r8) Calls proc~~df~~CallsGraph proc~df df proc~autocov_impo autocov_impo proc~df->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~df~~CalledByGraph proc~df df proc~calc_jf calc_Jf proc~calc_jf->proc~df program~test_least test_least program~test_least->proc~calc_jf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/df.html"},{"title":"f – TOOLIB","text":"function f(xi, yi, var, nb_var, typ) Uses data_arch proc~~f~~UsesGraph proc~f f module~data_arch data_arch proc~f->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Kind of particular 2D autocorrelation function Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi x coordinates real(kind=R8), intent(in) :: yi y coordinates real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameter vector integer(kind=I4), intent(in) :: nb_var number of parameters character(len=*), intent(in) :: typ not used here Return Value real(kind=r8) Calls proc~~f~~CallsGraph proc~f f proc~autocov_impo autocov_impo proc~f->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/f.html"},{"title":"calc_Jf – TOOLIB","text":"subroutine calc_Jf(long, larg, nb_var, vec_xy, var, Jf) Determine the Jacobian matrix of f Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long number of points along x integer(kind=I4), intent(in) :: larg number of points along y integer(kind=I4), intent(in) :: nb_var number of parameters to be determined real(kind=R8), intent(in), dimension(1:long * larg, 1:2) :: vec_xy x and y coordinates of evaluation points real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameters vector real(kind=R8), intent(out), dimension(1:long * larg, 1:nb_var) :: Jf Jacobian matrix Calls proc~~calc_jf~~CallsGraph proc~calc_jf calc_Jf proc~df df proc~calc_jf->proc~df proc~autocov_impo autocov_impo proc~df->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_jf~~CalledByGraph proc~calc_jf calc_Jf program~test_least test_least program~test_least->proc~calc_jf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_Jf ( long , larg , nb_var , vec_xy , var , Jf ) !! Determine the Jacobian matrix of f implicit none integer ( kind = I4 ), intent ( in ) :: long !! *number of points along x* integer ( kind = I4 ), intent ( in ) :: larg !! *number of points along y* integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* real ( kind = R8 ), intent ( in ), dimension ( 1 : long * larg , 1 : 2 ) :: vec_xy !! *x and y coordinates of evaluation points* real ( kind = R8 ), intent ( out ), dimension ( 1 : long * larg , 1 : nb_var ) :: Jf !! *Jacobian matrix* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameters vector* integer ( kind = I4 ) :: i , j , k , ivar k = 0 do j = 1 , larg do i = 1 , long k = k + 1 do ivar = 1 , nb_var Jf ( k , ivar ) = df ( xi = vec_xy ( k , 1 ), & ! yi = vec_xy ( k , 2 ), & ! var = var ( 1 : 3 ), & ! nb_var = 3 , & ! ivar = ivar , & ! typ = \"no_type\" ) ! enddo enddo enddo return endsubroutine calc_Jf","tags":"","loc":"proc/calc_jf.html"},{"title":"calc_imp_acf – TOOLIB","text":"subroutine calc_imp_acf(long, larg, tau1, tau2, alpha, ang, vec_acf, vec_xy) Note Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long * larg) :: vec_acf resulting acf real(kind=R8), intent(out), dimension(1:long * larg, 1:2) :: vec_xy points coordinates Calls proc~~calc_imp_acf~~CallsGraph proc~calc_imp_acf calc_imp_acf proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_imp_acf~~CalledByGraph proc~calc_imp_acf calc_imp_acf program~test_least test_least program~test_least->proc~calc_imp_acf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , vec_acf , vec_xy ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> !< The autocorrelation function is supposed to be obtained from a real surface which must be periodic !< or nearly periodic (because of the use of FFTs). !< In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), !< therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long * larg ), intent ( out ) :: vec_acf !! *resulting acf* real ( kind = R8 ), dimension ( 1 : long * larg , 1 : 2 ), intent ( out ) :: vec_xy !! *points coordinates* integer ( kind = I4 ) :: i , j , k , long2 , larg2 real ( kind = R8 ) :: xi , xj , r long2 = long / 2 + 1 larg2 = larg / 2 + 1 k = 0 do j = 1 , larg do i = 1 , long k = k + 1 xi = real ( i - long2 , kind = R8 ) / long xj = real ( j - larg2 , kind = R8 ) / larg vec_xy ( k , 1 ) = xi vec_xy ( k , 2 ) = xj call random_number ( r ) r = 1. + 0.05 * ( 2 * ( 0.5 - r )) vec_acf ( k ) = r * autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo return endsubroutine calc_imp_acf","tags":"","loc":"proc/calc_imp_acf.html"},{"title":"convert_to_poly – TOOLIB","text":"subroutine convert_to_poly(long1, long2, deg1, deg2, tab_coef, tab_out) Génération d’une surface polynômiale pour vérification des procédures d’approximation Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: deg1 degré selon x integer(kind=I4), intent(in) :: deg2 degré selon y real(kind=R8), intent(in), dimension(1:(deg1+1) * (deg2+1)) :: tab_coef tableau des coefficients real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface Called by proc~~convert_to_poly~~CalledByGraph proc~convert_to_poly convert_to_poly program~test_tchebychev test_tchebychev program~test_tchebychev->proc~convert_to_poly Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine convert_to_poly ( long1 , long2 , deg1 , deg2 , tab_coef , tab_out ) !! Génération d'une surface polynômiale pour vérification des procédures d'approximation implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , k1 , k2 , k1k2 tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine convert_to_poly","tags":"","loc":"proc/convert_to_poly.html"},{"title":"genere_surf_poly – TOOLIB","text":"subroutine genere_surf_poly(long1, long2, deg1, deg2, tab_out, tab_coef) génère une surface Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: deg1 degré selon x integer(kind=I4), intent(in) :: deg2 degré selon y real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface real(kind=R8), intent(out), dimension(1:(deg1+1) * (deg2+1)) :: tab_coef tableau des coefficients Calls proc~~genere_surf_poly~~CallsGraph proc~genere_surf_poly genere_surf_poly proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~genere_surf_poly->proc~coeff_tcheby_vers_monome proc~tcheby tcheby proc~genere_surf_poly->proc~tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~genere_surf_poly~~CalledByGraph proc~genere_surf_poly genere_surf_poly program~test_tchebychev test_tchebychev program~test_tchebychev->proc~genere_surf_poly Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine genere_surf_poly ( long1 , long2 , deg1 , deg2 , tab_out , tab_coef ) !! génère une surface implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ), intent ( out ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , ij , k1 , k2 , k1k2 real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai real ( kind = R8 ), dimension ( 0 : deg2 ) :: aj real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai_m real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_t real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_m call random_number ( ai ( 0 : deg1 ) ) call random_number ( aj ( 0 : deg2 ) ) ai = + 9 * ai - 4._R8 aj = - 5 * aj + 8._R8 ! =========================== SIMPLE CHECK ===================================================== ! A combination of Tchebychev polynomials must ! yield the same results as a classical polynomial !-------------------------------------------- val_xi_t = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_t ( i ) = val_xi_t ( i ) + ai ( k1 ) * tcheby ( n = k1 , x = xi ) enddo enddo !-------------------------------------------- ! Towards equivalent classical polynomial call coeff_tcheby_vers_monome ( coeff_t = ai ( 0 : deg1 ), coeff_m = ai_m ( 0 : deg1 ), deg = deg1 ) val_xi_m = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_m ( i ) = val_xi_m ( i ) + ai_m ( k1 ) * ( xi ** k1 ) enddo enddo !-------------------------------------------- write ( * , * ) 'Equivalence of Tchebychev and classical polynomials' write ( * , * ) 'Difference must be negligible' write ( * , * ) ' Diff = ' , maxval ( abs ( val_xi_m - val_xi_t ) ) !-------------------------------------------- ! =========================== END SIMPLE CHECK ================================================== tab_coef = 0._R8 ij = 0 do j = 0 , deg2 do i = 0 , deg1 ij = ij + 1 tab_coef ( ij ) = ai ( i ) * aj ( j ) enddo enddo tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine genere_surf_poly","tags":"","loc":"proc/genere_surf_poly.html"},{"title":"def_tab1D – TOOLIB","text":"function def_tab1D(i) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: i Return Value real(kind=r8) Called by proc~~def_tab1d~~CalledByGraph proc~def_tab1d def_tab1D proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~def_tab1d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/def_tab1d.html"},{"title":"def_tab2D – TOOLIB","text":"function def_tab2D(i, j) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Called by proc~~def_tab2d~~CalledByGraph proc~def_tab2d def_tab2D proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~def_tab2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/def_tab2d.html"},{"title":"test_interp_pond – TOOLIB","text":"subroutine test_interp_pond(ordre) Test interpolation/weighting function for a particular order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: ordre order Calls proc~~test_interp_pond~~CallsGraph proc~test_interp_pond test_interp_pond proc~def_tab1d def_tab1D proc~test_interp_pond->proc~def_tab1d proc~def_tab2d def_tab2D proc~test_interp_pond->proc~def_tab2d proc~interp1d interp1D proc~test_interp_pond->proc~interp1d proc~interp2d interp2D proc~test_interp_pond->proc~interp2d proc~restrict1d restrict1D proc~test_interp_pond->proc~restrict1d proc~restrict2d restrict2D proc~test_interp_pond->proc~restrict2d proc~interp interp proc~interp1d->proc~interp proc~interp2d->proc~interp1d proc~restrict restrict proc~restrict1d->proc~restrict proc~restrict2d->proc~restrict1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test_interp_pond~~CalledByGraph proc~test_interp_pond test_interp_pond program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test_interp_pond ( ordre ) !! Test interpolation/weighting function for a particular order implicit none integer ( kind = I4 ), intent ( in ) :: ordre !! order integer ( kind = I4 ) :: i , ii , j , jj , istat1 , istat2 real ( kind = R8 ), allocatable , dimension (:) :: tableau1D , tab_f1D , tab_g1D , erreur1D real ( kind = R8 ), allocatable , dimension (:,:) :: tableau2D , tab_f2D , tab_g2D , erreur2D type ( tborne ) :: bfin , bgro allocate ( tableau1D ( 0 : n2 ), tab_f1D ( 0 : n2 ), & ! tab_g1D ( 0 : n1 ), erreur1D ( 0 : n2 ), & ! stat = istat1 ) ! allocate ( tableau2D ( 0 : n2 , 0 : n2 ), tab_f2D ( 0 : n2 , 0 : n2 ), & ! tab_g2D ( 0 : n1 , 0 : n1 ), erreur2D ( 0 : n2 , 0 : n2 ), & ! stat = istat2 ) ! if ( istat1 + istat2 /= 0 ) stop '\"test_interp_pond\" problem of allocation' !............................................................. do ii = 0 , n1 i = 2 * ii tableau1D ( ii ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call interp1D ( tabgros = tableau1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( def_tab1D ( i ) - tab_f1D ( i ) ) / & ! ( def_tab1D ( i ) + tab_f1D ( i ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'interp 1D - max err, mean err: :         ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau do ii = 0 , n1 erreur1D ( ii ) = 200 * abs ( ( def_tab1D ( 2 * ii ) - tab_g1D ( ii ) ) / & ! ( def_tab1D ( 2 * ii ) + tab_g1D ( ii ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'weight 1D - max err, mean err:           ' , maxval ( erreur1D ( 0 : n1 ) ), sum ( erreur1D ( 0 : n1 ) ) / ( n1 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau call interp1D ( tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( tableau1D ( i ) - tab_f1D ( i ) ) / & ! ( tableau1D ( i ) + tab_f1D ( i ) ) ) ! comparaison avant/après enddo write ( * , * ) 'weight + interp 1D - max err, mean err:  ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !............................................................. ! Idem 2D !............................................................. do jj = 0 , n1 do ii = 0 , n1 i = 2 * ii j = 2 * jj tableau2D ( ii , jj ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call interp2D ( tabgro = tableau2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( def_tab2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( def_tab2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'interp 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! do jj = 0 , n1 do ii = 0 , n1 erreur2D ( ii , jj ) = 200 * abs ( ( def_tab2D ( 2 * ii , 2 * jj ) - tab_g2D ( ii , jj ) ) / & ! ( def_tab2D ( 2 * ii , 2 * jj ) + tab_g2D ( ii , jj ) ) ) ! enddo enddo write ( * , * ) 'weight 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n1 , 0 : n1 ) ), sum ( erreur2D ( 0 : n1 , 0 : n1 ) ) / ( n1 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! call interp2D ( tabgro = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( tableau2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( tableau2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'weight + interp 2D - max err, mean err:  ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 deallocate ( tableau1D , tab_f1D , tab_g1D , erreur1D ) deallocate ( tableau2D , tab_f2D , tab_g2D , erreur2D ) return endsubroutine test_interp_pond","tags":"","loc":"proc/test_interp_pond.html"},{"title":"urand – TOOLIB","text":"private  function urand(me) result(r) Return the next pseudo-random deviate from a sequence which is\nuniformly distributed in the interval [0,1] Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me Return Value real(kind=wp) Calls proc~~urand~~CallsGraph proc~urand pikaia_class%urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~urand~~CalledByGraph proc~urand pikaia_class%urand proc~cross pikaia_class%cross proc~cross->proc~urand proc~mutate pikaia_class%mutate proc~mutate->proc~urand proc~pikaia pikaia_class%pikaia proc~pikaia->proc~urand proc~pikaia->proc~cross proc~pikaia->proc~mutate proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~select_parents->proc~urand proc~stdrep->proc~urand proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function urand ( me ) result ( r ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ) :: r r = me % rand % genrand64_real1 () end function urand","tags":"","loc":"proc/urand.html"},{"title":"adjmut – TOOLIB","text":"private  subroutine adjmut(me, oldph, fitns, ifit) Dynamical adjustment of mutation rate: imut=2 or imut=5 : adjustment based on fitness differential\n   between best and median individuals imut=3 or imut=6 : adjustment based on metric distance\n   between best and median individuals Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit Called by proc~~adjmut~~CalledByGraph proc~adjmut pikaia_class%adjmut proc~pikaia pikaia_class%pikaia proc~pikaia->proc~adjmut proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine adjmut ( me , oldph , fitns , ifit ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % np ), intent ( in ) :: ifit real ( wp ), dimension ( me % n , me % np ), intent ( in ) :: oldph real ( wp ), dimension ( me % np ), intent ( in ) :: fitns integer :: i real ( wp ) :: rdif real ( wp ), parameter :: rdiflo = 0.05_wp real ( wp ), parameter :: rdifhi = 0.25_wp real ( wp ), parameter :: delta = 1.5_wp if ( me % imut == 2 . or . me % imut == 5 ) then !Adjustment based on fitness differential rdif = abs ( fitns ( ifit ( me % np )) - & fitns ( ifit ( me % np / 2 ))) / ( fitns ( ifit ( me % np )) + & fitns ( ifit ( me % np / 2 ))) else if ( me % imut == 3 . or . me % imut == 6 ) then !Adjustment based on normalized metric distance rdif = 0.0_wp do i = 1 , me % n rdif = rdif + ( oldph ( i , ifit ( me % np )) - oldph ( i , ifit ( me % np / 2 )) ) ** 2 end do rdif = sqrt ( rdif ) / real ( me % n , wp ) end if if ( rdif <= rdiflo ) then me % pmut = min ( me % pmutmx , me % pmut * delta ) else if ( rdif >= rdifhi ) then me % pmut = max ( me % pmutmn , me % pmut / delta ) end if end subroutine adjmut","tags":"","loc":"proc/adjmut.html"},{"title":"cross – TOOLIB","text":"private  subroutine cross(me, gn1, gn2) breeds two parent chromosomes into two offspring chromosomes.\n  breeding occurs through crossover. If the crossover probability\n  test yields true (crossover taking place), either one-point or\n  two-point crossover is used, with equal probabilities. Note Compatibility with version 1.0: To enforce 100% use of one-point\n      crossover, un-comment appropriate line in source code below Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn1 integer, intent(inout), dimension(me%n*me%nd) :: gn2 Calls proc~~cross~~CallsGraph proc~cross pikaia_class%cross proc~urand pikaia_class%urand proc~cross->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~cross~~CalledByGraph proc~cross pikaia_class%cross proc~pikaia pikaia_class%pikaia proc~pikaia->proc~cross proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cross ( me , gn1 , gn2 ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn1 integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn2 integer :: i , ispl , ispl2 , itmp , t !Use crossover probability to decide whether a crossover occurs if ( me % urand () < me % pcross ) then !Compute first crossover point ispl = int ( me % urand () * me % n * me % nd ) + 1 !Now choose between one-point and two-point crossover if ( me % urand () < 0.5_wp ) then ispl2 = me % n * me % nd else ispl2 = int ( me % urand () * me % n * me % nd ) + 1 !Un-comment following line to enforce one-point crossover !ispl2=me%n*me%nd if ( ispl2 < ispl ) then itmp = ispl2 ispl2 = ispl ispl = itmp end if end if !Swap genes from ispl to ispl2 do i = ispl , ispl2 t = gn2 ( i ) gn2 ( i ) = gn1 ( i ) gn1 ( i ) = t end do end if end subroutine cross","tags":"","loc":"proc/cross.html"},{"title":"decode – TOOLIB","text":"private  subroutine decode(me, gn, ph) decode genotype into phenotype parameters\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me integer, intent(in), dimension(me%n*me%nd) :: gn real(kind=wp), intent(out), dimension(me%n) :: ph Called by proc~~decode~~CalledByGraph proc~decode pikaia_class%decode proc~pikaia pikaia_class%pikaia proc~pikaia->proc~decode proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine decode ( me , gn , ph ) implicit none class ( pikaia_class ), intent ( in ) :: me integer , dimension ( me % n * me % nd ), intent ( in ) :: gn real ( wp ), dimension ( me % n ), intent ( out ) :: ph integer :: ip , i , j , ii real ( wp ) :: z z = 1 0.0_wp ** ( - me % nd ) ii = 0 do i = 1 , me % n ip = 0 do j = 1 , me % nd ip = 10 * ip + gn ( ii + j ) end do ph ( i ) = ip * z ii = ii + me % nd end do end subroutine decode","tags":"","loc":"proc/decode.html"},{"title":"encode – TOOLIB","text":"private  subroutine encode(me, ph, gn) Encode phenotype parameters into integer genotype\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me real(kind=wp), intent(in), dimension(me%n) :: ph integer, intent(out), dimension(me%n*me%nd) :: gn Called by proc~~encode~~CalledByGraph proc~encode pikaia_class%encode proc~pikaia pikaia_class%pikaia proc~pikaia->proc~encode proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine encode ( me , ph , gn ) implicit none class ( pikaia_class ), intent ( in ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: ph integer , dimension ( me % n * me % nd ), intent ( out ) :: gn integer :: ip , i , j , ii real ( wp ) :: z z = 1 0.0_wp ** me % nd ii = 0 do i = 1 , me % n ip = int ( ph ( i ) * z ) do j = me % nd , 1 , - 1 gn ( ii + j ) = mod ( ip , 10 ) ip = ip / 10 end do ii = ii + me % nd end do end subroutine encode","tags":"","loc":"proc/encode.html"},{"title":"func_wrapper – TOOLIB","text":"private  subroutine func_wrapper(me, x, f) Wrapper for the user’s function that is used by the main pikaia routine\nThe x input to this function comes from pikaia, and will be between [0,1]. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out) :: f Called by proc~~func_wrapper~~CalledByGraph proc~func_wrapper pikaia_class%func_wrapper proc~newpop pikaia_class%newpop proc~newpop->proc~func_wrapper proc~pikaia pikaia_class%pikaia proc~pikaia->proc~func_wrapper proc~pikaia->proc~newpop proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine func_wrapper ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me ! pikaia class real ( wp ), dimension (:), intent ( in ) :: x ! optimization variable vector [0,1] real ( wp ), intent ( out ) :: f ! fitness value real ( wp ), dimension ( me % n ) :: xp !unscaled x vector: [xu,xl] !map each x variable from [0,1] to [xl,xu]: xp = me % xl + me % del * x !call the user's function with xp: call me % user_f ( xp , f ) end subroutine func_wrapper","tags":"","loc":"proc/func_wrapper.html"},{"title":"genrep – TOOLIB","text":"private  subroutine genrep(me, ip, ph, newph) Full generational replacement: accumulate offspring into new\npopulation array Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in) :: ip real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(out), dimension(me%n,me%np) :: newph Called by proc~~genrep~~CalledByGraph proc~genrep pikaia_class%genrep proc~pikaia pikaia_class%pikaia proc~pikaia->proc~genrep proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine genrep ( me , ip , ph , newph ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , intent ( in ) :: ip real ( wp ), dimension ( me % n , 2 ), intent ( in ) :: ph real ( wp ), dimension ( me % n , me % np ), intent ( out ) :: newph integer :: i1 , i2 , k !Insert one offspring pair into new population i1 = 2 * ip - 1 i2 = i1 + 1 do k = 1 , me % n newph ( k , i1 ) = ph ( k , 1 ) newph ( k , i2 ) = ph ( k , 2 ) end do end subroutine genrep","tags":"","loc":"proc/genrep.html"},{"title":"mutate – TOOLIB","text":"private  subroutine mutate(me, gn) Introduces random mutation in a genotype.\n  Mutations occur at rate pmut at all gene loci. Input imut=1    Uniform mutation, constant rate imut=2    Uniform mutation, variable rate based on fitness imut=3    Uniform mutation, variable rate based on distance imut=4    Uniform or creep mutation, constant rate imut=5    Uniform or creep mutation, variable rate based on fitness imut=6    Uniform or creep mutation, variable rate based on distance Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn Calls proc~~mutate~~CallsGraph proc~mutate pikaia_class%mutate proc~urand pikaia_class%urand proc~mutate->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~mutate~~CalledByGraph proc~mutate pikaia_class%mutate proc~pikaia pikaia_class%pikaia proc~pikaia->proc~mutate proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mutate ( me , gn ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn integer :: i , j , k , l , ist , inc , loc logical :: fix !Decide which type of mutation is to occur if ( me % imut >= 4 . and . me % urand () <= 0.5_wp ) then !CREEP MUTATION OPERATOR !Subject each locus to random +/- 1 increment at the rate pmut do i = 1 , me % n do j = 1 , me % nd if ( me % urand () < me % pmut ) then !Construct integer loc = ( i - 1 ) * me % nd + j inc = nint ( me % urand () ) * 2 - 1 ist = ( i - 1 ) * me % nd + 1 gn ( loc ) = gn ( loc ) + inc !This is where we carry over the one (up to two digits) !first take care of decrement below 0 case if ( inc < 0 . and . gn ( loc ) < 0 ) then if ( j == 1 ) then gn ( loc ) = 0 else fix = . true . do k = loc , ist + 1 , - 1 gn ( k ) = 9 gn ( k - 1 ) = gn ( k - 1 ) - 1 if ( gn ( k - 1 ) >= 0 ) then fix = . false . exit end if end do if ( fix ) then !we popped under 0.00000 lower bound; fix it up if ( gn ( ist ) < 0 ) then do l = ist , loc gn ( l ) = 0 end do end if end if end if end if if ( inc > 0 . and . gn ( loc ) > 9 ) then if ( j == 1 ) then gn ( loc ) = 9 else fix = . true . do k = loc , ist + 1 , - 1 gn ( k ) = 0 gn ( k - 1 ) = gn ( k - 1 ) + 1 if ( gn ( k - 1 ) <= 9 ) then fix = . false . exit end if end do if ( fix ) then !we popped over 9.99999 upper bound; fix it up if ( gn ( ist ) > 9 ) then do l = ist , loc gn ( l ) = 9 end do end if end if end if end if end if end do end do else !UNIFORM MUTATION OPERATOR !Subject each locus to random mutation at the rate pmut do i = 1 , me % n * me % nd if ( me % urand () < me % pmut ) then gn ( i ) = int ( me % urand () * 1 0.0_wp ) end if end do end if end subroutine mutate","tags":"","loc":"proc/mutate.html"},{"title":"newpop – TOOLIB","text":"private  subroutine newpop(me, oldph, newph, ifit, jfit, fitns, nnew) Replaces old population by new; recomputes fitnesses & ranks History Jacob Williams : 3/9/2015 : avoid unnecessary function evaluation if ielite/=1 . Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%n,me%np) :: newph integer, intent(out), dimension(me%np) :: ifit integer, intent(out), dimension(me%np) :: jfit real(kind=wp), intent(out), dimension(me%np) :: fitns integer, intent(out) :: nnew Calls proc~~newpop~~CallsGraph proc~newpop pikaia_class%newpop proc~func_wrapper pikaia_class%func_wrapper proc~newpop->proc~func_wrapper proc~rnkpop pikaia_class%rnkpop proc~newpop->proc~rnkpop proc~rqsort rqsort proc~rnkpop->proc~rqsort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newpop~~CalledByGraph proc~newpop pikaia_class%newpop proc~pikaia pikaia_class%pikaia proc~pikaia->proc~newpop proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine newpop ( me , oldph , newph , ifit , jfit , fitns , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: oldph real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: newph integer , dimension ( me % np ), intent ( out ) :: ifit integer , dimension ( me % np ), intent ( out ) :: jfit real ( wp ), dimension ( me % np ), intent ( out ) :: fitns integer , intent ( out ) :: nnew integer :: i real ( wp ) :: f nnew = me % np if ( me % ielite == 1 ) then !if using elitism, introduce in new population fittest of old !population (if greater than fitness of the individual it is !to replace) call me % ff ( newph (:, 1 ), f ) if ( f < fitns ( ifit ( me % np ))) then newph (:, 1 ) = oldph (:, ifit ( me % np )) nnew = nnew - 1 end if end if !replace population oldph = newph !get fitness using caller's fitness function !$omp parallel do private(i) do i = 1 , me % np call me % ff ( oldph (:, i ), fitns ( i )) end do !$omp end parallel do !compute new population fitness rank order call me % rnkpop ( fitns , ifit , jfit ) end subroutine newpop","tags":"","loc":"proc/newpop.html"},{"title":"pikaia – TOOLIB","text":"private  subroutine pikaia(me, x, f, status, omp) Optimization (maximization) of user-supplied “fitness” function\n  over n-dimensional parameter space x using a basic genetic\n  algorithm method. Genetic algorithms are heuristic search techniques that\n  incorporate in a computational setting, the biological notion\n  of evolution by means of natural selection.  This subroutine\n  implements the three basic operations of selection, crossover,\n  and mutation, operating on “genotypes” encoded as strings. Version 1.2 differs from version 1.0 (December 1995) in that\n  it includes (1) two-point crossover, (2) creep mutation, and\n  (3) dynamical adjustment of the mutation rate based on metric\n  distance in parameter space. Authors Paul Charbonneau & Barry Knapp\n     (High Altitude Observatory, National Center for Atmospheric Research)\n     Version 1.2 [ 2002 April 3 ] Jacob Williams : 3/8/3015 : Refactoring and some new features. References Charbonneau, Paul. “An introduction to genetic algorithms for\n     numerical optimization”, NCAR Technical Note TN-450+IA\n     (April 2002) Charbonneau, Paul. “Release Notes for PIKAIA 1.2”,\n     NCAR Technical Note TN-451+STR (April 2002) Charbonneau, Paul, and Knapp, Barry. “A User’s Guide\n     to PIKAIA 1.0” NCAR Technical Note TN-418+IA\n     (December 1995) Goldberg, David E.  Genetic Algorithms in Search, Optimization,\n     & Machine Learning.  Addison-Wesley, 1989. Davis, Lawrence, ed.  Handbook of Genetic Algorithms.\n     Van Nostrand Reinhold, 1991. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x Input - initial guess for solution vector.\nOutput - the “fittest” (optimal) solution found,\ni.e., the solution which maximizes the fitness function. real(kind=wp), intent(out) :: f the (scalar) value of the fitness function at x integer, intent(out) :: status an indicator of the success or failure\nof the call to pikaia (0=success; non-zero=failure) logical, intent(in), optional :: omp if OpenMP is being used Calls proc~~pikaia~~CallsGraph proc~pikaia pikaia_class%pikaia proc~adjmut pikaia_class%adjmut proc~pikaia->proc~adjmut proc~cross pikaia_class%cross proc~pikaia->proc~cross proc~decode pikaia_class%decode proc~pikaia->proc~decode proc~encode pikaia_class%encode proc~pikaia->proc~encode proc~func_wrapper pikaia_class%func_wrapper proc~pikaia->proc~func_wrapper proc~genrep pikaia_class%genrep proc~pikaia->proc~genrep proc~mutate pikaia_class%mutate proc~pikaia->proc~mutate proc~newpop pikaia_class%newpop proc~pikaia->proc~newpop proc~report pikaia_class%report proc~pikaia->proc~report proc~rninit pikaia_class%rninit proc~pikaia->proc~rninit proc~rnkpop pikaia_class%rnkpop proc~pikaia->proc~rnkpop proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~urand pikaia_class%urand proc~pikaia->proc~urand proc~cross->proc~urand proc~mutate->proc~urand proc~newpop->proc~func_wrapper proc~newpop->proc~rnkpop none~initialize mt19937%initialize proc~rninit->none~initialize proc~rqsort rqsort proc~rnkpop->proc~rqsort proc~select_parents->proc~urand proc~stdrep->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64 mt19937%init_genrand64 none~initialize->proc~init_genrand64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~genrand64_int64->proc~init_genrand64 proc~init_by_array64->proc~init_genrand64 proc~init_genrand64_i4->none~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pikaia~~CalledByGraph proc~pikaia pikaia_class%pikaia proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine pikaia ( me , x , f , status , omp ) implicit none !subroutine arguments: class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! Input - initial guess for solution vector. !! Output - the \"fittest\" (optimal) solution found, !! i.e., the solution which maximizes the fitness function. real ( wp ), intent ( out ) :: f !! the (scalar) value of the fitness function at x integer , intent ( out ) :: status !! an indicator of the success or failure !! of the call to pikaia (0=success; non-zero=failure) logical , intent ( in ), optional :: omp !! if OpenMP is being used !Local variables integer :: k , ip , ig , ip1 , ip2 , new , newtot , istart , i_window , j real ( wp ) :: current_best_f , last_best_f , fguess logical :: convergence logical :: use_openmp !! if OpenMP is being used real ( wp ), dimension ( me % n , 2 , me % np / 2 ) :: ph real ( wp ), dimension ( me % n , me % np ) :: oldph real ( wp ), dimension ( me % n , me % np ) :: newph integer , dimension ( me % n * me % nd ) :: gn1 integer , dimension ( me % n * me % nd ) :: gn2 integer , dimension ( me % np ) :: ifit integer , dimension ( me % np ) :: jfit real ( wp ), dimension ( me % np ) :: fitns real ( wp ), dimension ( me % n ) :: xguess real ( wp ), dimension ( 2 , me % np / 2 ) :: fits real ( wp ), parameter :: big = huge ( 1.0_wp ) !! a large number !initialize: call me % rninit () me % bestft = - big me % pmutpv = - big me % pmut = me % pmuti !set initial mutation rate (it can change) i_window = 0 last_best_f = - big convergence = . false . status = 0 ! if OpenMP is being used: !$  use_openmp = .true. if ( present ( omp ) ) use_openmp = omp !Handle the initial guess: if ( me % initial_guess_frac == 0.0_wp ) then !initial guess not used (totally random population) istart = 1 !index to start random population members else !use the initial guess: xguess = x do k = 1 , me % n !make sure they are all within the [0,1] bounds xguess ( k ) = max ( 0.0_wp , min ( 1.0_wp , xguess ( k )) ) end do call me % ff ( xguess , fguess ) !how many elements in the population to set to xguess?: ! [at least 1, at most n] istart = max ( 1 , min ( me % np , int ( me % np * me % initial_guess_frac ))) do k = 1 , istart oldph (:, k ) = xguess fitns ( k ) = fguess end do istart = istart + 1 !index to start random population members end if !Compute initial (random but bounded) phenotypes do ip = istart , me % np do k = 1 , me % n oldph ( k , ip ) = me % urand () !from [0,1] end do end do !$omp parallel do private(ip) do ip = istart , me % np call me % ff ( oldph (:, ip ), fitns ( ip )) end do !$omp end parallel do !Rank initial population by fitness order call me % rnkpop ( fitns , ifit , jfit ) !Main Generation Loop ! This is modified from the original for parallelization. ! Note that, now, in a generation, the population is not changed until ! all the new members are computed. So only the current members are used ! in this process. do ig = 1 , me % ngen !Main Population Loop newtot = 0 do ip = 1 , me % np / 2 !1. pick two parents call me % select_parents ( jfit , ip1 , ip2 ) !2. encode parent phenotypes call me % encode ( oldph (:, ip1 ), gn1 ) call me % encode ( oldph (:, ip2 ), gn2 ) !3. breed call me % cross ( gn1 , gn2 ) call me % mutate ( gn1 ) call me % mutate ( gn2 ) !4. decode offspring genotypes call me % decode ( gn1 , ph (:, 1 , ip )) call me % decode ( gn2 , ph (:, 2 , ip )) !5. insert into population if ( me % irep == 1 ) then call me % genrep ( ip , ph (:,:, ip ), newph ) else if (. not . use_openmp ) then ! compute all the fitnesses in the parallel do j = 1 , 2 ! compute offspring fitness (with caller's fitness function) call me % ff ( ph (:, j , ip ), fits ( j , ip )) end do call me % stdrep ( ph (:,:, ip ), fits (:, ip ), oldph , fitns , ifit , jfit , new ) newtot = newtot + new end if end if end do if ( use_openmp ) then !5. insert into population if not already done if ( me % irep /= 1 ) then ! compute all the fitnesses in the parallel !$omp parallel do private(ip) do ip = 1 , me % np / 2 !$omp parallel do private(j) do j = 1 , 2 ! compute offspring fitness (with caller's fitness function) call me % ff ( ph (:, j , ip ), fits ( j , ip )) end do !$omp end parallel do end do !$omp end parallel do newtot = 0 do ip = 1 , me % np / 2 call me % stdrep ( ph (:,:, ip ), fits (:, ip ), oldph , fitns , ifit , jfit , new ) newtot = newtot + new end do end if end if !End of Main Population Loop !if running full generational replacement: swap populations if ( me % irep == 1 ) call me % newpop ( oldph , newph , ifit , jfit , fitns , newtot ) !adjust mutation rate? if ( any ( me % imut == [ 2 , 3 , 5 , 6 ])) call adjmut ( me , oldph , fitns , ifit ) !report this iteration: if ( me % ivrb > 0 ) call me % report ( oldph , fitns , ifit , ig , newtot ) !report (unscaled) x: if ( associated ( me % iter_f )) & call me % iter_f ( ig , me % xl + me % del * oldph ( 1 : me % n , ifit ( me % np )), fitns ( ifit ( me % np ))) !JW additions: add a convergence criteria ! [stop if the last convergence_window iterations are all within the convergence_tol] current_best_f = fitns ( ifit ( me % np )) !current iteration best fitness if ( abs ( current_best_f - last_best_f ) <= me % convergence_tol ) then !this solution is within the tol from the previous one i_window = i_window + 1 !number of solutions within the convergence tolerance else i_window = 0 !a significantly better solution was found, reset window end if if ( i_window >= me % convergence_window ) then convergence = . true . exit !exit main loop -> convergence end if last_best_f = current_best_f !to compare with next iteration end do !End of Main Generation Loop !JW additions: if ( me % ivrb > 0 ) then if ( convergence ) then write ( output_unit , '(A)' ) 'Solution Converged' else write ( output_unit , '(A)' ) 'Iteration Limit Reached' end if end if !Return best phenotype and its fitness x = oldph ( 1 : me % n , ifit ( me % np )) f = fitns ( ifit ( me % np )) end subroutine pikaia","tags":"","loc":"proc/pikaia.html"},{"title":"report – TOOLIB","text":"private  subroutine report(me, oldph, fitns, ifit, ig, nnew) Write generation report to standard output Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit integer, intent(in) :: ig integer, intent(in) :: nnew Called by proc~~report~~CalledByGraph proc~report pikaia_class%report proc~pikaia pikaia_class%pikaia proc~pikaia->proc~report proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine report ( me , oldph , fitns , ifit , ig , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , me % np ), intent ( in ) :: oldph real ( wp ), dimension ( me % np ), intent ( in ) :: fitns integer , dimension ( me % np ), intent ( in ) :: ifit integer , intent ( in ) :: ig integer , intent ( in ) :: nnew integer :: ndpwr , k logical :: rpt rpt = . false . if ( me % pmut /= me % pmutpv ) then me % pmutpv = me % pmut rpt = . true . end if if ( fitns ( ifit ( me % np )) /= me % bestft ) then me % bestft = fitns ( ifit ( me % np )) rpt = . true . end if if ( rpt . or . me % ivrb >= 2 ) then !Power of 10 to make integer genotypes for display ndpwr = 10 ** me % nd write ( output_unit , '(/I6,I6,F10.6,4F10.6)' ) & ig , nnew , me % pmut , fitns ( ifit ( me % np )),& fitns ( ifit ( me % np - 1 )), fitns ( ifit ( me % np / 2 )) do k = 1 , me % n write ( output_unit , '(22X,3I10)' ) & nint ( ndpwr * oldph ( k , ifit ( me % np ))),& nint ( ndpwr * oldph ( k , ifit ( me % np - 1 ))),& nint ( ndpwr * oldph ( k , ifit ( me % np / 2 ))) end do end if end subroutine report","tags":"","loc":"proc/report.html"},{"title":"rninit – TOOLIB","text":"private  subroutine rninit(me) Initialize the random number generator with the input seed value. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me Calls proc~~rninit~~CallsGraph proc~rninit pikaia_class%rninit none~initialize mt19937%initialize proc~rninit->none~initialize proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64 mt19937%init_genrand64 none~initialize->proc~init_genrand64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~init_by_array64->proc~init_genrand64 proc~init_genrand64_i4->none~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rninit~~CalledByGraph proc~rninit pikaia_class%rninit proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rninit proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine rninit ( me ) implicit none class ( pikaia_class ), intent ( inout ) :: me call me % rand % initialize ( me % iseed ) end subroutine rninit","tags":"","loc":"proc/rninit.html"},{"title":"rnkpop – TOOLIB","text":"private  subroutine rnkpop(me, arrin, indx, rank) Ranks initial population.\nCalls external sort routine to produce key index and rank order\nof input array arrin (which is not altered). Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%np) :: arrin integer, intent(out), dimension(me%np) :: indx integer, intent(out), dimension(me%np) :: rank Calls proc~~rnkpop~~CallsGraph proc~rnkpop pikaia_class%rnkpop proc~rqsort rqsort proc~rnkpop->proc~rqsort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~rnkpop~~CalledByGraph proc~rnkpop pikaia_class%rnkpop proc~newpop pikaia_class%newpop proc~newpop->proc~rnkpop proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rnkpop proc~pikaia->proc~newpop proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine rnkpop ( me , arrin , indx , rank ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % np ), intent ( in ) :: arrin integer , dimension ( me % np ), intent ( out ) :: indx integer , dimension ( me % np ), intent ( out ) :: rank integer :: i !Compute the key index call rqsort ( me % np , arrin , indx ) !and the rank order do i = 1 , me % np rank ( indx ( i )) = me % np - i + 1 end do end subroutine rnkpop","tags":"","loc":"proc/rnkpop.html"},{"title":"rqsort – TOOLIB","text":"private  subroutine rqsort(n, a, p) Return integer array p which indexes array a in increasing order.\n  Array a is not disturbed.  The Quicksort algorithm is used. Reference N. Wirth, “Algorithms and Data Structures”, Prentice-Hall, 1986 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: a integer, intent(out), dimension(n) :: p Called by proc~~rqsort~~CalledByGraph proc~rqsort rqsort proc~rnkpop pikaia_class%rnkpop proc~rnkpop->proc~rqsort proc~newpop pikaia_class%newpop proc~newpop->proc~rnkpop proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rnkpop proc~pikaia->proc~newpop proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine rqsort ( n , a , p ) implicit none integer , intent ( in ) :: n real ( wp ), dimension ( n ), intent ( in ) :: a integer , dimension ( n ), intent ( out ) :: p !Constants integer , parameter :: LGN = 32 !! log base 2 of maximum n integer , parameter :: Q = 11 !! smallest subfile to use quicksort on !Local: integer , dimension ( LGN ) :: stackl , stackr real ( wp ) :: x integer :: s , t , l , m , r , i , j !Initialize the stack stackl ( 1 ) = 1 stackr ( 1 ) = n l = stackl ( 1 ) r = stackr ( 1 ) s = 1 !Initialize the pointer array p = [( i , i = 1 , n )] do while ( s > 0 ) s = s - 1 if (( r - l ) < Q ) then !Use straight insertion insertion : do i = l + 1 , r t = p ( i ) x = a ( t ) do j = i - 1 , l , - 1 if ( a ( p ( j )) <= x ) then p ( j + 1 ) = t cycle insertion end if p ( j + 1 ) = p ( j ) end do j = l - 1 p ( j + 1 ) = t end do insertion else !Use quicksort, with pivot as median of a(l), a(m), a(r) m = ( l + r ) / 2 t = p ( m ) if ( a ( t ) < a ( p ( l ))) then p ( m ) = p ( l ) p ( l ) = t t = p ( m ) end if if ( a ( t ) > a ( p ( r ))) then p ( m ) = p ( r ) p ( r ) = t t = p ( m ) if ( a ( t ) < a ( p ( l ))) then p ( m ) = p ( l ) p ( l ) = t t = p ( m ) end if end if !Partition x = a ( t ) i = l + 1 j = r - 1 do while ( i <= j ) do while ( a ( p ( i )) < x ) i = i + 1 end do do while ( x < a ( p ( j ))) j = j - 1 end do if ( i <= j ) then t = p ( i ) p ( i ) = p ( j ) p ( j ) = t i = i + 1 j = j - 1 end if end do !Stack the larger subfile s = s + 1 if (( j - l ) > ( r - i )) then stackl ( s ) = l stackr ( s ) = j l = i else stackl ( s ) = i stackr ( s ) = r r = j end if s = s + 1 ! since it will be decremented next cycle cycle end if if ( s > 0 ) then l = stackl ( s ) r = stackr ( s ) end if end do end subroutine rqsort","tags":"","loc":"proc/rqsort.html"},{"title":"select_parents – TOOLIB","text":"private  subroutine select_parents(me, jfit, imom, idad) Selects two parents from the population, using roulette wheel\n  algorithm with the relative fitnesses of the phenotypes as\n  the “hit” probabilities. Reference Davis 1991, chap. 1. History Jacob Williams : 3/10/2015 : rewrote this routine to return both parents,\n    and also protect against the loop exiting without selecting a parent. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in), dimension(me%np) :: jfit integer, intent(out) :: imom integer, intent(out) :: idad Calls proc~~select_parents~~CallsGraph proc~select_parents pikaia_class%select_parents proc~urand pikaia_class%urand proc~select_parents->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~select_parents~~CalledByGraph proc~select_parents pikaia_class%select_parents proc~pikaia pikaia_class%pikaia proc~pikaia->proc~select_parents proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine select_parents ( me , jfit , imom , idad ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % np ), intent ( in ) :: jfit integer , intent ( out ) :: imom integer , intent ( out ) :: idad integer :: np1 , i , j real ( wp ) :: dice , rtfit integer , dimension ( 2 ) :: parents !initialize: np1 = me % np + 1 parents = - 99 !get two (unequal) parents: do j = 1 , 2 main : do dice = me % urand () * me % np * np1 rtfit = 0.0_wp do i = 1 , me % np rtfit = rtfit + np1 + me % fdif * ( np1 - 2 * jfit ( i )) if ( rtfit >= dice ) then parents ( j ) = i if ( parents ( 1 ) /= parents ( 2 )) exit main end if end do end do main end do imom = parents ( 1 ) idad = parents ( 2 ) end subroutine select_parents","tags":"","loc":"proc/select_parents.html"},{"title":"set_inputs – TOOLIB","text":"private  subroutine set_inputs(me, n, xl, xu, f, status, iter_f, np, ngen, nd, pcross, pmutmn, pmutmx, pmut, imut, fdif, irep, ielite, ivrb, convergence_tol, convergence_window, initial_guess_frac, iseed) Constructor for the pikaia_class .\n  The routine must be called before the solve routine can be used. The following inputs are required: n, f, xl, xu.\n  For the others, if they are not present, then\n  the default values are used Note Based on setctl in the original code. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(out) :: me pikaia class integer, intent(in) :: n the parameter space dimension, i.e., the number\nof adjustable parameters (size of the x vector). real(kind=wp), intent(in), dimension(n) :: xl vector of lower bounds for x real(kind=wp), intent(in), dimension(n) :: xu vector of upper bounds for x procedure( pikaia_func ) :: f user-supplied scalar function of n variables,\nwhich must have the pikaia_func procedure interface.\nBy convention, f should return higher values for more optimal\nparameter values (i.e., individuals which are more “fit”).\nFor example, in fitting a function through data points, f\ncould return the inverse of chi**2. integer, intent(out) :: status status output flag (0 if there were no errors) procedure( iter_func ), optional :: iter_f user-supplied subroutine that will report the\nbest solution for each generation.\nIt must have the iter_func procedure interface.  If not present,\nthen it is not used.  (note: this is independent of ivrb). integer, intent(in), optional :: np number of individuals in a population (default is 100) integer, intent(in), optional :: ngen maximum number of iterations integer, intent(in), optional :: nd number of significant digits (i.e., number of\ngenes) retained in chromosomal encoding (default is 6). real(kind=wp), intent(in), optional :: pcross crossover probability; must be  <= 1.0 (default\nis 0.85). If crossover takes place, either one\nor two splicing points are used, with equal\nprobabilities real(kind=wp), intent(in), optional :: pmutmn minimum mutation rate; must be >= 0.0 (default is 0.0005) real(kind=wp), intent(in), optional :: pmutmx maximum mutation rate; must be <= 1.0 (default is 0.25) real(kind=wp), intent(in), optional :: pmut initial mutation rate; should be small (default\nis 0.005) (Note: the mutation rate is the probability\nthat any one gene locus will mutate in\nany one generation.) integer, intent(in), optional :: imut mutation mode; 1/2/3/4/5 (default is 2).\n 1=one-point mutation, fixed rate.\n 2=one-point, adjustable rate based on fitness.\n 3=one-point, adjustable rate based on distance.\n 4=one-point+creep, fixed rate.\n 5=one-point+creep, adjustable rate based on fitness.\n 6=one-point+creep, adjustable rate based on distance. real(kind=wp), intent(in), optional :: fdif relative fitness differential; range from 0\n(none) to 1 (maximum).  (default is 1.0) integer, intent(in), optional :: irep reproduction plan; 1/2/3=Full generational\nreplacement/Steady-state-replace-random/Steady-\nstate-replace-worst (default is 3) integer, intent(in), optional :: ielite elitism flag; 0/1=off/on (default is 0)\n(Applies only to reproduction plans 1 and 2) integer, intent(in), optional :: ivrb printed output 0/1/2=None/Minimal/Verbose\n(default is 0) real(kind=wp), intent(in), optional :: convergence_tol convergence tolerance; must be > 0.0 (default is 0.0001) integer, intent(in), optional :: convergence_window convergence window; must be >= 0\nThis is the number of consecutive solutions\nwithin the tolerance for convergence to\nbe declared (default is 20) real(kind=wp), intent(in), optional :: initial_guess_frac fraction of the initial population\nto set equal to the initial guess.  Range from 0\n(none) to 1.0 (all). (default is 0.1 or 10%). integer, intent(in), optional :: iseed random seed value; must be > 0 (default is 999) Called by proc~~set_inputs~~CalledByGraph proc~set_inputs pikaia_class%set_inputs program~test_algen test_algen program~test_algen->proc~set_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_inputs ( me ,& n , xl , xu , f , status ,& iter_f ,& np , ngen , nd , pcross , pmutmn , pmutmx , pmut , imut ,& fdif , irep , ielite , ivrb ,& convergence_tol , convergence_window , initial_guess_frac ,& iseed ) implicit none class ( pikaia_class ), intent ( out ) :: me !! pikaia class integer , intent ( in ) :: n !! the parameter space dimension, i.e., the number !! of adjustable parameters (size of the x vector). real ( wp ), dimension ( n ), intent ( in ) :: xl !! vector of lower bounds for x real ( wp ), dimension ( n ), intent ( in ) :: xu !! vector of upper bounds for x procedure ( pikaia_func ) :: f !! user-supplied scalar function of n variables, !! which must have the [[pikaia_func]] procedure interface. !! By convention, f should return higher values for more optimal !! parameter values (i.e., individuals which are more \"fit\"). !! For example, in fitting a function through data points, f !! could return the inverse of chi**2. integer , intent ( out ) :: status !! status output flag (0 if there were no errors) procedure ( iter_func ), optional :: iter_f !! user-supplied subroutine that will report the !! best solution for each generation. !! It must have the [[iter_func]] procedure interface.  If not present, !! then it is not used.  (note: this is independent of ivrb). integer , intent ( in ), optional :: np !! number of individuals in a population (default is 100) integer , intent ( in ), optional :: ngen !! maximum number of iterations integer , intent ( in ), optional :: nd !! number of significant digits (i.e., number of !! genes) retained in chromosomal encoding (default is 6). real ( wp ), intent ( in ), optional :: pcross !! crossover probability; must be  <= 1.0 (default !! is 0.85). If crossover takes place, either one !! or two splicing points are used, with equal !! probabilities real ( wp ), intent ( in ), optional :: pmutmn !! minimum mutation rate; must be >= 0.0 (default is 0.0005) real ( wp ), intent ( in ), optional :: pmutmx !! maximum mutation rate; must be <= 1.0 (default is 0.25) real ( wp ), intent ( in ), optional :: pmut !! initial mutation rate; should be small (default !! is 0.005) (Note: the mutation rate is the probability !! that any one gene locus will mutate in !! any one generation.) integer , intent ( in ), optional :: imut !! mutation mode; 1/2/3/4/5 (default is 2). !!  1=one-point mutation, fixed rate. !!  2=one-point, adjustable rate based on fitness. !!  3=one-point, adjustable rate based on distance. !!  4=one-point+creep, fixed rate. !!  5=one-point+creep, adjustable rate based on fitness. !!  6=one-point+creep, adjustable rate based on distance. real ( wp ), intent ( in ), optional :: fdif !! relative fitness differential; range from 0 !! (none) to 1 (maximum).  (default is 1.0) integer , intent ( in ), optional :: irep !! reproduction plan; 1/2/3=Full generational !! replacement/Steady-state-replace-random/Steady- !! state-replace-worst (default is 3) integer , intent ( in ), optional :: ielite !! elitism flag; 0/1=off/on (default is 0) !! (Applies only to reproduction plans 1 and 2) integer , intent ( in ), optional :: ivrb !! printed output 0/1/2=None/Minimal/Verbose !! (default is 0) real ( wp ), intent ( in ), optional :: convergence_tol !! convergence tolerance; must be > 0.0 (default is 0.0001) integer , intent ( in ), optional :: convergence_window !! convergence window; must be >= 0 !! This is the number of consecutive solutions !! within the tolerance for convergence to !! be declared (default is 20) real ( wp ), intent ( in ), optional :: initial_guess_frac !! fraction of the initial population !! to set equal to the initial guess.  Range from 0 !! (none) to 1.0 (all). (default is 0.1 or 10%). integer , intent ( in ), optional :: iseed !! random seed value; must be > 0 (default is 999) me % n = n if ( allocated ( me % xl )) deallocate ( me % xl ) allocate ( me % xl ( n )) me % xl = xl if ( allocated ( me % xu )) deallocate ( me % xu ) allocate ( me % xu ( n )) me % xu = xu if ( allocated ( me % del )) deallocate ( me % del ) allocate ( me % del ( n )) me % del = me % xu - me % xl me % user_f => f if ( present ( iter_f )) me % iter_f => iter_f if ( present ( np )) me % np = np if ( present ( ngen )) me % ngen = ngen if ( present ( nd )) me % nd = nd if ( present ( pcross )) me % pcross = pcross if ( present ( imut )) me % imut = imut if ( present ( pmut )) me % pmuti = pmut !initial value if ( present ( pmutmn )) me % pmutmn = pmutmn if ( present ( pmutmx )) me % pmutmx = pmutmx if ( present ( fdif )) me % fdif = fdif if ( present ( irep )) me % irep = irep if ( present ( ielite )) me % ielite = ielite if ( present ( ivrb )) me % ivrb = ivrb if ( present ( convergence_tol )) me % convergence_tol = convergence_tol if ( present ( convergence_window )) me % convergence_window = convergence_window if ( present ( initial_guess_frac )) me % initial_guess_frac = initial_guess_frac if ( present ( iseed )) me % iseed = iseed !check for errors: !initialize error flag: status = 0 !Print a header if ( me % ivrb > 0 ) then write ( output_unit , '(A)' ) '------------------------------------------------------------' write ( output_unit , '(A)' ) '              PIKAIA Genetic Algorithm Report               ' write ( output_unit , '(A)' ) '------------------------------------------------------------' write ( output_unit , '(A,I4)' ) ' Number of Generations evolving: ' , me % ngen write ( output_unit , '(A,I4)' ) '     Individuals per generation: ' , me % np write ( output_unit , '(A,I4)' ) '  Number of Chromosome segments: ' , me % n write ( output_unit , '(A,I4)' ) '  Length of Chromosome segments: ' , me % nd write ( output_unit , '(A,E11.4)' ) '          Crossover probability: ' , me % pcross write ( output_unit , '(A,E11.4)' ) '          Initial mutation rate: ' , me % pmuti write ( output_unit , '(A,E11.4)' ) '          Minimum mutation rate: ' , me % pmutmn write ( output_unit , '(A,E11.4)' ) '          Maximum mutation rate: ' , me % pmutmx write ( output_unit , '(A,E11.4)' ) '  Relative fitness differential: ' , me % fdif write ( output_unit , '(A,E11.4)' ) '         Initial guess fraction: ' , me % initial_guess_frac write ( output_unit , '(A,E11.4)' ) '          Convergence tolerance: ' , me % convergence_tol write ( output_unit , '(A,I4)' ) '             Convergence window: ' , me % convergence_window select case ( me % imut ) case ( 1 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Constant Rate' case ( 2 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Variable Rate (F)' case ( 3 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Variable Rate (D)' case ( 4 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Constant Rate' case ( 5 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Variable Rate (F)' case ( 6 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Variable Rate (D)' end select select case ( me % irep ) case ( 1 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Full generational replacement' case ( 2 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Steady-state-replace-random' case ( 3 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Steady-state-replace-worst' end select write ( output_unit , '(A)' ) '------------------------------------------------------------' end if !Check some control values if ( me % imut /= 1 . and . me % imut /= 2 . and . me % imut /= 3 . and . & me % imut /= 4 . and . me % imut /= 5 . and . me % imut /= 6 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Mutation Mode.' status = 5 end if if ( me % fdif > 1.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Relative fitness differential.' status = 9 end if if ( me % irep /= 1 . and . me % irep /= 2 . and . me % irep /= 3 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Reproduction plan.' status = 10 end if if ( me % pcross > 1.0_wp . or . me % pcross < 0.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Crossover probability.' status = 4 end if if ( me % ielite /= 0 . and . me % ielite /= 1 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Elitism flag.' status = 11 end if if ( me % convergence_tol <= 0.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Convergence tolerance.' status = 101 end if if ( me % convergence_window <= 0 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Convergence window.' status = 102 end if if ( me % iseed <= 0 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for iseed.' status = 103 end if if ( me % nd > 9 . or . me % nd < 1 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Chromosome length.' status = 104 end if if ( mod ( me % np , 2 ) > 0 ) then write ( output_unit , '(A)' ) ' ERROR: population size must be an even number.' status = 105 end if if ( me % initial_guess_frac < 0.0_wp . or . me % initial_guess_frac > 1.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Initial guess fraction.' status = 106 end if if ( me % irep == 1 . and . me % imut == 1 . and . me % pmuti > 0.5_wp . and . me % ielite == 0 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously high value for Initial mutation rate; ' // & '(Should enforce elitism with ielite=1.)' end if if ( me % irep == 1 . and . me % imut == 2 . and . me % pmutmx > 0.5_wp . and . me % ielite == 0 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously high value for Maximum mutation rate; ' // & '(Should enforce elitism with ielite=1.)' end if if ( me % fdif < 0.33_wp . and . me % irep /= 3 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously low value of Relative fitness differential.' end if end subroutine set_inputs","tags":"","loc":"proc/set_inputs.html"},{"title":"solve_with_pikaia – TOOLIB","text":"private  subroutine solve_with_pikaia(me, x, f, status, omp) Main pikaia wrapper used by the class. Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(out) :: f integer, intent(out) :: status logical, intent(in), optional :: omp if OpenMP is being used Calls proc~~solve_with_pikaia~~CallsGraph proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~pikaia pikaia_class%pikaia proc~solve_with_pikaia->proc~pikaia proc~adjmut pikaia_class%adjmut proc~pikaia->proc~adjmut proc~cross pikaia_class%cross proc~pikaia->proc~cross proc~decode pikaia_class%decode proc~pikaia->proc~decode proc~encode pikaia_class%encode proc~pikaia->proc~encode proc~func_wrapper pikaia_class%func_wrapper proc~pikaia->proc~func_wrapper proc~genrep pikaia_class%genrep proc~pikaia->proc~genrep proc~mutate pikaia_class%mutate proc~pikaia->proc~mutate proc~newpop pikaia_class%newpop proc~pikaia->proc~newpop proc~report pikaia_class%report proc~pikaia->proc~report proc~rninit pikaia_class%rninit proc~pikaia->proc~rninit proc~rnkpop pikaia_class%rnkpop proc~pikaia->proc~rnkpop proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~urand pikaia_class%urand proc~pikaia->proc~urand proc~cross->proc~urand proc~mutate->proc~urand proc~newpop->proc~func_wrapper proc~newpop->proc~rnkpop none~initialize mt19937%initialize proc~rninit->none~initialize proc~rqsort rqsort proc~rnkpop->proc~rqsort proc~select_parents->proc~urand proc~stdrep->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64 mt19937%init_genrand64 none~initialize->proc~init_genrand64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~genrand64_int64->proc~init_genrand64 proc~init_by_array64->proc~init_genrand64 proc~init_genrand64_i4->none~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solve_with_pikaia~~CalledByGraph proc~solve_with_pikaia pikaia_class%solve_with_pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine solve_with_pikaia ( me , x , f , status , omp ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), intent ( out ) :: f integer , intent ( out ) :: status logical , intent ( in ), optional :: omp !! if OpenMP is being used if ( associated ( me % user_f )) then !scale input initial guess to be [0,1]: x = ( x - me % xl ) / me % del !call the main routine, using the wrapper function: call me % pikaia ( x , f , status , omp ) !unscale output to be [xl,xu]: x = me % xl + me % del * x else write ( output_unit , '(A)' ) 'Error: pikaia class not initialized.' status = - 1 end if end subroutine solve_with_pikaia","tags":"","loc":"proc/solve_with_pikaia.html"},{"title":"stdrep – TOOLIB","text":"private  subroutine stdrep(me, ph, fits, oldph, fitns, ifit, jfit, nnew) Steady-state reproduction: insert offspring pair into population\nonly if they are fit enough (replace-random if irep=2 or\nreplace-worst if irep=3). Type Bound pikaia_class Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(in), dimension(2) :: fits real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%np) :: fitns integer, intent(inout), dimension(me%np) :: ifit integer, intent(inout), dimension(me%np) :: jfit integer, intent(out) :: nnew Calls proc~~stdrep~~CallsGraph proc~stdrep pikaia_class%stdrep proc~urand pikaia_class%urand proc~stdrep->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~stdrep~~CalledByGraph proc~stdrep pikaia_class%stdrep proc~pikaia pikaia_class%pikaia proc~pikaia->proc~stdrep proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine stdrep ( me , ph , fits , oldph , fitns , ifit , jfit , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , 2 ), intent ( in ) :: ph real ( wp ), dimension ( 2 ), intent ( in ) :: fits real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: oldph real ( wp ), dimension ( me % np ), intent ( inout ) :: fitns integer , dimension ( me % np ), intent ( inout ) :: ifit integer , dimension ( me % np ), intent ( inout ) :: jfit integer , intent ( out ) :: nnew integer :: i , j , k , i1 , if1 real ( wp ) :: fit nnew = 0 main_loop : do j = 1 , 2 !1. get offspring fitness fit = fits ( j ) !2. if fit enough, insert in population do i = me % np , 1 , - 1 if ( fit > fitns ( ifit ( i ))) then !make sure the phenotype is not already in the population if ( i < me % np ) then if ( all ( oldph ( 1 : me % n , ifit ( i + 1 )) == ph ( 1 : me % n , j ))) cycle main_loop end if !offspring is fit enough for insertion, and is unique !(i) insert phenotype at appropriate place in population if ( me % irep == 3 ) then i1 = 1 else if ( me % ielite == 0 . or . i == me % np ) then i1 = int ( me % urand () * me % np ) + 1 else i1 = int ( me % urand () * ( me % np - 1 )) + 1 end if if1 = ifit ( i1 ) fitns ( if1 ) = fit do k = 1 , me % n oldph ( k , if1 ) = ph ( k , j ) end do !(ii) shift and update ranking arrays if ( i < i1 ) then !shift up jfit ( if1 ) = me % np - i do k = i1 - 1 , i + 1 , - 1 jfit ( ifit ( k )) = jfit ( ifit ( k )) - 1 ifit ( k + 1 ) = ifit ( k ) end do ifit ( i + 1 ) = if1 else !shift down jfit ( if1 ) = me % np - i + 1 do k = i1 + 1 , i jfit ( ifit ( k )) = jfit ( ifit ( k )) + 1 ifit ( k - 1 ) = ifit ( k ) end do ifit ( i ) = if1 end if nnew = nnew + 1 cycle main_loop end if end do end do main_loop end subroutine stdrep","tags":"","loc":"proc/stdrep.html"},{"title":"alloc_fftw3 – TOOLIB","text":"private  subroutine alloc_fftw3(long, larg) Note Allocation of the memory needed by the transformations, forward and backward. 1 FFT distributed on several threads The space remains allocated as long as transformations are needed. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~alloc_fftw3~~CallsGraph proc~alloc_fftw3 alloc_fftw3 interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3->interface~fftw_alloc_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_fftw3~~CalledByGraph proc~alloc_fftw3 alloc_fftw3 proc~init_fftw3 init_fftw3 proc~init_fftw3->proc~alloc_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~init_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3 program~test_fftw3->proc~calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine alloc_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward p_f_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_f_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_f_i , cmp_f_i , ( / long , larg / )) call c_f_pointer ( p_f_o , cmp_f_o , ( / long , larg / )) ! backward p_b_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_b_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_b_i , cmp_b_i , ( / long , larg / )) call c_f_pointer ( p_b_o , cmp_b_o , ( / long , larg / )) return endsubroutine alloc_fftw3","tags":"","loc":"proc/alloc_fftw3.html"},{"title":"alloc_fftw3_real – TOOLIB","text":"private  subroutine alloc_fftw3_real(long, larg) Note Allocation of the memory needed by the transformations, forward and backward, for the\n  real case. 1 FFT distributed on several threads The space remains allocated as long as transformations are needed. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~alloc_fftw3_real~~CallsGraph proc~alloc_fftw3_real alloc_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real->interface~fftw_alloc_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~alloc_fftw3_real~~CalledByGraph proc~alloc_fftw3_real alloc_fftw3_real proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine alloc_fftw3_real ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward p_f_i = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) p_f_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_f_i , rea_f_i , ( / long , larg / )) call c_f_pointer ( p_f_o , cmp_f_o , ( / long , larg / )) ! backward p_b_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_b_o = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_b_i , cmp_b_i , ( / long , larg / )) call c_f_pointer ( p_b_o , rea_b_o , ( / long , larg / )) return endsubroutine alloc_fftw3_real","tags":"","loc":"proc/alloc_fftw3_real.html"},{"title":"apod – TOOLIB","text":"public  subroutine apod(tab_in, tab_out, long, larg, type_apo, param) Note Function that returns an apodized array. To prevent gaps from appearing after FFT (because of non periodic waves), the surface must\n  be transformed, but not too much … Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input array real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width character(len=*), intent(in) :: type_apo apodization type real(kind=R8), intent(in), optional :: param apodized array Called by proc~~apod~~CalledByGraph proc~apod apod proc~extend extend proc~extend->proc~apod Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine apod ( tab_in , tab_out , long , larg , type_apo , param ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* character ( len =* ), intent ( in ) :: type_apo !! *apodization type* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized array* real ( kind = R8 ), intent ( in ), optional :: param !! *apodized array* real ( kind = R8 ) :: a0 , a1 , a2 , ro , u , v , fct , pun , mun , eps , mi , mj , li , lj , ri , rj , fcti integer ( kind = I4 ) :: i , j , dis , ii , jj , lo2 , la2 select case ( type_apo ( 1 : 6 ) ) case ( 'blackm' ) a0 = 2 1. / 5 0. a1 = 0 1. / 0 2. a2 = 0 2. / 2 5. ri = real ( long ) ; rj = real ( larg ) mi = ( ri + UN ) / 2 ; mj = ( rj + UN ) / 2 li = ( ri - UN ) / 2 ; lj = ( rj - UN ) / 2 do i = 1 , long u = ( i - mi ) / li do j = 1 , larg v = ( j - mj ) / lj fct = ( a0 + a1 * cos ( PI_R8 * u ) + a2 * cos ( 2 * PI_R8 * u ) ) * & ! ( a0 + a1 * cos ( PI_R8 * v ) + a2 * cos ( 2 * PI_R8 * v ) ) ! tab_out ( i , j ) = tab_in ( i , j ) * fct enddo enddo case ( 'tuckey' ) !http://en.wikipedia.org/wiki/Window_function#Tukey_window mun = - UN pun = + UN eps = 0.25_R8 if ( present ( param ) ) eps = param dis = nint ( eps * long / 2 ) tab_out ( 1 : long , 1 : larg ) = UN do i = 0 , dis ro = 2. * i / ( eps * ( long - 1 ) ) - UN tab_out ( i + 1 , 1 : larg ) = 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo do i = long - 1 - dis , long - 1 ro = 2. * i / ( eps * ( long - 1 ) ) + UN - 2. / eps tab_out ( i + 1 , 1 : larg ) = 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo dis = nint ( eps * larg / 2 ) do j = 0 , dis ro = 2. * j / ( eps * ( larg - 1 ) ) - UN tab_out ( 1 : long , j + 1 ) = tab_out ( 1 : long , j + 1 ) * 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo do j = larg - 1 - dis , larg - 1 ro = 2. * j / ( eps * ( larg - 1 ) ) + UN - 2. / eps tab_out ( 1 : long , j + 1 ) = tab_out ( 1 : long , j + 1 ) * 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo tab_out ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) * tab_in ( 1 : long , 1 : larg ) case ( 'hann__' ) do i = 1 , long fcti = 0.5 * ( 1.0 - cos ( 2.0 * PI_R8 * ( i - 1 ) / ( long - 1 ))) do j = 1 , larg fct = fcti * 0.5 * ( 1.0 - cos ( 2.0 * PI_R8 * ( j - 1 ) / ( larg - 1 ))) tab_out ( i , j ) = tab_in ( i , j ) * fct enddo enddo case ( 'welch_' ) ri = long / 2.000001_R8 rj = larg / 2.000001_R8 lo2 = ceiling ( ri ) la2 = ceiling ( rj ) do ii = lo2 - long , lo2 - 1 u = ( ii / ri ) ** 2 i = max ( ii + lo2 , 1 ) do jj = la2 - larg , la2 - 1 v = ( jj / rj ) ** 2 j = max ( jj + la2 , 1 ) if ( u + v > UN ) then tab_out ( i , j ) = 0 cycle endif tab_out ( i , j ) = tab_in ( i , j ) * ( 1._R8 - ( u + v ) ) enddo enddo case ( 'no_apo' ) tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) case default stop 'apod, apodization type bad choice' endselect return endsubroutine apod","tags":"","loc":"proc/apod.html"},{"title":"calc_fftw3 – TOOLIB","text":"public  subroutine calc_fftw3(sens, tab_in, tab_ou, long, larg) Note Subroutine that transforms forward or backward a double complex array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: sens =FORWARD or =BACKWARD complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~calc_fftw3~~CallsGraph proc~calc_fftw3 calc_fftw3 interface~fftw_execute_dft fftw_execute_dft proc~calc_fftw3->interface~fftw_execute_dft interface~fftw_plan_with_nthreads fftw_plan_with_nthreads proc~calc_fftw3->interface~fftw_plan_with_nthreads omp_get_num_procs omp_get_num_procs proc~calc_fftw3->omp_get_num_procs proc~end_fftw3 end_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~init_fftw3 init_fftw3 proc~calc_fftw3->proc~init_fftw3 proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~alloc_fftw3 alloc_fftw3 proc~init_fftw3->proc~alloc_fftw3 proc~make_plan_fftw3 make_plan_fftw3 proc~init_fftw3->proc~make_plan_fftw3 interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3->interface~fftw_alloc_complex interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~make_plan_fftw3->interface~fftw_plan_dft_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_fftw3~~CalledByGraph proc~calc_fftw3 calc_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_fftw3 ( sens , tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: sens !! *```=FORWARD``` or ```=BACKWARD```* integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3 ( long = long , larg = larg ) endif select case ( sens ) case ( FORWARD ) cmp_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( plan_f , cmp_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) case ( BACKWARD ) cmp_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( plan_b , cmp_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) endselect return endsubroutine calc_fftw3","tags":"","loc":"proc/calc_fftw3.html"},{"title":"calc_fftw3_real_bwd – TOOLIB","text":"public  subroutine calc_fftw3_real_bwd(tab_in, tab_ou, long, larg, planner_flag) Note Subroutine that transforms backward a double real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in), optional :: planner_flag planning option, FFTW_ESTIMATE for example Calls proc~~calc_fftw3_real_bwd~~CallsGraph proc~calc_fftw3_real_bwd calc_fftw3_real_bwd interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r interface~fftw_plan_with_nthreads fftw_plan_with_nthreads proc~calc_fftw3_real_bwd->interface~fftw_plan_with_nthreads omp_get_num_procs omp_get_num_procs proc~calc_fftw3_real_bwd->omp_get_num_procs proc~end_fftw3 end_fftw3 proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~init_fftw3_real init_fftw3_real proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~alloc_fftw3_real alloc_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~make_plan_fftw3_real make_plan_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real->interface~fftw_alloc_real interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_fftw3_real_bwd~~CalledByGraph proc~calc_fftw3_real_bwd calc_fftw3_real_bwd program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_fftw3_real_bwd ( tab_in , tab_ou , long , larg , planner_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ), intent ( in ), optional :: planner_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: plan_flag if ( . not . present ( planner_flag ) ) then plan_flag = FFTW_ESTIMATE else plan_flag = planner_flag endif if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3_real ( long = long , larg = larg , plan_flag = plan_flag ) endif cmp_b_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_c2r ( plan_b , cmp_b_i ( 1 : long , 1 : larg ), rea_b_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = rea_b_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine calc_fftw3_real_bwd","tags":"","loc":"proc/calc_fftw3_real_bwd.html"},{"title":"calc_fftw3_real_fwd – TOOLIB","text":"public  subroutine calc_fftw3_real_fwd(tab_in, tab_ou, long, larg, planner_flag) Note Subroutine that transforms forward a double real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in), optional :: planner_flag planning option, FFTW_ESTIMATE for example Calls proc~~calc_fftw3_real_fwd~~CallsGraph proc~calc_fftw3_real_fwd calc_fftw3_real_fwd interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c interface~fftw_plan_with_nthreads fftw_plan_with_nthreads proc~calc_fftw3_real_fwd->interface~fftw_plan_with_nthreads omp_get_num_procs omp_get_num_procs proc~calc_fftw3_real_fwd->omp_get_num_procs proc~end_fftw3 end_fftw3 proc~calc_fftw3_real_fwd->proc~end_fftw3 proc~init_fftw3_real init_fftw3_real proc~calc_fftw3_real_fwd->proc~init_fftw3_real proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~alloc_fftw3_real alloc_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~make_plan_fftw3_real make_plan_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real->interface~fftw_alloc_real interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~calc_fftw3_real_fwd~~CalledByGraph proc~calc_fftw3_real_fwd calc_fftw3_real_fwd program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_fftw3_real_fwd ( tab_in , tab_ou , long , larg , planner_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ), intent ( in ), optional :: planner_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: plan_flag if ( . not . present ( planner_flag ) ) then plan_flag = FFTW_ESTIMATE else plan_flag = planner_flag endif if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3_real ( long = long , larg = larg , plan_flag = plan_flag ) endif rea_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_r2c ( plan_f , rea_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine calc_fftw3_real_fwd","tags":"","loc":"proc/calc_fftw3_real_fwd.html"},{"title":"desalloc_fftw3 – TOOLIB","text":"private  subroutine desalloc_fftw3() Note When no more transformation is needed, the memory is released. 1 FFT distributed on several threads Arguments None Calls proc~~desalloc_fftw3~~CallsGraph proc~desalloc_fftw3 desalloc_fftw3 interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~desalloc_fftw3~~CalledByGraph proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3 end_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~end_fftw3 program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine desalloc_fftw3 () implicit none ! forward call fftw_free ( p_f_i ) ; p_f_i = C_NULL_PTR call fftw_free ( p_f_o ) ; p_f_o = C_NULL_PTR ! backward call fftw_free ( p_b_i ) ; p_b_i = C_NULL_PTR call fftw_free ( p_b_o ) ; p_b_o = C_NULL_PTR return endsubroutine desalloc_fftw3","tags":"","loc":"proc/desalloc_fftw3.html"},{"title":"destroy_plan_fftw3 – TOOLIB","text":"private  subroutine destroy_plan_fftw3() Plans are no more needed as no additional transformation will occur. 1 FFT distributed on several threads Arguments None Calls proc~~destroy_plan_fftw3~~CallsGraph proc~destroy_plan_fftw3 destroy_plan_fftw3 interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~destroy_plan_fftw3~~CalledByGraph proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3 end_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~end_fftw3 program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine destroy_plan_fftw3 () !! Plans are no more needed as no additional transformation will occur. *1 FFT distributed on several threads* implicit none ! forward call fftw_destroy_plan ( plan_f ) ! backward call fftw_destroy_plan ( plan_b ) return endsubroutine destroy_plan_fftw3","tags":"","loc":"proc/destroy_plan_fftw3.html"},{"title":"end_fftw3 – TOOLIB","text":"public  subroutine end_fftw3() FFTW3 is no more useful from here. 1 FFT distributed on several threads Arguments None Calls proc~~end_fftw3~~CallsGraph proc~end_fftw3 end_fftw3 proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~end_fftw3~~CalledByGraph proc~end_fftw3 end_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~end_fftw3 program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine end_fftw3 () !! FFTW3 is no more useful from here. *1 FFT distributed on several threads* implicit none if ( SINGL_FFTW_ALLOCATED ) then call destroy_plan_fftw3 () call desalloc_fftw3 () endif SINGL_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine end_fftw3","tags":"","loc":"proc/end_fftw3.html"},{"title":"extend – TOOLIB","text":"public  subroutine extend(tab_in, tab_out, nx, ny, nx2, ny2, ext, type_apo) Note Function that extends an array for FFT processing. nx2 = 2 * ( nint(PAD_FFT_FILTER * nx)/2 ) ny2 = 2 * ( nint(PAD_FFT_FILTER * ny)/2 ) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx,  1:ny ) :: tab_in input array real(kind=R8), intent(out), dimension(1:nx2, 1:ny2) :: tab_out apodized array integer(kind=I4), intent(in) :: nx 2D input array length integer(kind=I4), intent(in) :: ny 2D input array width integer(kind=I4), intent(in) :: nx2 2D output array length integer(kind=I4), intent(in) :: ny2 2D output array width character(len=*), intent(in) :: ext extension character(len=*), intent(in), optional :: type_apo apodization type Calls proc~~extend~~CallsGraph proc~extend extend proc~apod apod proc~extend->proc~apod Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine extend ( tab_in , tab_out , nx , ny , nx2 , ny2 , ext , type_apo ) implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *2D input array length* integer ( kind = I4 ), intent ( in ) :: ny !! *2D input array width* integer ( kind = I4 ), intent ( in ) :: nx2 !! *2D output array length* integer ( kind = I4 ), intent ( in ) :: ny2 !! *2D output array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx2 , 1 : ny2 ) :: tab_out !! *apodized array* character ( len =* ), intent ( in ) :: ext !! *extension* character ( len =* ), intent ( in ), optional :: type_apo !! *apodization type* integer ( kind = I4 ) :: i , j , ibx , iby , iex , iey real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ibx = ceiling ( ( nx2 - nx ) / 2. ) ; iex = ibx + nx - 1 iby = ceiling ( ( ny2 - ny ) / 2. ) ; iey = iby + ny - 1 allocate ( tab_tmp ( 1 : nx2 , 1 : ny2 ) ) tab_tmp ( 1 : nx2 , 1 : ny2 ) = 0 tab_tmp ( ibx : iex , iby : iey ) = tab_in ( 1 : nx , 1 : ny ) select case ( ext ) case ( 'symmetry' ) do i = 1 , ibx - 1 tab_tmp ( ibx - i , iby : iey ) = tab_tmp ( ibx + i , iby : iey ) enddo do i = iex + 1 , nx2 tab_tmp ( i , iby : iey ) = tab_tmp ( iex - ( i - iex ), iby : iey ) enddo do j = 1 , iby - 1 tab_tmp ( 1 : nx2 , iby - j ) = tab_tmp ( 1 : nx2 , iby + j ) enddo do j = iey + 1 , ny2 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iey - ( j - iey )) enddo case ( 'constant' ) do i = 1 , ibx - 1 tab_tmp ( i , iby : iey ) = tab_tmp ( ibx , iby : iey ) enddo do i = iex + 1 , nx2 tab_tmp ( i , iby : iey ) = tab_tmp ( iex , iby : iey ) enddo do j = 1 , iby - 1 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iby ) enddo do j = iey + 1 , ny2 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iey ) enddo case ( 'zero' ) endselect if ( present ( type_apo ) ) then call apod ( tab_in = tab_tmp ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_out ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 , & ! type_apo = type_apo ) ! else tab_out ( 1 : nx2 , 1 : ny2 ) = tab_tmp ( 1 : nx2 , 1 : ny2 ) endif deallocate ( tab_tmp ) return endsubroutine extend","tags":"","loc":"proc/extend.html"},{"title":"init_fftw3 – TOOLIB","text":"public  subroutine init_fftw3(long, larg) Subroutine to initialize the FFTW3 process 1 FFT distributed on several threads .\nComplex case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~init_fftw3~~CallsGraph proc~init_fftw3 init_fftw3 proc~alloc_fftw3 alloc_fftw3 proc~init_fftw3->proc~alloc_fftw3 proc~make_plan_fftw3 make_plan_fftw3 proc~init_fftw3->proc~make_plan_fftw3 interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3->interface~fftw_alloc_complex interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~make_plan_fftw3->interface~fftw_plan_dft_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_fftw3~~CalledByGraph proc~init_fftw3 init_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~init_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3 program~test_fftw3->proc~calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_fftw3 ( long , larg ) !! Subroutine to initialize the FFTW3 process *1 FFT distributed on several threads*. !! Complex case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* call alloc_fftw3 ( long , larg ) call make_plan_fftw3 ( long , larg ) SINGL_FFTW_ALLOCATED = . true . FFT_DIM ( 1 : 2 ) = [ long , larg ] return endsubroutine init_fftw3","tags":"","loc":"proc/init_fftw3.html"},{"title":"init_fftw3_real – TOOLIB","text":"public  subroutine init_fftw3_real(long, larg, plan_flag) Subroutine to initialize the FFTW3 process 1 FFT distributed on several threads Real case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~init_fftw3_real~~CallsGraph proc~init_fftw3_real init_fftw3_real proc~alloc_fftw3_real alloc_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~make_plan_fftw3_real make_plan_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real->interface~fftw_alloc_real interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_fftw3_real~~CalledByGraph proc~init_fftw3_real init_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_fftw3_real ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *1 FFT distributed on several threads* !! Real case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* call alloc_fftw3_real ( long , larg ) call make_plan_fftw3_real ( long , larg , plan_flag ) SINGL_FFTW_ALLOCATED = . true . FFT_DIM ( 1 : 2 ) = [ long , larg ] return endsubroutine init_fftw3_real","tags":"","loc":"proc/init_fftw3_real.html"},{"title":"make_plan_fftw3 – TOOLIB","text":"private  subroutine make_plan_fftw3(long, larg) Note Creates forward and backward plans. 1 FFT distributed on several threads Until no more transformation is needed, the plans remain as they are. Warning In C, the order line/column is reversed, so the 2nd dimension larg of the array\n   is first provided in fftw_plan_dft_2d calling from fortran Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~make_plan_fftw3~~CallsGraph proc~make_plan_fftw3 make_plan_fftw3 interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~make_plan_fftw3->interface~fftw_plan_dft_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_plan_fftw3~~CalledByGraph proc~make_plan_fftw3 make_plan_fftw3 proc~init_fftw3 init_fftw3 proc~init_fftw3->proc~make_plan_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~init_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3 program~test_fftw3->proc~calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_plan_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward plan_f = fftw_plan_dft_2d ( larg , long , cmp_f_i , cmp_f_o , FFTW_FORWARD , flags = FFTW_ESTIMATE ) ! backward plan_b = fftw_plan_dft_2d ( larg , long , cmp_b_i , cmp_b_o , FFTW_BACKWARD , flags = FFTW_ESTIMATE ) return endsubroutine make_plan_fftw3","tags":"","loc":"proc/make_plan_fftw3.html"},{"title":"make_plan_fftw3_real – TOOLIB","text":"private  subroutine make_plan_fftw3_real(long, larg, plan_flag) Note Creates forward and backward plans. 1 FFT distributed on several threads Until no more transformation is needed, the plans remain as they are. Warning In C, the order line/column is reversed, so the 2nd dimension larg of the array\n   is first provided in fftw_plan_dft_2d calling from fortran Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~make_plan_fftw3_real~~CallsGraph proc~make_plan_fftw3_real make_plan_fftw3_real interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_plan_fftw3_real~~CalledByGraph proc~make_plan_fftw3_real make_plan_fftw3_real proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_plan_fftw3_real ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* ! forward plan_f = fftw_plan_dft_r2c_2d ( n0 = larg , n1 = long , in = rea_f_i , out = cmp_f_o , flags = plan_flag ) ! backward plan_b = fftw_plan_dft_c2r_2d ( n0 = larg , n1 = long , in = cmp_b_i , out = rea_b_o , flags = plan_flag ) return endsubroutine make_plan_fftw3_real","tags":"","loc":"proc/make_plan_fftw3_real.html"},{"title":"tab_alloc_fftw3 – TOOLIB","text":"private  subroutine tab_alloc_fftw3(long, larg) Note Allocation of the memory needed by the transformations, forward and backward. several FFT on single thread each The space remains allocated as long as transformations are needed. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~tab_alloc_fftw3~~CallsGraph proc~tab_alloc_fftw3 tab_alloc_fftw3 interface~fftw_alloc_complex fftw_alloc_complex proc~tab_alloc_fftw3->interface~fftw_alloc_complex Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_alloc_fftw3~~CalledByGraph proc~tab_alloc_fftw3 tab_alloc_fftw3 proc~tab_init_fftw3 tab_init_fftw3 proc~tab_init_fftw3->proc~tab_alloc_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_alloc_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ) :: ithread ! forward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_f_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_f_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_f_i ( ithread ), tab_cmp_f_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_f_o ( ithread ), tab_cmp_f_o ( ithread )% tab , ( / long , larg / )) enddo ! backward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_b_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_b_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_b_i ( ithread ), tab_cmp_b_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_b_o ( ithread ), tab_cmp_b_o ( ithread )% tab , ( / long , larg / )) enddo return endsubroutine tab_alloc_fftw3","tags":"","loc":"proc/tab_alloc_fftw3.html"},{"title":"tab_alloc_fftw3_real – TOOLIB","text":"private  subroutine tab_alloc_fftw3_real(long, larg) Note Allocation of the memory needed by the transformations, forward and backward, for the\n  real case. several FFT on single thread each The space remains allocated as long as transformations are needed. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~tab_alloc_fftw3_real~~CallsGraph proc~tab_alloc_fftw3_real tab_alloc_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~tab_alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~tab_alloc_fftw3_real->interface~fftw_alloc_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_alloc_fftw3_real~~CalledByGraph proc~tab_alloc_fftw3_real tab_alloc_fftw3_real proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_alloc_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_alloc_fftw3_real ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ) :: ithread ! forward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_f_i ( ithread ) = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) tab_p_f_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_f_i ( ithread ), tab_rea_f_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_f_o ( ithread ), tab_cmp_f_o ( ithread )% tab , ( / long , larg / )) enddo ! backward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_b_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_b_o ( ithread ) = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_b_i ( ithread ), tab_cmp_b_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_b_o ( ithread ), tab_rea_b_o ( ithread )% tab , ( / long , larg / )) enddo return endsubroutine tab_alloc_fftw3_real","tags":"","loc":"proc/tab_alloc_fftw3_real.html"},{"title":"tab_calc_fftw3 – TOOLIB","text":"public  subroutine tab_calc_fftw3(sens, tab_in, tab_ou, long, larg) Note Subroutine that transforms forward or bacward a double complex array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: sens =FORWARD or =BACKWARD complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~tab_calc_fftw3~~CallsGraph proc~tab_calc_fftw3 tab_calc_fftw3 interface~fftw_execute_dft fftw_execute_dft proc~tab_calc_fftw3->interface~fftw_execute_dft omp_get_thread_num omp_get_thread_num proc~tab_calc_fftw3->omp_get_thread_num Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_calc_fftw3~~CalledByGraph proc~tab_calc_fftw3 tab_calc_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_calc_fftw3 ( sens , tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: sens !! *```=FORWARD``` or ```=BACKWARD```* integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () select case ( sens ) case ( FORWARD ) tab_cmp_f_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( tab_plan_f ( ithread ), tab_cmp_f_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) case ( BACKWARD ) tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( tab_plan_b ( ithread ), tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_b_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_b_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) endselect return endsubroutine tab_calc_fftw3","tags":"","loc":"proc/tab_calc_fftw3.html"},{"title":"tab_calc_fftw3_real_bwd – TOOLIB","text":"public  subroutine tab_calc_fftw3_real_bwd(tab_in, tab_ou, long, larg) Note Subroutine that transforms backward a real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~tab_calc_fftw3_real_bwd~~CallsGraph proc~tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~tab_calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r omp_get_thread_num omp_get_thread_num proc~tab_calc_fftw3_real_bwd->omp_get_thread_num Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_calc_fftw3_real_bwd~~CalledByGraph proc~tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_calc_fftw3_real_bwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_calc_fftw3_real_bwd ( tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_c2r ( tab_plan_b ( ithread ), tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_rea_b_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_rea_b_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine tab_calc_fftw3_real_bwd","tags":"","loc":"proc/tab_calc_fftw3_real_bwd.html"},{"title":"tab_calc_fftw3_real_fwd – TOOLIB","text":"public  subroutine tab_calc_fftw3_real_fwd(tab_in, tab_ou, long, larg) Note Subroutine that transforms forward a real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension Calls proc~~tab_calc_fftw3_real_fwd~~CallsGraph proc~tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~tab_calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c omp_get_thread_num omp_get_thread_num proc~tab_calc_fftw3_real_fwd->omp_get_thread_num Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_calc_fftw3_real_fwd~~CalledByGraph proc~tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_calc_fftw3_real_fwd ( tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () tab_rea_f_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_r2c ( tab_plan_f ( ithread ), tab_rea_f_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine tab_calc_fftw3_real_fwd","tags":"","loc":"proc/tab_calc_fftw3_real_fwd.html"},{"title":"tab_desalloc_fftw3 – TOOLIB","text":"private  subroutine tab_desalloc_fftw3() Note When no more transformation is needed, the memory is released. several FFT on single thread each Arguments None Calls proc~~tab_desalloc_fftw3~~CallsGraph proc~tab_desalloc_fftw3 tab_desalloc_fftw3 interface~fftw_free fftw_free proc~tab_desalloc_fftw3->interface~fftw_free Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_desalloc_fftw3~~CalledByGraph proc~tab_desalloc_fftw3 tab_desalloc_fftw3 proc~tab_end_fftw3 tab_end_fftw3 proc~tab_end_fftw3->proc~tab_desalloc_fftw3 proc~tab_end_fftw3_real tab_end_fftw3_real proc~tab_end_fftw3_real->proc~tab_desalloc_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_end_fftw3 program~test_fftw3->proc~tab_end_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_desalloc_fftw3 () implicit none integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward call fftw_free ( tab_p_f_i ( ithread )) ; tab_p_f_i ( ithread ) = C_NULL_PTR call fftw_free ( tab_p_f_o ( ithread )) ; tab_p_f_o ( ithread ) = C_NULL_PTR ! backward call fftw_free ( tab_p_b_i ( ithread )) ; tab_p_b_i ( ithread ) = C_NULL_PTR call fftw_free ( tab_p_b_o ( ithread )) ; tab_p_b_o ( ithread ) = C_NULL_PTR enddo return endsubroutine tab_desalloc_fftw3","tags":"","loc":"proc/tab_desalloc_fftw3.html"},{"title":"tab_destroy_plan_fftw3 – TOOLIB","text":"private  subroutine tab_destroy_plan_fftw3() Plans are no more needed as no additional transformation will occur. several FFT on single thread each Arguments None Calls proc~~tab_destroy_plan_fftw3~~CallsGraph proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 interface~fftw_destroy_plan fftw_destroy_plan proc~tab_destroy_plan_fftw3->interface~fftw_destroy_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_destroy_plan_fftw3~~CalledByGraph proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 proc~tab_end_fftw3 tab_end_fftw3 proc~tab_end_fftw3->proc~tab_destroy_plan_fftw3 proc~tab_end_fftw3_real tab_end_fftw3_real proc~tab_end_fftw3_real->proc~tab_destroy_plan_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_end_fftw3 program~test_fftw3->proc~tab_end_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_destroy_plan_fftw3 () !! Plans are no more needed as no additional transformation will occur. *several FFT on single thread each* implicit none integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward call fftw_destroy_plan ( tab_plan_f ( ithread )) ! backward call fftw_destroy_plan ( tab_plan_b ( ithread )) enddo return endsubroutine tab_destroy_plan_fftw3","tags":"","loc":"proc/tab_destroy_plan_fftw3.html"},{"title":"tab_end_fftw3 – TOOLIB","text":"public  subroutine tab_end_fftw3() FFTW3 is no more useful from here. several FFT on single thread each Arguments None Calls proc~~tab_end_fftw3~~CallsGraph proc~tab_end_fftw3 tab_end_fftw3 proc~tab_desalloc_fftw3 tab_desalloc_fftw3 proc~tab_end_fftw3->proc~tab_desalloc_fftw3 proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 proc~tab_end_fftw3->proc~tab_destroy_plan_fftw3 interface~fftw_free fftw_free proc~tab_desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~tab_destroy_plan_fftw3->interface~fftw_destroy_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_end_fftw3~~CalledByGraph proc~tab_end_fftw3 tab_end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_end_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_end_fftw3 () !! FFTW3 is no more useful from here. *several FFT on single thread each* implicit none if ( MULTI_FFTW_ALLOCATED ) then call tab_destroy_plan_fftw3 () call tab_desalloc_fftw3 () deallocate ( tab_p_f_i , tab_p_f_o , tab_p_b_i , tab_p_b_o ) deallocate ( tab_cmp_f_i , tab_cmp_f_o , tab_cmp_b_i , tab_cmp_b_o ) deallocate ( tab_plan_f , tab_plan_b ) endif MULTI_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine tab_end_fftw3","tags":"","loc":"proc/tab_end_fftw3.html"},{"title":"tab_end_fftw3_real – TOOLIB","text":"public  subroutine tab_end_fftw3_real() FFTW3 is no more useful from here. several FFT on single thread each Arguments None Calls proc~~tab_end_fftw3_real~~CallsGraph proc~tab_end_fftw3_real tab_end_fftw3_real proc~tab_desalloc_fftw3 tab_desalloc_fftw3 proc~tab_end_fftw3_real->proc~tab_desalloc_fftw3 proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 proc~tab_end_fftw3_real->proc~tab_destroy_plan_fftw3 interface~fftw_free fftw_free proc~tab_desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~tab_destroy_plan_fftw3->interface~fftw_destroy_plan Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_end_fftw3_real~~CalledByGraph proc~tab_end_fftw3_real tab_end_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_end_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_end_fftw3_real () !! FFTW3 is no more useful from here. *several FFT on single thread each* implicit none call tab_destroy_plan_fftw3 () call tab_desalloc_fftw3 () deallocate ( tab_p_f_i , tab_p_f_o , tab_p_b_i , tab_p_b_o ) deallocate ( tab_rea_f_i , tab_cmp_f_o , tab_cmp_b_i , tab_rea_b_o ) deallocate ( tab_plan_f , tab_plan_b ) MULTI_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine tab_end_fftw3_real","tags":"","loc":"proc/tab_end_fftw3_real.html"},{"title":"tab_init_fftw3 – TOOLIB","text":"public  subroutine tab_init_fftw3(long, larg, plan_flag) Subroutine to initialize the FFTW3 process several FFT on single thread each Complex case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~tab_init_fftw3~~CallsGraph proc~tab_init_fftw3 tab_init_fftw3 proc~tab_alloc_fftw3 tab_alloc_fftw3 proc~tab_init_fftw3->proc~tab_alloc_fftw3 proc~tab_make_plan_fftw3 tab_make_plan_fftw3 proc~tab_init_fftw3->proc~tab_make_plan_fftw3 interface~fftw_alloc_complex fftw_alloc_complex proc~tab_alloc_fftw3->interface~fftw_alloc_complex interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~tab_make_plan_fftw3->interface~fftw_plan_dft_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_init_fftw3~~CalledByGraph proc~tab_init_fftw3 tab_init_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_init_fftw3 ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *several FFT on single thread each* !! Complex case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* allocate ( tab_cmp_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_f ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_b ( 0 : NB_THREADS_FFT - 1 ) ) call tab_alloc_fftw3 ( long , larg ) call tab_make_plan_fftw3 ( long , larg , plan_flag ) MULTI_FFTW_ALLOCATED = . true . return endsubroutine tab_init_fftw3","tags":"","loc":"proc/tab_init_fftw3.html"},{"title":"tab_init_fftw3_real – TOOLIB","text":"public  subroutine tab_init_fftw3_real(long, larg, plan_flag) Subroutine to initialize the FFTW3 process several FFT on single thread each Real case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~tab_init_fftw3_real~~CallsGraph proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_alloc_fftw3_real tab_alloc_fftw3_real proc~tab_init_fftw3_real->proc~tab_alloc_fftw3_real proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real proc~tab_init_fftw3_real->proc~tab_make_plan_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~tab_alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~tab_alloc_fftw3_real->interface~fftw_alloc_real interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_init_fftw3_real~~CalledByGraph proc~tab_init_fftw3_real tab_init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_init_fftw3_real ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *several FFT on single thread each* !! Real case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* allocate ( tab_rea_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_rea_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_f ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_b ( 0 : NB_THREADS_FFT - 1 ) ) call tab_alloc_fftw3_real ( long , larg ) call tab_make_plan_fftw3_real ( long , larg , plan_flag ) MULTI_FFTW_ALLOCATED = . true . return endsubroutine tab_init_fftw3_real","tags":"","loc":"proc/tab_init_fftw3_real.html"},{"title":"tab_make_plan_fftw3 – TOOLIB","text":"private  subroutine tab_make_plan_fftw3(long, larg, plan_flag) Note Creates forward and backward plans. several FFT on single thread each Until no more transformation is needed, the plans remain as they are. Warning In C, the order line/column is reversed, so the 2nd dimension larg of the array\n   is first provided in fftw_plan_dft_2d calling from fortran Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~tab_make_plan_fftw3~~CallsGraph proc~tab_make_plan_fftw3 tab_make_plan_fftw3 interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~tab_make_plan_fftw3->interface~fftw_plan_dft_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_make_plan_fftw3~~CalledByGraph proc~tab_make_plan_fftw3 tab_make_plan_fftw3 proc~tab_init_fftw3 tab_init_fftw3 proc~tab_init_fftw3->proc~tab_make_plan_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_make_plan_fftw3 ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward tab_plan_f ( ithread ) = fftw_plan_dft_2d ( larg , long , tab_cmp_f_i ( ithread )% tab , & ! tab_cmp_f_o ( ithread )% tab , & ! FORWARD , plan_flag ) ! ! backward tab_plan_b ( ithread ) = fftw_plan_dft_2d ( larg , long , tab_cmp_b_i ( ithread )% tab , & ! tab_cmp_b_o ( ithread )% tab , & ! BACKWARD , plan_flag ) ! enddo return endsubroutine tab_make_plan_fftw3","tags":"","loc":"proc/tab_make_plan_fftw3.html"},{"title":"tab_make_plan_fftw3_real – TOOLIB","text":"private  subroutine tab_make_plan_fftw3_real(long, larg, plan_flag) Note Creates forward and backward plans. several FFT on single thread each Until no more transformation is needed, the plans remain as they are. Warning In C, the order line/column is reversed, so the 2nd dimension larg of the array\n   is first provided in fftw_plan_dft_2d calling from fortran Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example Calls proc~~tab_make_plan_fftw3_real~~CallsGraph proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_make_plan_fftw3_real~~CalledByGraph proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_make_plan_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~tab_init_fftw3_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_make_plan_fftw3_real ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward tab_plan_f ( ithread ) = fftw_plan_dft_r2c_2d ( larg , long , tab_rea_f_i ( ithread )% tab , & ! tab_cmp_f_o ( ithread )% tab , & ! plan_flag ) ! ! backward tab_plan_b ( ithread ) = fftw_plan_dft_c2r_2d ( larg , long , tab_cmp_b_i ( ithread )% tab , & ! tab_rea_b_o ( ithread )% tab , & ! plan_flag ) ! enddo return endsubroutine tab_make_plan_fftw3_real","tags":"","loc":"proc/tab_make_plan_fftw3_real.html"},{"title":"fftw_alignment_of – TOOLIB","text":"interface private  function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_alignment_of.html"},{"title":"fftw_alloc_complex – TOOLIB","text":"interface Called by interface~~fftw_alloc_complex~~CalledByGraph interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3 alloc_fftw3 proc~alloc_fftw3->interface~fftw_alloc_complex proc~alloc_fftw3_real alloc_fftw3_real proc~alloc_fftw3_real->interface~fftw_alloc_complex proc~tab_alloc_fftw3 tab_alloc_fftw3 proc~tab_alloc_fftw3->interface~fftw_alloc_complex proc~tab_alloc_fftw3_real tab_alloc_fftw3_real proc~tab_alloc_fftw3_real->interface~fftw_alloc_complex proc~init_fftw3 init_fftw3 proc~init_fftw3->proc~alloc_fftw3 proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~tab_init_fftw3 tab_init_fftw3 proc~tab_init_fftw3->proc~tab_alloc_fftw3 proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_alloc_fftw3_real proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~init_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~tab_init_fftw3 program~test_fftw3->proc~tab_init_fftw3_real program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftw_alloc_complex.html"},{"title":"fftw_alloc_real – TOOLIB","text":"interface Called by interface~~fftw_alloc_real~~CalledByGraph interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real alloc_fftw3_real proc~alloc_fftw3_real->interface~fftw_alloc_real proc~tab_alloc_fftw3_real tab_alloc_fftw3_real proc~tab_alloc_fftw3_real->interface~fftw_alloc_real proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_alloc_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~tab_init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftw_alloc_real.html"},{"title":"fftw_cleanup – TOOLIB","text":"interface private  subroutine fftw_cleanup() bind(C, name='fftw_cleanup') Arguments None","tags":"","loc":"interface/fftw_cleanup.html"},{"title":"fftw_cleanup_threads – TOOLIB","text":"interface private  subroutine fftw_cleanup_threads() bind(C, name='fftw_cleanup_threads') Arguments None","tags":"","loc":"interface/fftw_cleanup_threads.html"},{"title":"fftw_cost – TOOLIB","text":"interface private  function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","loc":"interface/fftw_cost.html"},{"title":"fftw_destroy_plan – TOOLIB","text":"interface Called by interface~~fftw_destroy_plan~~CalledByGraph interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~destroy_plan_fftw3->interface~fftw_destroy_plan proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 proc~tab_destroy_plan_fftw3->interface~fftw_destroy_plan proc~end_fftw3 end_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~tab_end_fftw3 tab_end_fftw3 proc~tab_end_fftw3->proc~tab_destroy_plan_fftw3 proc~tab_end_fftw3_real tab_end_fftw3_real proc~tab_end_fftw3_real->proc~tab_destroy_plan_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~end_fftw3 program~test_fftw3->proc~tab_end_fftw3 program~test_fftw3->proc~tab_end_fftw3_real program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine fftw_destroy_plan(p) bind(C, name='fftw_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_destroy_plan.html"},{"title":"fftw_estimate_cost – TOOLIB","text":"interface private  function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","loc":"interface/fftw_estimate_cost.html"},{"title":"fftw_execute_dft – TOOLIB","text":"interface Called by interface~~fftw_execute_dft~~CalledByGraph interface~fftw_execute_dft fftw_execute_dft proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->interface~fftw_execute_dft proc~tab_calc_fftw3 tab_calc_fftw3 proc~tab_calc_fftw3->interface~fftw_execute_dft program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~tab_calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine fftw_execute_dft(p, in, out) bind(C, name='fftw_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft.html"},{"title":"fftw_execute_dft_c2r – TOOLIB","text":"interface Called by interface~~fftw_execute_dft_c2r~~CalledByGraph interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r proc~tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd proc~tab_calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~tab_calc_fftw3_real_bwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name='fftw_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_c2r.html"},{"title":"fftw_execute_dft_r2c – TOOLIB","text":"interface Called by interface~~fftw_execute_dft_r2c~~CalledByGraph interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c proc~tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd proc~tab_calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c program~test_fftw3 test_fftw3 program~test_fftw3->proc~calc_fftw3_real_fwd program~test_fftw3->proc~tab_calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name='fftw_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_dft_r2c.html"},{"title":"fftw_execute_r2r – TOOLIB","text":"interface private  subroutine fftw_execute_r2r(p, in, out) bind(C, name='fftw_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_r2r.html"},{"title":"fftw_execute_split_dft – TOOLIB","text":"interface private  subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftw_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft.html"},{"title":"fftw_execute_split_dft_c2r – TOOLIB","text":"interface private  subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftw_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftw_execute_split_dft_c2r.html"},{"title":"fftw_execute_split_dft_r2c – TOOLIB","text":"interface private  subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftw_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftw_execute_split_dft_r2c.html"},{"title":"fftw_export_wisdom – TOOLIB","text":"interface private  subroutine fftw_export_wisdom(write_char, data) bind(C, name='fftw_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftw_export_wisdom.html"},{"title":"fftw_export_wisdom_to_file – TOOLIB","text":"interface private  subroutine fftw_export_wisdom_to_file(output_file) bind(C, name='fftw_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_export_wisdom_to_file.html"},{"title":"fftw_export_wisdom_to_filename – TOOLIB","text":"interface private  function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_export_wisdom_to_filename.html"},{"title":"fftw_export_wisdom_to_string – TOOLIB","text":"interface private  function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(c_ptr)","tags":"","loc":"interface/fftw_export_wisdom_to_string.html"},{"title":"fftw_flops – TOOLIB","text":"interface private  subroutine fftw_flops(p, add, mul, fmas) bind(C, name='fftw_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftw_flops.html"},{"title":"fftw_forget_wisdom – TOOLIB","text":"interface private  subroutine fftw_forget_wisdom() bind(C, name='fftw_forget_wisdom') Arguments None","tags":"","loc":"interface/fftw_forget_wisdom.html"},{"title":"fftw_fprint_plan – TOOLIB","text":"interface private  subroutine fftw_fprint_plan(p, output_file) bind(C, name='fftw_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftw_fprint_plan.html"},{"title":"fftw_free – TOOLIB","text":"interface Called by interface~~fftw_free~~CalledByGraph interface~fftw_free fftw_free proc~desalloc_fftw3 desalloc_fftw3 proc~desalloc_fftw3->interface~fftw_free proc~tab_desalloc_fftw3 tab_desalloc_fftw3 proc~tab_desalloc_fftw3->interface~fftw_free proc~end_fftw3 end_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~tab_end_fftw3 tab_end_fftw3 proc~tab_end_fftw3->proc~tab_desalloc_fftw3 proc~tab_end_fftw3_real tab_end_fftw3_real proc~tab_end_fftw3_real->proc~tab_desalloc_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~end_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~end_fftw3 program~test_fftw3->proc~tab_end_fftw3 program~test_fftw3->proc~tab_end_fftw3_real program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine fftw_free(p) bind(C, name='fftw_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_free.html"},{"title":"fftw_import_system_wisdom – TOOLIB","text":"interface private  function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_import_system_wisdom.html"},{"title":"fftw_import_wisdom – TOOLIB","text":"interface private  function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_import_wisdom.html"},{"title":"fftw_import_wisdom_from_file – TOOLIB","text":"interface private  function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_import_wisdom_from_file.html"},{"title":"fftw_import_wisdom_from_filename – TOOLIB","text":"interface private  function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_import_wisdom_from_filename.html"},{"title":"fftw_import_wisdom_from_string – TOOLIB","text":"interface private  function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_import_wisdom_from_string.html"},{"title":"fftw_init_threads – TOOLIB","text":"interface private  function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_init_threads.html"},{"title":"fftw_make_planner_thread_safe – TOOLIB","text":"interface private  subroutine fftw_make_planner_thread_safe() bind(C, name='fftw_make_planner_thread_safe') Arguments None","tags":"","loc":"interface/fftw_make_planner_thread_safe.html"},{"title":"fftw_malloc – TOOLIB","text":"interface private  function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftw_malloc.html"},{"title":"fftw_plan_dft – TOOLIB","text":"interface private  function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft.html"},{"title":"fftw_plan_dft_1d – TOOLIB","text":"interface private  function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_1d.html"},{"title":"fftw_plan_dft_2d – TOOLIB","text":"interface Called by interface~~fftw_plan_dft_2d~~CalledByGraph interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~make_plan_fftw3 make_plan_fftw3 proc~make_plan_fftw3->interface~fftw_plan_dft_2d proc~tab_make_plan_fftw3 tab_make_plan_fftw3 proc~tab_make_plan_fftw3->interface~fftw_plan_dft_2d proc~init_fftw3 init_fftw3 proc~init_fftw3->proc~make_plan_fftw3 proc~tab_init_fftw3 tab_init_fftw3 proc~tab_init_fftw3->proc~tab_make_plan_fftw3 proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->proc~init_fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3 program~test_fftw3->proc~tab_init_fftw3 program~test_fftw3->proc~calc_fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_2d.html"},{"title":"fftw_plan_dft_3d – TOOLIB","text":"interface private  function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_3d.html"},{"title":"fftw_plan_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_c2r.html"},{"title":"fftw_plan_dft_c2r_1d – TOOLIB","text":"interface private  function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_c2r_1d.html"},{"title":"fftw_plan_dft_c2r_2d – TOOLIB","text":"interface Called by interface~~fftw_plan_dft_c2r_2d~~CalledByGraph interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real make_plan_fftw3_real proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_make_plan_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~tab_init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_c2r_2d.html"},{"title":"fftw_plan_dft_c2r_3d – TOOLIB","text":"interface private  function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_c2r_3d.html"},{"title":"fftw_plan_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_r2c.html"},{"title":"fftw_plan_dft_r2c_1d – TOOLIB","text":"interface private  function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_r2c_1d.html"},{"title":"fftw_plan_dft_r2c_2d – TOOLIB","text":"interface Called by interface~~fftw_plan_dft_r2c_2d~~CalledByGraph interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real make_plan_fftw3_real proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d proc~init_fftw3_real init_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real proc~tab_init_fftw3_real tab_init_fftw3_real proc~tab_init_fftw3_real->proc~tab_make_plan_fftw3_real proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->proc~init_fftw3_real proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->proc~init_fftw3_real program~test_fftw3 test_fftw3 program~test_fftw3->proc~init_fftw3_real program~test_fftw3->proc~tab_init_fftw3_real program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_r2c_2d.html"},{"title":"fftw_plan_dft_r2c_3d – TOOLIB","text":"interface private  function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_dft_r2c_3d.html"},{"title":"fftw_plan_guru64_dft – TOOLIB","text":"interface private  function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_dft.html"},{"title":"fftw_plan_guru64_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_dft_c2r.html"},{"title":"fftw_plan_guru64_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_dft_r2c.html"},{"title":"fftw_plan_guru64_r2r – TOOLIB","text":"interface private  function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_r2r.html"},{"title":"fftw_plan_guru64_split_dft – TOOLIB","text":"interface private  function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_split_dft.html"},{"title":"fftw_plan_guru64_split_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_c2r.html"},{"title":"fftw_plan_guru64_split_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru64_split_dft_r2c.html"},{"title":"fftw_plan_guru_dft – TOOLIB","text":"interface private  function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_dft.html"},{"title":"fftw_plan_guru_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_dft_c2r.html"},{"title":"fftw_plan_guru_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_dft_r2c.html"},{"title":"fftw_plan_guru_r2r – TOOLIB","text":"interface private  function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_r2r.html"},{"title":"fftw_plan_guru_split_dft – TOOLIB","text":"interface private  function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_split_dft.html"},{"title":"fftw_plan_guru_split_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_split_dft_c2r.html"},{"title":"fftw_plan_guru_split_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_guru_split_dft_r2c.html"},{"title":"fftw_plan_many_dft – TOOLIB","text":"interface private  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_many_dft.html"},{"title":"fftw_plan_many_dft_c2r – TOOLIB","text":"interface private  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_many_dft_c2r.html"},{"title":"fftw_plan_many_dft_r2c – TOOLIB","text":"interface private  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_many_dft_r2c.html"},{"title":"fftw_plan_many_r2r – TOOLIB","text":"interface private  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_many_r2r.html"},{"title":"fftw_plan_r2r – TOOLIB","text":"interface private  function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_r2r.html"},{"title":"fftw_plan_r2r_1d – TOOLIB","text":"interface private  function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_r2r_1d.html"},{"title":"fftw_plan_r2r_2d – TOOLIB","text":"interface private  function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_r2r_2d.html"},{"title":"fftw_plan_r2r_3d – TOOLIB","text":"interface private  function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftw_plan_r2r_3d.html"},{"title":"fftw_plan_with_nthreads – TOOLIB","text":"interface Called by interface~~fftw_plan_with_nthreads~~CalledByGraph interface~fftw_plan_with_nthreads fftw_plan_with_nthreads proc~calc_fftw3 calc_fftw3 proc~calc_fftw3->interface~fftw_plan_with_nthreads proc~calc_fftw3_real_bwd calc_fftw3_real_bwd proc~calc_fftw3_real_bwd->interface~fftw_plan_with_nthreads proc~calc_fftw3_real_fwd calc_fftw3_real_fwd proc~calc_fftw3_real_fwd->interface~fftw_plan_with_nthreads program~test_fftw3 test_fftw3 program~test_fftw3->interface~fftw_plan_with_nthreads program~test_fftw3->proc~calc_fftw3 program~test_fftw3->proc~calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_fwd Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine fftw_plan_with_nthreads(nthreads) bind(C, name='fftw_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftw_plan_with_nthreads.html"},{"title":"fftw_planner_nthreads – TOOLIB","text":"interface private  function fftw_planner_nthreads() bind(C, name='fftw_planner_nthreads') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftw_planner_nthreads.html"},{"title":"fftw_print_plan – TOOLIB","text":"interface private  subroutine fftw_print_plan(p) bind(C, name='fftw_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftw_print_plan.html"},{"title":"fftw_set_timelimit – TOOLIB","text":"interface private  subroutine fftw_set_timelimit(t) bind(C, name='fftw_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftw_set_timelimit.html"},{"title":"fftw_sprint_plan – TOOLIB","text":"interface private  function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr)","tags":"","loc":"interface/fftw_sprint_plan.html"},{"title":"fftwf_alignment_of – TOOLIB","text":"interface private  function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_alignment_of.html"},{"title":"fftwf_alloc_complex – TOOLIB","text":"interface private  function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_alloc_complex.html"},{"title":"fftwf_alloc_real – TOOLIB","text":"interface private  function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_alloc_real.html"},{"title":"fftwf_cleanup – TOOLIB","text":"interface private  subroutine fftwf_cleanup() bind(C, name='fftwf_cleanup') Arguments None","tags":"","loc":"interface/fftwf_cleanup.html"},{"title":"fftwf_cleanup_threads – TOOLIB","text":"interface private  subroutine fftwf_cleanup_threads() bind(C, name='fftwf_cleanup_threads') Arguments None","tags":"","loc":"interface/fftwf_cleanup_threads.html"},{"title":"fftwf_cost – TOOLIB","text":"interface private  function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","loc":"interface/fftwf_cost.html"},{"title":"fftwf_destroy_plan – TOOLIB","text":"interface private  subroutine fftwf_destroy_plan(p) bind(C, name='fftwf_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_destroy_plan.html"},{"title":"fftwf_estimate_cost – TOOLIB","text":"interface private  function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double)","tags":"","loc":"interface/fftwf_estimate_cost.html"},{"title":"fftwf_execute_dft – TOOLIB","text":"interface private  subroutine fftwf_execute_dft(p, in, out) bind(C, name='fftwf_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft.html"},{"title":"fftwf_execute_dft_c2r – TOOLIB","text":"interface private  subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name='fftwf_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_c2r.html"},{"title":"fftwf_execute_dft_r2c – TOOLIB","text":"interface private  subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name='fftwf_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_dft_r2c.html"},{"title":"fftwf_execute_r2r – TOOLIB","text":"interface private  subroutine fftwf_execute_r2r(p, in, out) bind(C, name='fftwf_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_r2r.html"},{"title":"fftwf_execute_split_dft – TOOLIB","text":"interface private  subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftwf_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft.html"},{"title":"fftwf_execute_split_dft_c2r – TOOLIB","text":"interface private  subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftwf_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out","tags":"","loc":"interface/fftwf_execute_split_dft_c2r.html"},{"title":"fftwf_execute_split_dft_r2c – TOOLIB","text":"interface private  subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftwf_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io","tags":"","loc":"interface/fftwf_execute_split_dft_r2c.html"},{"title":"fftwf_export_wisdom – TOOLIB","text":"interface private  subroutine fftwf_export_wisdom(write_char, data) bind(C, name='fftwf_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data","tags":"","loc":"interface/fftwf_export_wisdom.html"},{"title":"fftwf_export_wisdom_to_file – TOOLIB","text":"interface private  subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name='fftwf_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_export_wisdom_to_file.html"},{"title":"fftwf_export_wisdom_to_filename – TOOLIB","text":"interface private  function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_export_wisdom_to_filename.html"},{"title":"fftwf_export_wisdom_to_string – TOOLIB","text":"interface private  function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_export_wisdom_to_string.html"},{"title":"fftwf_flops – TOOLIB","text":"interface private  subroutine fftwf_flops(p, add, mul, fmas) bind(C, name='fftwf_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas","tags":"","loc":"interface/fftwf_flops.html"},{"title":"fftwf_forget_wisdom – TOOLIB","text":"interface private  subroutine fftwf_forget_wisdom() bind(C, name='fftwf_forget_wisdom') Arguments None","tags":"","loc":"interface/fftwf_forget_wisdom.html"},{"title":"fftwf_fprint_plan – TOOLIB","text":"interface private  subroutine fftwf_fprint_plan(p, output_file) bind(C, name='fftwf_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file","tags":"","loc":"interface/fftwf_fprint_plan.html"},{"title":"fftwf_free – TOOLIB","text":"interface private  subroutine fftwf_free(p) bind(C, name='fftwf_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_free.html"},{"title":"fftwf_import_system_wisdom – TOOLIB","text":"interface private  function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_import_system_wisdom.html"},{"title":"fftwf_import_wisdom – TOOLIB","text":"interface private  function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_import_wisdom.html"},{"title":"fftwf_import_wisdom_from_file – TOOLIB","text":"interface private  function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_import_wisdom_from_file.html"},{"title":"fftwf_import_wisdom_from_filename – TOOLIB","text":"interface private  function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_import_wisdom_from_filename.html"},{"title":"fftwf_import_wisdom_from_string – TOOLIB","text":"interface private  function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_import_wisdom_from_string.html"},{"title":"fftwf_init_threads – TOOLIB","text":"interface private  function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_init_threads.html"},{"title":"fftwf_make_planner_thread_safe – TOOLIB","text":"interface private  subroutine fftwf_make_planner_thread_safe() bind(C, name='fftwf_make_planner_thread_safe') Arguments None","tags":"","loc":"interface/fftwf_make_planner_thread_safe.html"},{"title":"fftwf_malloc – TOOLIB","text":"interface private  function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_malloc.html"},{"title":"fftwf_plan_dft – TOOLIB","text":"interface private  function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft.html"},{"title":"fftwf_plan_dft_1d – TOOLIB","text":"interface private  function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_1d.html"},{"title":"fftwf_plan_dft_2d – TOOLIB","text":"interface private  function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_2d.html"},{"title":"fftwf_plan_dft_3d – TOOLIB","text":"interface private  function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_3d.html"},{"title":"fftwf_plan_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_c2r.html"},{"title":"fftwf_plan_dft_c2r_1d – TOOLIB","text":"interface private  function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_c2r_1d.html"},{"title":"fftwf_plan_dft_c2r_2d – TOOLIB","text":"interface private  function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_c2r_2d.html"},{"title":"fftwf_plan_dft_c2r_3d – TOOLIB","text":"interface private  function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_c2r_3d.html"},{"title":"fftwf_plan_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_r2c.html"},{"title":"fftwf_plan_dft_r2c_1d – TOOLIB","text":"interface private  function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_r2c_1d.html"},{"title":"fftwf_plan_dft_r2c_2d – TOOLIB","text":"interface private  function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_r2c_2d.html"},{"title":"fftwf_plan_dft_r2c_3d – TOOLIB","text":"interface private  function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_dft_r2c_3d.html"},{"title":"fftwf_plan_guru64_dft – TOOLIB","text":"interface private  function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_dft.html"},{"title":"fftwf_plan_guru64_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_dft_c2r.html"},{"title":"fftwf_plan_guru64_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_dft_r2c.html"},{"title":"fftwf_plan_guru64_r2r – TOOLIB","text":"interface private  function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_r2r.html"},{"title":"fftwf_plan_guru64_split_dft – TOOLIB","text":"interface private  function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft.html"},{"title":"fftwf_plan_guru64_split_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_c2r.html"},{"title":"fftwf_plan_guru64_split_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru64_split_dft_r2c.html"},{"title":"fftwf_plan_guru_dft – TOOLIB","text":"interface private  function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_dft.html"},{"title":"fftwf_plan_guru_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_dft_c2r.html"},{"title":"fftwf_plan_guru_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_dft_r2c.html"},{"title":"fftwf_plan_guru_r2r – TOOLIB","text":"interface private  function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_r2r.html"},{"title":"fftwf_plan_guru_split_dft – TOOLIB","text":"interface private  function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_split_dft.html"},{"title":"fftwf_plan_guru_split_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_c2r.html"},{"title":"fftwf_plan_guru_split_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_guru_split_dft_r2c.html"},{"title":"fftwf_plan_many_dft – TOOLIB","text":"interface private  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_many_dft.html"},{"title":"fftwf_plan_many_dft_c2r – TOOLIB","text":"interface private  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_many_dft_c2r.html"},{"title":"fftwf_plan_many_dft_r2c – TOOLIB","text":"interface private  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_many_dft_r2c.html"},{"title":"fftwf_plan_many_r2r – TOOLIB","text":"interface private  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_many_r2r.html"},{"title":"fftwf_plan_r2r – TOOLIB","text":"interface private  function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_r2r.html"},{"title":"fftwf_plan_r2r_1d – TOOLIB","text":"interface private  function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_r2r_1d.html"},{"title":"fftwf_plan_r2r_2d – TOOLIB","text":"interface private  function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_r2r_2d.html"},{"title":"fftwf_plan_r2r_3d – TOOLIB","text":"interface private  function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_plan_r2r_3d.html"},{"title":"fftwf_plan_with_nthreads – TOOLIB","text":"interface private  subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name='fftwf_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads","tags":"","loc":"interface/fftwf_plan_with_nthreads.html"},{"title":"fftwf_planner_nthreads – TOOLIB","text":"interface private  function fftwf_planner_nthreads() bind(C, name='fftwf_planner_nthreads') Arguments None Return Value integer(kind=c_int)","tags":"","loc":"interface/fftwf_planner_nthreads.html"},{"title":"fftwf_print_plan – TOOLIB","text":"interface private  subroutine fftwf_print_plan(p) bind(C, name='fftwf_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p","tags":"","loc":"interface/fftwf_print_plan.html"},{"title":"fftwf_set_timelimit – TOOLIB","text":"interface private  subroutine fftwf_set_timelimit(t) bind(C, name='fftwf_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t","tags":"","loc":"interface/fftwf_set_timelimit.html"},{"title":"fftwf_sprint_plan – TOOLIB","text":"interface private  function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr)","tags":"","loc":"interface/fftwf_sprint_plan.html"},{"title":"interp – TOOLIB","text":"private  function interp(tab, lb, ind, ordre) Interpolate evenly spaced points Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb:) :: tab tableau 1D à interpoler integer(kind=I4), intent(in) :: lb borne inférieure integer(kind=4), intent(in) :: ind position de l’élément “milieu” integer(kind=4), intent(in) :: ordre ordre de l’interp 1, 3, 5 ou 7 Return Value real(kind=R8) valeur particulière interpolée Called by proc~~interp~~CalledByGraph proc~interp interp proc~interp1d interp1D proc~interp1d->proc~interp proc~interp2d interp2D proc~interp2d->proc~interp1d proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~interp1d proc~test_interp_pond->proc~interp2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function interp ( tab , lb , ind , ordre ) !! Interpolate evenly spaced points implicit none real ( kind = R8 ) :: interp !! *valeur particulière interpolée* integer ( kind = I4 ), intent ( in ) :: lb !! *borne inférieure* integer ( kind = 4 ), intent ( in ) :: ind !! *position de l'élément \"milieu\"* integer ( kind = 4 ), intent ( in ) :: ordre !! *ordre de l'interp 1, 3, 5 ou 7* real ( kind = R8 ), intent ( in ), dimension ( lb :) :: tab !! *tableau 1D à interpoler* select case ( ordre ) case ( 1 ) interp = ci1_00 * tab ( ind ) + & ! ci1_01 * tab ( ind + 1 ) ! case ( 3 ) interp = ci3_00 * tab ( ind - 1 ) + & ! ci3_01 * tab ( ind ) + & ! ci3_02 * tab ( ind + 1 ) + & ! ci3_03 * tab ( ind + 2 ) ! case ( 5 ) interp = ci5_00 * tab ( ind - 2 ) + & ! ci5_01 * tab ( ind - 1 ) + & ! ci5_02 * tab ( ind ) + & ! ci5_03 * tab ( ind + 1 ) + & ! ci5_04 * tab ( ind + 2 ) + & ! ci5_05 * tab ( ind + 3 ) ! case ( 7 ) interp = ci7_00 * tab ( ind - 3 ) + & ! ci7_01 * tab ( ind - 2 ) + & ! ci7_02 * tab ( ind - 1 ) + & ! ci7_03 * tab ( ind ) + & ! ci7_04 * tab ( ind + 1 ) + & ! ci7_05 * tab ( ind + 2 ) + & ! ci7_06 * tab ( ind + 3 ) + & ! ci7_07 * tab ( ind + 4 ) ! case default stop 'Bad choice in function \"interp\"' endselect return endfunction interp","tags":"","loc":"proc/interp.html"},{"title":"restrict – TOOLIB","text":"private  function restrict(tab, lb, ind, ordre) Restrict evenly spaced points Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb:) :: tab tableau 1D à réduire integer(kind=4), intent(in) :: lb borne inférieure integer(kind=4), intent(in) :: ind position de l’élément “milieu” integer(kind=4), intent(in) :: ordre ordre de la restriction 1, 3, 5 ou 7 Return Value real(kind=R8) valeur particulière pondérée Called by proc~~restrict~~CalledByGraph proc~restrict restrict proc~restrict1d restrict1D proc~restrict1d->proc~restrict proc~restrict2d restrict2D proc~restrict2d->proc~restrict1d proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~restrict1d proc~test_interp_pond->proc~restrict2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function restrict ( tab , lb , ind , ordre ) !! Restrict evenly spaced points implicit none real ( kind = R8 ) :: restrict !! *valeur particulière pondérée* integer ( kind = 4 ), intent ( in ) :: lb !! *borne inférieure* integer ( kind = 4 ), intent ( in ) :: ind !! *position de l'élément \"milieu\"* integer ( kind = 4 ), intent ( in ) :: ordre !! *ordre de la restriction 1, 3, 5 ou 7* real ( kind = R8 ), intent ( in ), dimension ( lb :) :: tab !! *tableau 1D à réduire* select case ( ordre ) case ( 0 ) restrict = cp0_00 * tab ( ind ) case ( 1 ) restrict = cp1_00 * tab ( ind - 1 ) + & ! cp1_01 * tab ( ind ) + & ! cp1_02 * tab ( ind + 1 ) ! case ( 3 ) restrict = cp3_00 * tab ( ind - 3 ) + & ! cp3_01 * tab ( ind - 2 ) + & ! cp3_02 * tab ( ind - 1 ) + & ! cp3_03 * tab ( ind ) + & ! cp3_04 * tab ( ind + 1 ) + & ! cp3_05 * tab ( ind + 2 ) + & ! cp3_06 * tab ( ind + 3 ) ! case ( 5 ) restrict = cp5_00 * tab ( ind - 5 ) + & ! cp5_01 * tab ( ind - 4 ) + & ! cp5_02 * tab ( ind - 3 ) + & ! cp5_03 * tab ( ind - 2 ) + & ! cp5_04 * tab ( ind - 1 ) + & ! cp5_05 * tab ( ind ) + & ! cp5_06 * tab ( ind + 1 ) + & ! cp5_07 * tab ( ind + 2 ) + & ! cp5_08 * tab ( ind + 3 ) + & ! cp5_09 * tab ( ind + 4 ) + & ! cp5_10 * tab ( ind + 5 ) ! case ( 7 ) restrict = cp7_00 * tab ( ind - 7 ) + & ! cp7_01 * tab ( ind - 6 ) + & ! cp7_02 * tab ( ind - 5 ) + & ! cp7_03 * tab ( ind - 4 ) + & ! cp7_04 * tab ( ind - 3 ) + & ! cp7_05 * tab ( ind - 2 ) + & ! cp7_06 * tab ( ind - 1 ) + & ! cp7_07 * tab ( ind ) + & ! cp7_08 * tab ( ind + 1 ) + & ! cp7_09 * tab ( ind + 2 ) + & ! cp7_10 * tab ( ind + 3 ) + & ! cp7_11 * tab ( ind + 4 ) + & ! cp7_12 * tab ( ind + 5 ) + & ! cp7_13 * tab ( ind + 6 ) + & ! cp7_14 * tab ( ind + 7 ) ! case default stop 'Bad choice in function \"restrict\"' endselect return endfunction restrict","tags":"","loc":"proc/restrict.html"},{"title":"genere_coeff_lagrange – TOOLIB","text":"private  subroutine genere_coeff_lagrange() subroutine generating coefficients for kth-order interpolation Arguments None Source Code subroutine genere_coeff_lagrange () !! subroutine generating coefficients for kth-order interpolation implicit none integer ( kind = I4 ) :: i , j , k , n , c real ( kind = R8 ) :: coeff do write ( * , * ) 'n' ; read ( * , * ) n ; if ( n == 0 ) exit write ( * , * ) 'k' ; read ( * , * ) k write ( * , * ) 'c' ; read ( * , * ) c do i = 0 , n coeff = 1.0d0 do j = 0 , n if ( j == i ) cycle coeff = coeff * ( 0.5_R8 * ( 2 * k - 2 * j + 1 ) ) / ( i - j ) enddo write ( * , * ) coeff * c enddo enddo return endsubroutine genere_coeff_lagrange","tags":"","loc":"proc/genere_coeff_lagrange.html"},{"title":"interp1D – TOOLIB","text":"public  subroutine interp1D(tabgros, lb_gros, tabfin, lb_fin, ub_gros, ordre) Interpolate evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb_gros:) :: tabgros tableau grossier à interpoler integer(kind=I4), intent(in) :: lb_gros indice inférieur real(kind=R8), intent(out), dimension(lb_fin :) :: tabfin tableau résultant, 2 fois plus fin integer(kind=I4), intent(in) :: lb_fin indice inférieur de tab_fin integer(kind=I4), intent(in) :: ub_gros taille de tabgros integer(kind=I4), intent(in) :: ordre ordre de l’interpolation Calls proc~~interp1d~~CallsGraph proc~interp1d interp1D proc~interp interp proc~interp1d->proc~interp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interp1d~~CalledByGraph proc~interp1d interp1D proc~interp2d interp2D proc~interp2d->proc~interp1d proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~interp1d proc~test_interp_pond->proc~interp2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine interp1D ( tabgros , lb_gros , tabfin , lb_fin , ub_gros , ordre ) !! Interpolate evenly spaced points, taking into account the borders implicit none integer ( kind = I4 ), intent ( in ) :: lb_gros !! *indice inférieur* integer ( kind = I4 ), intent ( in ) :: lb_fin !! *indice inférieur de tab_fin* integer ( kind = I4 ), intent ( in ) :: ub_gros !! *taille de tabgros* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( lb_gros :) :: tabgros !! *tableau grossier à interpoler* real ( kind = R8 ), intent ( out ), dimension ( lb_fin :) :: tabfin !! *tableau résultant, 2 fois plus fin* integer ( kind = I4 ) :: l_inf , l_sup , i , ii real ( kind = R8 ) :: tmp0 , dtmp real ( kind = R8 ), dimension ( - ordre / 2 : ordre ) :: tab_inf real ( kind = R8 ), dimension ( ub_gros - ordre : ub_gros + ordre / 2 ) :: tab_sup ! bornes pour déterminer les limites d'utilisation de la fonction interp l_inf = ordre / 2 l_sup = ub_gros - l_inf ! extension du tableau par prolongement de la dérivée tab_inf ( 0 : ordre ) = tabgros ( 0 : ordre ) tmp0 = tab_inf ( 0 ) dtmp = tab_inf ( 0 ) - tab_inf ( 1 ) do i = 1 , l_inf tab_inf ( - i ) = tmp0 + i * dtmp enddo do ii = 0 , l_inf i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tab_inf , & ! lb = - ordre / 2 , & ! ind = ii , & ! ordre = ordre ) ! enddo ! utilisation d'interp dans les limites normales do ii = l_inf + 1 , l_sup - 1 i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tabgros , & ! lb = lb_gros , & ! ind = ii , & ! ordre = ordre ) ! enddo ! extension du tableau par prolongement de la dérivée tab_sup ( ub_gros - ordre : ub_gros ) = tabgros ( ub_gros - ordre : ub_gros ) tmp0 = tab_sup ( ub_gros ) dtmp = tab_sup ( ub_gros ) - tab_sup ( ub_gros - 1 ) do i = 1 , l_inf tab_sup ( i + ub_gros ) = tmp0 + i * dtmp enddo do ii = l_sup , ub_gros - 1 i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tab_sup , & ! lb = ub_gros - ordre , & ! ind = ii , & ! ordre = ordre ) ! enddo tabfin ( 2 * ub_gros ) = tabgros ( ub_gros ) return endsubroutine interp1D","tags":"","loc":"proc/interp1d.html"},{"title":"interp2D – TOOLIB","text":"public  subroutine interp2D(tabgro, bgro, tabfin, bfin, ordre) Interpolate 2D evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(bgro%lb1:bgro%ub1, bgro%lb2:bgro%ub2) :: tabgro tableau grossier départ type( tborne ), intent(in) :: bgro indices des tableaux real(kind=R8), intent(out), dimension(bfin%lb1:bfin%ub1, bfin%lb2:bfin%ub2) :: tabfin tableau résultant fin type( tborne ), intent(in) :: bfin indices des tableaux integer(kind=I4), intent(in) :: ordre ordre de l’interpolation Calls proc~~interp2d~~CallsGraph proc~interp2d interp2D proc~interp1d interp1D proc~interp2d->proc~interp1d proc~interp interp proc~interp1d->proc~interp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interp2d~~CalledByGraph proc~interp2d interp2D proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~interp2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine interp2D ( tabgro , bgro , tabfin , bfin , ordre ) !! Interpolate 2D evenly spaced points, taking into account the borders implicit none type ( tborne ), intent ( in ) :: bfin , bgro !! *indices des tableaux* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( bgro % lb1 : bgro % ub1 , bgro % lb2 : bgro % ub2 ) :: tabgro !! *tableau grossier départ* real ( kind = R8 ), intent ( out ), dimension ( bfin % lb1 : bfin % ub1 , bfin % lb2 : bfin % ub2 ) :: tabfin !! *tableau résultant fin* integer ( kind = I4 ) :: ii , j real ( kind = R8 ), dimension ( bgro % lb1 : bgro % ub1 , bfin % lb2 : 2 * bgro % ub2 ) :: tab_tmp do ii = bgro % lb1 , bgro % ub1 call interp1D ( tabgros = tabgro ( ii ,:), & ! lb_gros = bgro % lb2 , & ! tabfin = tab_tmp ( ii ,:), & ! lb_fin = bfin % lb2 , & ! ub_gros = bgro % ub2 , & ! ordre = ordre ) ! enddo do j = bfin % lb2 , 2 * bgro % ub2 call interp1D ( tabgros = tab_tmp (:, j ), & ! lb_gros = bgro % lb1 , & ! tabfin = tabfin (:, j ), & ! lb_fin = bfin % lb1 , & ! ub_gros = bgro % ub1 , & ! ordre = ordre ) ! enddo return endsubroutine interp2D","tags":"","loc":"proc/interp2d.html"},{"title":"restrict1D – TOOLIB","text":"public  subroutine restrict1D(tabfin, lb_fin, tabgros, lb_gros, ub_gros, ordre) Restrict evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb_fin:) :: tabfin tableau de départ integer(kind=I4), intent(in) :: lb_fin indice inférieur de tab_fin real(kind=R8), intent(out), dimension(lb_gros:) :: tabgros tableau grossier résultant integer(kind=I4), intent(in) :: lb_gros indice inférieur integer(kind=I4), intent(in) :: ub_gros taille de tabgros integer(kind=I4), intent(in) :: ordre ordre de la restriction Calls proc~~restrict1d~~CallsGraph proc~restrict1d restrict1D proc~restrict restrict proc~restrict1d->proc~restrict Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~restrict1d~~CalledByGraph proc~restrict1d restrict1D proc~restrict2d restrict2D proc~restrict2d->proc~restrict1d proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~restrict1d proc~test_interp_pond->proc~restrict2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine restrict1D ( tabfin , lb_fin , tabgros , lb_gros , ub_gros , ordre ) !! Restrict evenly spaced points, taking into account the borders implicit none integer ( kind = I4 ), intent ( in ) :: lb_fin !! *indice inférieur de tab_fin* integer ( kind = I4 ), intent ( in ) :: lb_gros !! *indice inférieur* integer ( kind = I4 ), intent ( in ) :: ub_gros !! *taille de tabgros* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de la restriction* real ( kind = R8 ), intent ( in ), dimension ( lb_fin :) :: tabfin !! *tableau de départ* real ( kind = R8 ), intent ( out ), dimension ( lb_gros :) :: tabgros !! *tableau grossier résultant* integer ( kind = I4 ) :: l_inf , l_sup , i , ii real ( kind = R8 ) :: tmp0 , dtmp real ( kind = R8 ), dimension ( - ordre : 2 * ordre ) :: tab_inf real ( kind = R8 ), dimension ( 2 * ub_gros - 2 * ordre : 2 * ub_gros + ordre ) :: tab_sup ! bornes pour déterminer les limites d'utilisation de la fonction restrict l_inf = ordre / 2 l_sup = ub_gros - l_inf ! extension du tableau par prolongement de la dérivée tab_inf ( 0 : 2 * ordre ) = tabfin ( 0 : 2 * ordre ) tmp0 = tab_inf ( 0 ) dtmp = tab_inf ( 0 ) - tab_inf ( 1 ) do i = 1 , ordre tab_inf ( - i ) = tmp0 + i * dtmp enddo do ii = 0 , l_inf i = 2 * ii tabgros ( ii ) = restrict ( tab = tab_inf , & ! lb = - ordre , & ! ind = i , & ! ordre = ordre ) ! enddo ! utilisation d'interp dans les limites normales do ii = l_inf + 1 , l_sup - 1 i = 2 * ii tabgros ( ii ) = restrict ( tab = tabfin , & ! lb = lb_fin , & ! ind = i , & ! ordre = ordre ) ! enddo ! extension du tableau par prolongement de la dérivée tab_sup ( 2 * ub_gros - 2 * ordre : 2 * ub_gros ) = tabfin ( 2 * ub_gros - 2 * ordre : 2 * ub_gros ) tmp0 = tab_sup ( 2 * ub_gros ) dtmp = tab_sup ( 2 * ub_gros ) - tab_sup ( 2 * ub_gros - 1 ) do i = 1 , ordre tab_sup ( 2 * ub_gros + i ) = tmp0 + i * dtmp enddo do ii = l_sup , ub_gros i = 2 * ii tabgros ( ii ) = restrict ( tab = tab_sup , & ! lb = 2 * ub_gros - 2 * ordre , & ! ind = i , & ! ordre = ordre ) ! enddo return endsubroutine restrict1D","tags":"","loc":"proc/restrict1d.html"},{"title":"restrict2D – TOOLIB","text":"public  subroutine restrict2D(tabfin, bfin, tabgros, bgros, ordre) Interpolate 2D evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension( bfin%lb1: bfin%ub1,  bfin%lb2: bfin%ub2) :: tabfin tableau de départ fin type( tborne ), intent(in) :: bfin indices des tableaux real(kind=R8), intent(out), dimension(bgros%lb1:bgros%ub1, bgros%lb2:bgros%ub2) :: tabgros tableau grossier résultant type( tborne ), intent(in) :: bgros indices des tableaux integer(kind=I4), intent(in) :: ordre ordre de l’interpolation Calls proc~~restrict2d~~CallsGraph proc~restrict2d restrict2D proc~restrict1d restrict1D proc~restrict2d->proc~restrict1d proc~restrict restrict proc~restrict1d->proc~restrict Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~restrict2d~~CalledByGraph proc~restrict2d restrict2D proc~test_interp_pond test_interp_pond proc~test_interp_pond->proc~restrict2d program~test_intpl test_intpl program~test_intpl->proc~test_interp_pond Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine restrict2D ( tabfin , bfin , tabgros , bgros , ordre ) !! Interpolate 2D evenly spaced points, taking into account the borders implicit none type ( tborne ), intent ( in ) :: bfin , bgros !! *indices des tableaux* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( bfin % lb1 : bfin % ub1 , bfin % lb2 : bfin % ub2 ) :: tabfin !! *tableau de départ fin* real ( kind = R8 ), intent ( out ), dimension ( bgros % lb1 : bgros % ub1 , bgros % lb2 : bgros % ub2 ) :: tabgros !! *tableau grossier résultant* integer ( kind = I4 ) :: ii , j real ( kind = R8 ), dimension ( bgros % lb1 : bgros % ub1 , bfin % lb2 : 2 * bgros % ub2 ) :: tab_tmp do j = bfin % lb2 , 2 * bgros % ub2 call restrict1D ( tabfin = tabfin (:, j ), & ! lb_fin = bfin % lb1 , & ! tabgros = tab_tmp (:, j ), & ! lb_gros = bgros % lb1 , & ! ub_gros = bgros % ub1 , & ! ordre = ordre ) ! enddo do ii = bgros % lb1 , bgros % ub1 call restrict1D ( tabfin = tab_tmp ( ii ,:), & ! lb_fin = bfin % lb2 , & ! tabgros = tabgros ( ii ,:), & ! lb_gros = bgros % lb2 , & ! ub_gros = bgros % ub2 , & ! ordre = ordre ) ! enddo return endsubroutine restrict2D","tags":"","loc":"proc/restrict2d.html"},{"title":"abs_diff_sk_ku – TOOLIB","text":"function abs_diff_sk_ku(chrom) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: chrom Return Value real(kind=r8) Calls proc~~abs_diff_sk_ku~~CallsGraph proc~abs_diff_sk_ku abs_diff_sk_ku proc~sk_ku sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~abs_diff_sk_ku~~CalledByGraph proc~abs_diff_sk_ku abs_diff_sk_ku proc~cost cost proc~cost->proc~abs_diff_sk_ku proc~cost_func cost_func proc~cost_func->proc~abs_diff_sk_ku proc~newton_raphson_downhill newton_raphson_downhill proc~newton_raphson_downhill->proc~abs_diff_sk_ku program~test_algen test_algen program~test_algen->proc~abs_diff_sk_ku program~test_algen->proc~newton_raphson_downhill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/abs_diff_sk_ku.html"},{"title":"add_tang – TOOLIB","text":"function add_tang(n, deb, fin, alp, bet, mu, si) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n integer(kind=i4), intent(in) :: deb integer(kind=i4), intent(in) :: fin real(kind=R8), intent(in) :: alp real(kind=R8), intent(in) :: bet real(kind=R8), intent(in) :: mu real(kind=R8), intent(in) :: si Return Value real(kind=r8) Calls proc~~add_tang~~CallsGraph proc~add_tang add_tang proc~tang tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~add_tang~~CalledByGraph proc~add_tang add_tang proc~sk_ku sk_ku proc~sk_ku->proc~add_tang proc~abs_diff_sk_ku abs_diff_sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~cost cost proc~cost->proc~abs_diff_sk_ku proc~cost_func cost_func proc~cost_func->proc~abs_diff_sk_ku proc~newton_raphson_downhill newton_raphson_downhill proc~newton_raphson_downhill->proc~abs_diff_sk_ku program~test_algen test_algen program~test_algen->proc~abs_diff_sk_ku program~test_algen->proc~newton_raphson_downhill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/add_tang.html"},{"title":"cost_func – TOOLIB","text":"function cost_func(chrom) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: chrom Return Value real(kind=r8) Calls proc~~cost_func~~CallsGraph proc~cost_func cost_func proc~abs_diff_sk_ku abs_diff_sk_ku proc~cost_func->proc~abs_diff_sk_ku proc~sk_ku sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/cost_func.html"},{"title":"tang – TOOLIB","text":"function tang(xi, n, alp, bet, mu, si) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=i4), intent(in) :: n real(kind=R8), intent(in) :: alp real(kind=R8), intent(in) :: bet real(kind=R8), intent(in) :: mu real(kind=R8), intent(in) :: si Return Value real(kind=r8) Called by proc~~tang~~CalledByGraph proc~tang tang proc~add_tang add_tang proc~add_tang->proc~tang proc~sk_ku sk_ku proc~sk_ku->proc~tang proc~sk_ku->proc~add_tang proc~abs_diff_sk_ku abs_diff_sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~cost cost proc~cost->proc~abs_diff_sk_ku proc~cost_func cost_func proc~cost_func->proc~abs_diff_sk_ku proc~newton_raphson_downhill newton_raphson_downhill proc~newton_raphson_downhill->proc~abs_diff_sk_ku program~test_algen test_algen program~test_algen->proc~abs_diff_sk_ku program~test_algen->proc~newton_raphson_downhill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/tang.html"},{"title":"calc_moments_1D – TOOLIB","text":"subroutine calc_moments_1D(tab, mx, nb_mom, lg) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:lg) :: tab type( moment_stat ), intent(out) :: mx integer(kind=I4), intent(in) :: nb_mom integer(kind=I4), intent(in) :: lg Called by proc~~calc_moments_1d~~CalledByGraph proc~calc_moments_1d calc_moments_1D proc~profil_theo_trie_1d profil_theo_trie_1D proc~profil_theo_trie_1d->proc~calc_moments_1d program~test_algen test_algen program~test_algen->proc~profil_theo_trie_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine calc_moments_1D ( tab , mx , nb_mom , lg ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg integer ( kind = I4 ) , intent ( in ) :: nb_mom real ( kind = R8 ) , intent ( in ), dimension ( 1 : lg ) :: tab type ( moment_stat ), intent ( out ) :: mx integer ( kind = I4 ) :: i real ( kind = R8 ) :: tmp mx % mu = 0 mx % si = 0 mx % va = 0 mx % Sk = 0 mx % Ku = 0 do i = 1 , lg mx % mu = mx % mu + tab ( i ) / lg enddo if ( nb_mom == 1 ) return do i = 1 , lg mx % va = mx % va + (( tab ( i ) - mx % mu ) ** 2 ) / lg enddo mx % si = sqrt ( mx % va ) if ( nb_mom == 2 ) return if ( mx % si < 1.e-15_R8 ) then mx % Sk = 0 mx % Ku = 0 else do i = 1 , lg tmp = ( tab ( i ) - mx % mu ) / mx % si mx % Sk = mx % Sk + ( tmp ** 3 ) / lg mx % Ku = mx % Ku + ( tmp ** 4 ) / lg enddo endif return endsubroutine calc_moments_1D","tags":"","loc":"proc/calc_moments_1d.html"},{"title":"cost – TOOLIB","text":"subroutine cost(me, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f Calls proc~~cost~~CallsGraph proc~cost cost proc~abs_diff_sk_ku abs_diff_sk_ku proc~cost->proc~abs_diff_sk_ku proc~sk_ku sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cost ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = 1. / ( 1. + abs_diff_sk_ku ( chrom = x ( 1 : 2 ))) return endsubroutine cost","tags":"","loc":"proc/cost.html"},{"title":"melange – TOOLIB","text":"subroutine melange(tab, lg) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(1:lg) :: tab integer(kind=i4), intent(in) :: lg Calls proc~~melange~~CallsGraph proc~melange melange proc~sort_array2 sort_array2 proc~melange->proc~sort_array2 proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~melange~~CalledByGraph proc~melange melange program~test_algen test_algen program~test_algen->proc~melange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine melange ( tab , lg ) implicit none integer ( kind = i4 ), intent ( in ) :: lg real ( kind = r8 ) , intent ( inout ), dimension ( 1 : lg ) :: tab real ( kind = r8 ), dimension ( 1 : lg ) :: tmp integer ( kind = i4 ) :: i call random_number ( harvest = tmp ) call sort_array2 ( tab_inout = tmp ( 1 : lg ), & ! tab1 = tab ( 1 : lg ), n = lg ) ! return endsubroutine melange","tags":"","loc":"proc/melange.html"},{"title":"newton_raphson_downhill – TOOLIB","text":"subroutine newton_raphson_downhill(x, fvec, eps, ndir, rel) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:2) :: x real(kind=R8), intent(out) :: fvec real(kind=R8), intent(in) :: eps integer(kind=I4), intent(in) :: ndir real(kind=R8), intent(in) :: rel Calls proc~~newton_raphson_downhill~~CallsGraph proc~newton_raphson_downhill newton_raphson_downhill proc~abs_diff_sk_ku abs_diff_sk_ku proc~newton_raphson_downhill->proc~abs_diff_sk_ku proc~sk_ku sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~newton_raphson_downhill~~CalledByGraph proc~newton_raphson_downhill newton_raphson_downhill program~test_algen test_algen program~test_algen->proc~newton_raphson_downhill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine newton_raphson_downhill ( x , fvec , eps , ndir , rel ) implicit none integer ( kind = I4 ), intent ( in ) :: ndir real ( kind = R8 ), intent ( in ) :: eps real ( kind = R8 ), intent ( in ) :: rel real ( kind = R8 ), intent ( inout ), dimension ( 1 : 2 ) :: x real ( kind = R8 ), intent ( out ) :: fvec real ( kind = R8 ), dimension ( 1 : 2 ) :: x0 real ( kind = R8 ), dimension ( 1 : ndir ) :: ct , st , ff , x1 , x2 real ( kind = R8 ) :: f0 , fd1 , fd2 , ti , dfdx1 , dfdx2 , dx1 , dx2 , dt integer ( kind = I4 ) :: i do i = 1 , ndir ti = PI_R8 * ( - 1. + ( i - 1 ) * 2. / ndir ) ct ( i ) = cos ( ti ) st ( i ) = sin ( ti ) enddo x0 = x do f0 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) / )) fd1 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) + eps , x0 ( 2 ) / )) fd2 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) + eps / )) dfdx1 = ( fd1 - f0 ) / eps dfdx2 = ( fd2 - f0 ) / eps !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) !$OMP DO PRIVATE(i, dt, dx1, dx2) do i = 1 , ndir dt = - f0 / ( eps * ( dfdx1 * ct ( i ) + dfdx2 * st ( i )) ) dx1 = eps * ct ( i ) * dt dx2 = eps * st ( i ) * dt x1 ( i ) = x0 ( 1 ) + rel * dx1 x2 ( i ) = x0 ( 2 ) + rel * dx2 ff ( i ) = abs_diff_sk_ku ( chrom = ( / x1 ( i ), x2 ( i ) / )) enddo !$OMP END DO !$OMP END PARALLEL i = minloc ( ff , 1 ) x0 = ( / x1 ( i ), x2 ( i ) / ) if ( ff ( i ) < 1.e-8 ) exit write ( * , * ) x0 ( 1 ), x0 ( 2 ), ff ( i ) enddo x = x0 fvec = ff ( i ) return endsubroutine newton_raphson_downhill","tags":"","loc":"proc/newton_raphson_downhill.html"},{"title":"profil_theo_trie_1D – TOOLIB","text":"subroutine profil_theo_trie_1D(tab, lg, x, mx) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab integer(kind=I4), intent(in) :: lg real(kind=R8), intent(in), dimension(1:2) :: x type( moment_stat ), intent(out) :: mx Calls proc~~profil_theo_trie_1d~~CallsGraph proc~profil_theo_trie_1d profil_theo_trie_1D proc~calc_moments_1d calc_moments_1D proc~profil_theo_trie_1d->proc~calc_moments_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~profil_theo_trie_1d~~CalledByGraph proc~profil_theo_trie_1d profil_theo_trie_1D program~test_algen test_algen program~test_algen->proc~profil_theo_trie_1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine profil_theo_trie_1D ( tab , lg , x , mx ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg real ( kind = R8 ) , intent ( out ), dimension ( 1 : lg ) :: tab real ( kind = R8 ) , intent ( in ), dimension ( 1 : 2 ) :: x type ( moment_stat ), intent ( out ) :: mx real ( kind = R8 ) :: b1 , b2 , alp , bet integer ( kind = I4 ) :: i b1 = - PI_R8 / 2 * ( 1. - x ( 1 )) b2 = + PI_R8 / 2 * ( 1. - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i + alp ) / bet ) enddo call calc_moments_1D ( tab , mx , nb_mom = 4 , lg = lg ) tab ( 1 : lg ) = ( tab ( 1 : lg ) - mx % mu ) / mx % si mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D","tags":"","loc":"proc/profil_theo_trie_1d.html"},{"title":"sk_ku – TOOLIB","text":"subroutine sk_ku(xx, sk, ku) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: xx real(kind=R8), intent(out) :: sk real(kind=R8), intent(out) :: ku Calls proc~~sk_ku~~CallsGraph proc~sk_ku sk_ku proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~add_tang->proc~tang Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sk_ku~~CalledByGraph proc~sk_ku sk_ku proc~abs_diff_sk_ku abs_diff_sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~cost cost proc~cost->proc~abs_diff_sk_ku proc~cost_func cost_func proc~cost_func->proc~abs_diff_sk_ku proc~newton_raphson_downhill newton_raphson_downhill proc~newton_raphson_downhill->proc~abs_diff_sk_ku program~test_algen test_algen program~test_algen->proc~abs_diff_sk_ku program~test_algen->proc~newton_raphson_downhill Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sk_ku ( xx , sk , ku ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: xx real ( kind = R8 ), intent ( out ) :: sk real ( kind = R8 ), intent ( out ) :: ku real ( kind = R8 ) :: xa , xb , mu , si , a , b , un real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: ia , ib , deb , fin , npts , long , i , k real ( kind = R8 ), dimension ( 1 : 2 ) :: x long = nn do k = 1 , 2 x ( k ) = max ( xx ( k ), 1.e-4_R8 ) enddo ia = long ib = long npts = long * long deb = 1 + ia fin = npts - ib a = x ( 1 ) b = x ( 2 ) hh = ( 2._R8 - a - b ) / ( npts - 1 ) h = ( pi_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - pi_R8 / 2 * ( 1. - a ) b2 = + pi_R8 / 2 * ( 1. - b ) alp = - ( b2 - npts * b1 ) / ( b2 - b1 ) bet = ( npts - 1 ) / ( b2 - b1 ) un = 1._R8 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * sin (( pi_R8 * xa ) / 2. )) mu = ( un / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = ( pi_R8 * ( - 2 + xa + xb )) / 2. - ( mu ** 2 * pi_R8 * ( - 2 + xa + xb )) / 2. + 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 2 * mu * Log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * Sin (( pi_R8 * xa ) / 2. )) si = ( un / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / npts si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = ( 6 * mu * pi_R8 - 2 * mu ** 3 * pi_R8 - 3 * mu * pi_R8 * xa + mu ** 3 * pi_R8 * xa - 3 * mu * pi_R8 * xb + mu ** 3 * pi_R8 * xb - 6 * mu * 1._R8 / tan (( pi_R8 * xa ) / 2. ) - 6 * mu * 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 - 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 6 * mu ** 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 2 * Log ( Sin (( pi_R8 * xb ) / 2. )) - 6 * mu ** 2 * Log ( Sin (( pi_R8 * xb ) / 2. ))) / ( 2. * si ** 3 ) sk = ( un / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo sk = sk / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = ( 6 * pi_R8 - 36 * mu ** 2 * pi_R8 + 6 * mu ** 4 * pi_R8 - 3 * pi_R8 * xa + 18 * mu ** 2 * pi_R8 * xa - 3 * mu ** 4 * pi_R8 * xa - 3 * pi_R8 * xb + 18 * mu ** 2 * pi_R8 * xb - 3 * mu ** 4 * pi_R8 * xb + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xb ) / 2. ) + 12 * mu * 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 - 12 * mu * 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 + 24 * mu * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu ** 3 * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu * Log ( Sin (( pi_R8 * xb ) / 2. )) + 24 * mu ** 3 * Log ( Sin (( pi_R8 * xb ) / 2. )) + 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 4 * Sin ( pi_R8 * xa ) + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 4 * Sin ( pi_R8 * xb )) / ( 6. * si ** 4 ) ku = ( un / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo ku = ku / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . return endsubroutine sk_ku","tags":"","loc":"proc/sk_ku.html"},{"title":"make_CSC_ci – TOOLIB","text":"public  function make_CSC_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) Called by proc~~make_csc_ci~~CalledByGraph proc~make_csc_ci make_CSC_ci interface~pcsc pCSC interface~pcsc->proc~make_csc_ci Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csc_ci.html"},{"title":"make_CSC_di – TOOLIB","text":"public  function make_CSC_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) Called by proc~~make_csc_di~~CalledByGraph proc~make_csc_di make_CSC_di interface~pcsc pCSC interface~pcsc->proc~make_csc_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csc_di.html"},{"title":"make_CSC_zi – TOOLIB","text":"public  function make_CSC_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) Called by proc~~make_csc_zi~~CalledByGraph proc~make_csc_zi make_CSC_zi interface~pcsc pCSC interface~pcsc->proc~make_csc_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csc_zi.html"},{"title":"make_CSR_ci – TOOLIB","text":"public  function make_CSR_ci(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) Called by proc~~make_csr_ci~~CalledByGraph proc~make_csr_ci make_CSR_ci interface~pcsr pCSR interface~pcsr->proc~make_csr_ci Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csr_ci.html"},{"title":"make_CSR_di – TOOLIB","text":"public  function make_CSR_di(Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) Called by proc~~make_csr_di~~CalledByGraph proc~make_csr_di make_CSR_di interface~pcsr pCSR interface~pcsr->proc~make_csr_di Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csr_di.html"},{"title":"make_CSR_zi – TOOLIB","text":"public  function make_CSR_zi(Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) Called by proc~~make_csr_zi~~CalledByGraph proc~make_csr_zi make_CSR_zi interface~pcsr pCSR interface~pcsr->proc~make_csr_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_csr_zi.html"},{"title":"make_Vec_zi – TOOLIB","text":"public  function make_Vec_zi(bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) Called by proc~~make_vec_zi~~CalledByGraph proc~make_vec_zi make_Vec_zi interface~pvec pVec interface~pvec->proc~make_vec_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/make_vec_zi.html"},{"title":"umfpack_ci_numeric – TOOLIB","text":"public  function umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_numeric~~CallsGraph proc~umfpack_ci_numeric umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_numeric~~CalledByGraph proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_numeric.html"},{"title":"umfpack_ci_operator_CSC – TOOLIB","text":"public  function umfpack_ci_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csc~~CallsGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_operator_csc~~CalledByGraph proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_operator_csc.html"},{"title":"umfpack_ci_operator_CSR – TOOLIB","text":"public  function umfpack_ci_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_csr~~CallsGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_operator_csr~~CalledByGraph proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_operator_csr.html"},{"title":"umfpack_ci_operator_pCSC – TOOLIB","text":"public  function umfpack_ci_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsc~~CallsGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_operator_pcsc~~CalledByGraph proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_operator_pcsc.html"},{"title":"umfpack_ci_operator_pCSR – TOOLIB","text":"public  function umfpack_ci_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_ci_operator_pcsr~~CallsGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_operator_pcsr~~CalledByGraph proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_operator_pcsr.html"},{"title":"umfpack_ci_scale – TOOLIB","text":"public  function umfpack_ci_scale(Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_ci_scale~~CallsGraph proc~umfpack_ci_scale umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_scale~~CalledByGraph proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~s_umfpack_zi_scale s_umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_scale.html"},{"title":"umfpack_ci_solve – TOOLIB","text":"public  function umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_solve~~CallsGraph proc~umfpack_ci_solve umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_solve~~CalledByGraph proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_zi_solve s_umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4zsol->proc~umf4zsol_ip proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_solve.html"},{"title":"umfpack_ci_symbolic – TOOLIB","text":"public  function umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_ci_symbolic~~CallsGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_ci_symbolic~~CalledByGraph proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_ci_symbolic.html"},{"title":"umfpack_di_load_numeric – TOOLIB","text":"public  function umfpack_di_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_numeric~~CallsGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_load_numeric~~CalledByGraph proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_load_numeric.html"},{"title":"umfpack_di_load_symbolic – TOOLIB","text":"public  function umfpack_di_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_load_symbolic~~CallsGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_load_symbolic~~CalledByGraph proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_load_symbolic.html"},{"title":"umfpack_di_numeric – TOOLIB","text":"public  function umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_numeric~~CallsGraph proc~umfpack_di_numeric umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_numeric~~CalledByGraph proc~umfpack_di_numeric umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_numeric.html"},{"title":"umfpack_di_operator_CSC – TOOLIB","text":"public  function umfpack_di_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csc~~CallsGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_operator_csc~~CalledByGraph proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_operator_csc.html"},{"title":"umfpack_di_operator_CSR – TOOLIB","text":"public  function umfpack_di_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_di_operator_csr~~CallsGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_operator_csr~~CalledByGraph proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_operator_csr.html"},{"title":"umfpack_di_operator_pCSC – TOOLIB","text":"public  function umfpack_di_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsc~~CallsGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_operator_pcsc~~CalledByGraph proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_operator_pcsc.html"},{"title":"umfpack_di_operator_pCSR – TOOLIB","text":"public  function umfpack_di_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) Calls proc~~umfpack_di_operator_pcsr~~CallsGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_operator_pcsr~~CalledByGraph proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_operator_pcsr.html"},{"title":"umfpack_di_save_numeric – TOOLIB","text":"public  function umfpack_di_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_numeric~~CallsGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_save_numeric~~CalledByGraph proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_save_numeric.html"},{"title":"umfpack_di_save_symbolic – TOOLIB","text":"public  function umfpack_di_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_di_save_symbolic~~CallsGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_save_symbolic~~CalledByGraph proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_save_symbolic.html"},{"title":"umfpack_di_scale – TOOLIB","text":"public  function umfpack_di_scale(X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_di_scale~~CallsGraph proc~umfpack_di_scale umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_scale~~CalledByGraph proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_scale.html"},{"title":"umfpack_di_solve – TOOLIB","text":"public  function umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_solve~~CallsGraph proc~umfpack_di_solve umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_solve~~CalledByGraph proc~umfpack_di_solve umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst->proc~solution_solver proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_solve.html"},{"title":"umfpack_di_symbolic – TOOLIB","text":"public  function umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_di_symbolic~~CallsGraph proc~umfpack_di_symbolic umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_symbolic~~CalledByGraph proc~umfpack_di_symbolic umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_symbolic.html"},{"title":"umfpack_load_numeric – TOOLIB","text":"public  function umfpack_load_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_numeric~~CallsGraph proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_load_numeric~~CalledByGraph proc~umfpack_load_numeric umfpack_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_load_numeric.html"},{"title":"umfpack_load_symbolic – TOOLIB","text":"public  function umfpack_load_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_load_symbolic~~CallsGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_load_symbolic~~CalledByGraph proc~umfpack_load_symbolic umfpack_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_load_symbolic.html"},{"title":"umfpack_save_numeric – TOOLIB","text":"public  function umfpack_save_numeric(Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_numeric~~CallsGraph proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_save_numeric~~CalledByGraph proc~umfpack_save_numeric umfpack_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_save_numeric.html"},{"title":"umfpack_save_symbolic – TOOLIB","text":"public  function umfpack_save_symbolic(Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer Calls proc~~umfpack_save_symbolic~~CallsGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_save_symbolic~~CalledByGraph proc~umfpack_save_symbolic umfpack_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_save_symbolic.html"},{"title":"umfpack_zi_load_numeric – TOOLIB","text":"public  function umfpack_zi_load_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_numeric~~CallsGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_load_numeric~~CalledByGraph proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_load_numeric.html"},{"title":"umfpack_zi_load_symbolic – TOOLIB","text":"public  function umfpack_zi_load_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_load_symbolic~~CallsGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_load_symbolic~~CalledByGraph proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_load_symbolic.html"},{"title":"umfpack_zi_numeric – TOOLIB","text":"public  function umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_numeric~~CallsGraph proc~umfpack_zi_numeric umfpack_zi_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_numeric.html"},{"title":"umfpack_zi_operator_CSC – TOOLIB","text":"public  function umfpack_zi_operator_CSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csc~~CallsGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_operator_csc~~CalledByGraph proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_operator_csc.html"},{"title":"umfpack_zi_operator_CSR – TOOLIB","text":"public  function umfpack_zi_operator_CSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_csr~~CallsGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_operator_csr~~CalledByGraph proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_operator_csr.html"},{"title":"umfpack_zi_operator_pCSC – TOOLIB","text":"public  function umfpack_zi_operator_pCSC(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsc~~CallsGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_operator_pcsc~~CalledByGraph proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_operator_pcsc.html"},{"title":"umfpack_zi_operator_pCSR – TOOLIB","text":"public  function umfpack_zi_operator_pCSR(A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) Calls proc~~umfpack_zi_operator_pcsr~~CallsGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_operator_pcsr~~CalledByGraph proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_operator_pcsr.html"},{"title":"umfpack_zi_save_numeric – TOOLIB","text":"public  function umfpack_zi_save_numeric(Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_numeric~~CallsGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_save_numeric~~CalledByGraph proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_save_numeric.html"},{"title":"umfpack_zi_save_symbolic – TOOLIB","text":"public  function umfpack_zi_save_symbolic(Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer Calls proc~~umfpack_zi_save_symbolic~~CallsGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_save_symbolic~~CalledByGraph proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_save_symbolic.html"},{"title":"umfpack_zi_scale – TOOLIB","text":"public  function umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer Calls proc~~umfpack_zi_scale~~CallsGraph proc~umfpack_zi_scale umfpack_zi_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_scale.html"},{"title":"umfpack_zi_solve – TOOLIB","text":"public  function umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), intent(in), optional, target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_solve~~CallsGraph proc~umfpack_zi_solve umfpack_zi_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_solve.html"},{"title":"umfpack_zi_symbolic – TOOLIB","text":"public  function umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Calls proc~~umfpack_zi_symbolic~~CallsGraph proc~umfpack_zi_symbolic umfpack_zi_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_symbolic.html"},{"title":"s_umfpack_ci_numeric – TOOLIB","text":"public  subroutine s_umfpack_ci_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_numeric~~CallsGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_ci_numeric~~CalledByGraph proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_ci_numeric.html"},{"title":"s_umfpack_ci_scale – TOOLIB","text":"public  subroutine s_umfpack_ci_scale(Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_ci_scale~~CallsGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_ci_scale~~CalledByGraph proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_ci_scale.html"},{"title":"s_umfpack_ci_solve – TOOLIB","text":"public  subroutine s_umfpack_ci_solve(sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_solve~~CallsGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_ci_solve~~CalledByGraph proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4zsol->proc~umf4zsol_ip proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_ci_solve.html"},{"title":"s_umfpack_ci_symbolic – TOOLIB","text":"public  subroutine s_umfpack_ci_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_ci_symbolic~~CallsGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_ci_symbolic~~CalledByGraph proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_ci_symbolic.html"},{"title":"s_umfpack_di_load_numeric – TOOLIB","text":"public  subroutine s_umfpack_di_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_numeric~~CallsGraph proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_load_numeric.html"},{"title":"s_umfpack_di_load_symbolic – TOOLIB","text":"public  subroutine s_umfpack_di_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_load_symbolic~~CallsGraph proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_load_symbolic.html"},{"title":"s_umfpack_di_numeric – TOOLIB","text":"public  subroutine s_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_numeric~~CallsGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_di_numeric~~CalledByGraph proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_numeric.html"},{"title":"s_umfpack_di_save_numeric – TOOLIB","text":"public  subroutine s_umfpack_di_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_numeric~~CallsGraph proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_save_numeric.html"},{"title":"s_umfpack_di_save_symbolic – TOOLIB","text":"public  subroutine s_umfpack_di_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_di_save_symbolic~~CallsGraph proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_save_symbolic.html"},{"title":"s_umfpack_di_scale – TOOLIB","text":"public  subroutine s_umfpack_di_scale(X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_di_scale~~CallsGraph proc~s_umfpack_di_scale s_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_di_scale~~CalledByGraph proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_scale.html"},{"title":"s_umfpack_di_solve – TOOLIB","text":"public  subroutine s_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_solve~~CallsGraph proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_di_solve~~CalledByGraph proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst->proc~solution_solver proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_solve.html"},{"title":"s_umfpack_di_symbolic – TOOLIB","text":"public  subroutine s_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_di_symbolic~~CallsGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~s_umfpack_di_symbolic~~CalledByGraph proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_di_symbolic.html"},{"title":"s_umfpack_load_numeric – TOOLIB","text":"public  subroutine s_umfpack_load_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_numeric~~CallsGraph proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_load_numeric.html"},{"title":"s_umfpack_load_symbolic – TOOLIB","text":"public  subroutine s_umfpack_load_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_load_symbolic~~CallsGraph proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_load_symbolic.html"},{"title":"s_umfpack_save_numeric – TOOLIB","text":"public  subroutine s_umfpack_save_numeric(Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_numeric~~CallsGraph proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_save_numeric.html"},{"title":"s_umfpack_save_symbolic – TOOLIB","text":"public  subroutine s_umfpack_save_symbolic(Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version Calls proc~~s_umfpack_save_symbolic~~CallsGraph proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_save_symbolic.html"},{"title":"s_umfpack_zi_load_numeric – TOOLIB","text":"public  subroutine s_umfpack_zi_load_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_numeric~~CallsGraph proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_load_numeric.html"},{"title":"s_umfpack_zi_load_symbolic – TOOLIB","text":"public  subroutine s_umfpack_zi_load_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_load_symbolic~~CallsGraph proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_load_symbolic.html"},{"title":"s_umfpack_zi_numeric – TOOLIB","text":"public  subroutine s_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_numeric~~CallsGraph proc~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~umfpack_zi_numeric umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_numeric.html"},{"title":"s_umfpack_zi_save_numeric – TOOLIB","text":"public  subroutine s_umfpack_zi_save_numeric(Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_numeric~~CallsGraph proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_save_numeric.html"},{"title":"s_umfpack_zi_save_symbolic – TOOLIB","text":"public  subroutine s_umfpack_zi_save_symbolic(Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status Calls proc~~s_umfpack_zi_save_symbolic~~CallsGraph proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_save_symbolic.html"},{"title":"s_umfpack_zi_scale – TOOLIB","text":"public  subroutine s_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status Calls proc~~s_umfpack_zi_scale~~CallsGraph proc~s_umfpack_zi_scale s_umfpack_zi_scale interface~umfpack_zi_scale umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_scale.html"},{"title":"s_umfpack_zi_solve – TOOLIB","text":"public  subroutine s_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_solve~~CallsGraph proc~s_umfpack_zi_solve s_umfpack_zi_solve interface~umfpack_zi_solve umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_solve.html"},{"title":"s_umfpack_zi_symbolic – TOOLIB","text":"public  subroutine s_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status Calls proc~~s_umfpack_zi_symbolic~~CallsGraph proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/s_umfpack_zi_symbolic.html"},{"title":"umf4cdef – TOOLIB","text":"public  subroutine umf4cdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cdef~~CallsGraph proc~umf4cdef umf4cdef proc~umfpack_defaults umfpack_defaults proc~umf4cdef->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cdef.html"},{"title":"umf4cfnum – TOOLIB","text":"public  subroutine umf4cfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4cfnum~~CallsGraph proc~umf4cfnum umf4cfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cfnum.html"},{"title":"umf4cfnum_ip – TOOLIB","text":"public  subroutine umf4cfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4cfnum_ip~~CallsGraph proc~umf4cfnum_ip umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4cfnum_ip~~CalledByGraph proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cfnum_ip.html"},{"title":"umf4cfsym – TOOLIB","text":"public  subroutine umf4cfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4cfsym~~CallsGraph proc~umf4cfsym umf4cfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cfsym.html"},{"title":"umf4cfsym_ip – TOOLIB","text":"public  subroutine umf4cfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4cfsym_ip~~CallsGraph proc~umf4cfsym_ip umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4cfsym_ip~~CalledByGraph proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cfsym_ip.html"},{"title":"umf4clnum – TOOLIB","text":"public  subroutine umf4clnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum~~CallsGraph proc~umf4clnum umf4clnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4clnum.html"},{"title":"umf4clnum_ip – TOOLIB","text":"public  subroutine umf4clnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clnum_ip~~CallsGraph proc~umf4clnum_ip umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4clnum_ip~~CalledByGraph proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4clnum_ip.html"},{"title":"umf4clsym – TOOLIB","text":"public  subroutine umf4clsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym~~CallsGraph proc~umf4clsym umf4clsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4clsym.html"},{"title":"umf4clsym_ip – TOOLIB","text":"public  subroutine umf4clsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4clsym_ip~~CallsGraph proc~umf4clsym_ip umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4clsym_ip~~CalledByGraph proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4clsym_ip.html"},{"title":"umf4cnum – TOOLIB","text":"public  subroutine umf4cnum(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum~~CallsGraph proc~umf4cnum umf4cnum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cnum.html"},{"title":"umf4cnum_ip – TOOLIB","text":"public  subroutine umf4cnum_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cnum_ip~~CallsGraph proc~umf4cnum_ip umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4cnum_ip~~CalledByGraph proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cnum_ip.html"},{"title":"umf4cpcon – TOOLIB","text":"public  subroutine umf4cpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4cpcon~~CallsGraph proc~umf4cpcon umf4cpcon proc~umfpack_report_control umfpack_report_control proc~umf4cpcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cpcon.html"},{"title":"umf4cpinf – TOOLIB","text":"public  subroutine umf4cpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4cpinf~~CallsGraph proc~umf4cpinf umf4cpinf proc~umfpack_report_info umfpack_report_info proc~umf4cpinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cpinf.html"},{"title":"umf4cscal – TOOLIB","text":"public  subroutine umf4cscal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal~~CallsGraph proc~umf4cscal umf4cscal interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cscal.html"},{"title":"umf4cscal_ip – TOOLIB","text":"public  subroutine umf4cscal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4cscal_ip~~CallsGraph proc~umf4cscal_ip umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4cscal_ip~~CalledByGraph proc~umf4cscal_ip umf4cscal_ip interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cscal_ip.html"},{"title":"umf4csnum – TOOLIB","text":"public  subroutine umf4csnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum~~CallsGraph proc~umf4csnum umf4csnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csnum.html"},{"title":"umf4csnum_ip – TOOLIB","text":"public  subroutine umf4csnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4csnum_ip~~CallsGraph proc~umf4csnum_ip umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4csnum_ip~~CalledByGraph proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csnum_ip.html"},{"title":"umf4csol – TOOLIB","text":"public  subroutine umf4csol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol~~CallsGraph proc~umf4csol umf4csol interface~s_umfpack_solve s_umfpack_solve proc~umf4csol->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csol.html"},{"title":"umf4csol_ip – TOOLIB","text":"public  subroutine umf4csol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csol_ip~~CallsGraph proc~umf4csol_ip umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4csol_ip~~CalledByGraph proc~umf4csol_ip umf4csol_ip interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csol_ip.html"},{"title":"umf4csolr – TOOLIB","text":"public  subroutine umf4csolr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr~~CallsGraph proc~umf4csolr umf4csolr interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csolr.html"},{"title":"umf4csolr_ip – TOOLIB","text":"public  subroutine umf4csolr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csolr_ip~~CallsGraph proc~umf4csolr_ip umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4csolr_ip~~CalledByGraph proc~umf4csolr_ip umf4csolr_ip interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csolr_ip.html"},{"title":"umf4cssym – TOOLIB","text":"public  subroutine umf4cssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym~~CallsGraph proc~umf4cssym umf4cssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cssym.html"},{"title":"umf4cssym_ip – TOOLIB","text":"public  subroutine umf4cssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4cssym_ip~~CallsGraph proc~umf4cssym_ip umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4cssym_ip~~CalledByGraph proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4cssym_ip.html"},{"title":"umf4csym – TOOLIB","text":"public  subroutine umf4csym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym~~CallsGraph proc~umf4csym umf4csym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csym.html"},{"title":"umf4csym_ip – TOOLIB","text":"public  subroutine umf4csym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4csym_ip~~CallsGraph proc~umf4csym_ip umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4csym_ip~~CalledByGraph proc~umf4csym_ip umf4csym_ip interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4csym_ip.html"},{"title":"umf4def – TOOLIB","text":"public  subroutine umf4def(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4def~~CallsGraph proc~umf4def umf4def proc~umfpack_defaults umfpack_defaults proc~umf4def->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4def.html"},{"title":"umf4fnum – TOOLIB","text":"public  subroutine umf4fnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4fnum~~CallsGraph proc~umf4fnum umf4fnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4fnum.html"},{"title":"umf4fnum_ip – TOOLIB","text":"public  subroutine umf4fnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4fnum_ip~~CallsGraph proc~umf4fnum_ip umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4fnum_ip~~CalledByGraph proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4fnum_ip.html"},{"title":"umf4fsym – TOOLIB","text":"public  subroutine umf4fsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4fsym~~CallsGraph proc~umf4fsym umf4fsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4fsym.html"},{"title":"umf4fsym_ip – TOOLIB","text":"public  subroutine umf4fsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4fsym_ip~~CallsGraph proc~umf4fsym_ip umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4fsym_ip~~CalledByGraph proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4fsym_ip.html"},{"title":"umf4lnum – TOOLIB","text":"public  subroutine umf4lnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum~~CallsGraph proc~umf4lnum umf4lnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4lnum.html"},{"title":"umf4lnum_ip – TOOLIB","text":"public  subroutine umf4lnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lnum_ip~~CallsGraph proc~umf4lnum_ip umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4lnum_ip~~CalledByGraph proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4lnum_ip.html"},{"title":"umf4lsym – TOOLIB","text":"public  subroutine umf4lsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym~~CallsGraph proc~umf4lsym umf4lsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4lsym.html"},{"title":"umf4lsym_ip – TOOLIB","text":"public  subroutine umf4lsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4lsym_ip~~CallsGraph proc~umf4lsym_ip umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4lsym_ip~~CalledByGraph proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4lsym_ip.html"},{"title":"umf4num – TOOLIB","text":"public  subroutine umf4num(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num~~CallsGraph proc~umf4num umf4num interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4num.html"},{"title":"umf4num_ip – TOOLIB","text":"public  subroutine umf4num_ip(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4num_ip~~CallsGraph proc~umf4num_ip umf4num_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4num_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4num_ip~~CalledByGraph proc~umf4num_ip umf4num_ip interface~umf4num umf4num interface~umf4num->proc~umf4num_ip interface~umf4num->interface~umf4num Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4num_ip.html"},{"title":"umf4pcon – TOOLIB","text":"public  subroutine umf4pcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4pcon~~CallsGraph proc~umf4pcon umf4pcon proc~umfpack_report_control umfpack_report_control proc~umf4pcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4pcon.html"},{"title":"umf4pinf – TOOLIB","text":"public  subroutine umf4pinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4pinf~~CallsGraph proc~umf4pinf umf4pinf proc~umfpack_report_info umfpack_report_info proc~umf4pinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4pinf.html"},{"title":"umf4scal – TOOLIB","text":"public  subroutine umf4scal(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal~~CallsGraph proc~umf4scal umf4scal interface~umfpack_scale_function umfpack_scale_function proc~umf4scal->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4scal.html"},{"title":"umf4scal_ip – TOOLIB","text":"public  subroutine umf4scal_ip(x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4scal_ip~~CallsGraph proc~umf4scal_ip umf4scal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4scal_ip~~CalledByGraph proc~umf4scal_ip umf4scal_ip interface~umf4scal umf4scal interface~umf4scal->proc~umf4scal_ip interface~umf4scal->interface~umf4scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4scal_ip.html"},{"title":"umf4snum – TOOLIB","text":"public  subroutine umf4snum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum~~CallsGraph proc~umf4snum umf4snum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4snum.html"},{"title":"umf4snum_ip – TOOLIB","text":"public  subroutine umf4snum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4snum_ip~~CallsGraph proc~umf4snum_ip umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4snum_ip~~CalledByGraph proc~umf4snum_ip umf4snum_ip interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4snum_ip.html"},{"title":"umf4sol – TOOLIB","text":"public  subroutine umf4sol(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol~~CallsGraph proc~umf4sol umf4sol interface~s_umfpack_solve s_umfpack_solve proc~umf4sol->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4sol.html"},{"title":"umf4sol_ip – TOOLIB","text":"public  subroutine umf4sol_ip(sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sol_ip~~CallsGraph proc~umf4sol_ip umf4sol_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4sol_ip~~CalledByGraph proc~umf4sol_ip umf4sol_ip interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4sol_ip.html"},{"title":"umf4solr – TOOLIB","text":"public  subroutine umf4solr(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr~~CallsGraph proc~umf4solr umf4solr interface~s_umfpack_solve s_umfpack_solve proc~umf4solr->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4solr.html"},{"title":"umf4solr_ip – TOOLIB","text":"public  subroutine umf4solr_ip(sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4solr_ip~~CallsGraph proc~umf4solr_ip umf4solr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4solr_ip~~CalledByGraph proc~umf4solr_ip umf4solr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4solr_ip interface~umf4solr->interface~umf4solr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4solr_ip.html"},{"title":"umf4ssym – TOOLIB","text":"public  subroutine umf4ssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym~~CallsGraph proc~umf4ssym umf4ssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4ssym.html"},{"title":"umf4ssym_ip – TOOLIB","text":"public  subroutine umf4ssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4ssym_ip~~CallsGraph proc~umf4ssym_ip umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4ssym_ip~~CalledByGraph proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4ssym_ip.html"},{"title":"umf4sym – TOOLIB","text":"public  subroutine umf4sym(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym~~CallsGraph proc~umf4sym umf4sym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4sym.html"},{"title":"umf4sym_ip – TOOLIB","text":"public  subroutine umf4sym_ip(m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4sym_ip~~CallsGraph proc~umf4sym_ip umf4sym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4sym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4sym_ip~~CalledByGraph proc~umf4sym_ip umf4sym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4sym_ip interface~umf4sym->interface~umf4sym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4sym_ip.html"},{"title":"umf4zdef – TOOLIB","text":"public  subroutine umf4zdef(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zdef~~CallsGraph proc~umf4zdef umf4zdef proc~umfpack_defaults umfpack_defaults proc~umf4zdef->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zdef.html"},{"title":"umf4zfnum – TOOLIB","text":"public  subroutine umf4zfnum(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric Calls proc~~umf4zfnum~~CallsGraph proc~umf4zfnum umf4zfnum proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zfnum.html"},{"title":"umf4zfnum_ip – TOOLIB","text":"public  subroutine umf4zfnum_ip(Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric Calls proc~~umf4zfnum_ip~~CallsGraph proc~umf4zfnum_ip umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zfnum_ip~~CalledByGraph proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zfnum_ip.html"},{"title":"umf4zfsym – TOOLIB","text":"public  subroutine umf4zfsym(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic Calls proc~~umf4zfsym~~CallsGraph proc~umf4zfsym umf4zfsym proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zfsym.html"},{"title":"umf4zfsym_ip – TOOLIB","text":"public  subroutine umf4zfsym_ip(Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic Calls proc~~umf4zfsym_ip~~CallsGraph proc~umf4zfsym_ip umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zfsym_ip~~CalledByGraph proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zfsym_ip.html"},{"title":"umf4zlnum – TOOLIB","text":"public  subroutine umf4zlnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum~~CallsGraph proc~umf4zlnum umf4zlnum proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zlnum.html"},{"title":"umf4zlnum_ip – TOOLIB","text":"public  subroutine umf4zlnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlnum_ip~~CallsGraph proc~umf4zlnum_ip umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zlnum_ip~~CalledByGraph proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zlnum_ip.html"},{"title":"umf4zlsym – TOOLIB","text":"public  subroutine umf4zlsym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym~~CallsGraph proc~umf4zlsym umf4zlsym proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zlsym.html"},{"title":"umf4zlsym_ip – TOOLIB","text":"public  subroutine umf4zlsym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zlsym_ip~~CallsGraph proc~umf4zlsym_ip umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zlsym_ip~~CalledByGraph proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zlsym_ip.html"},{"title":"umf4znum – TOOLIB","text":"public  subroutine umf4znum(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum~~CallsGraph proc~umf4znum umf4znum interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4znum.html"},{"title":"umf4znum_ip – TOOLIB","text":"public  subroutine umf4znum_ip(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4znum_ip~~CallsGraph proc~umf4znum_ip umf4znum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4znum_ip~~CalledByGraph proc~umf4znum_ip umf4znum_ip interface~umf4num umf4num interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4znum_ip.html"},{"title":"umf4zpcon – TOOLIB","text":"public  subroutine umf4zpcon(Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umf4zpcon~~CallsGraph proc~umf4zpcon umf4zpcon proc~umfpack_report_control umfpack_report_control proc~umf4zpcon->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zpcon.html"},{"title":"umf4zpinf – TOOLIB","text":"public  subroutine umf4zpinf(Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zpinf~~CallsGraph proc~umf4zpinf umf4zpinf proc~umfpack_report_info umfpack_report_info proc~umf4zpinf->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zpinf.html"},{"title":"umf4zscal – TOOLIB","text":"public  subroutine umf4zscal(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal~~CallsGraph proc~umf4zscal umf4zscal interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zscal.html"},{"title":"umf4zscal_ip – TOOLIB","text":"public  subroutine umf4zscal_ip(x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status Calls proc~~umf4zscal_ip~~CallsGraph proc~umf4zscal_ip umf4zscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zscal_ip~~CalledByGraph proc~umf4zscal_ip umf4zscal_ip interface~umf4scal umf4scal interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zscal_ip.html"},{"title":"umf4zsnum – TOOLIB","text":"public  subroutine umf4zsnum(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum~~CallsGraph proc~umf4zsnum umf4zsnum proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsnum.html"},{"title":"umf4zsnum_ip – TOOLIB","text":"public  subroutine umf4zsnum_ip(Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zsnum_ip~~CallsGraph proc~umf4zsnum_ip umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zsnum_ip~~CalledByGraph proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsnum_ip.html"},{"title":"umf4zsol – TOOLIB","text":"public  subroutine umf4zsol(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol~~CallsGraph proc~umf4zsol umf4zsol interface~s_umfpack_solve s_umfpack_solve proc~umf4zsol->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsol.html"},{"title":"umf4zsol_ip – TOOLIB","text":"public  subroutine umf4zsol_ip(sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsol_ip~~CallsGraph proc~umf4zsol_ip umf4zsol_ip interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zsol_ip~~CalledByGraph proc~umf4zsol_ip umf4zsol_ip interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsol_ip.html"},{"title":"umf4zsolr – TOOLIB","text":"public  subroutine umf4zsolr(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr~~CallsGraph proc~umf4zsolr umf4zsolr interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsolr.html"},{"title":"umf4zsolr_ip – TOOLIB","text":"public  subroutine umf4zsolr_ip(sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsolr_ip~~CallsGraph proc~umf4zsolr_ip umf4zsolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zsolr_ip~~CalledByGraph proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr umf4solr interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsolr_ip.html"},{"title":"umf4zssym – TOOLIB","text":"public  subroutine umf4zssym(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym~~CallsGraph proc~umf4zssym umf4zssym proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zssym.html"},{"title":"umf4zssym_ip – TOOLIB","text":"public  subroutine umf4zssym_ip(Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status Calls proc~~umf4zssym_ip~~CallsGraph proc~umf4zssym_ip umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zssym_ip~~CalledByGraph proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zssym_ip.html"},{"title":"umf4zsym – TOOLIB","text":"public  subroutine umf4zsym(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym~~CallsGraph proc~umf4zsym umf4zsym interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsym.html"},{"title":"umf4zsym_ip – TOOLIB","text":"public  subroutine umf4zsym_ip(m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) Calls proc~~umf4zsym_ip~~CallsGraph proc~umf4zsym_ip umf4zsym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umf4zsym_ip~~CalledByGraph proc~umf4zsym_ip umf4zsym_ip interface~umf4sym umf4sym interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umf4zsym_ip.html"},{"title":"umfpack_defaults – TOOLIB","text":"public  subroutine umfpack_defaults(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_defaults~~CallsGraph proc~umfpack_defaults umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_defaults~~CalledByGraph proc~umfpack_defaults umfpack_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_defaults.html"},{"title":"umfpack_di_defaults – TOOLIB","text":"public  subroutine umfpack_di_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_defaults~~CallsGraph proc~umfpack_di_defaults umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_defaults~~CalledByGraph proc~umfpack_di_defaults umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_defaults.html"},{"title":"umfpack_di_free_numeric – TOOLIB","text":"public  subroutine umfpack_di_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_di_free_numeric~~CallsGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_free_numeric~~CalledByGraph proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~freefact_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_free_numeric.html"},{"title":"umfpack_di_free_symbolic – TOOLIB","text":"public  subroutine umfpack_di_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_di_free_symbolic~~CallsGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_free_symbolic~~CalledByGraph proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_free_symbolic.html"},{"title":"umfpack_di_report_control – TOOLIB","text":"public  subroutine umfpack_di_report_control(Control) Uses iso_fortran_env proc~~umfpack_di_report_control~~UsesGraph proc~umfpack_di_report_control umfpack_di_report_control iso_fortran_env iso_fortran_env proc~umfpack_di_report_control->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_di_report_control~~CallsGraph proc~umfpack_di_report_control umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_report_control~~CalledByGraph proc~umfpack_di_report_control umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_report_control.html"},{"title":"umfpack_di_report_info – TOOLIB","text":"public  subroutine umfpack_di_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_di_report_info~~UsesGraph proc~umfpack_di_report_info umfpack_di_report_info iso_fortran_env iso_fortran_env proc~umfpack_di_report_info->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_di_report_info~~CallsGraph proc~umfpack_di_report_info umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_di_report_info~~CalledByGraph proc~umfpack_di_report_info umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_di_report_info.html"},{"title":"umfpack_free_numeric – TOOLIB","text":"public  subroutine umfpack_free_numeric(Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version Calls proc~~umfpack_free_numeric~~CallsGraph proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_free_numeric~~CalledByGraph proc~umfpack_free_numeric umfpack_free_numeric interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_free_numeric.html"},{"title":"umfpack_free_symbolic – TOOLIB","text":"public  subroutine umfpack_free_symbolic(Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version Calls proc~~umfpack_free_symbolic~~CallsGraph proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_free_symbolic~~CalledByGraph proc~umfpack_free_symbolic umfpack_free_symbolic interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_free_symbolic.html"},{"title":"umfpack_report_control – TOOLIB","text":"public  subroutine umfpack_report_control(Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version Calls proc~~umfpack_report_control~~CallsGraph proc~umfpack_report_control umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_report_control~~CalledByGraph proc~umfpack_report_control umfpack_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_report_control.html"},{"title":"umfpack_report_info – TOOLIB","text":"public  subroutine umfpack_report_info(Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version Calls proc~~umfpack_report_info~~CallsGraph proc~umfpack_report_info umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_report_info~~CalledByGraph proc~umfpack_report_info umfpack_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_report_info.html"},{"title":"umfpack_zi_defaults – TOOLIB","text":"public  subroutine umfpack_zi_defaults(Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_defaults~~CallsGraph proc~umfpack_zi_defaults umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_defaults~~CalledByGraph proc~umfpack_zi_defaults umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_defaults.html"},{"title":"umfpack_zi_free_numeric – TOOLIB","text":"public  subroutine umfpack_zi_free_numeric(Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric Calls proc~~umfpack_zi_free_numeric~~CallsGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_free_numeric~~CalledByGraph proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_free_numeric.html"},{"title":"umfpack_zi_free_symbolic – TOOLIB","text":"public  subroutine umfpack_zi_free_symbolic(Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic Calls proc~~umfpack_zi_free_symbolic~~CallsGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_free_symbolic~~CalledByGraph proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_free_symbolic.html"},{"title":"umfpack_zi_report_control – TOOLIB","text":"public  subroutine umfpack_zi_report_control(Control) Uses iso_fortran_env proc~~umfpack_zi_report_control~~UsesGraph proc~umfpack_zi_report_control umfpack_zi_report_control iso_fortran_env iso_fortran_env proc~umfpack_zi_report_control->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) Calls proc~~umfpack_zi_report_control~~CallsGraph proc~umfpack_zi_report_control umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_report_control~~CalledByGraph proc~umfpack_zi_report_control umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_report_control.html"},{"title":"umfpack_zi_report_info – TOOLIB","text":"public  subroutine umfpack_zi_report_info(Control, Info) Uses iso_fortran_env proc~~umfpack_zi_report_info~~UsesGraph proc~umfpack_zi_report_info umfpack_zi_report_info iso_fortran_env iso_fortran_env proc~umfpack_zi_report_info->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) Calls proc~~umfpack_zi_report_info~~CallsGraph proc~umfpack_zi_report_info umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~umfpack_zi_report_info~~CalledByGraph proc~umfpack_zi_report_info umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/umfpack_zi_report_info.html"},{"title":"c_umfpack_di_defaults – TOOLIB","text":"interface Called by interface~~c_umfpack_di_defaults~~CalledByGraph interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~s_umfpack_di_defaults s_umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults proc~init_solver init_solver proc~init_solver->proc~umfpack_di_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_di_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_di_defaults(Control) bind(c,name='umfpack_di_defaults') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":"","loc":"interface/c_umfpack_di_defaults.html"},{"title":"c_umfpack_di_free_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_di_free_numeric~~CalledByGraph interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~umfpack_di_free_numeric proc~freefact_solver freefact_solver proc~freefact_solver->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~freefact_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name='umfpack_di_free_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","tags":"","loc":"interface/c_umfpack_di_free_numeric.html"},{"title":"c_umfpack_di_free_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_di_free_symbolic~~CalledByGraph interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic proc~close_solver close_solver proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name='umfpack_di_free_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","tags":"","loc":"interface/c_umfpack_di_free_symbolic.html"},{"title":"c_umfpack_di_load_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_di_load_numeric~~CalledByGraph interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric s_umfpack_di_load_numeric proc~s_umfpack_di_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_load_numeric.html"},{"title":"c_umfpack_di_load_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_di_load_symbolic~~CalledByGraph interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic s_umfpack_di_load_symbolic proc~s_umfpack_di_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_load_symbolic.html"},{"title":"c_umfpack_di_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_di_numeric~~CalledByGraph interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_di_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric proc~factorize_solver factorize_solver proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_numeric.html"},{"title":"c_umfpack_di_report_control – TOOLIB","text":"interface Called by interface~~c_umfpack_di_report_control~~CalledByGraph interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~s_umfpack_di_report_control s_umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control proc~init_solver init_solver proc~init_solver->proc~umfpack_di_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_di_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_di_report_control(Control) bind(c,name='umfpack_di_report_control') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":"","loc":"interface/c_umfpack_di_report_control.html"},{"title":"c_umfpack_di_report_info – TOOLIB","text":"interface Called by interface~~c_umfpack_di_report_info~~CalledByGraph interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~s_umfpack_di_report_info s_umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info proc~close_solver close_solver proc~close_solver->proc~umfpack_di_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_di_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_di_report_info(Control, Info) bind(c,name='umfpack_di_report_info') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","tags":"","loc":"interface/c_umfpack_di_report_info.html"},{"title":"c_umfpack_di_report_numeric – TOOLIB","text":"interface public  function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_report_numeric.html"},{"title":"c_umfpack_di_report_status – TOOLIB","text":"interface public  subroutine c_umfpack_di_report_status(Control, status) bind(c,name='umfpack_di_report_status') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","tags":"","loc":"interface/c_umfpack_di_report_status.html"},{"title":"c_umfpack_di_report_symbolic – TOOLIB","text":"interface public  function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_report_symbolic.html"},{"title":"c_umfpack_di_save_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_di_save_numeric~~CalledByGraph interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric s_umfpack_di_save_numeric proc~s_umfpack_di_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_save_numeric.html"},{"title":"c_umfpack_di_save_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_di_save_symbolic~~CalledByGraph interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic s_umfpack_di_save_symbolic proc~s_umfpack_di_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_save_symbolic.html"},{"title":"c_umfpack_di_scale – TOOLIB","text":"interface Called by interface~~c_umfpack_di_scale~~CalledByGraph interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_di_scale proc~s_umfpack_di_scale s_umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_scale.html"},{"title":"c_umfpack_di_solve – TOOLIB","text":"interface Called by interface~~c_umfpack_di_solve~~CalledByGraph interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_di_solve proc~s_umfpack_di_solve s_umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve proc~solution_solver solution_solver proc~solution_solver->proc~s_umfpack_di_solve proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst->proc~solution_solver proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_solve.html"},{"title":"c_umfpack_di_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_di_symbolic~~CalledByGraph interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic proc~analyse_solver analyse_solver proc~analyse_solver->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csc umfpack_di_operator_CSC proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr umfpack_di_operator_CSR proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_di_operator_csc interface~operator(.umfpack.)->proc~umfpack_di_operator_csr interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_di_symbolic.html"},{"title":"c_umfpack_zi_defaults – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_defaults~~CalledByGraph interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults interface~s_umfpack_zi_defaults s_umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults proc~umfpack_defaults umfpack_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~s_umfpack_defaults s_umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umf4cdef umf4cdef proc~umf4cdef->proc~umfpack_defaults proc~umf4def umf4def proc~umf4def->proc~umfpack_defaults proc~umf4zdef umf4zdef proc~umf4zdef->proc~umfpack_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_zi_defaults(Control) bind(c,name='umfpack_zi_defaults') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":"","loc":"interface/c_umfpack_zi_defaults.html"},{"title":"c_umfpack_zi_free_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_free_numeric~~CalledByGraph interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_free_numeric umfpack_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~s_umfpack_free_numeric s_umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umf4cfnum umf4cfnum proc~umf4cfnum->proc~umfpack_free_numeric proc~umf4cfnum_ip umf4cfnum_ip proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umf4fnum umf4fnum proc~umf4fnum->proc~umfpack_free_numeric proc~umf4fnum_ip umf4fnum_ip proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umf4zfnum umf4zfnum proc~umf4zfnum->proc~umfpack_free_numeric proc~umf4zfnum_ip umf4zfnum_ip proc~umf4zfnum_ip->proc~umfpack_free_numeric interface~umf4cfnum umf4cfnum interface~umf4cfnum->proc~umf4cfnum_ip interface~umf4cfnum->interface~umf4cfnum interface~umf4fnum umf4fnum interface~umf4fnum->proc~umf4fnum_ip interface~umf4fnum->interface~umf4fnum interface~umf4zfnum umf4zfnum interface~umf4zfnum->proc~umf4zfnum_ip interface~umf4zfnum->interface~umf4zfnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name='umfpack_zi_free_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric","tags":"","loc":"interface/c_umfpack_zi_free_numeric.html"},{"title":"c_umfpack_zi_free_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_free_symbolic~~CalledByGraph interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~s_umfpack_free_symbolic s_umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umf4cfsym umf4cfsym proc~umf4cfsym->proc~umfpack_free_symbolic proc~umf4cfsym_ip umf4cfsym_ip proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umf4fsym umf4fsym proc~umf4fsym->proc~umfpack_free_symbolic proc~umf4fsym_ip umf4fsym_ip proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umf4zfsym umf4zfsym proc~umf4zfsym->proc~umfpack_free_symbolic proc~umf4zfsym_ip umf4zfsym_ip proc~umf4zfsym_ip->proc~umfpack_free_symbolic interface~umf4cfsym umf4cfsym interface~umf4cfsym->proc~umf4cfsym_ip interface~umf4cfsym->interface~umf4cfsym interface~umf4fsym umf4fsym interface~umf4fsym->proc~umf4fsym_ip interface~umf4fsym->interface~umf4fsym interface~umf4zfsym umf4zfsym interface~umf4zfsym->proc~umf4zfsym_ip interface~umf4zfsym->interface~umf4zfsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name='umfpack_zi_free_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic","tags":"","loc":"interface/c_umfpack_zi_free_symbolic.html"},{"title":"c_umfpack_zi_load_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_load_numeric~~CalledByGraph interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric s_umfpack_zi_load_numeric proc~s_umfpack_zi_load_numeric->proc~umfpack_zi_load_numeric proc~umfpack_load_numeric umfpack_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric proc~s_umfpack_load_numeric s_umfpack_load_numeric proc~s_umfpack_load_numeric->proc~umfpack_load_numeric proc~umf4clnum umf4clnum proc~umf4clnum->proc~umfpack_load_numeric proc~umf4clnum_ip umf4clnum_ip proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umf4lnum umf4lnum proc~umf4lnum->proc~umfpack_load_numeric proc~umf4lnum_ip umf4lnum_ip proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umf4zlnum umf4zlnum proc~umf4zlnum->proc~umfpack_load_numeric proc~umf4zlnum_ip umf4zlnum_ip proc~umf4zlnum_ip->proc~umfpack_load_numeric interface~umf4clnum umf4clnum interface~umf4clnum->proc~umf4clnum_ip interface~umf4clnum->interface~umf4clnum interface~umf4lnum umf4lnum interface~umf4lnum->proc~umf4lnum_ip interface~umf4lnum->interface~umf4lnum interface~umf4zlnum umf4zlnum interface~umf4zlnum->proc~umf4zlnum_ip interface~umf4zlnum->interface~umf4zlnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_load_numeric.html"},{"title":"c_umfpack_zi_load_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_load_symbolic~~CalledByGraph interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic s_umfpack_zi_load_symbolic proc~s_umfpack_zi_load_symbolic->proc~umfpack_zi_load_symbolic proc~umfpack_load_symbolic umfpack_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic proc~s_umfpack_load_symbolic s_umfpack_load_symbolic proc~s_umfpack_load_symbolic->proc~umfpack_load_symbolic proc~umf4clsym umf4clsym proc~umf4clsym->proc~umfpack_load_symbolic proc~umf4clsym_ip umf4clsym_ip proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umf4lsym umf4lsym proc~umf4lsym->proc~umfpack_load_symbolic proc~umf4lsym_ip umf4lsym_ip proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umf4zlsym umf4zlsym proc~umf4zlsym->proc~umfpack_load_symbolic proc~umf4zlsym_ip umf4zlsym_ip proc~umf4zlsym_ip->proc~umfpack_load_symbolic interface~umf4clsym umf4clsym interface~umf4clsym->proc~umf4clsym_ip interface~umf4clsym->interface~umf4clsym interface~umf4lsym umf4lsym interface~umf4lsym->proc~umf4lsym_ip interface~umf4lsym->interface~umf4lsym interface~umf4zlsym umf4zlsym interface~umf4zlsym->proc~umf4zlsym_ip interface~umf4zlsym->interface~umf4zlsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_load_symbolic.html"},{"title":"c_umfpack_zi_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_numeric~~CalledByGraph interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric proc~umfpack_zi_numeric umfpack_zi_numeric proc~umfpack_zi_numeric->interface~c_umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_numeric.html"},{"title":"c_umfpack_zi_report_control – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_report_control~~CalledByGraph interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control interface~s_umfpack_zi_report_control s_umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control proc~umfpack_report_control umfpack_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~s_umfpack_report_control s_umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umf4cpcon umf4cpcon proc~umf4cpcon->proc~umfpack_report_control proc~umf4pcon umf4pcon proc~umf4pcon->proc~umfpack_report_control proc~umf4zpcon umf4zpcon proc~umf4zpcon->proc~umfpack_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_zi_report_control(Control) bind(c,name='umfpack_zi_report_control') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control","tags":"","loc":"interface/c_umfpack_zi_report_control.html"},{"title":"c_umfpack_zi_report_info – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_report_info~~CalledByGraph interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info interface~s_umfpack_zi_report_info s_umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info proc~umfpack_report_info umfpack_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~s_umfpack_report_info s_umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umf4cpinf umf4cpinf proc~umf4cpinf->proc~umfpack_report_info proc~umf4pinf umf4pinf proc~umf4pinf->proc~umfpack_report_info proc~umf4zpinf umf4zpinf proc~umf4zpinf->proc~umfpack_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name='umfpack_zi_report_info') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info","tags":"","loc":"interface/c_umfpack_zi_report_info.html"},{"title":"c_umfpack_zi_report_numeric – TOOLIB","text":"interface public  function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_report_numeric.html"},{"title":"c_umfpack_zi_report_status – TOOLIB","text":"interface public  subroutine c_umfpack_zi_report_status(Control, status) bind(c,name='umfpack_zi_report_status') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status","tags":"","loc":"interface/c_umfpack_zi_report_status.html"},{"title":"c_umfpack_zi_report_symbolic – TOOLIB","text":"interface public  function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_report_symbolic.html"},{"title":"c_umfpack_zi_save_numeric – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_save_numeric~~CalledByGraph interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric s_umfpack_zi_save_numeric proc~s_umfpack_zi_save_numeric->proc~umfpack_zi_save_numeric proc~umfpack_save_numeric umfpack_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric proc~s_umfpack_save_numeric s_umfpack_save_numeric proc~s_umfpack_save_numeric->proc~umfpack_save_numeric proc~umf4csnum umf4csnum proc~umf4csnum->proc~umfpack_save_numeric proc~umf4csnum_ip umf4csnum_ip proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umf4snum umf4snum proc~umf4snum->proc~umfpack_save_numeric proc~umf4snum_ip umf4snum_ip proc~umf4snum_ip->proc~umfpack_save_numeric proc~umf4zsnum umf4zsnum proc~umf4zsnum->proc~umfpack_save_numeric proc~umf4zsnum_ip umf4zsnum_ip proc~umf4zsnum_ip->proc~umfpack_save_numeric interface~umf4csnum umf4csnum interface~umf4csnum->proc~umf4csnum_ip interface~umf4csnum->interface~umf4csnum interface~umf4snum umf4snum interface~umf4snum->proc~umf4snum_ip interface~umf4snum->interface~umf4snum interface~umf4zsnum umf4zsnum interface~umf4zsnum->proc~umf4zsnum_ip interface~umf4zsnum->interface~umf4zsnum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_save_numeric.html"},{"title":"c_umfpack_zi_save_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_save_symbolic~~CalledByGraph interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic s_umfpack_zi_save_symbolic proc~s_umfpack_zi_save_symbolic->proc~umfpack_zi_save_symbolic proc~umfpack_save_symbolic umfpack_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic proc~s_umfpack_save_symbolic s_umfpack_save_symbolic proc~s_umfpack_save_symbolic->proc~umfpack_save_symbolic proc~umf4cssym umf4cssym proc~umf4cssym->proc~umfpack_save_symbolic proc~umf4cssym_ip umf4cssym_ip proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umf4ssym umf4ssym proc~umf4ssym->proc~umfpack_save_symbolic proc~umf4ssym_ip umf4ssym_ip proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umf4zssym umf4zssym proc~umf4zssym->proc~umfpack_save_symbolic proc~umf4zssym_ip umf4zssym_ip proc~umf4zssym_ip->proc~umfpack_save_symbolic interface~umf4cssym umf4cssym interface~umf4cssym->proc~umf4cssym_ip interface~umf4cssym->interface~umf4cssym interface~umf4ssym umf4ssym interface~umf4ssym->proc~umf4ssym_ip interface~umf4ssym->interface~umf4ssym interface~umf4zssym umf4zssym interface~umf4zssym->proc~umf4zssym_ip interface~umf4zssym->interface~umf4zssym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_save_symbolic.html"},{"title":"c_umfpack_zi_scale – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_scale~~CalledByGraph interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale proc~umfpack_zi_scale umfpack_zi_scale proc~umfpack_zi_scale->interface~c_umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->proc~umfpack_ci_scale interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~s_umfpack_zi_scale s_umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_scale.html"},{"title":"c_umfpack_zi_solve – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_solve~~CalledByGraph interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve proc~umfpack_zi_solve umfpack_zi_solve proc~umfpack_zi_solve->interface~c_umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_zi_solve s_umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve proc~umf4csol_ip umf4csol_ip proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~umf4csol umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4csol->interface~umf4csol interface~umf4sol umf4sol interface~umf4sol->proc~umf4csol_ip interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4zsol->proc~umf4zsol_ip proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_solve.html"},{"title":"c_umfpack_zi_symbolic – TOOLIB","text":"interface Called by interface~~c_umfpack_zi_symbolic~~CalledByGraph interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic proc~umfpack_zi_symbolic umfpack_zi_symbolic proc~umfpack_zi_symbolic->interface~c_umfpack_zi_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int)","tags":"","loc":"interface/c_umfpack_zi_symbolic.html"},{"title":"operator(.umfpack.) – TOOLIB","text":"public interface operator(.umfpack.) Calls interface~~operator(.umfpack.)~~CallsGraph interface~operator(.umfpack.) operator(.umfpack.) proc~umfpack_ci_operator_csc umfpack_ci_operator_CSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_csc proc~umfpack_ci_operator_csr umfpack_ci_operator_CSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_csr proc~umfpack_ci_operator_pcsc umfpack_ci_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsc proc~umfpack_ci_operator_pcsr umfpack_ci_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_ci_operator_pcsr proc~umfpack_di_operator_csc umfpack_di_operator_CSC interface~operator(.umfpack.)->proc~umfpack_di_operator_csc proc~umfpack_di_operator_csr umfpack_di_operator_CSR interface~operator(.umfpack.)->proc~umfpack_di_operator_csr proc~umfpack_di_operator_pcsc umfpack_di_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsc proc~umfpack_di_operator_pcsr umfpack_di_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_di_operator_pcsr proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~s_umfpack_ci_numeric s_umfpack_ci_numeric proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_numeric proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_solve proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic proc~umfpack_ci_operator_csc->proc~s_umfpack_ci_symbolic proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_ci_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_csr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsc->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_numeric proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_solve proc~umfpack_ci_operator_pcsr->proc~s_umfpack_ci_symbolic proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_ci_operator_pcsr->proc~umfpack_zi_free_symbolic proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~umfpack_di_operator_csc->proc~s_umfpack_di_numeric proc~s_umfpack_di_solve s_umfpack_di_solve proc~umfpack_di_operator_csc->proc~s_umfpack_di_solve proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~umfpack_di_operator_csc->proc~s_umfpack_di_symbolic proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_di_operator_csc->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_di_operator_csc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_csr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_csr->proc~s_umfpack_di_solve proc~umfpack_di_operator_csr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_csr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_csr->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsc->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsc->proc~umfpack_di_free_symbolic proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_numeric proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_solve proc~umfpack_di_operator_pcsr->proc~s_umfpack_di_symbolic proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_numeric proc~umfpack_di_operator_pcsr->proc~umfpack_di_free_symbolic interface~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_csr->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsc->proc~umfpack_zi_free_symbolic proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_numeric proc~umfpack_zi_operator_pcsr->proc~umfpack_zi_free_symbolic interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1)","tags":"","loc":"interface/operator(.umfpack.).html"},{"title":"pCSC – TOOLIB","text":"public interface pCSC Calls interface~~pcsc~~CallsGraph interface~pcsc pCSC proc~make_csc_ci make_CSC_ci interface~pcsc->proc~make_csc_ci proc~make_csc_di make_CSC_di interface~pcsc->proc~make_csc_di proc~make_csc_zi make_CSC_zi interface~pcsc->proc~make_csc_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public  function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public  function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci )","tags":"","loc":"interface/pcsc.html"},{"title":"pCSR – TOOLIB","text":"public interface pCSR Calls interface~~pcsr~~CallsGraph interface~pcsr pCSR proc~make_csr_ci make_CSR_ci interface~pcsr->proc~make_csr_ci proc~make_csr_di make_CSR_di interface~pcsr->proc~make_csr_di proc~make_csr_zi make_CSR_zi interface~pcsr->proc~make_csr_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public  function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public  function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci )","tags":"","loc":"interface/pcsr.html"},{"title":"pVec – TOOLIB","text":"public interface pVec Calls interface~~pvec~~CallsGraph interface~pvec pVec proc~make_vec_zi make_Vec_zi interface~pvec->proc~make_vec_zi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi )","tags":"","loc":"interface/pvec.html"},{"title":"s_umfpack_defaults – TOOLIB","text":"public interface s_umfpack_defaults Calls interface~~s_umfpack_defaults~~CallsGraph interface~s_umfpack_defaults s_umfpack_defaults proc~umfpack_defaults umfpack_defaults interface~s_umfpack_defaults->proc~umfpack_defaults proc~umfpack_di_defaults umfpack_di_defaults proc~umfpack_defaults->proc~umfpack_di_defaults proc~umfpack_zi_defaults umfpack_zi_defaults proc~umfpack_defaults->proc~umfpack_zi_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","tags":"","loc":"interface/s_umfpack_defaults.html"},{"title":"s_umfpack_di_defaults – TOOLIB","text":"public interface s_umfpack_di_defaults Calls interface~~s_umfpack_di_defaults~~CallsGraph interface~s_umfpack_di_defaults s_umfpack_di_defaults proc~umfpack_di_defaults umfpack_di_defaults interface~s_umfpack_di_defaults->proc~umfpack_di_defaults interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1)","tags":"","loc":"interface/s_umfpack_di_defaults.html"},{"title":"s_umfpack_di_free_numeric – TOOLIB","text":"public interface s_umfpack_di_free_numeric Calls interface~~s_umfpack_di_free_numeric~~CallsGraph interface~s_umfpack_di_free_numeric s_umfpack_di_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric interface~s_umfpack_di_free_numeric->proc~umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","tags":"","loc":"interface/s_umfpack_di_free_numeric.html"},{"title":"s_umfpack_di_free_symbolic – TOOLIB","text":"public interface s_umfpack_di_free_symbolic Calls interface~~s_umfpack_di_free_symbolic~~CallsGraph interface~s_umfpack_di_free_symbolic s_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic interface~s_umfpack_di_free_symbolic->proc~umfpack_di_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","tags":"","loc":"interface/s_umfpack_di_free_symbolic.html"},{"title":"s_umfpack_di_report_control – TOOLIB","text":"public interface s_umfpack_di_report_control Calls interface~~s_umfpack_di_report_control~~CallsGraph interface~s_umfpack_di_report_control s_umfpack_di_report_control proc~umfpack_di_report_control umfpack_di_report_control interface~s_umfpack_di_report_control->proc~umfpack_di_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1)","tags":"","loc":"interface/s_umfpack_di_report_control.html"},{"title":"s_umfpack_di_report_info – TOOLIB","text":"public interface s_umfpack_di_report_info Calls interface~~s_umfpack_di_report_info~~CallsGraph interface~s_umfpack_di_report_info s_umfpack_di_report_info proc~umfpack_di_report_info umfpack_di_report_info interface~s_umfpack_di_report_info->proc~umfpack_di_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/s_umfpack_di_report_info.html"},{"title":"s_umfpack_free_numeric – TOOLIB","text":"public interface s_umfpack_free_numeric Calls interface~~s_umfpack_free_numeric~~CallsGraph interface~s_umfpack_free_numeric s_umfpack_free_numeric proc~umfpack_free_numeric umfpack_free_numeric interface~s_umfpack_free_numeric->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version","tags":"","loc":"interface/s_umfpack_free_numeric.html"},{"title":"s_umfpack_free_symbolic – TOOLIB","text":"public interface s_umfpack_free_symbolic Calls interface~~s_umfpack_free_symbolic~~CallsGraph interface~s_umfpack_free_symbolic s_umfpack_free_symbolic proc~umfpack_free_symbolic umfpack_free_symbolic interface~s_umfpack_free_symbolic->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version","tags":"","loc":"interface/s_umfpack_free_symbolic.html"},{"title":"s_umfpack_numeric – TOOLIB","text":"public interface s_umfpack_numeric Calls interface~~s_umfpack_numeric~~CallsGraph interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_numeric~~CalledByGraph interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_numeric () Arguments None public  subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_numeric.html"},{"title":"s_umfpack_report_control – TOOLIB","text":"public interface s_umfpack_report_control Calls interface~~s_umfpack_report_control~~CallsGraph interface~s_umfpack_report_control s_umfpack_report_control proc~umfpack_report_control umfpack_report_control interface~s_umfpack_report_control->proc~umfpack_report_control proc~umfpack_di_report_control umfpack_di_report_control proc~umfpack_report_control->proc~umfpack_di_report_control proc~umfpack_zi_report_control umfpack_zi_report_control proc~umfpack_report_control->proc~umfpack_zi_report_control interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version","tags":"","loc":"interface/s_umfpack_report_control.html"},{"title":"s_umfpack_report_info – TOOLIB","text":"public interface s_umfpack_report_info Calls interface~~s_umfpack_report_info~~CallsGraph interface~s_umfpack_report_info s_umfpack_report_info proc~umfpack_report_info umfpack_report_info interface~s_umfpack_report_info->proc~umfpack_report_info proc~umfpack_di_report_info umfpack_di_report_info proc~umfpack_report_info->proc~umfpack_di_report_info proc~umfpack_zi_report_info umfpack_zi_report_info proc~umfpack_report_info->proc~umfpack_zi_report_info interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version","tags":"","loc":"interface/s_umfpack_report_info.html"},{"title":"s_umfpack_scale – TOOLIB","text":"public interface s_umfpack_scale Calls interface~~s_umfpack_scale~~CallsGraph interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_scale->proc~s_umfpack_ci_scale proc~s_umfpack_di_scale s_umfpack_di_scale interface~s_umfpack_scale->proc~s_umfpack_di_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale proc~s_umfpack_di_scale->proc~umfpack_di_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public  interface s_umfpack_zi_scale () Arguments None public  subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","tags":"","loc":"interface/s_umfpack_scale.html"},{"title":"s_umfpack_solve – TOOLIB","text":"public interface s_umfpack_solve Calls interface~~s_umfpack_solve~~CallsGraph interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_solve~~CalledByGraph interface~s_umfpack_solve s_umfpack_solve proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip umf4sol_ip proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4sol umf4sol interface~umf4sol->proc~umf4sol_ip interface~umf4sol->interface~umf4sol interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_solve () Arguments None public  subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_solve.html"},{"title":"s_umfpack_symbolic – TOOLIB","text":"public interface s_umfpack_symbolic Calls interface~~s_umfpack_symbolic~~CallsGraph interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_symbolic~~CalledByGraph interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_symbolic () Arguments None public  subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_symbolic.html"},{"title":"s_umfpack_zi_defaults – TOOLIB","text":"public interface s_umfpack_zi_defaults Calls interface~~s_umfpack_zi_defaults~~CallsGraph interface~s_umfpack_zi_defaults s_umfpack_zi_defaults proc~umfpack_zi_defaults umfpack_zi_defaults interface~s_umfpack_zi_defaults->proc~umfpack_zi_defaults interface~c_umfpack_zi_defaults c_umfpack_zi_defaults proc~umfpack_zi_defaults->interface~c_umfpack_zi_defaults Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1)","tags":"","loc":"interface/s_umfpack_zi_defaults.html"},{"title":"s_umfpack_zi_free_numeric – TOOLIB","text":"public interface s_umfpack_zi_free_numeric Calls interface~~s_umfpack_zi_free_numeric~~CallsGraph interface~s_umfpack_zi_free_numeric s_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric interface~s_umfpack_zi_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric","tags":"","loc":"interface/s_umfpack_zi_free_numeric.html"},{"title":"s_umfpack_zi_free_symbolic – TOOLIB","text":"public interface s_umfpack_zi_free_symbolic Calls interface~~s_umfpack_zi_free_symbolic~~CallsGraph interface~s_umfpack_zi_free_symbolic s_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic interface~s_umfpack_zi_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic","tags":"","loc":"interface/s_umfpack_zi_free_symbolic.html"},{"title":"s_umfpack_zi_numeric – TOOLIB","text":"public interface s_umfpack_zi_numeric Calls interface~~s_umfpack_zi_numeric~~CallsGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_zi_numeric~~CalledByGraph interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_numeric s_umfpack_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_numeric proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_numeric interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4cnum umf4cnum proc~umf4cnum->interface~s_umfpack_numeric proc~umf4cnum_ip umf4cnum_ip proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num umf4num proc~umf4num->interface~s_umfpack_numeric proc~umf4num_ip umf4num_ip proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum umf4znum proc~umf4znum->interface~s_umfpack_numeric proc~umf4znum_ip umf4znum_ip proc~umf4znum_ip->interface~s_umfpack_numeric interface~umf4cnum umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->proc~umf4cnum_ip interface~umf4num->proc~umf4num_ip interface~umf4num->proc~umf4znum_ip interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface s_umfpack_zi_numeric () Arguments None public  subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_zi_numeric.html"},{"title":"s_umfpack_zi_report_control – TOOLIB","text":"public interface s_umfpack_zi_report_control Calls interface~~s_umfpack_zi_report_control~~CallsGraph interface~s_umfpack_zi_report_control s_umfpack_zi_report_control proc~umfpack_zi_report_control umfpack_zi_report_control interface~s_umfpack_zi_report_control->proc~umfpack_zi_report_control interface~c_umfpack_zi_report_control c_umfpack_zi_report_control proc~umfpack_zi_report_control->interface~c_umfpack_zi_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1)","tags":"","loc":"interface/s_umfpack_zi_report_control.html"},{"title":"s_umfpack_zi_report_info – TOOLIB","text":"public interface s_umfpack_zi_report_info Calls interface~~s_umfpack_zi_report_info~~CallsGraph interface~s_umfpack_zi_report_info s_umfpack_zi_report_info proc~umfpack_zi_report_info umfpack_zi_report_info interface~s_umfpack_zi_report_info->proc~umfpack_zi_report_info interface~c_umfpack_zi_report_info c_umfpack_zi_report_info proc~umfpack_zi_report_info->interface~c_umfpack_zi_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/s_umfpack_zi_report_info.html"},{"title":"s_umfpack_zi_scale – TOOLIB","text":"public interface s_umfpack_zi_scale Calls interface~~s_umfpack_zi_scale~~CallsGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale proc~s_umfpack_ci_scale s_umfpack_ci_scale interface~s_umfpack_zi_scale->proc~s_umfpack_ci_scale proc~umfpack_ci_scale umfpack_ci_scale proc~s_umfpack_ci_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_zi_scale~~CalledByGraph interface~s_umfpack_zi_scale s_umfpack_zi_scale interface~s_umfpack_zi_scale->interface~s_umfpack_zi_scale interface~s_umfpack_scale s_umfpack_scale interface~s_umfpack_scale->interface~s_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface s_umfpack_zi_scale () Arguments None public  subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status","tags":"","loc":"interface/s_umfpack_zi_scale.html"},{"title":"s_umfpack_zi_solve – TOOLIB","text":"public interface s_umfpack_zi_solve Calls interface~~s_umfpack_zi_solve~~CallsGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_zi_solve~~CalledByGraph interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_solve s_umfpack_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~umf4zsol_ip umf4zsol_ip proc~umf4zsol_ip->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_solve proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_solve interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr interface~umf4sol umf4sol interface~umf4sol->proc~umf4zsol_ip interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip interface~umf4zsol->proc~umf4zsol_ip interface~umf4zsol->interface~umf4zsol proc~umf4csol umf4csol proc~umf4csol->interface~s_umfpack_solve proc~umf4csolr umf4csolr proc~umf4csolr->interface~s_umfpack_solve proc~umf4csolr_ip umf4csolr_ip proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4sol umf4sol proc~umf4sol->interface~s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve proc~umf4solr umf4solr proc~umf4solr->interface~s_umfpack_solve proc~umf4solr_ip umf4solr_ip proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsol umf4zsol proc~umf4zsol->interface~s_umfpack_solve proc~umf4zsolr umf4zsolr proc~umf4zsolr->interface~s_umfpack_solve proc~umf4zsolr_ip umf4zsolr_ip proc~umf4zsolr_ip->interface~s_umfpack_solve interface~umf4csolr umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->proc~umf4csolr_ip interface~umf4solr->proc~umf4solr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface s_umfpack_zi_solve () Arguments None public  subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_zi_solve.html"},{"title":"s_umfpack_zi_symbolic – TOOLIB","text":"public interface s_umfpack_zi_symbolic Calls interface~~s_umfpack_zi_symbolic~~CallsGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~s_umfpack_zi_symbolic~~CalledByGraph interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_symbolic s_umfpack_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csc umfpack_zi_operator_CSC proc~umfpack_zi_operator_csc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_csr umfpack_zi_operator_CSR proc~umfpack_zi_operator_csr->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsc umfpack_zi_operator_pCSC proc~umfpack_zi_operator_pcsc->interface~s_umfpack_zi_symbolic proc~umfpack_zi_operator_pcsr umfpack_zi_operator_pCSR proc~umfpack_zi_operator_pcsr->interface~s_umfpack_zi_symbolic interface~operator(.umfpack.) operator(.umfpack.) interface~operator(.umfpack.)->proc~umfpack_zi_operator_csc interface~operator(.umfpack.)->proc~umfpack_zi_operator_csr interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsc interface~operator(.umfpack.)->proc~umfpack_zi_operator_pcsr proc~umf4csym umf4csym proc~umf4csym->interface~s_umfpack_symbolic proc~umf4csym_ip umf4csym_ip proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym umf4sym proc~umf4sym->interface~s_umfpack_symbolic proc~umf4sym_ip umf4sym_ip proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym umf4zsym proc~umf4zsym->interface~s_umfpack_symbolic proc~umf4zsym_ip umf4zsym_ip proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~umf4csym umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->proc~umf4csym_ip interface~umf4sym->proc~umf4sym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface s_umfpack_zi_symbolic () Arguments None public  subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status","tags":"","loc":"interface/s_umfpack_zi_symbolic.html"},{"title":"umf4cfnum – TOOLIB","text":"public interface umf4cfnum Calls interface~~umf4cfnum~~CallsGraph interface~umf4cfnum umf4cfnum interface~umf4cfnum->interface~umf4cfnum proc~umf4cfnum_ip umf4cfnum_ip interface~umf4cfnum->proc~umf4cfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4cfnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4cfnum () Arguments None public  subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":"","loc":"interface/umf4cfnum.html"},{"title":"umf4cfsym – TOOLIB","text":"public interface umf4cfsym Calls interface~~umf4cfsym~~CallsGraph interface~umf4cfsym umf4cfsym interface~umf4cfsym->interface~umf4cfsym proc~umf4cfsym_ip umf4cfsym_ip interface~umf4cfsym->proc~umf4cfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4cfsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4cfsym () Arguments None public  subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":"","loc":"interface/umf4cfsym.html"},{"title":"umf4clnum – TOOLIB","text":"public interface umf4clnum Calls interface~~umf4clnum~~CallsGraph interface~umf4clnum umf4clnum interface~umf4clnum->interface~umf4clnum proc~umf4clnum_ip umf4clnum_ip interface~umf4clnum->proc~umf4clnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4clnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4clnum () Arguments None public  subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4clnum.html"},{"title":"umf4clsym – TOOLIB","text":"public interface umf4clsym Calls interface~~umf4clsym~~CallsGraph interface~umf4clsym umf4clsym interface~umf4clsym->interface~umf4clsym proc~umf4clsym_ip umf4clsym_ip interface~umf4clsym->proc~umf4clsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4clsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4clsym () Arguments None public  subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4clsym.html"},{"title":"umf4cnum – TOOLIB","text":"public interface umf4cnum Calls interface~~umf4cnum~~CallsGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum proc~umf4cnum_ip umf4cnum_ip interface~umf4cnum->proc~umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4cnum~~CalledByGraph interface~umf4cnum umf4cnum interface~umf4cnum->interface~umf4cnum interface~umf4num umf4num interface~umf4num->interface~umf4cnum interface~umf4num->interface~umf4num interface~umf4znum umf4znum interface~umf4num->interface~umf4znum interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4cnum.html"},{"title":"umf4cscal – TOOLIB","text":"public interface umf4cscal Calls interface~~umf4cscal~~CallsGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal proc~umf4cscal_ip umf4cscal_ip interface~umf4cscal->proc~umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4cscal~~CalledByGraph interface~umf4cscal umf4cscal interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":"","loc":"interface/umf4cscal.html"},{"title":"umf4csnum – TOOLIB","text":"public interface umf4csnum Calls interface~~umf4csnum~~CallsGraph interface~umf4csnum umf4csnum interface~umf4csnum->interface~umf4csnum proc~umf4csnum_ip umf4csnum_ip interface~umf4csnum->proc~umf4csnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4csnum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4csnum () Arguments None public  subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4csnum.html"},{"title":"umf4csol – TOOLIB","text":"public interface umf4csol Calls interface~~umf4csol~~CallsGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol proc~umf4csol_ip umf4csol_ip interface~umf4csol->proc~umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4csol~~CalledByGraph interface~umf4csol umf4csol interface~umf4csol->interface~umf4csol interface~umf4sol umf4sol interface~umf4sol->interface~umf4csol interface~umf4sol->interface~umf4sol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4csol.html"},{"title":"umf4csolr – TOOLIB","text":"public interface umf4csolr Calls interface~~umf4csolr~~CallsGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4csolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4csolr~~CalledByGraph interface~umf4csolr umf4csolr interface~umf4csolr->interface~umf4csolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4csolr interface~umf4solr->interface~umf4solr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4csolr.html"},{"title":"umf4cssym – TOOLIB","text":"public interface umf4cssym Calls interface~~umf4cssym~~CallsGraph interface~umf4cssym umf4cssym interface~umf4cssym->interface~umf4cssym proc~umf4cssym_ip umf4cssym_ip interface~umf4cssym->proc~umf4cssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4cssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4cssym () Arguments None public  subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4cssym.html"},{"title":"umf4csym – TOOLIB","text":"public interface umf4csym Calls interface~~umf4csym~~CallsGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4csym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4csym~~CalledByGraph interface~umf4csym umf4csym interface~umf4csym->interface~umf4csym interface~umf4sym umf4sym interface~umf4sym->interface~umf4csym interface~umf4sym->interface~umf4sym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4csym.html"},{"title":"umf4fnum – TOOLIB","text":"public interface umf4fnum Calls interface~~umf4fnum~~CallsGraph interface~umf4fnum umf4fnum interface~umf4fnum->interface~umf4fnum proc~umf4fnum_ip umf4fnum_ip interface~umf4fnum->proc~umf4fnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4fnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4fnum () Arguments None public  subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":"","loc":"interface/umf4fnum.html"},{"title":"umf4fsym – TOOLIB","text":"public interface umf4fsym Calls interface~~umf4fsym~~CallsGraph interface~umf4fsym umf4fsym interface~umf4fsym->interface~umf4fsym proc~umf4fsym_ip umf4fsym_ip interface~umf4fsym->proc~umf4fsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4fsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4fsym () Arguments None public  subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":"","loc":"interface/umf4fsym.html"},{"title":"umf4lnum – TOOLIB","text":"public interface umf4lnum Calls interface~~umf4lnum~~CallsGraph interface~umf4lnum umf4lnum interface~umf4lnum->interface~umf4lnum proc~umf4lnum_ip umf4lnum_ip interface~umf4lnum->proc~umf4lnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4lnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4lnum () Arguments None public  subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4lnum.html"},{"title":"umf4lsym – TOOLIB","text":"public interface umf4lsym Calls interface~~umf4lsym~~CallsGraph interface~umf4lsym umf4lsym interface~umf4lsym->interface~umf4lsym proc~umf4lsym_ip umf4lsym_ip interface~umf4lsym->proc~umf4lsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4lsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4lsym () Arguments None public  subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4lsym.html"},{"title":"umf4num – TOOLIB","text":"public interface umf4num Calls interface~~umf4num~~CallsGraph interface~umf4num umf4num interface~umf4num->interface~umf4num interface~umf4cnum umf4cnum interface~umf4num->interface~umf4cnum interface~umf4znum umf4znum interface~umf4num->interface~umf4znum proc~umf4cnum_ip umf4cnum_ip interface~umf4num->proc~umf4cnum_ip proc~umf4num_ip umf4num_ip interface~umf4num->proc~umf4num_ip proc~umf4znum_ip umf4znum_ip interface~umf4num->proc~umf4znum_ip interface~umf4cnum->interface~umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~umf4znum->interface~umf4cnum interface~umf4znum->interface~umf4znum interface~umf4znum->proc~umf4cnum_ip interface~umf4znum->proc~umf4znum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4num_ip->interface~s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4num () Arguments None public  subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4znum () Arguments None public  subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4num.html"},{"title":"umf4scal – TOOLIB","text":"public interface umf4scal Calls interface~~umf4scal~~CallsGraph interface~umf4scal umf4scal interface~umf4scal->interface~umf4scal interface~umf4cscal umf4cscal interface~umf4scal->interface~umf4cscal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal proc~umf4cscal_ip umf4cscal_ip interface~umf4scal->proc~umf4cscal_ip proc~umf4scal_ip umf4scal_ip interface~umf4scal->proc~umf4scal_ip proc~umf4zscal_ip umf4zscal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4scal () Arguments None public  subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4zscal () Arguments None public  subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":"","loc":"interface/umf4scal.html"},{"title":"umf4snum – TOOLIB","text":"public interface umf4snum Calls interface~~umf4snum~~CallsGraph interface~umf4snum umf4snum interface~umf4snum->interface~umf4snum proc~umf4snum_ip umf4snum_ip interface~umf4snum->proc~umf4snum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4snum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4snum () Arguments None public  subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4snum.html"},{"title":"umf4sol – TOOLIB","text":"public interface umf4sol Calls interface~~umf4sol~~CallsGraph interface~umf4sol umf4sol interface~umf4sol->interface~umf4sol interface~umf4csol umf4csol interface~umf4sol->interface~umf4csol interface~umf4zsol umf4zsol interface~umf4sol->interface~umf4zsol proc~umf4csol_ip umf4csol_ip interface~umf4sol->proc~umf4csol_ip proc~umf4sol_ip umf4sol_ip interface~umf4sol->proc~umf4sol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4sol->proc~umf4zsol_ip interface~umf4csol->interface~umf4csol interface~umf4csol->proc~umf4csol_ip interface~umf4zsol->interface~umf4csol interface~umf4zsol->interface~umf4zsol interface~umf4zsol->proc~umf4csol_ip interface~umf4zsol->proc~umf4zsol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_solve s_umfpack_solve proc~umf4sol_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4sol () Arguments None public  subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsol () Arguments None public  subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4sol.html"},{"title":"umf4solr – TOOLIB","text":"public interface umf4solr Calls interface~~umf4solr~~CallsGraph interface~umf4solr umf4solr interface~umf4solr->interface~umf4solr interface~umf4csolr umf4csolr interface~umf4solr->interface~umf4csolr interface~umf4zsolr umf4zsolr interface~umf4solr->interface~umf4zsolr proc~umf4csolr_ip umf4csolr_ip interface~umf4solr->proc~umf4csolr_ip proc~umf4solr_ip umf4solr_ip interface~umf4solr->proc~umf4solr_ip proc~umf4zsolr_ip umf4zsolr_ip interface~umf4solr->proc~umf4zsolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~umf4zsolr->interface~umf4csolr interface~umf4zsolr->interface~umf4zsolr interface~umf4zsolr->proc~umf4csolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4solr_ip->interface~s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4solr () Arguments None public  subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsolr () Arguments None public  subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4solr.html"},{"title":"umf4ssym – TOOLIB","text":"public interface umf4ssym Calls interface~~umf4ssym~~CallsGraph interface~umf4ssym umf4ssym interface~umf4ssym->interface~umf4ssym proc~umf4ssym_ip umf4ssym_ip interface~umf4ssym->proc~umf4ssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4ssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4ssym () Arguments None public  subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4ssym.html"},{"title":"umf4sym – TOOLIB","text":"public interface umf4sym Calls interface~~umf4sym~~CallsGraph interface~umf4sym umf4sym interface~umf4sym->interface~umf4sym interface~umf4csym umf4csym interface~umf4sym->interface~umf4csym interface~umf4zsym umf4zsym interface~umf4sym->interface~umf4zsym proc~umf4csym_ip umf4csym_ip interface~umf4sym->proc~umf4csym_ip proc~umf4sym_ip umf4sym_ip interface~umf4sym->proc~umf4sym_ip proc~umf4zsym_ip umf4zsym_ip interface~umf4sym->proc~umf4zsym_ip interface~umf4csym->interface~umf4csym interface~umf4csym->proc~umf4csym_ip interface~umf4zsym->interface~umf4csym interface~umf4zsym->interface~umf4zsym interface~umf4zsym->proc~umf4csym_ip interface~umf4zsym->proc~umf4zsym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4sym_ip->interface~s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4sym () Arguments None public  subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsym () Arguments None public  subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4sym.html"},{"title":"umf4zfnum – TOOLIB","text":"public interface umf4zfnum Calls interface~~umf4zfnum~~CallsGraph interface~umf4zfnum umf4zfnum interface~umf4zfnum->interface~umf4zfnum proc~umf4zfnum_ip umf4zfnum_ip interface~umf4zfnum->proc~umf4zfnum_ip proc~umfpack_free_numeric umfpack_free_numeric proc~umf4zfnum_ip->proc~umfpack_free_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~umfpack_free_numeric->proc~umfpack_di_free_numeric proc~umfpack_zi_free_numeric umfpack_zi_free_numeric proc~umfpack_free_numeric->proc~umfpack_zi_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_zi_free_numeric c_umfpack_zi_free_numeric proc~umfpack_zi_free_numeric->interface~c_umfpack_zi_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zfnum () Arguments None public  subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric","tags":"","loc":"interface/umf4zfnum.html"},{"title":"umf4zfsym – TOOLIB","text":"public interface umf4zfsym Calls interface~~umf4zfsym~~CallsGraph interface~umf4zfsym umf4zfsym interface~umf4zfsym->interface~umf4zfsym proc~umf4zfsym_ip umf4zfsym_ip interface~umf4zfsym->proc~umf4zfsym_ip proc~umfpack_free_symbolic umfpack_free_symbolic proc~umf4zfsym_ip->proc~umfpack_free_symbolic proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_di_free_symbolic proc~umfpack_zi_free_symbolic umfpack_zi_free_symbolic proc~umfpack_free_symbolic->proc~umfpack_zi_free_symbolic interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_zi_free_symbolic c_umfpack_zi_free_symbolic proc~umfpack_zi_free_symbolic->interface~c_umfpack_zi_free_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zfsym () Arguments None public  subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic","tags":"","loc":"interface/umf4zfsym.html"},{"title":"umf4zlnum – TOOLIB","text":"public interface umf4zlnum Calls interface~~umf4zlnum~~CallsGraph interface~umf4zlnum umf4zlnum interface~umf4zlnum->interface~umf4zlnum proc~umf4zlnum_ip umf4zlnum_ip interface~umf4zlnum->proc~umf4zlnum_ip proc~umfpack_load_numeric umfpack_load_numeric proc~umf4zlnum_ip->proc~umfpack_load_numeric proc~umfpack_di_load_numeric umfpack_di_load_numeric proc~umfpack_load_numeric->proc~umfpack_di_load_numeric proc~umfpack_zi_load_numeric umfpack_zi_load_numeric proc~umfpack_load_numeric->proc~umfpack_zi_load_numeric interface~c_umfpack_di_load_numeric c_umfpack_di_load_numeric proc~umfpack_di_load_numeric->interface~c_umfpack_di_load_numeric interface~c_umfpack_zi_load_numeric c_umfpack_zi_load_numeric proc~umfpack_zi_load_numeric->interface~c_umfpack_zi_load_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zlnum () Arguments None public  subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4zlnum.html"},{"title":"umf4zlsym – TOOLIB","text":"public interface umf4zlsym Calls interface~~umf4zlsym~~CallsGraph interface~umf4zlsym umf4zlsym interface~umf4zlsym->interface~umf4zlsym proc~umf4zlsym_ip umf4zlsym_ip interface~umf4zlsym->proc~umf4zlsym_ip proc~umfpack_load_symbolic umfpack_load_symbolic proc~umf4zlsym_ip->proc~umfpack_load_symbolic proc~umfpack_di_load_symbolic umfpack_di_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_di_load_symbolic proc~umfpack_zi_load_symbolic umfpack_zi_load_symbolic proc~umfpack_load_symbolic->proc~umfpack_zi_load_symbolic interface~c_umfpack_di_load_symbolic c_umfpack_di_load_symbolic proc~umfpack_di_load_symbolic->interface~c_umfpack_di_load_symbolic interface~c_umfpack_zi_load_symbolic c_umfpack_zi_load_symbolic proc~umfpack_zi_load_symbolic->interface~c_umfpack_zi_load_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zlsym () Arguments None public  subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4zlsym.html"},{"title":"umf4znum – TOOLIB","text":"public interface umf4znum Calls interface~~umf4znum~~CallsGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum interface~umf4cnum umf4cnum interface~umf4znum->interface~umf4cnum proc~umf4cnum_ip umf4cnum_ip interface~umf4znum->proc~umf4cnum_ip proc~umf4znum_ip umf4znum_ip interface~umf4znum->proc~umf4znum_ip interface~umf4cnum->interface~umf4cnum interface~umf4cnum->proc~umf4cnum_ip interface~s_umfpack_numeric s_umfpack_numeric proc~umf4cnum_ip->interface~s_umfpack_numeric proc~umf4znum_ip->interface~s_umfpack_numeric interface~s_umfpack_zi_numeric s_umfpack_zi_numeric interface~s_umfpack_numeric->interface~s_umfpack_zi_numeric proc~s_umfpack_ci_numeric s_umfpack_ci_numeric interface~s_umfpack_numeric->proc~s_umfpack_ci_numeric proc~s_umfpack_di_numeric s_umfpack_di_numeric interface~s_umfpack_numeric->proc~s_umfpack_di_numeric interface~s_umfpack_zi_numeric->interface~s_umfpack_zi_numeric interface~s_umfpack_zi_numeric->proc~s_umfpack_ci_numeric proc~umfpack_ci_numeric umfpack_ci_numeric proc~s_umfpack_ci_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4znum~~CalledByGraph interface~umf4znum umf4znum interface~umf4znum->interface~umf4znum interface~umf4num umf4num interface~umf4num->interface~umf4znum interface~umf4num->interface~umf4num Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4znum () Arguments None public  subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4znum.html"},{"title":"umf4zscal – TOOLIB","text":"public interface umf4zscal Calls interface~~umf4zscal~~CallsGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal interface~umf4cscal umf4cscal interface~umf4zscal->interface~umf4cscal proc~umf4cscal_ip umf4cscal_ip interface~umf4zscal->proc~umf4cscal_ip proc~umf4zscal_ip umf4zscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4zscal_ip->interface~umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4zscal~~CalledByGraph interface~umf4zscal umf4zscal interface~umf4zscal->interface~umf4zscal interface~umf4scal umf4scal interface~umf4scal->interface~umf4zscal interface~umf4scal->interface~umf4scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zscal () Arguments None public  subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status","tags":"","loc":"interface/umf4zscal.html"},{"title":"umf4zsnum – TOOLIB","text":"public interface umf4zsnum Calls interface~~umf4zsnum~~CallsGraph interface~umf4zsnum umf4zsnum interface~umf4zsnum->interface~umf4zsnum proc~umf4zsnum_ip umf4zsnum_ip interface~umf4zsnum->proc~umf4zsnum_ip proc~umfpack_save_numeric umfpack_save_numeric proc~umf4zsnum_ip->proc~umfpack_save_numeric proc~umfpack_di_save_numeric umfpack_di_save_numeric proc~umfpack_save_numeric->proc~umfpack_di_save_numeric proc~umfpack_zi_save_numeric umfpack_zi_save_numeric proc~umfpack_save_numeric->proc~umfpack_zi_save_numeric interface~c_umfpack_di_save_numeric c_umfpack_di_save_numeric proc~umfpack_di_save_numeric->interface~c_umfpack_di_save_numeric interface~c_umfpack_zi_save_numeric c_umfpack_zi_save_numeric proc~umfpack_zi_save_numeric->interface~c_umfpack_zi_save_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zsnum () Arguments None public  subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4zsnum.html"},{"title":"umf4zsol – TOOLIB","text":"public interface umf4zsol Calls interface~~umf4zsol~~CallsGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol interface~umf4csol umf4csol interface~umf4zsol->interface~umf4csol proc~umf4csol_ip umf4csol_ip interface~umf4zsol->proc~umf4csol_ip proc~umf4zsol_ip umf4zsol_ip interface~umf4zsol->proc~umf4zsol_ip interface~umf4csol->interface~umf4csol interface~umf4csol->proc~umf4csol_ip proc~s_umfpack_ci_solve s_umfpack_ci_solve proc~umf4csol_ip->proc~s_umfpack_ci_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve proc~umf4zsol_ip->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4zsol~~CalledByGraph interface~umf4zsol umf4zsol interface~umf4zsol->interface~umf4zsol interface~umf4sol umf4sol interface~umf4sol->interface~umf4zsol interface~umf4sol->interface~umf4sol Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zsol () Arguments None public  subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4zsol.html"},{"title":"umf4zsolr – TOOLIB","text":"public interface umf4zsolr Calls interface~~umf4zsolr~~CallsGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr interface~umf4csolr umf4csolr interface~umf4zsolr->interface~umf4csolr proc~umf4csolr_ip umf4csolr_ip interface~umf4zsolr->proc~umf4csolr_ip proc~umf4zsolr_ip umf4zsolr_ip interface~umf4zsolr->proc~umf4zsolr_ip interface~umf4csolr->interface~umf4csolr interface~umf4csolr->proc~umf4csolr_ip interface~s_umfpack_solve s_umfpack_solve proc~umf4csolr_ip->interface~s_umfpack_solve proc~umf4zsolr_ip->interface~s_umfpack_solve interface~s_umfpack_zi_solve s_umfpack_zi_solve interface~s_umfpack_solve->interface~s_umfpack_zi_solve proc~s_umfpack_ci_solve s_umfpack_ci_solve interface~s_umfpack_solve->proc~s_umfpack_ci_solve proc~s_umfpack_di_solve s_umfpack_di_solve interface~s_umfpack_solve->proc~s_umfpack_di_solve interface~s_umfpack_zi_solve->interface~s_umfpack_zi_solve interface~s_umfpack_zi_solve->proc~s_umfpack_ci_solve proc~umfpack_ci_solve umfpack_ci_solve proc~s_umfpack_ci_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4zsolr~~CalledByGraph interface~umf4zsolr umf4zsolr interface~umf4zsolr->interface~umf4zsolr interface~umf4solr umf4solr interface~umf4solr->interface~umf4zsolr interface~umf4solr->interface~umf4solr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zsolr () Arguments None public  subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4zsolr.html"},{"title":"umf4zssym – TOOLIB","text":"public interface umf4zssym Calls interface~~umf4zssym~~CallsGraph interface~umf4zssym umf4zssym interface~umf4zssym->interface~umf4zssym proc~umf4zssym_ip umf4zssym_ip interface~umf4zssym->proc~umf4zssym_ip proc~umfpack_save_symbolic umfpack_save_symbolic proc~umf4zssym_ip->proc~umfpack_save_symbolic proc~umfpack_di_save_symbolic umfpack_di_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_di_save_symbolic proc~umfpack_zi_save_symbolic umfpack_zi_save_symbolic proc~umfpack_save_symbolic->proc~umfpack_zi_save_symbolic interface~c_umfpack_di_save_symbolic c_umfpack_di_save_symbolic proc~umfpack_di_save_symbolic->interface~c_umfpack_di_save_symbolic interface~c_umfpack_zi_save_symbolic c_umfpack_zi_save_symbolic proc~umfpack_zi_save_symbolic->interface~c_umfpack_zi_save_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zssym () Arguments None public  subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status","tags":"","loc":"interface/umf4zssym.html"},{"title":"umf4zsym – TOOLIB","text":"public interface umf4zsym Calls interface~~umf4zsym~~CallsGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym interface~umf4csym umf4csym interface~umf4zsym->interface~umf4csym proc~umf4csym_ip umf4csym_ip interface~umf4zsym->proc~umf4csym_ip proc~umf4zsym_ip umf4zsym_ip interface~umf4zsym->proc~umf4zsym_ip interface~umf4csym->interface~umf4csym interface~umf4csym->proc~umf4csym_ip interface~s_umfpack_symbolic s_umfpack_symbolic proc~umf4csym_ip->interface~s_umfpack_symbolic proc~umf4zsym_ip->interface~s_umfpack_symbolic interface~s_umfpack_zi_symbolic s_umfpack_zi_symbolic interface~s_umfpack_symbolic->interface~s_umfpack_zi_symbolic proc~s_umfpack_ci_symbolic s_umfpack_ci_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_ci_symbolic proc~s_umfpack_di_symbolic s_umfpack_di_symbolic interface~s_umfpack_symbolic->proc~s_umfpack_di_symbolic interface~s_umfpack_zi_symbolic->interface~s_umfpack_zi_symbolic interface~s_umfpack_zi_symbolic->proc~s_umfpack_ci_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic proc~s_umfpack_ci_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umf4zsym~~CalledByGraph interface~umf4zsym umf4zsym interface~umf4zsym->interface~umf4zsym interface~umf4sym umf4sym interface~umf4sym->interface~umf4zsym interface~umf4sym->interface~umf4sym Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umf4zsym () Arguments None public  subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"interface/umf4zsym.html"},{"title":"umfpack_numeric – TOOLIB","text":"public interface umfpack_numeric Calls interface~~umfpack_numeric~~CallsGraph interface~umfpack_numeric umfpack_numeric interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_numeric->proc~umfpack_ci_numeric proc~umfpack_di_numeric umfpack_di_numeric interface~umfpack_numeric->proc~umfpack_di_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_numeric () Arguments None public  function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_numeric.html"},{"title":"umfpack_scale_function – TOOLIB","text":"public interface umfpack_scale_function Calls interface~~umfpack_scale_function~~CallsGraph interface~umfpack_scale_function umfpack_scale_function interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_scale_function->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_scale_function->proc~umfpack_ci_scale proc~umfpack_di_scale umfpack_di_scale interface~umfpack_scale_function->proc~umfpack_di_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale interface~c_umfpack_di_scale c_umfpack_di_scale proc~umfpack_di_scale->interface~c_umfpack_di_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umfpack_scale_function~~CalledByGraph interface~umfpack_scale_function umfpack_scale_function proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public  interface umfpack_zi_scale () Arguments None public  function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","tags":"","loc":"interface/umfpack_scale_function.html"},{"title":"umfpack_solve – TOOLIB","text":"public interface umfpack_solve Calls interface~~umfpack_solve~~CallsGraph interface~umfpack_solve umfpack_solve interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_solve->proc~umfpack_ci_solve proc~umfpack_di_solve umfpack_di_solve interface~umfpack_solve->proc~umfpack_di_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_solve () Arguments None public  function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_solve.html"},{"title":"umfpack_symbolic – TOOLIB","text":"public interface umfpack_symbolic Calls interface~~umfpack_symbolic~~CallsGraph interface~umfpack_symbolic umfpack_symbolic interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_symbolic->proc~umfpack_ci_symbolic proc~umfpack_di_symbolic umfpack_di_symbolic interface~umfpack_symbolic->proc~umfpack_di_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_symbolic () Arguments None public  function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_symbolic.html"},{"title":"umfpack_zi_numeric – TOOLIB","text":"public interface umfpack_zi_numeric Calls interface~~umfpack_zi_numeric~~CallsGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric proc~umfpack_ci_numeric umfpack_ci_numeric interface~umfpack_zi_numeric->proc~umfpack_ci_numeric interface~c_umfpack_zi_numeric c_umfpack_zi_numeric proc~umfpack_ci_numeric->interface~c_umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umfpack_zi_numeric~~CalledByGraph interface~umfpack_zi_numeric umfpack_zi_numeric interface~umfpack_zi_numeric->interface~umfpack_zi_numeric interface~umfpack_numeric umfpack_numeric interface~umfpack_numeric->interface~umfpack_zi_numeric proc~s_umfpack_zi_numeric s_umfpack_zi_numeric proc~s_umfpack_zi_numeric->interface~umfpack_zi_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umfpack_zi_numeric () Arguments None public  function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_zi_numeric.html"},{"title":"umfpack_zi_scale – TOOLIB","text":"public interface umfpack_zi_scale Calls interface~~umfpack_zi_scale~~CallsGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale proc~umfpack_ci_scale umfpack_ci_scale interface~umfpack_zi_scale->proc~umfpack_ci_scale interface~c_umfpack_zi_scale c_umfpack_zi_scale proc~umfpack_ci_scale->interface~c_umfpack_zi_scale Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umfpack_zi_scale~~CalledByGraph interface~umfpack_zi_scale umfpack_zi_scale interface~umfpack_zi_scale->interface~umfpack_zi_scale interface~umfpack_scale_function umfpack_scale_function interface~umfpack_scale_function->interface~umfpack_zi_scale proc~s_umfpack_zi_scale s_umfpack_zi_scale proc~s_umfpack_zi_scale->interface~umfpack_zi_scale proc~umf4cscal umf4cscal proc~umf4cscal->interface~umfpack_scale_function proc~umf4cscal_ip umf4cscal_ip proc~umf4cscal_ip->interface~umfpack_scale_function proc~umf4scal umf4scal proc~umf4scal->interface~umfpack_scale_function proc~umf4scal_ip umf4scal_ip proc~umf4scal_ip->interface~umfpack_scale_function proc~umf4zscal umf4zscal proc~umf4zscal->interface~umfpack_scale_function proc~umf4zscal_ip umf4zscal_ip proc~umf4zscal_ip->interface~umfpack_scale_function interface~umf4cscal umf4cscal interface~umf4cscal->proc~umf4cscal_ip interface~umf4cscal->interface~umf4cscal interface~umf4scal umf4scal interface~umf4scal->proc~umf4cscal_ip interface~umf4scal->proc~umf4scal_ip interface~umf4scal->proc~umf4zscal_ip interface~umf4scal->interface~umf4cscal interface~umf4scal->interface~umf4scal interface~umf4zscal umf4zscal interface~umf4scal->interface~umf4zscal interface~umf4zscal->proc~umf4cscal_ip interface~umf4zscal->proc~umf4zscal_ip interface~umf4zscal->interface~umf4cscal interface~umf4zscal->interface~umf4zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umfpack_zi_scale () Arguments None public  function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer","tags":"","loc":"interface/umfpack_zi_scale.html"},{"title":"umfpack_zi_solve – TOOLIB","text":"public interface umfpack_zi_solve Calls interface~~umfpack_zi_solve~~CallsGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve proc~umfpack_ci_solve umfpack_ci_solve interface~umfpack_zi_solve->proc~umfpack_ci_solve interface~c_umfpack_zi_solve c_umfpack_zi_solve proc~umfpack_ci_solve->interface~c_umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umfpack_zi_solve~~CalledByGraph interface~umfpack_zi_solve umfpack_zi_solve interface~umfpack_zi_solve->interface~umfpack_zi_solve interface~umfpack_solve umfpack_solve interface~umfpack_solve->interface~umfpack_zi_solve proc~s_umfpack_zi_solve s_umfpack_zi_solve proc~s_umfpack_zi_solve->interface~umfpack_zi_solve Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umfpack_zi_solve () Arguments None public  function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_zi_solve.html"},{"title":"umfpack_zi_symbolic – TOOLIB","text":"public interface umfpack_zi_symbolic Calls interface~~umfpack_zi_symbolic~~CallsGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic proc~umfpack_ci_symbolic umfpack_ci_symbolic interface~umfpack_zi_symbolic->proc~umfpack_ci_symbolic interface~c_umfpack_zi_symbolic c_umfpack_zi_symbolic proc~umfpack_ci_symbolic->interface~c_umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~umfpack_zi_symbolic~~CalledByGraph interface~umfpack_zi_symbolic umfpack_zi_symbolic interface~umfpack_zi_symbolic->interface~umfpack_zi_symbolic interface~umfpack_symbolic umfpack_symbolic interface~umfpack_symbolic->interface~umfpack_zi_symbolic proc~s_umfpack_zi_symbolic s_umfpack_zi_symbolic proc~s_umfpack_zi_symbolic->interface~umfpack_zi_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures public  interface umfpack_zi_symbolic () Arguments None public  function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer","tags":"","loc":"interface/umfpack_zi_symbolic.html"},{"title":"lower – TOOLIB","text":"private  function lower(s1) result(s2) Converts uppercase to lowercase, adapted from here Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 string to transform to lower case Return Value character(len=len(s1)) result: same string but each character is lower case Called by proc~~lower~~CalledByGraph proc~lower lower proc~read_surf read_surf proc~read_surf->proc~lower proc~write_surf write_surf proc~write_surf->proc~lower program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function lower ( s1 ) result ( s2 ) !! Converts uppercase to lowercase, adapted from [here](http://fortranwiki.org/fortran/show/String_Functions) character ( * ), intent ( in ) :: s1 !! *string to transform to lower case* character ( len ( s1 )) :: s2 !! *result: same string but each character is lower case* character ( len = 1 ) :: ch integer ( kind = I4 ), parameter :: duc = ichar ( 'A' ) - ichar ( 'a' ) integer ( kind = I4 ) :: i do i = 1 , len ( s1 ) ch = s1 ( i : i ) if ( ch >= 'A' . and . ch <= 'Z' ) ch = char ( ichar ( ch ) - duc ) s2 ( i : i ) = ch enddo return endfunction lower","tags":"","loc":"proc/lower.html"},{"title":"unit2IUc – TOOLIB","text":"public  function unit2IUc(string) result(met) Convert a C type unit string into value (m) Arguments Type Intent Optional Attributes Name character(kind=C_CHAR, len=1), intent(in), dimension(:) :: string Return Value real(kind=R8) Calls proc~~unit2iuc~~CallsGraph proc~unit2iuc unit2IUc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~unit2iuc~~CalledByGraph proc~unit2iuc unit2IUc proc~build_surf build_surf proc~build_surf->proc~unit2iuc proc~trans_surf_tab trans_surf_tab proc~trans_surf_tab->proc~unit2iuc proc~read_surf read_surf proc~read_surf->proc~trans_surf_tab proc~write_surf write_surf proc~write_surf->proc~build_surf program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function unit2IUc ( string ) result ( met ) !! Convert a C type unit string into value (m) implicit none real ( kind = R8 ) :: met character ( kind = C_CHAR ), dimension (:), intent ( in ) :: string character ( len = 2 ) :: chaine chaine = string ( 1 ) // string ( 2 ) met = unit2IUf ( chaine ) return endfunction unit2IUc","tags":"","loc":"proc/unit2iuc.html"},{"title":"unit2IUf – TOOLIB","text":"public  function unit2IUf(string) result(met) Convert a unit string into value (m) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=R8) Called by proc~~unit2iuf~~CalledByGraph proc~unit2iuf unit2IUf proc~surf2scal surf2scal proc~surf2scal->proc~unit2iuf proc~unit2iuc unit2IUc proc~unit2iuc->proc~unit2iuf proc~build_surf build_surf proc~build_surf->proc~unit2iuc proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~trans_surf_tab trans_surf_tab proc~trans_surf_tab->proc~unit2iuc proc~write_surf write_surf proc~write_surf->proc~surf2scal proc~write_surf->proc~build_surf proc~read_surf read_surf proc~read_surf->proc~open_surffile proc~read_surf->proc~trans_surf_tab program~test_surfile test_surfile program~test_surfile->proc~write_surf program~test_surfile->proc~read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function unit2IUf ( string ) result ( met ) !! Convert a unit string into value (m) implicit none real ( kind = R8 ) :: met character ( * ), intent ( in ) :: string select case ( string ) case ( 'm' ) met = 1.e+00_R8 case ( 'cm' ) met = 1.e-02_R8 case ( 'mm' ) met = 1.e-03_R8 case ( 'µm' ) met = 1.e-06_R8 case ( 'µ' ) met = 1.e-06_R8 case ( 'nm' ) met = 1.e-09_R8 case ( 'pm' ) met = 1.e-12_R8 case ( 'Pa' ) met = 1.e+00_R8 case ( 'MP' ) met = 1.e+06_R8 case ( 'GP' ) met = 1.e+09_R8 case default if ( string ( 1 : 1 ) == '%' ) then met = 1.e-02_R8 else met = 1 endif endselect return endfunction unit2IUf","tags":"","loc":"proc/unit2iuf.html"},{"title":"build_surf – TOOLIB","text":"private  subroutine build_surf(surf, tab) Creates an object OBJ_SURF from an array Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf resulting object OBJ_SURF real(kind=R8), intent(in), dimension(1:surf%xres, 1:surf%yres) :: tab Calls proc~~build_surf~~CallsGraph proc~build_surf build_surf proc~unit2iuc unit2IUc proc~build_surf->proc~unit2iuc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~build_surf~~CalledByGraph proc~build_surf build_surf proc~write_surf write_surf proc~write_surf->proc~build_surf program~test_surfile test_surfile program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine build_surf ( surf , tab ) !! Creates an object [[OBJ_SURF]] from an array implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *resulting object ```OBJ_SURF```* real ( kind = R8 ), dimension ( 1 : surf % xres , 1 : surf % yres ), intent ( in ) :: tab integer ( kind = I4 ) :: i , j , k , nx , ny real ( kind = R8 ) :: max_n , min_t , max_t , mil_t , amp_t , unit_x , unit_y , unit_z nx = surf % xres ny = surf % yres surf % nofpoints = nx * ny unit_x = unit2IUc ( surf % dx_unit ) unit_y = unit2IUc ( surf % dy_unit ) unit_z = unit2IUc ( surf % dz_unit ) if ( allocated ( surf % val )) deallocate ( surf % val ) allocate ( surf % val ( 1 : surf % nofpoints )) min_t = minval ( tab ( 1 : nx , 1 : ny ) ) / unit_z max_t = maxval ( tab ( 1 : nx , 1 : ny ) ) / unit_z mil_t = 0.5_R8 * ( min_t + max_t ) ! middle of the range amp_t = max_t - min_t ! range amplitude surf % ZOffset = mil_t max_n = 0.5 * huge ( 1 ) ! the heights are integers, allowed to span ! half the positive integer range. surf % dz = amp_t / max_n ! subsequent dz k = 0 do j = 1 , ny do i = 1 , nx k = k + 1 surf % val ( k ) = nint ( ( tab ( i , j ) / unit_z - surf % ZOffset ) / surf % dz ) ! enddo enddo surf % zmin = minval ( surf % val ) surf % zmax = maxval ( surf % val ) return endsubroutine build_surf","tags":"","loc":"proc/build_surf.html"},{"title":"c_f_string – TOOLIB","text":"private  subroutine c_f_string(cs, fs, lngth_s) Note Converts a C string to a Fortran string From a memory viewpoint, a C string is like a character vector ending with a C_NULL_CHAR so, as long as it is not found, the characters are copied one by one in a fortran string Arguments Type Intent Optional Attributes Name character(kind=C_CHAR, len=1), intent(in), dimension(:) :: cs C string character(len=*), intent(out) :: fs Fortran string integer(kind=I4), intent(out) :: lngth_s resulting Fortran string length Calls proc~~c_f_string~~CallsGraph proc~c_f_string c_f_string proc~empty empty proc~c_f_string->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~c_f_string~~CalledByGraph proc~c_f_string c_f_string proc~surf2scal surf2scal proc~surf2scal->proc~c_f_string proc~trans_surf_txt trans_surf_txt proc~trans_surf_txt->proc~c_f_string proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~open_surffile->proc~trans_surf_txt proc~write_surf write_surf proc~write_surf->proc~surf2scal program~test_surfile test_surfile program~test_surfile->proc~trans_surf_txt program~test_surfile->proc~write_surf proc~read_surf read_surf program~test_surfile->proc~read_surf proc~read_surf->proc~open_surffile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine c_f_string ( cs , fs , lngth_s ) implicit none character ( kind = C_CHAR ), dimension (:), intent ( in ) :: cs !! *C string* character ( len =* ), intent ( out ) :: fs !! *Fortran string* integer ( kind = I4 ), intent ( out ) :: lngth_s !! *resulting Fortran string length* integer ( kind = I4 ) :: i , ucs ucs = size ( cs ) ! vector length lngth_s = ucs ! resulting string default length i = 1 do if ( i > ucs ) exit if ( cs ( i ) == C_NULL_CHAR ) then ! fin de chaîne c rencontrée ; s'il n'y a pas de null_char lngth_s = i - 1 ! c'est qu'on utilise tout le vecteur exit endif i = i + 1 enddo call empty ( fs ) do i = 1 , lngth_s ! the C string is translated into fortran fs ( i : i ) = cs ( i ) enddo return endsubroutine c_f_string","tags":"","loc":"proc/c_f_string.html"},{"title":"empty – TOOLIB","text":"public  subroutine empty(charinout) Just empties a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: charinout Called by proc~~empty~~CalledByGraph proc~empty empty proc~c_f_string c_f_string proc~c_f_string->proc~empty proc~init_scal init_scal proc~init_scal->proc~empty proc~trans_surf_txt trans_surf_txt proc~trans_surf_txt->proc~empty proc~trans_surf_txt->proc~c_f_string proc~open_surffile open_surffile proc~open_surffile->proc~trans_surf_txt proc~surf2scal surf2scal proc~open_surffile->proc~surf2scal proc~surf2scal->proc~c_f_string program~test_surfile test_surfile program~test_surfile->proc~init_scal program~test_surfile->proc~trans_surf_txt proc~read_surf read_surf program~test_surfile->proc~read_surf proc~write_surf write_surf program~test_surfile->proc~write_surf proc~read_surf->proc~open_surffile proc~write_surf->proc~surf2scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine empty ( charinout ) !! Just empties a string implicit none character ( len =* ), intent ( inout ) :: charinout charinout = repeat ( ' ' , len ( charinout )) return endsubroutine empty","tags":"","loc":"proc/empty.html"},{"title":"f_c_string – TOOLIB","text":"private  subroutine f_c_string(fs, cs) Note Converts a Fortran string to a C string A From a memory viewpoint, a C string is like a character vector ending with a C_NULL_CHAR ,\n  so the characters are copied one by one in a C_CHAR vector that ends with a C_NULL_CHAR Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fs fortran string character(kind=C_CHAR, len=1), intent(out), dimension(:) :: cs resulting C string Called by proc~~f_c_string~~CalledByGraph proc~f_c_string f_c_string proc~scal2surf scal2surf proc~scal2surf->proc~f_c_string proc~write_surf write_surf proc~write_surf->proc~scal2surf program~test_surfile test_surfile program~test_surfile->proc~scal2surf program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine f_c_string ( fs , cs ) implicit none character ( len =* ), intent ( in ) :: fs !! *fortran string* character ( kind = C_CHAR ), dimension (:), intent ( out ) :: cs !! *resulting C string* integer ( kind = I4 ) :: i , ufs ufs = len_trim ( fs ) ! longueur de la chaîne fortran sans les null, les blancs, ... if ( ufs == 0 ) then ! si la chaîne est vide cs ( 1 ) = C_NULL_CHAR else do i = 1 , ufs cs ( i ) = fs ( i : i ) enddo if ( ufs < size ( cs )) cs ( ufs + 1 ) = C_NULL_CHAR ! si la fin du vecteur n'est pas atteinte endif return endsubroutine f_c_string","tags":"","loc":"proc/f_c_string.html"},{"title":"init_scal – TOOLIB","text":"public  subroutine init_scal(scal, nx, ny, lx, ly, unit_z) OBJ_SURF initialization, every unit is m Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF integer(kind=I4), intent(in), optional :: nx integer(kind=I4), intent(in), optional :: ny real(kind=R8), intent(in), optional :: lx real(kind=R8), intent(in), optional :: ly character(len=*), intent(in), optional :: unit_z Calls proc~~init_scal~~CallsGraph proc~init_scal init_scal proc~empty empty proc~init_scal->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_scal~~CalledByGraph proc~init_scal init_scal program~test_surfile test_surfile program~test_surfile->proc~init_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_scal ( scal , nx , ny , lx , ly , unit_z ) !! [[OBJ_SURF]] initialization, every unit is m implicit none type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ), optional , intent ( in ) :: nx integer ( kind = I4 ), optional , intent ( in ) :: ny real ( kind = R8 ), optional , intent ( in ) :: lx real ( kind = R8 ), optional , intent ( in ) :: ly character ( * ), optional , intent ( in ) :: unit_z integer ( kind = I4 ), dimension ( 1 : 8 ) :: time_val character ( len = 256 ) :: string call date_and_time ( values = time_val ) scal % format = 0 scal % nobjects = 1 scal % version = 1 scal % type = 2 scal % material_code = 1 scal % acquisition = 0 scal % range = 0 scal % special_points = 0 scal % absolute = 1 scal % pointsize = 32 scal % zmin = 0 scal % zmax = 0 scal % xres = 0 scal % yres = 0 scal % nofpoints = 0 scal % xunit_ratio = 1. scal % yunit_ratio = 1. scal % zunit_ratio = 1. scal % imprint = 0 scal % inversion = 0 scal % leveling = 0 scal % seconds = time_val ( 7 ) scal % minutes = time_val ( 6 ) scal % hours = time_val ( 5 ) scal % day = time_val ( 3 ) scal % month = time_val ( 2 ) scal % year = time_val ( 1 ) scal % dayof = 0 scal % measurement_duration = 0.0 scal % comment_size = 0 scal % private_size = 0 scal % XOffset = 0. scal % YOffset = 0. scal % ZOffset = 0. call empty ( scal % reserved ) call empty ( scal % obsolete2 ) call empty ( scal % obsolete ) call empty ( scal % reservedzone ) call empty ( scal % client_zone ) call empty ( scal % object_name ) call empty ( scal % signature ) call empty ( scal % operator_name ) scal % object_name = 'HOME MADE' scal % signature = 'DIGITAL SURF' scal % operator_name = 'MOD_SURFILE' call empty ( scal % xaxis ) call empty ( scal % yaxis ) call empty ( scal % zaxis ) scal % xaxis = \"X\" scal % yaxis = \"Y\" scal % zaxis = \"Z\" call empty ( scal % xlength_unit ) call empty ( scal % ylength_unit ) call empty ( scal % zlength_unit ) call empty ( scal % dx_unit ) call empty ( scal % dy_unit ) call empty ( scal % dz_unit ) scal % xlength_unit = \"m\" ; scal % dx_unit = trim ( scal % xlength_unit ) ; scal % dx = 1.0 scal % ylength_unit = \"m\" ; scal % dy_unit = trim ( scal % ylength_unit ) ; scal % dy = 1.0 scal % zlength_unit = \"m\" ; scal % dz_unit = trim ( scal % zlength_unit ) ; scal % dz = 1.0 scal % mu = 0 scal % si = 0 if ( present ( nx )) scal % xres = nx if ( present ( ny )) scal % yres = ny if ( present ( lx )) scal % lx = lx if ( present ( ly )) scal % ly = ly if ( present ( nx ). and . present ( lx )) scal % dx = lx / nx if ( present ( ny ). and . present ( ly )) scal % dy = ly / ny if ( present ( unit_z )) then ; scal % zlength_unit = trim ( unit_z ) scal % dz_unit = trim ( unit_z ) ; endif return endsubroutine init_scal","tags":"","loc":"proc/init_scal.html"},{"title":"open_surffile – TOOLIB","text":"private  subroutine open_surffile(fichier, surf, scal, dump) Note Subroutine that opens a .sur file and transfers it contents into an object OBJ_SURF Warning By default here, the heights are not written with dump=.true. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be read type( OBJ_SURF ), intent(out) :: surf object that will contain the file infos and heights type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF logical(kind=I4), intent(in), optional :: dump whether to transform the data in a text file Calls proc~~open_surffile~~CallsGraph proc~open_surffile open_surffile proc~get_unit get_unit proc~open_surffile->proc~get_unit proc~surf2scal surf2scal proc~open_surffile->proc~surf2scal proc~trans_surf_txt trans_surf_txt proc~open_surffile->proc~trans_surf_txt proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~unit2iuf unit2IUf proc~surf2scal->proc~unit2iuf proc~trans_surf_txt->proc~get_unit proc~trans_surf_txt->proc~c_f_string proc~empty empty proc~trans_surf_txt->proc~empty proc~c_f_string->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_surffile~~CalledByGraph proc~open_surffile open_surffile proc~read_surf read_surf proc~read_surf->proc~open_surffile program~test_surfile test_surfile program~test_surfile->proc~read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine open_surffile ( fichier , surf , scal , dump ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be read* type ( OBJ_SURF ), intent ( out ) :: surf !! *object that will contain the file infos and heights* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* logical ( kind = I4 ), optional , intent ( in ) :: dump !! *whether to transform the data in a text file* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: scal_x , scal_y , scal_z character ( kind = C_CHAR ) :: charact call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"read\" , & ! position = \"rewind\" , & ! convert = 'little_endian' ,& ! status = 'old' ) read ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone do i = 1 , surf % comment_size read ( k ) charact enddo allocate ( surf % val ( 1 : surf % nofpoints ) ) do i = 1 , surf % nofpoints read ( k ) surf % val ( i ) enddo close ( k ) call surf2scal ( surf , scal ) if ( present ( dump ). and . dump ) call trans_surf_txt ( surf , trim ( fichier ) // '.txt' , xyz = . false .) return endsubroutine open_surffile","tags":"","loc":"proc/open_surffile.html"},{"title":"read_surf – TOOLIB","text":"public  subroutine read_surf(nom_fic, mu, sq, tab_s, scal) Note Subroutine that opens a surface file .sur or .dat The heights are centred, scaled then put into a vector. Warning If the scale factor sq is negative, the heights are not scaled when reading .sur Warning By default, the .sur header is dumped Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), optional :: mu desired mean real(kind=R8), intent(in), optional :: sq desired height standard deviation real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF Calls proc~~read_surf~~CallsGraph proc~read_surf read_surf proc~get_unit get_unit proc~read_surf->proc~get_unit proc~lower lower proc~read_surf->proc~lower proc~open_surffile open_surffile proc~read_surf->proc~open_surffile proc~sort_array2 sort_array2 proc~read_surf->proc~sort_array2 proc~trans_surf_tab trans_surf_tab proc~read_surf->proc~trans_surf_tab proc~open_surffile->proc~get_unit proc~surf2scal surf2scal proc~open_surffile->proc~surf2scal proc~trans_surf_txt trans_surf_txt proc~open_surffile->proc~trans_surf_txt proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~unit2iuc unit2IUc proc~trans_surf_tab->proc~unit2iuc proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~unit2iuf unit2IUf proc~surf2scal->proc~unit2iuf proc~trans_surf_txt->proc~get_unit proc~trans_surf_txt->proc~c_f_string proc~empty empty proc~trans_surf_txt->proc~empty proc~unit2iuc->proc~unit2iuf proc~c_f_string->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_surf~~CalledByGraph proc~read_surf read_surf program~test_surfile test_surfile program~test_surfile->proc~read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_surf ( nom_fic , mu , sq , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* real ( kind = R8 ), intent ( in ), optional :: mu !! *desired mean* real ( kind = R8 ), intent ( in ), optional :: sq !! *desired height standard deviation* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable , intent ( out ) :: tab_s !! *height array* integer ( kind = I4 ) :: style , i , ii , j , jj , k , nb , eof , tmp , nx , ny real ( kind = R8 ) :: sqs , mean , dz , lx , ly , lz type ( OBJ_SURF ) :: surf character ( len = 3 ) :: ext real ( kind = R8 ), dimension (:), allocatable :: x , y , z i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call open_surffile ( fichier = trim ( nom_fic ), surf = surf , scal = scal , dump = . false .) call trans_surf_tab ( surf = surf , tab = tab_s ) case ( SURF_DAT ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) nb = 0 do read ( k , * , iostat = eof ) if ( eof /= 0 ) exit nb = nb + 1 enddo rewind ( k ) allocate ( x ( 1 : nb ) ) allocate ( y ( 1 : nb ) ) allocate ( z ( 1 : nb ) ) do i = 1 , nb read ( k , * ) x ( i ), y ( i ), z ( i ) enddo close ( k ) ! the triplet x, y, z is sorted according x !----------------------------------------------------------- call sort_array2 ( tab_inout = x ( 1 : nb ), & ! tab1 = y ( 1 : nb ), & ! tab2 = z ( 1 : nb ), n = nb ) ! i = 1 do if ( abs ( x ( i ) - x ( 1 )) > 100 * EPS_R8 ) exit i = i + 1 enddo scal % dx = abs ( x ( i ) - x ( 1 )) j = 1 do if ( abs ( x ( j + 1 ) - x ( j )) > 1.0e-10 ) exit j = j + 1 enddo ny = j ! number of same abscissae for a given column if ( mod ( nb , ny ) /= 0 ) STOP 'READ_SURF, non rectangular mesh' nx = nb / ny scal % xres = nx scal % yres = ny do i = 1 , nx ii = ( i - 1 ) * ny + 1 jj = ii + ny - 1 call sort_array2 ( tab_inout = y ( ii : jj ), & ! tab1 = z ( ii : jj ), n = jj - ii + 1 ) ! enddo j = 1 do if ( abs ( y ( j ) - y ( 1 )) > 100 * EPS_R8 ) exit j = j + 1 enddo scal % dy = abs ( y ( j ) - y ( 1 )) allocate ( tab_s ( 1 : nx , 1 : ny ) ) k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 tab_s ( i , j ) = z ( k ) enddo enddo lx = maxval ( x ) - minval ( x ) ly = maxval ( y ) - minval ( y ) lz = maxval ( tab_s ) - minval ( tab_s ) scal % dz = lz / ( nx * ny ) scal % xlength_unit = 'm ' ; scal % dx_unit = 'm ' scal % ylength_unit = 'm ' ; scal % dy_unit = 'm ' scal % zlength_unit = 'm ' ; scal % dz_unit = 'm ' !call sort_real(g=1, d=nx*ny, rtabref=z(1:nx*ny)) !scal%dz = 1.e+10 !do i = 2, nx*ny !   dz = z(i) -z(i-1) !   if (abs(dz) < 100*EPS_R8) cycle !   scal%dz = min(scal%dz, dz) !enddo !scal%dz = dz deallocate ( x , y , z ) endselect nx = scal % xres ny = scal % yres scal % mu = sum ( tab_s ( 1 : nx , 1 : ny ) ) / ( nx * ny ) scal % si = ( sum ( ( tab_s ( 1 : nx , 1 : ny ) - scal % mu ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) ! centering ? if ( present ( mu ) ) then tab_s ( 1 : nx , 1 : ny ) = ( tab_s ( 1 : nx , 1 : ny ) - scal % mu ) + mu endif ! scaling ? if ( present ( sq ) ) then mean = sum ( tab_s ( 1 : nx , 1 : ny ) ) / ( nx * ny ) sqs = ( sum ( ( tab_s ( 1 : nx , 1 : ny ) - mean ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) tab_s ( 1 : nx , 1 : ny ) = sq * ( tab_s ( 1 : nx , 1 : ny ) - mean ) / sqs + mean endif return endsubroutine read_surf","tags":"","loc":"proc/read_surf.html"},{"title":"scal2surf – TOOLIB","text":"public  subroutine scal2surf(scal, surf) Transform a SCALE_SURF object into a OBJ_SURF object Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(in) :: scal object SCALE_SURF type( OBJ_SURF ), intent(out) :: surf object OBJ_SURF Calls proc~~scal2surf~~CallsGraph proc~scal2surf scal2surf proc~f_c_string f_c_string proc~scal2surf->proc~f_c_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scal2surf~~CalledByGraph proc~scal2surf scal2surf proc~write_surf write_surf proc~write_surf->proc~scal2surf program~test_surfile test_surfile program~test_surfile->proc~scal2surf program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine scal2surf ( scal , surf ) !! Transform a [[SCALE_SURF]] object into a [[OBJ_SURF]] object implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *object [[SCALE_SURF]]* type ( OBJ_SURF ), intent ( out ) :: surf !! *object [[OBJ_SURF]]* call f_c_string ( fs = trim ( scal % signature ), & ! cs = surf % signature ) ! call f_c_string ( fs = trim ( scal % xlength_unit ), & ! cs = surf % xlength_unit ) ! call f_c_string ( fs = trim ( scal % ylength_unit ), & ! cs = surf % ylength_unit ) ! call f_c_string ( fs = trim ( scal % zlength_unit ), & ! cs = surf % zlength_unit ) ! call f_c_string ( fs = trim ( scal % xaxis ), & ! cs = surf % xaxis ) ! call f_c_string ( fs = trim ( scal % yaxis ), & ! cs = surf % yaxis ) ! call f_c_string ( fs = trim ( scal % zaxis ), & ! cs = surf % zaxis ) ! call f_c_string ( fs = trim ( scal % dx_unit ), & ! cs = surf % dx_unit ) ! call f_c_string ( fs = trim ( scal % dy_unit ), & ! cs = surf % dy_unit ) ! call f_c_string ( fs = trim ( scal % dz_unit ), & ! cs = surf % dz_unit ) ! call f_c_string ( fs = trim ( scal % object_name ), & ! cs = surf % object_name ) ! call f_c_string ( fs = trim ( scal % operator_name ), & ! cs = surf % operator_name ) ! call f_c_string ( fs = trim ( scal % client_zone ), & ! cs = surf % client_zone ) ! call f_c_string ( fs = trim ( scal % reserved ), & ! cs = surf % reserved ) ! call f_c_string ( fs = trim ( scal % reservedzone ), & ! cs = surf % reservedzone ) ! call f_c_string ( fs = trim ( scal % obsolete ), & ! cs = surf % obsolete ) ! call f_c_string ( fs = trim ( scal % obsolete2 ), & ! cs = surf % obsolete2 ) ! surf % dx = scal % dx surf % dy = scal % dy surf % dz = scal % dz surf % xunit_ratio = scal % xunit_ratio surf % yunit_ratio = scal % yunit_ratio surf % zunit_ratio = scal % zunit_ratio surf % XOffset = scal % XOffset surf % YOffset = scal % YOffset surf % ZOffset = scal % ZOffset surf % measurement_duration = scal % measurement_duration surf % zmin = scal % zmin surf % zmax = scal % zmax surf % xres = scal % xres surf % yres = scal % yres surf % nofpoints = scal % nofpoints surf % format = scal % format surf % version = scal % version surf % material_code = scal % material_code surf % type = scal % type surf % range = scal % range surf % special_points = scal % special_points surf % absolute = scal % absolute surf % pointsize = scal % pointsize surf % imprint = scal % imprint surf % inversion = scal % inversion surf % leveling = scal % leveling surf % seconds = scal % seconds surf % minutes = scal % minutes surf % hours = scal % hours surf % day = scal % day surf % month = scal % month surf % year = scal % year surf % dayof = scal % dayof surf % comment_size = scal % comment_size surf % private_size = scal % private_size surf % nobjects = scal % nobjects surf % acquisition = scal % acquisition return endsubroutine scal2surf","tags":"","loc":"proc/scal2surf.html"},{"title":"surf2scal – TOOLIB","text":"public  subroutine surf2scal(surf, scal) Transform a OBJ_SURF object into a SCALE_SURF object Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF Calls proc~~surf2scal~~CallsGraph proc~surf2scal surf2scal proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~unit2iuf unit2IUf proc~surf2scal->proc~unit2iuf proc~empty empty proc~c_f_string->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~surf2scal~~CalledByGraph proc~surf2scal surf2scal proc~open_surffile open_surffile proc~open_surffile->proc~surf2scal proc~write_surf write_surf proc~write_surf->proc~surf2scal proc~read_surf read_surf proc~read_surf->proc~open_surffile program~test_surfile test_surfile program~test_surfile->proc~write_surf program~test_surfile->proc~read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine surf2scal ( surf , scal ) !! Transform a [[OBJ_SURF]] object into a [[SCALE_SURF]] object implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ) :: i call c_f_string ( cs = surf % signature , & ! fs = scal % signature , & ! lngth_s = i ) ! call c_f_string ( cs = surf % xlength_unit , & ! fs = scal % xlength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % ylength_unit , & ! fs = scal % ylength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % zlength_unit , & ! fs = scal % zlength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % xaxis , & ! fs = scal % xaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % yaxis , & ! fs = scal % yaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % zaxis , & ! fs = scal % zaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dx_unit , & ! fs = scal % dx_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dy_unit , & ! fs = scal % dy_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dz_unit , & ! fs = scal % dz_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % object_name , & ! fs = scal % object_name , & ! lngth_s = i ) ! call c_f_string ( cs = surf % operator_name , & ! fs = scal % operator_name , & ! lngth_s = i ) ! call c_f_string ( cs = surf % client_zone , & ! fs = scal % client_zone , & ! lngth_s = i ) ! call c_f_string ( cs = surf % reserved , & ! fs = scal % reserved , & ! lngth_s = i ) ! call c_f_string ( cs = surf % reservedzone , & ! fs = scal % reservedzone , & ! lngth_s = i ) ! call c_f_string ( cs = surf % obsolete , & ! fs = scal % obsolete , & ! lngth_s = i ) ! call c_f_string ( cs = surf % obsolete2 , & ! fs = scal % obsolete2 , & ! lngth_s = i ) ! scal % dx = surf % dx scal % dy = surf % dy scal % dz = surf % dz scal % xunit_ratio = surf % xunit_ratio scal % yunit_ratio = surf % yunit_ratio scal % zunit_ratio = surf % zunit_ratio scal % XOffset = surf % XOffset scal % YOffset = surf % YOffset scal % ZOffset = surf % ZOffset scal % measurement_duration = surf % measurement_duration scal % zmin = surf % zmin scal % zmax = surf % zmax scal % xres = surf % xres scal % yres = surf % yres scal % nofpoints = surf % nofpoints scal % format = surf % format scal % version = surf % version scal % material_code = surf % material_code scal % type = surf % type scal % range = surf % range scal % special_points = surf % special_points scal % absolute = surf % absolute scal % pointsize = surf % pointsize scal % imprint = surf % imprint scal % inversion = surf % inversion scal % leveling = surf % leveling scal % seconds = surf % seconds scal % minutes = surf % minutes scal % hours = surf % hours scal % day = surf % day scal % month = surf % month scal % year = surf % year scal % dayof = surf % dayof scal % comment_size = surf % comment_size scal % private_size = surf % private_size scal % nobjects = surf % nobjects scal % acquisition = surf % acquisition scal % lx = scal % dx * scal % xres * unit2IUf ( scal % dx_unit ) scal % ly = scal % dy * scal % yres * unit2IUf ( scal % dy_unit ) return endsubroutine surf2scal","tags":"","loc":"proc/surf2scal.html"},{"title":"trans_surf_tab – TOOLIB","text":"private  subroutine trans_surf_tab(surf, tab) Write the heights of an OBJ_SURF object into a 2D array Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF that contains the heights real(kind=R8), intent(out), dimension(:, :), allocatable :: tab height array Calls proc~~trans_surf_tab~~CallsGraph proc~trans_surf_tab trans_surf_tab proc~unit2iuc unit2IUc proc~trans_surf_tab->proc~unit2iuc proc~unit2iuf unit2IUf proc~unit2iuc->proc~unit2iuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trans_surf_tab~~CalledByGraph proc~trans_surf_tab trans_surf_tab proc~read_surf read_surf proc~read_surf->proc~trans_surf_tab program~test_surfile test_surfile program~test_surfile->proc~read_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_surf_tab ( surf , tab ) !! Write the heights of an [[OBJ_SURF]] object into a 2D array implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` that contains the heights* real ( kind = R8 ), dimension (:, :), allocatable , intent ( out ) :: tab !! *height array* integer ( kind = I4 ) :: long , larg , i , j , k real ( kind = R8 ) :: unit_z long = surf % xres larg = surf % yres allocate ( tab ( 1 : long , 1 : larg ) ) unit_z = unit2IUc ( surf % dz_unit ) do j = 1 , larg do i = 1 , long k = ( j - 1 ) * long + i tab ( i , j ) = ( surf % val ( k ) * surf % dz + surf % Zoffset ) * unit_z enddo enddo deallocate ( surf % val ) return endsubroutine trans_surf_tab","tags":"","loc":"proc/trans_surf_tab.html"},{"title":"trans_surf_txt – TOOLIB","text":"public  subroutine trans_surf_txt(surf, fichier, xyz) Note Writes an OBJ_SURF object in a text file The object components are first written in a fortran string, then it is written into\n  the file with a comment Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF character(len=*), intent(in) :: fichier text file to write logical(kind=I4), intent(in) :: xyz whether to also write the heights (maybe huge) Calls proc~~trans_surf_txt~~CallsGraph proc~trans_surf_txt trans_surf_txt proc~c_f_string c_f_string proc~trans_surf_txt->proc~c_f_string proc~empty empty proc~trans_surf_txt->proc~empty proc~get_unit get_unit proc~trans_surf_txt->proc~get_unit proc~c_f_string->proc~empty Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trans_surf_txt~~CalledByGraph proc~trans_surf_txt trans_surf_txt proc~open_surffile open_surffile proc~open_surffile->proc~trans_surf_txt program~test_surfile test_surfile program~test_surfile->proc~trans_surf_txt proc~read_surf read_surf program~test_surfile->proc~read_surf proc~read_surf->proc~open_surffile Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine trans_surf_txt ( surf , fichier , xyz ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* character ( len =* ), intent ( in ) :: fichier !! *text file to write* logical ( kind = I4 ), intent ( in ) :: xyz !! *whether to also write the heights (maybe huge)* integer ( kind = I4 ) :: i , k , s character ( len = 512 ) :: string , cc call get_unit ( k ) open ( k , file = trim ( fichier )) call c_f_string ( cs = surf % signature , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"signature              \" ; call empty ( cc ) write ( cc , * ) surf % format ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"format                 \" ; call empty ( cc ) write ( cc , * ) surf % nobjects ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nobjects               \" ; call empty ( cc ) write ( cc , * ) surf % version ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"version                \" ; call empty ( cc ) write ( cc , * ) surf % type ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"type                   \" ; call empty ( cc ) call c_f_string ( cs = surf % object_name , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"object_name            \" ; call empty ( cc ) call c_f_string ( cs = surf % operator_name , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"operator_name          \" ; call empty ( cc ) write ( cc , * ) surf % material_code ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"material_code          \" ; call empty ( cc ) write ( cc , * ) surf % acquisition ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"acquisition            \" ; call empty ( cc ) write ( cc , * ) surf % range ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"range                  \" ; call empty ( cc ) write ( cc , * ) surf % special_points ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"special_points         \" ; call empty ( cc ) write ( cc , * ) surf % absolute ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"absolute               \" ; call empty ( cc ) call c_f_string ( cs = surf % reserved , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reserved               \" ; call empty ( cc ) write ( cc , * ) surf % pointsize ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"pointsize              \" ; call empty ( cc ) write ( cc , * ) surf % zmin ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmin                   \" ; call empty ( cc ) write ( cc , * ) surf % zmax ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmax                   \" ; call empty ( cc ) write ( cc , * ) surf % xres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xres                   \" ; call empty ( cc ) write ( cc , * ) surf % yres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yres                   \" ; call empty ( cc ) write ( cc , * ) surf % nofpoints ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nofpoints              \" ; call empty ( cc ) write ( cc , * ) surf % dx ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx                     \" ; call empty ( cc ) write ( cc , * ) surf % dy ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy                     \" ; call empty ( cc ) write ( cc , * ) surf % dz ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz                     \" ; call empty ( cc ) call c_f_string ( cs = surf % xaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % yaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % zaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % dx_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dy_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dz_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % xlength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xlength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % ylength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ylength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % zlength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zlength_unit           \" ; call empty ( cc ) write ( cc , * ) surf % xunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % yunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % zunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % imprint ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"imprint                \" ; call empty ( cc ) write ( cc , * ) surf % inversion ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"inversion              \" ; call empty ( cc ) write ( cc , * ) surf % leveling ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"leveling               \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete               \" ; call empty ( cc ) write ( cc , * ) surf % seconds ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"seconds                \" ; call empty ( cc ) write ( cc , * ) surf % minutes ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"minutes                \" ; call empty ( cc ) write ( cc , * ) surf % hours ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"hours                  \" ; call empty ( cc ) write ( cc , * ) surf % day ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"day                    \" ; call empty ( cc ) write ( cc , * ) surf % month ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"month                  \" ; call empty ( cc ) write ( cc , * ) surf % year ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"year                   \" ; call empty ( cc ) write ( cc , * ) surf % dayof ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dayof                  \" ; call empty ( cc ) write ( cc , * ) surf % measurement_duration ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"measurement_duration   \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete2 , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete2              \" ; call empty ( cc ) write ( cc , * ) surf % comment_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"comment_size           \" ; call empty ( cc ) write ( cc , * ) surf % private_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"private_size           \" ; call empty ( cc ) call c_f_string ( cs = surf % client_zone , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"client_zone            \" ; call empty ( cc ) write ( cc , * ) surf % XOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"XOffset                \" ; call empty ( cc ) write ( cc , * ) surf % YOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"YOffset                \" ; call empty ( cc ) write ( cc , * ) surf % ZOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ZOffset                \" ; call empty ( cc ) call c_f_string ( cs = surf % reservedzone , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reservedzone           \" ; call empty ( cc ) if ( xyz ) then do i = 0 , surf % nofpoints - 1 write ( k , * ) mod ( i , surf % xres ) * surf % dx , ( i / surf % xres ) * surf % dy , surf % val ( i + 1 ) * surf % dz enddo endif close ( k ) return endsubroutine trans_surf_txt","tags":"","loc":"proc/trans_surf_txt.html"},{"title":"write_surf – TOOLIB","text":"public  subroutine write_surf(nom_fic, tab_s, scal) Writes a height array into a surface file .sur or .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_s type( SCALE_SURF ), intent(inout) :: scal object SCALE_SURF Calls proc~~write_surf~~CallsGraph proc~write_surf write_surf proc~build_surf build_surf proc~write_surf->proc~build_surf proc~get_unit get_unit proc~write_surf->proc~get_unit proc~lower lower proc~write_surf->proc~lower proc~scal2surf scal2surf proc~write_surf->proc~scal2surf proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~write_surffile write_surffile proc~write_surf->proc~write_surffile proc~unit2iuc unit2IUc proc~build_surf->proc~unit2iuc proc~f_c_string f_c_string proc~scal2surf->proc~f_c_string proc~c_f_string c_f_string proc~surf2scal->proc~c_f_string proc~unit2iuf unit2IUf proc~surf2scal->proc~unit2iuf proc~write_surffile->proc~get_unit proc~empty empty proc~c_f_string->proc~empty proc~unit2iuc->proc~unit2iuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_surf~~CalledByGraph proc~write_surf write_surf program~test_surfile test_surfile program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_surf ( nom_fic , tab_s , scal ) !! Writes a height array into a surface file ```.sur``` or ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* type ( SCALE_SURF ), intent ( inout ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension ( 1 : scal % xres , 1 : scal % yres ), intent ( in ) :: tab_s character ( len = 3 ) :: ext integer ( kind = I4 ) :: style , i , j , k type ( OBJ_SURF ) :: surf_s real ( kind = R8 ) :: dx , dy i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call scal2surf ( scal , surf_s ) call build_surf ( surf = surf_s , tab = tab_s ( 1 : scal % xres , 1 : scal % yres )) surf_s % comment_size = 0 ! to increase compatibility with mountains surf_s % material_code = 1 ! to increase compatibility with mountains surf_s % type = 2 ! to increase compatibility with mountains surf_s % range = 0 ! to increase compatibility with mountains surf_s % imprint = 0 ! to increase compatibility with mountains call write_surffile ( fichier = trim ( nom_fic ), surf = surf_s ) call surf2scal ( surf_s , scal ) case ( SURF_DAT ) dx = scal % dx dy = scal % dy call get_unit ( k ) open ( k , file = trim ( nom_fic )) do i = 1 , scal % xres do j = 1 , scal % yres write ( k , * ) ( i - 1 ) * dx , ( j - 1 ) * dy , tab_s ( i , j ) enddo enddo close ( k ) endselect return endsubroutine write_surf","tags":"","loc":"proc/write_surf.html"},{"title":"write_surffile – TOOLIB","text":"private  subroutine write_surffile(fichier, surf) Write an object OBJ_SURF in a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be written type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF to write Calls proc~~write_surffile~~CallsGraph proc~write_surffile write_surffile proc~get_unit get_unit proc~write_surffile->proc~get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_surffile~~CalledByGraph proc~write_surffile write_surffile proc~write_surf write_surf proc~write_surf->proc~write_surffile program~test_surfile test_surfile program~test_surfile->proc~write_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_surffile ( fichier , surf ) !! Write an object [[OBJ_SURF]] in a file implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be written* type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` to write* integer ( kind = I4 ) :: i , k call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"write\" , & ! position = \"rewind\" , & ! status = \"replace\" , & ! convert = 'little_endian' ) write ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone , & ( surf % val ( i ), i = 1 , surf % nofpoints ) close ( k ) return endsubroutine write_surffile","tags":"","loc":"proc/write_surffile.html"},{"title":"chkder_f – TOOLIB","text":"subroutine chkder_f(n, x, fvec, fjac, ldfjac, iflag) CHKDER_F is a function/jacobian routine for use with CHKDER_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag Called by proc~~chkder_f~~CalledByGraph proc~chkder_f chkder_f proc~chkder_test chkder_test proc~chkder_test->proc~chkder_f program~test_minpack test_minpack program~test_minpack->proc~chkder_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/chkder_f.html"},{"title":"chkder_test – TOOLIB","text":"subroutine chkder_test() CHKDER_TEST tests CHKDER. Arguments None Calls proc~~chkder_test~~CallsGraph proc~chkder_test chkder_test proc~chkder chkder proc~chkder_test->proc~chkder proc~chkder_f chkder_f proc~chkder_test->proc~chkder_f proc~r8vec_print r8vec_print proc~chkder_test->proc~r8vec_print Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chkder_test~~CalledByGraph proc~chkder_test chkder_test program~test_minpack test_minpack program~test_minpack->proc~chkder_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/chkder_test.html"},{"title":"hybrd1_f – TOOLIB","text":"subroutine hybrd1_f(n, x, fvec, iflag) HYBRD1_F is a function routine for use with HYBRD1_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) integer :: iflag Called by proc~~hybrd1_f~~CalledByGraph proc~hybrd1_f hybrd1_f proc~hybrd1_test hybrd1_test proc~hybrd1_test->proc~hybrd1_f proc~hybrj1_test hybrj1_test proc~hybrj1_test->proc~hybrd1_f program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hybrd1_f.html"},{"title":"hybrd1_test – TOOLIB","text":"subroutine hybrd1_test() HYBRD1_TEST tests HYBRD1. Arguments None Calls proc~~hybrd1_test~~CallsGraph proc~hybrd1_test hybrd1_test proc~hybrd1 hybrd1 proc~hybrd1_test->proc~hybrd1 proc~hybrd1_f hybrd1_f proc~hybrd1_test->proc~hybrd1_f proc~r8vec_print r8vec_print proc~hybrd1_test->proc~r8vec_print proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~dogleg dogleg proc~hybrd->proc~dogleg proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrd1_test~~CalledByGraph proc~hybrd1_test hybrd1_test program~test_minpack test_minpack program~test_minpack->proc~hybrd1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hybrd1_test.html"},{"title":"hybrj1_f – TOOLIB","text":"subroutine hybrj1_f(n, x, fvec, fjac, ldfjac, iflag) HYBRJ1_F is a function/jacobian routine for use with HYBRJ1_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag","tags":"","loc":"proc/hybrj1_f.html"},{"title":"hybrj1_test – TOOLIB","text":"subroutine hybrj1_test() HYBRJ1_TEST tests HYBRJ1. Arguments None Calls proc~~hybrj1_test~~CallsGraph proc~hybrj1_test hybrj1_test proc~hybrd1_f hybrd1_f proc~hybrj1_test->proc~hybrd1_f proc~hybrj1 hybrj1 proc~hybrj1_test->proc~hybrj1 proc~r8vec_print r8vec_print proc~hybrj1_test->proc~r8vec_print proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~dogleg dogleg proc~hybrj->proc~dogleg proc~enorm enorm proc~hybrj->proc~enorm proc~qform qform proc~hybrj->proc~qform proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~r1updt r1updt proc~hybrj->proc~r1updt proc~dogleg->proc~enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~hybrj1_test~~CalledByGraph proc~hybrj1_test hybrj1_test program~test_minpack test_minpack program~test_minpack->proc~hybrj1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/hybrj1_test.html"},{"title":"lmder1_2_f – TOOLIB","text":"subroutine lmder1_2_f(m, n, x, fvec, fjac, ldfjac, iflag) LMDER1_2_F is a function/jacobian routine for use with LMDER1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag Called by proc~~lmder1_2_f~~CalledByGraph proc~lmder1_2_f lmder1_2_f proc~lmder1_2_test lmder1_2_test proc~lmder1_2_test->proc~lmder1_2_f program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmder1_2_f.html"},{"title":"lmder1_2_test – TOOLIB","text":"subroutine lmder1_2_test() LMDER1_2_TEST tests LMDER1. Arguments None Calls proc~~lmder1_2_test~~CallsGraph proc~lmder1_2_test lmder1_2_test proc~lmder1 lmder1 proc~lmder1_2_test->proc~lmder1 proc~lmder1_2_f lmder1_2_f proc~lmder1_2_test->proc~lmder1_2_f proc~r8vec_print r8vec_print proc~lmder1_2_test->proc~r8vec_print proc~lmder lmder proc~lmder1->proc~lmder proc~enorm enorm proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~qrfac qrfac proc~lmder->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmder1_2_test~~CalledByGraph proc~lmder1_2_test lmder1_2_test program~test_minpack test_minpack program~test_minpack->proc~lmder1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmder1_2_test.html"},{"title":"lmder1_f – TOOLIB","text":"subroutine lmder1_f(m, n, x, fvec, fjac, ldfjac, iflag) LMDER1_F is a function/jacobian routine for use with LMDER1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag Called by proc~~lmder1_f~~CalledByGraph proc~lmder1_f lmder1_f proc~lmder1_test lmder1_test proc~lmder1_test->proc~lmder1_f program~test_minpack test_minpack program~test_minpack->proc~lmder1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmder1_f.html"},{"title":"lmder1_test – TOOLIB","text":"subroutine lmder1_test() LMDER1_TEST tests LMDER1. Arguments None Calls proc~~lmder1_test~~CallsGraph proc~lmder1_test lmder1_test proc~lmder1 lmder1 proc~lmder1_test->proc~lmder1 proc~lmder1_f lmder1_f proc~lmder1_test->proc~lmder1_f proc~r8vec_print r8vec_print proc~lmder1_test->proc~r8vec_print proc~lmder lmder proc~lmder1->proc~lmder proc~enorm enorm proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~qrfac qrfac proc~lmder->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmder1_test~~CalledByGraph proc~lmder1_test lmder1_test program~test_minpack test_minpack program~test_minpack->proc~lmder1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmder1_test.html"},{"title":"lmdif1_2_f – TOOLIB","text":"subroutine lmdif1_2_f(m, n, x, fvec, iflag) LMDIF1_2_F is a function routine for use with LMDIF1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) integer :: iflag Called by proc~~lmdif1_2_f~~CalledByGraph proc~lmdif1_2_f lmdif1_2_f proc~lmdif1_2_test lmdif1_2_test proc~lmdif1_2_test->proc~lmdif1_2_f program~test_minpack test_minpack program~test_minpack->proc~lmdif1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmdif1_2_f.html"},{"title":"lmdif1_2_test – TOOLIB","text":"subroutine lmdif1_2_test() LMDIF1_2_TEST tests LMDIF1. Arguments None Calls proc~~lmdif1_2_test~~CallsGraph proc~lmdif1_2_test lmdif1_2_test proc~lmdif1 lmdif1 proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_2_f lmdif1_2_f proc~lmdif1_2_test->proc~lmdif1_2_f proc~r8vec_print r8vec_print proc~lmdif1_2_test->proc~r8vec_print proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~enorm enorm proc~lmdif->proc~enorm proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~lmpar lmpar proc~lmdif->proc~lmpar proc~qrfac qrfac proc~lmdif->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmdif1_2_test~~CalledByGraph proc~lmdif1_2_test lmdif1_2_test program~test_minpack test_minpack program~test_minpack->proc~lmdif1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmdif1_2_test.html"},{"title":"lmdif1_f – TOOLIB","text":"subroutine lmdif1_f(m, n, x, fvec, iflag) LMDIF1_F is a function routine for use with LMDIF1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) integer :: iflag Called by proc~~lmdif1_f~~CalledByGraph proc~lmdif1_f lmdif1_f proc~lmdif1_test lmdif1_test proc~lmdif1_test->proc~lmdif1_f program~test_minpack test_minpack program~test_minpack->proc~lmdif1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmdif1_f.html"},{"title":"lmdif1_test – TOOLIB","text":"subroutine lmdif1_test() LMDIF1_TEST tests LMDIF1. Arguments None Calls proc~~lmdif1_test~~CallsGraph proc~lmdif1_test lmdif1_test proc~lmdif1 lmdif1 proc~lmdif1_test->proc~lmdif1 proc~lmdif1_f lmdif1_f proc~lmdif1_test->proc~lmdif1_f proc~r8vec_print r8vec_print proc~lmdif1_test->proc~r8vec_print proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~enorm enorm proc~lmdif->proc~enorm proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~lmpar lmpar proc~lmdif->proc~lmpar proc~qrfac qrfac proc~lmdif->proc~qrfac proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmdif1_test~~CalledByGraph proc~lmdif1_test lmdif1_test program~test_minpack test_minpack program~test_minpack->proc~lmdif1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmdif1_test.html"},{"title":"lmstr1_2_f – TOOLIB","text":"subroutine lmstr1_2_f(m, n, x, fvec, fjrow, iflag) LMSTR1_2_F is a function/jacobian routine for use with LMSTR1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjrow (n) integer :: iflag Called by proc~~lmstr1_2_f~~CalledByGraph proc~lmstr1_2_f lmstr1_2_f proc~lmstr1_2_test lmstr1_2_test proc~lmstr1_2_test->proc~lmstr1_2_f program~test_minpack test_minpack program~test_minpack->proc~lmstr1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmstr1_2_f.html"},{"title":"lmstr1_2_test – TOOLIB","text":"subroutine lmstr1_2_test() LMSTR1_2_TEST tests LMSTR1. Arguments None Calls proc~~lmstr1_2_test~~CallsGraph proc~lmstr1_2_test lmstr1_2_test proc~lmstr1 lmstr1 proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_2_f lmstr1_2_f proc~lmstr1_2_test->proc~lmstr1_2_f proc~r8vec_print r8vec_print proc~lmstr1_2_test->proc~r8vec_print proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~enorm enorm proc~lmstr->proc~enorm proc~lmpar lmpar proc~lmstr->proc~lmpar proc~qrfac qrfac proc~lmstr->proc~qrfac proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmstr1_2_test~~CalledByGraph proc~lmstr1_2_test lmstr1_2_test program~test_minpack test_minpack program~test_minpack->proc~lmstr1_2_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmstr1_2_test.html"},{"title":"lmstr1_f – TOOLIB","text":"subroutine lmstr1_f(m, n, x, fvec, fjrow, iflag) LMSTR1_F is a function/jacobian routine for use with LMSTR1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjrow (n) integer :: iflag Called by proc~~lmstr1_f~~CalledByGraph proc~lmstr1_f lmstr1_f proc~lmstr1_test lmstr1_test proc~lmstr1_test->proc~lmstr1_f program~test_minpack test_minpack program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmstr1_f.html"},{"title":"lmstr1_test – TOOLIB","text":"subroutine lmstr1_test() LMSTR1_TEST tests LMSTR1. Arguments None Calls proc~~lmstr1_test~~CallsGraph proc~lmstr1_test lmstr1_test proc~lmstr1 lmstr1 proc~lmstr1_test->proc~lmstr1 proc~lmstr1_f lmstr1_f proc~lmstr1_test->proc~lmstr1_f proc~r8vec_print r8vec_print proc~lmstr1_test->proc~r8vec_print proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~enorm enorm proc~lmstr->proc~enorm proc~lmpar lmpar proc~lmstr->proc~lmpar proc~qrfac qrfac proc~lmstr->proc~qrfac proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lmstr1_test~~CalledByGraph proc~lmstr1_test lmstr1_test program~test_minpack test_minpack program~test_minpack->proc~lmstr1_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/lmstr1_test.html"},{"title":"qform_test – TOOLIB","text":"subroutine qform_test() QFORM_TEST tests QFORM. Arguments None Calls proc~~qform_test~~CallsGraph proc~qform_test qform_test proc~qform qform proc~qform_test->proc~qform proc~qrfac qrfac proc~qform_test->proc~qrfac proc~r8mat_print r8mat_print proc~qform_test->proc~r8mat_print proc~enorm enorm proc~qrfac->proc~enorm proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~qform_test~~CalledByGraph proc~qform_test qform_test program~test_minpack test_minpack program~test_minpack->proc~qform_test Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/qform_test.html"},{"title":"tcheby – TOOLIB","text":"public  function tcheby(n, x) Note Valeur en x du polynôme de Tchebichev de degré n Site Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n degré du polynôme real(kind=R8), intent(in) :: x variable Return Value real(kind=R8) Called by proc~~tcheby~~CalledByGraph proc~tcheby tcheby proc~genere_surf_poly genere_surf_poly proc~genere_surf_poly->proc~tcheby proc~tab_tcheby tab_tcheby proc~tab_tcheby->proc~tcheby proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~tab_tcheby program~test_tchebychev test_tchebychev program~test_tchebychev->proc~genere_surf_poly program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function tcheby ( n , x ) implicit none real ( kind = R8 ) :: tcheby integer ( kind = I4 ), intent ( in ) :: n !! *degré du polynôme* real ( kind = R8 ), intent ( in ) :: x !! *variable* integer ( kind = I4 ) :: k , kk real ( kind = R8 ) :: y , tmp if ( n == 0 ) then tcheby = 1._R8 return endif tmp = 0. do k = 1 , n / 2 y = 1._R8 do kk = 1 , k - 1 y = y * ( real (( n - k - kk ), kind = R8 ) / kk ) enddo tmp = tmp + y * (( - 1 ) ** k ) * (( 2 * x ) ** ( n - 2 * k )) / k enddo tcheby = (( 2 * x ) ** n ) / 2 + n * tmp / 2. return endfunction tcheby","tags":"","loc":"proc/tcheby.html"},{"title":"coeff_poly_tcheby_xy_vers_poly_monome – TOOLIB","text":"public  subroutine coeff_poly_tcheby_xy_vers_poly_monome(var, coeff_m, deg_x, deg_y) Transformation d’une CL de produits de polynômes de Tchebychev en x et y en polynôme classique Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:(deg_x+1)*(deg_y+1)) :: var coefficients du produits de polynômes de Tchebychev real(kind=R8), intent(out), dimension(1:(deg_x+1)*(deg_y+1)) :: coeff_m coefficients du polynôme classique en x et y integer(kind=I4), intent(in) :: deg_x degré du polynôme en x integer(kind=I4), intent(in) :: deg_y degré du polynôme en y Calls proc~~coeff_poly_tcheby_xy_vers_poly_monome~~CallsGraph proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_poly_tcheby_xy_vers_poly_monome->proc~coeff_tcheby_xy_vers_monome proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~coeff_tcheby_xy_vers_monome->proc~coeff_tcheby_vers_monome Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~coeff_poly_tcheby_xy_vers_poly_monome~~CalledByGraph proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~coeff_poly_tcheby_xy_vers_poly_monome program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine coeff_poly_tcheby_xy_vers_poly_monome ( var , coeff_m , deg_x , deg_y ) !! Transformation d'une CL de produits de polynômes de Tchebychev en x et y en polynôme classique implicit none integer ( kind = I4 ), intent ( in ) :: deg_x !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: deg_y !! *degré du polynôme en y* real ( kind = R8 ), intent ( in ), dimension ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) :: var !! *coefficients du produits de polynômes de Tchebychev* real ( kind = R8 ), intent ( out ), dimension ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) :: coeff_m !! *coefficients du polynôme classique en x et y* integer ( kind = I4 ) :: i , j , ij real ( kind = R8 ), dimension ( 0 : deg_x , 0 : deg_y ) :: tab_poly__m , tab_coeff_m coeff_m ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) = 0._R8 tab_poly__m ( 0 : deg_x , 0 : deg_y ) = 0._R8 ij = 0 do j = 0 , deg_y do i = 0 , deg_x ij = ij + 1 call coeff_tcheby_xy_vers_monome ( tab_coeff_m ( 0 : i , 0 : j ), deg_x = i , deg_y = j ) tab_coeff_m ( 0 : i , 0 : j ) = var ( ij ) * tab_coeff_m ( 0 : i , 0 : j ) tab_poly__m ( 0 : i , 0 : j ) = tab_poly__m ( 0 : i , 0 : j ) + tab_coeff_m ( 0 : i , 0 : j ) enddo enddo ij = 0 do j = 0 , deg_y do i = 0 , deg_x ij = ij + 1 coeff_m ( ij ) = tab_poly__m ( i , j ) enddo enddo return endsubroutine coeff_poly_tcheby_xy_vers_poly_monome","tags":"","loc":"proc/coeff_poly_tcheby_xy_vers_poly_monome.html"},{"title":"coeff_tcheby_vers_monome – TOOLIB","text":"public  subroutine coeff_tcheby_vers_monome(coeff_t, coeff_m, deg) Note Transformation des coefficients de Tchebychev en coefficients de monômes Un monôme de degré p reçoit de Ti(x) (polynôme de Tcheby de degré i) : Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(0:deg) :: coeff_t coefficients de la CL de polynômes de Tchebychev real(kind=R8), intent(out), dimension(0:deg) :: coeff_m coefficients de la CL de monômes integer(kind=I4), intent(in) :: deg degré du polynôme Called by proc~~coeff_tcheby_vers_monome~~CalledByGraph proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_tcheby_xy_vers_monome->proc~coeff_tcheby_vers_monome proc~genere_surf_poly genere_surf_poly proc~genere_surf_poly->proc~coeff_tcheby_vers_monome proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~coeff_poly_tcheby_xy_vers_poly_monome->proc~coeff_tcheby_xy_vers_monome program~test_tchebychev test_tchebychev program~test_tchebychev->proc~genere_surf_poly proc~least_squares_tcheby least_squares_tcheby program~test_tchebychev->proc~least_squares_tcheby proc~least_squares_tcheby->proc~coeff_poly_tcheby_xy_vers_poly_monome Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine coeff_tcheby_vers_monome ( coeff_t , coeff_m , deg ) implicit none integer ( kind = I4 ), intent ( in ) :: deg !! *degré du polynôme* real ( kind = R8 ), intent ( in ), dimension ( 0 : deg ) :: coeff_t !! *coefficients de la CL de polynômes de Tchebychev* real ( kind = R8 ), intent ( out ), dimension ( 0 : deg ) :: coeff_m !! *coefficients de la CL de monômes* integer ( kind = I4 ) :: k , n , p , q real ( kind = R8 ) :: tkm2q , tmp n = deg coeff_m ( 0 : deg ) = 0._R8 select case ( n ) case ( 0 ) coeff_m ( 0 ) = coeff_t ( 0 ) case ( 1 ) coeff_m ( 0 : 1 ) = [ coeff_t ( 0 ) , coeff_t ( 1 ) ] case ( 2 ) coeff_m ( 0 : 2 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) , 2 * coeff_t ( 2 ) ] case ( 3 ) coeff_m ( 0 : 3 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) - 3 * coeff_t ( 3 ), 2 * coeff_t ( 2 ), 4 * coeff_t ( 3 ) ] case ( 4 :) coeff_m ( 0 : 3 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) - 3 * coeff_t ( 3 ), 2 * coeff_t ( 2 ), 4 * coeff_t ( 3 ) ] do k = 4 , n q = 0 coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * ( 2 ** ( k - 1 )) q = 1 coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * ( - k / 2._R8 ) * ( 2 ** ( k - 2 )) do q = 2 , k / 2 tmp = 1._R8 do p = 1 , q - 1 tmp = tmp * ( ( k - q - p ) / ( 1._R8 * p ) ) enddo tkm2q = ( k / 2._R8 ) * (( - 1 ) ** q ) * ( 2 ** ( k - 2 * q )) * ( 1._R8 / q ) * tmp coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * tkm2q enddo enddo endselect return endsubroutine coeff_tcheby_vers_monome","tags":"","loc":"proc/coeff_tcheby_vers_monome.html"},{"title":"coeff_tcheby_xy_vers_monome – TOOLIB","text":"public  subroutine coeff_tcheby_xy_vers_monome(tab_coeff_m, deg_x, deg_y) Transformation du produit de Tchebychev en coefficients de monômes Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(0:deg_x, 0:deg_y) :: tab_coeff_m *coefficients de la CL de monômes integer(kind=I4), intent(in) :: deg_x *degré du polynôme en integer(kind=I4), intent(in) :: deg_y *degré du polynôme en Calls proc~~coeff_tcheby_xy_vers_monome~~CallsGraph proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~coeff_tcheby_xy_vers_monome->proc~coeff_tcheby_vers_monome Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~coeff_tcheby_xy_vers_monome~~CalledByGraph proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~coeff_poly_tcheby_xy_vers_poly_monome->proc~coeff_tcheby_xy_vers_monome proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~coeff_poly_tcheby_xy_vers_poly_monome program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine coeff_tcheby_xy_vers_monome ( tab_coeff_m , deg_x , deg_y ) !!  Transformation du produit ti(x) \\cdot tj(y) de Tchebychev en coefficients de monômes x&#94;i \\cdot y&#94;j implicit none integer ( kind = I4 ), intent ( in ) :: deg_x !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: deg_y !! *degré du polynôme en y* real ( kind = R8 ), intent ( out ), dimension ( 0 : deg_x , 0 : deg_y ) :: tab_coeff_m !! *coefficients de la CL de monômes x&#94;i * y&#94;j* integer ( kind = I4 ) :: i , j real ( kind = R8 ), dimension ( 0 : deg_x ) :: coeff_tx , coeff_mx real ( kind = R8 ), dimension ( 0 : deg_y ) :: coeff_ty , coeff_my ! single Tchebychev polynomial, deg_x coeff_tx ( 0 : deg_x ) = 0._R8 coeff_tx ( deg_x ) = 1._R8 call coeff_tcheby_vers_monome ( coeff_tx ( 0 : deg_x ), coeff_mx ( 0 : deg_x ), deg_x ) ! single Tchebychev polynomial, deg_y coeff_ty ( 0 : deg_y ) = 0._R8 coeff_ty ( deg_y ) = 1._R8 call coeff_tcheby_vers_monome ( coeff_ty ( 0 : deg_y ), coeff_my ( 0 : deg_y ), deg_y ) tab_coeff_m ( 0 : deg_x , 0 : deg_y ) = 0._R8 do j = 0 , deg_y do i = 0 , deg_x tab_coeff_m ( i , j ) = coeff_mx ( i ) * coeff_my ( j ) enddo enddo return endsubroutine coeff_tcheby_xy_vers_monome","tags":"","loc":"proc/coeff_tcheby_xy_vers_monome.html"},{"title":"least_squares_tcheby – TOOLIB","text":"public  subroutine least_squares_tcheby(tab_in, tab_out, long1, long2, nvarx, nvary, imask, verif, multi_thread) Resulting polynomial surface, determined by linear least squares Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long1, 1:long2) :: tab_in surface dont on a fait une approximation qui lui est soustraite real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: nvarx degré du polynôme en x integer(kind=I4), intent(in) :: nvary degré du polynôme en y integer(kind=I4), intent(in), optional, dimension(1:long1, 1:long2) :: imask masque logical(kind=I4), intent(in), optional :: verif dump logical(kind=I4), intent(in), optional :: multi_thread use multithread? Calls proc~~least_squares_tcheby~~CallsGraph proc~least_squares_tcheby least_squares_tcheby proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~least_squares_tcheby->proc~coeff_poly_tcheby_xy_vers_poly_monome proc~get_unit get_unit proc~least_squares_tcheby->proc~get_unit proc~moindres_carres_lineaire moindres_carres_lineaire proc~least_squares_tcheby->proc~moindres_carres_lineaire proc~tab_jf_tcheby tab_Jf_tcheby proc~least_squares_tcheby->proc~tab_jf_tcheby proc~tab_poly_tcheby tab_poly_tcheby proc~least_squares_tcheby->proc~tab_poly_tcheby proc~tab_tcheby tab_tcheby proc~least_squares_tcheby->proc~tab_tcheby proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_poly_tcheby_xy_vers_poly_monome->proc~coeff_tcheby_xy_vers_monome proc~choldc choldc proc~moindres_carres_lineaire->proc~choldc proc~cholsl cholsl proc~moindres_carres_lineaire->proc~cholsl omp_get_num_procs omp_get_num_procs proc~tab_jf_tcheby->omp_get_num_procs proc~tab_poly_tcheby->omp_get_num_procs proc~tcheby tcheby proc~tab_tcheby->proc~tcheby proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~coeff_tcheby_xy_vers_monome->proc~coeff_tcheby_vers_monome Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~least_squares_tcheby~~CalledByGraph proc~least_squares_tcheby least_squares_tcheby program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine least_squares_tcheby ( tab_in , tab_out , long1 , long2 , nvarx , nvary , imask , verif , multi_thread ) !! Resulting polynomial surface, determined by linear least squares implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré du polynôme en y* real ( kind = R8 ), intent ( in ), dimension ( 1 : long1 , 1 : long2 ) :: tab_in !! *surface dont on a fait une approximation qui lui est soustraite* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* integer ( kind = I4 ), intent ( in ), dimension ( 1 : long1 , 1 : long2 ), optional :: imask !! *masque* logical ( kind = I4 ), intent ( in ) , optional :: verif !! *dump* logical ( kind = I4 ), intent ( in ) , optional :: multi_thread !! *use multithread?* real ( kind = R8 ), allocatable , dimension (:) :: var1 , vec_x1 , vec_x2 , vec_hij real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tche1 , tab_tche2 , Jf real ( kind = R8 ), dimension ( 1 :( nvarx + 1 ) * ( nvary + 1 )) :: coeff_mxy integer ( kind = I4 ) :: i , iu , nbvar , nbpts character ( len = 128 ) :: string if ( nvarx == 0 . and . nvary == 0 ) then tab_out ( 1 : long1 , 1 : long2 ) = 0._R8 return endif nbvar = ( nvarx + 1 ) * ( nvary + 1 ) if ( present ( imask )) then nbpts = sum ( imask ) else nbpts = long1 * long2 endif allocate ( var1 ( 1 : nbvar ) ) allocate ( vec_x1 ( 1 : long1 ), vec_x2 ( 1 : long2 ) ) var1 = 0 do i = 1 , long1 vec_x1 ( i ) = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) !real(i-long1/2, kind=R8)/(long1/2) enddo do i = 1 , long2 vec_x2 ( i ) = - 1. + ( i - 1 ) * 2. / ( long2 - 1 ) !real(i-long2/2, kind=R8)/(long2/2) enddo call tab_tcheby ( deg = nvarx , nx = long1 , vec_x = vec_x1 ( 1 : long1 ), tab_tche = tab_tche1 ) call tab_tcheby ( deg = nvary , nx = long2 , vec_x = vec_x2 ( 1 : long2 ), tab_tche = tab_tche2 ) call tab_Jf_tcheby ( nx1 = long1 , & ! nx2 = long2 , & ! nb_pts = nbpts , & ! nvarx = nvarx , & ! nvary = nvary , & ! nb_var = nbvar , & ! tab_tche1 = tab_tche1 ( 1 : long1 , 1 : nvarx + 1 ), & ! tab_tche2 = tab_tche2 ( 1 : long2 , 1 : nvary + 1 ), & ! tab_Jf = Jf , & ! imask = imask ( 1 : long1 , 1 : long2 ), & ! multi_thread = multi_thread ) ! allocate ( vec_hij ( 1 : nbpts )) if ( present ( imask )) then vec_hij ( 1 : nbpts ) = pack ( tab_in ( 1 : long1 , 1 : long2 ), mask = ( imask ( 1 : long1 , 1 : long2 ) == 1 )) else vec_hij ( 1 : nbpts ) = reshape ( tab_in ( 1 : long1 , 1 : long2 ), shape = [ nbpts ]) endif call moindres_carres_lineaire ( nb_var = nbvar , & ! nb_pts = nbpts , & ! hij = vec_hij ( 1 : nbpts ), & ! beta = var1 ( 1 : nbvar ), & ! Jf = Jf ( 1 : nbpts , 1 : nbvar )) ! deallocate ( vec_hij ) if ( present ( verif ) . and . verif ) then call coeff_poly_tcheby_xy_vers_poly_monome ( var = var1 ( 1 : nbvar ), & ! coeff_m = coeff_mxy ( 1 : nbvar ), & ! deg_x = nvarx , & ! deg_y = nvary ) ! write ( string , '(a,i3.3,a)' ) '(' , nbvar , 'E18.8,a)' call get_unit ( iu ) open ( iu , file = 'verif_tcheby_vers_monome.txt' ) write ( iu , trim ( string )) ( coeff_mxy ( i ), i = 1 , nbvar ), \" coeff tchebychev\" ! à ce stade on a les coefficients var1(:) tels que : ! surface_approchante(x,y) = var1(1).t0(x)t0(y) +var1(2).t1(x)t0(y) +var1(3).t2(x)t0(y) +...+var1(nvarx+1 +1).t0(x)t1(y) +...+var1(nbvar).t_{nvarx+1}(x)t_{nvary+1}(y) write ( iu , '(a)' ) 'pour vérifier avec gwyddion, il faut préalablement décocher \"surface carrée\", donner à l''image un facteur d''échelle x et y identiques, ' // & ! 'et mettre un décalage pour que x soit compris entre -1 et 1 tout comme y. ' // & ! 'coeff_mxy donne les coeffs de 1 x x&#94;2 x&#94;3 ... x&#94;i y xy x&#94;2.y ...x&#94;i.y&#94;j' close ( iu ) endif call tab_poly_tcheby ( nx1 = long1 , & ! nx2 = long2 , & ! nvarx = nvarx , & ! nvary = nvary , & ! nb_var = nbvar , & ! tab_tche1 = tab_tche1 ( 1 : long1 , 1 : nvarx + 1 ), & ! tab_tche2 = tab_tche2 ( 1 : long2 , 1 : nvary + 1 ), & ! var = var1 ( 1 : nbvar ), & ! tab_poly_tche = tab_out ( 1 : long1 , 1 : long2 ), & ! multi_thread = multi_thread ) ! deallocate ( Jf ) deallocate ( vec_x1 , vec_x2 ) deallocate ( var1 ) deallocate ( tab_tche1 , tab_tche2 ) return endsubroutine least_squares_tcheby","tags":"","loc":"proc/least_squares_tcheby.html"},{"title":"tab_Jf_tcheby – TOOLIB","text":"public  subroutine tab_Jf_tcheby(nx1, nx2, nb_pts, nvarx, nvary, nb_var, tab_tche1, tab_tche2, tab_Jf, imask, multi_thread) Tableau des dérivées par rapport aux coefficients de tab_tche Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx1 nbre de points de calcul selon x integer(kind=I4), intent(in) :: nx2 nbre de points de calcul selon y integer(kind=I4), intent(in) :: nb_pts nbre de points integer(kind=I4), intent(in) :: nvarx degré max de Tchebychev utilisé selon x integer(kind=I4), intent(in) :: nvary degré max de Tchebychev utilisé selon y integer(kind=I4), intent(in) :: nb_var nombre de fonctions de base utilisées real(kind=R8), intent(in), dimension(1:nx1, 1:nvarx+1) :: tab_tche1 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nx2, 1:nvary+1) :: tab_tche2 tableau des valeurs calculées real(kind=R8), intent(out), allocatable, dimension(:,:) :: tab_Jf tableau des dérivées integer(kind=I4), intent(in), optional, dimension(1:nx1, 1:nx2) :: imask masque logical(kind=I4), intent(in), optional :: multi_thread Calls proc~~tab_jf_tcheby~~CallsGraph proc~tab_jf_tcheby tab_Jf_tcheby omp_get_num_procs omp_get_num_procs proc~tab_jf_tcheby->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_jf_tcheby~~CalledByGraph proc~tab_jf_tcheby tab_Jf_tcheby proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~tab_jf_tcheby program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_Jf_tcheby ( nx1 , nx2 , nb_pts , nvarx , nvary , nb_var , tab_tche1 , tab_tche2 , tab_Jf , imask , multi_thread ) !! Tableau des dérivées par rapport aux coefficients de tab_tche implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *nombre de fonctions de base utilisées* integer ( kind = I4 ), intent ( in ) :: nx1 !! *nbre de points de calcul selon x* integer ( kind = I4 ), intent ( in ) :: nx2 !! *nbre de points de calcul selon y* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *nbre de points* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré max de Tchebychev utilisé selon x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré max de Tchebychev utilisé selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx1 , 1 : nvarx + 1 ) :: tab_tche1 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx2 , 1 : nvary + 1 ) :: tab_tche2 !! *tableau des valeurs calculées* integer ( kind = I4 ), intent ( in ), dimension ( 1 : nx1 , 1 : nx2 ), optional :: imask !! *masque* real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: tab_Jf !! *tableau des dérivées* logical ( kind = I4 ), intent ( in ), optional :: multi_thread integer ( kind = I4 ) :: ivar , jvar , ij , ipt , jpt , ijpt , ibatch , nb_threads logical ( kind = I4 ) :: lmask logical ( kind = I4 ) :: mlth mlth = . false . if ( present ( multi_thread ) ) mlth = multi_thread nb_threads = omp_get_num_procs () ibatch = max ( nx2 / nb_threads , 1 ) lmask = present ( imask ) allocate ( tab_Jf ( 1 : nb_pts , 1 : nb_var ) ) ! table des dérivées des poly par rapport aux coeff, c'est donc UN produit de polynômes !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_threads) IF(mlth) !$OMP DO SCHEDULE (STATIC,ibatch) PRIVATE(ijpt, ipt, jpt, ij, ivar, jvar) do jpt = 1 , nx2 do ipt = 1 , nx1 if ( lmask ) then if ( imask ( ipt , jpt ) == 0 ) cycle endif ijpt = ( jpt - 1 ) * nx1 + ipt ij = 0 do jvar = 0 , nvary do ivar = 0 , nvarx ij = ij + 1 tab_Jf ( ijpt , ij ) = tab_tche1 ( ipt , ivar + 1 ) * tab_tche2 ( jpt , jvar + 1 ) enddo enddo enddo enddo !$OMP END DO !$OMP END PARALLEL return endsubroutine tab_Jf_tcheby","tags":"","loc":"proc/tab_jf_tcheby.html"},{"title":"tab_poly_tcheby – TOOLIB","text":"public  subroutine tab_poly_tcheby(nx1, nx2, nvarx, nvary, nb_var, tab_tche1, tab_tche2, var, tab_poly_tche, multi_thread) Note Surface définie par un produit de polynômes de Tchebychev en x et y Le domaine étant discrétisé et UN ensemble de coefficients donnés (provenant\n d’une approximation par moindres carrés) on a la valeur de la fonction surface en chaque point. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx1 nbre de points de calcul selon x integer(kind=I4), intent(in) :: nx2 nbre de points de calcul selon y integer(kind=I4), intent(in) :: nvarx degré max de Tchebychev utilisé selon x integer(kind=I4), intent(in) :: nvary degré max de Tchebychev utilisé selon y integer(kind=I4), intent(in) :: nb_var nbre de coefficients real(kind=R8), intent(in), dimension(1:nx1, 1:nvarx+1) :: tab_tche1 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nx2, 1:nvary+1) :: tab_tche2 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nb_var) :: var vecteur des coefficients real(kind=R8), intent(out), dimension(1:nx1, 1:nx2) :: tab_poly_tche tableau résultant : surface logical(kind=I4), intent(in), optional :: multi_thread Calls proc~~tab_poly_tcheby~~CallsGraph proc~tab_poly_tcheby tab_poly_tcheby omp_get_num_procs omp_get_num_procs proc~tab_poly_tcheby->omp_get_num_procs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_poly_tcheby~~CalledByGraph proc~tab_poly_tcheby tab_poly_tcheby proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~tab_poly_tcheby program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_poly_tcheby ( nx1 , nx2 , nvarx , nvary , nb_var , tab_tche1 , tab_tche2 , var , tab_poly_tche , multi_thread ) implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *nbre de coefficients* integer ( kind = I4 ), intent ( in ) :: nx1 !! *nbre de points de calcul selon x* integer ( kind = I4 ), intent ( in ) :: nx2 !! *nbre de points de calcul selon y* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré max de Tchebychev utilisé selon x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré max de Tchebychev utilisé selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx1 , 1 : nvarx + 1 ) :: tab_tche1 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx2 , 1 : nvary + 1 ) :: tab_tche2 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_var ) :: var !! *vecteur des coefficients* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx1 , 1 : nx2 ) :: tab_poly_tche !! *tableau résultant : surface* logical ( kind = I4 ), intent ( in ), optional :: multi_thread real ( kind = R8 ) :: tmp1 , tmp2 integer ( kind = I4 ) :: ivar , jvar , ij , ipt , jpt , ibatch , nb_threads logical ( kind = I4 ) :: mlth mlth = . false . if ( present ( multi_thread ) ) mlth = multi_thread ! surface d'UN produit de polynômes de tchebytchev nb_threads = omp_get_num_procs () ibatch = max ( nx2 / nb_threads , 1 ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_threads) IF(mlth) !$OMP DO SCHEDULE (STATIC,ibatch) PRIVATE(ipt, tmp1, ij, jvar, tmp2, ivar) do jpt = 1 , nx2 do ipt = 1 , nx1 ! Un dommaine discrétisé (nx+1)*(nx+1) est balayé tmp1 = 0._R8 ij = 0 ! chaque point est unique do jvar = 0 , nvary ! En chaque point, la fonction calculée est le produit des sommes tmp2 = 0._R8 !  de polynômes de Tchebychev. En effet l'approximation est faite do ivar = 0 , nvarx !  avec UN polynôme à variables séparées. ij = ij + 1 tmp2 = tmp2 + var ( ij ) * tab_tche1 ( ipt , ivar + 1 ) enddo tmp1 = tmp1 + tmp2 * tab_tche2 ( jpt , jvar + 1 ) enddo tab_poly_tche ( ipt , jpt ) = tmp1 enddo enddo !$OMP END DO !$OMP END PARALLEL return endsubroutine tab_poly_tcheby","tags":"","loc":"proc/tab_poly_tcheby.html"},{"title":"tab_tcheby – TOOLIB","text":"public  subroutine tab_tcheby(deg, nx, vec_x, tab_tche) Note Valeurs tabulées de polynômes de Tchebychev On se donne des points xi le long d’UN axe et on calcule les valeurs d’un\n polynôme de Tchebychev de degré j en ces points. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: deg degré max du polynôme integer(kind=I4), intent(in) :: nx nbre de points de calcul real(kind=R8), intent(in), dimension(1:nx) :: vec_x vecteur des points de calcul real(kind=R8), intent(out), allocatable, dimension(:,:) :: tab_tche tableau des valeurs calculées Calls proc~~tab_tcheby~~CallsGraph proc~tab_tcheby tab_tcheby proc~tcheby tcheby proc~tab_tcheby->proc~tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~tab_tcheby~~CalledByGraph proc~tab_tcheby tab_tcheby proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~tab_tcheby program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine tab_tcheby ( deg , nx , vec_x , tab_tche ) implicit none integer ( kind = I4 ), intent ( in ) :: deg !! *degré max du polynôme* integer ( kind = I4 ), intent ( in ) :: nx !! *nbre de points de calcul* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx ) :: vec_x !! *vecteur des points de calcul* real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: tab_tche !! *tableau des valeurs calculées* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: xi allocate ( tab_tche ( 1 : nx , 1 : deg + 1 ) ) do i = 1 , nx xi = vec_x ( i ) ! points de l'axe do j = 0 , deg ! pour UN degré de polynôme donné, valeurs en ces points tab_tche ( i , j + 1 ) = tcheby ( j , xi ) enddo enddo return endsubroutine tab_tcheby","tags":"","loc":"proc/tab_tcheby.html"},{"title":"choldc – TOOLIB","text":"public  subroutine choldc(a, n, np, p, info) Note Given a positive definite symmetric matrix a(1:n,1:n), with\n physical dimensions np, this routine constructs its Cholesky\n decomposition, A=L L&#94;T. On input, only the upper triangle of\n a need to be given; it is not modified. The Cholesky factor L\n is returned in the lower triangle of a, except for its diagonal\n elements which are returned in p(1:n). (c) Numerical recipes Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(np, np) :: a system matrix integer(kind=I4), intent(in) :: n system size integer(kind=I4), intent(in) :: np matrix size real(kind=R8), intent(out), dimension(np) :: p diagonal elements integer(kind=I4), intent(out) :: info information ouput Called by proc~~choldc~~CalledByGraph proc~choldc choldc proc~moindres_carres moindres_carres proc~moindres_carres->proc~choldc proc~moindres_carres_lineaire moindres_carres_lineaire proc~moindres_carres_lineaire->proc~choldc program~test_utils test_utils program~test_utils->proc~choldc proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~moindres_carres_lineaire program~test_least test_least program~test_least->proc~moindres_carres program~test_least->proc~moindres_carres_lineaire program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine choldc ( a , n , np , p , info ) !================================================================================================ !<@note Given a positive definite symmetric matrix a(1:n,1:n), with !< physical dimensions np, this routine constructs its Cholesky !< decomposition, A=L L&#94;T. On input, only the upper triangle of !< a need to be given; it is not modified. The Cholesky factor L !< is returned in the lower triangle of a, except for its diagonal !< elements which are returned in p(1:n). !< !< (c) Numerical recipes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *system size* integer ( kind = I4 ), intent ( in ) :: np !! *matrix size* integer ( kind = I4 ), intent ( out ) :: info !! *information ouput* real ( kind = R8 ), intent ( inout ), dimension ( np , np ) :: a !! *system matrix* real ( kind = R8 ), intent ( out ), dimension ( np ) :: p !! *diagonal elements* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: ssum info = 0 o : do i = 1 , n do j = i , n ssum = a ( i , j ) do k = i - 1 , 1 , - 1 ssum = ssum - a ( i , k ) * a ( j , k ) enddo if ( i == j ) then if ( ssum <= 0. ) then info = 1 p ( np ) = 0._R8 p ( 1 ) = - ssum exit o endif p ( i ) = sqrt ( ssum ) else a ( j , i ) = ssum / p ( i ) endif enddo enddo o return endsubroutine choldc","tags":"","loc":"proc/choldc.html"},{"title":"cholsl – TOOLIB","text":"public  subroutine cholsl(a, n, np, p, b, x, info) Note Solves the set of linear equations A x = b, where A is a positive-\n definite symmetric matrix with physical dimensions np. A and P are\n are input as the output from choldc. Only the lower triangle of A\n is accessed. B(1:n) is inout as the right-hand side vector. The\n solution vector is returned in X(1:n). A, n, np, and P are not\n modified and can be left in place for successive calls with different\n right-hand sides B. B is not modified unless you identify B and X in\n the calling sequence, which is allowed. (c) after Numerical recipes Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(np, np) :: a system matrix integer(kind=I4), intent(in) :: n system size integer(kind=I4), intent(in) :: np matrix size real(kind=R8), intent(in), dimension(np) :: p diagonal elements real(kind=R8), intent(inout), dimension(np) :: b rhs real(kind=R8), intent(inout), dimension(np) :: x solution vector integer(kind=I4), intent(inout) :: info information ouput Called by proc~~cholsl~~CalledByGraph proc~cholsl cholsl proc~moindres_carres moindres_carres proc~moindres_carres->proc~cholsl proc~moindres_carres_lineaire moindres_carres_lineaire proc~moindres_carres_lineaire->proc~cholsl program~test_utils test_utils program~test_utils->proc~cholsl proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~moindres_carres_lineaire program~test_least test_least program~test_least->proc~moindres_carres program~test_least->proc~moindres_carres_lineaire program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine cholsl ( a , n , np , p , b , x , info ) !================================================================================================ !<@note Solves the set of linear equations A x = b, where A is a positive- !< definite symmetric matrix with physical dimensions np. A and P are !< are input as the output from choldc. Only the lower triangle of A !< is accessed. B(1:n) is inout as the right-hand side vector. The !< solution vector is returned in X(1:n). A, n, np, and P are not !< modified and can be left in place for successive calls with different !< right-hand sides B. B is not modified unless you identify B and X in !< the calling sequence, which is allowed. !< !< (c) after Numerical recipes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *system size* integer ( kind = I4 ), intent ( in ) :: np !! *matrix size* integer ( kind = I4 ), intent ( inout ) :: info !! *information ouput* real ( kind = R8 ), intent ( in ), dimension ( np , np ) :: a !! *system matrix* real ( kind = R8 ), intent ( in ), dimension ( np ) :: p !! *diagonal elements* real ( kind = R8 ), intent ( inout ), dimension ( np ) :: b !! *rhs* real ( kind = R8 ), intent ( inout ), dimension ( np ) :: x !! *solution vector* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: ssum if ( info == 1 ) return do i = 1 , n ssum = b ( i ) do k = i - 1 , 1 , - 1 ssum = ssum - a ( i , k ) * x ( k ) enddo x ( i ) = ssum / p ( i ) enddo do i = n , 1 , - 1 ssum = x ( i ) do k = i + 1 , n ssum = ssum - a ( k , i ) * x ( k ) enddo x ( i ) = ssum / p ( i ) enddo return endsubroutine cholsl","tags":"","loc":"proc/cholsl.html"},{"title":"change_array_order – TOOLIB","text":"private  subroutine change_array_order(tab_inout, order, n) Given an order vector, sort a real or integer vector Arguments Type Intent Optional Attributes Name class(*), intent(inout), dimension(n) :: tab_inout array to sort integer(kind=I4), intent(inout), dimension(n) :: order order vector integer(kind=I4), intent(in) :: n size of the arrays Called by proc~~change_array_order~~CalledByGraph proc~change_array_order change_array_order proc~sort_array2 sort_array2 proc~sort_array2->proc~change_array_order proc~from_elemental_to_assembled from_elemental_to_assembled proc~from_elemental_to_assembled->proc~sort_array2 proc~melange melange proc~melange->proc~sort_array2 proc~read_surf read_surf proc~read_surf->proc~sort_array2 program~main main program~main->proc~sort_array2 proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_algen test_algen program~test_algen->proc~melange program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine change_array_order ( tab_inout , order , n ) !! Given an order vector, sort a real or integer vector implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the arrays* class ( * ) , intent ( inout ), dimension ( n ) :: tab_inout !! *array to sort* integer ( kind = I4 ), intent ( inout ), dimension ( n ) :: order !! *order vector* integer ( kind = I4 ) :: i integer ( kind = I4 ), allocatable , dimension (:) :: tab_int real ( kind = R8 ), allocatable , dimension (:) :: tab_real select type ( tab_inout ) type is ( integer ( kind = I4 ) ) allocate ( tab_int ( 1 : n ) ) tab_int ( 1 : n ) = tab_inout ( 1 : n ) do i = 1 , n tab_inout ( i ) = tab_int ( order ( i ) ) enddo deallocate ( tab_int ) type is ( real ( kind = R8 ) ) allocate ( tab_real ( 1 : n ) ) tab_real ( 1 : n ) = tab_inout ( 1 : n ) do i = 1 , n tab_inout ( i ) = tab_real ( order ( i ) ) enddo deallocate ( tab_real ) endselect return endsubroutine change_array_order","tags":"","loc":"proc/change_array_order.html"},{"title":"init_order – TOOLIB","text":"public  subroutine init_order(order, n) Vector initialization: 1 … n Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(n) :: order order vector integer(kind=I4), intent(in) :: n size of the vector Called by proc~~init_order~~CalledByGraph proc~init_order init_order proc~sort_array2 sort_array2 proc~sort_array2->proc~init_order program~main main program~main->proc~init_order program~main->proc~sort_array2 proc~from_elemental_to_assembled from_elemental_to_assembled proc~from_elemental_to_assembled->proc~sort_array2 proc~melange melange proc~melange->proc~sort_array2 proc~read_surf read_surf proc~read_surf->proc~sort_array2 proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_algen test_algen program~test_algen->proc~melange program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_order ( order , n ) !! Vector initialization: 1 ... n implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the vector* integer ( kind = I4 ), dimension ( n ), intent ( out ) :: order !! *order vector* integer ( kind = I4 ) :: i order = [ integer ( kind = I4 ) :: ( i , i = 1 , n ) ] return endsubroutine init_order","tags":"","loc":"proc/init_order.html"},{"title":"sort_array2 – TOOLIB","text":"public  subroutine sort_array2(tab_inout, tab0, tab1, tab2, tab3, n) Sort 1D arrays, real or integer, according the first one Arguments Type Intent Optional Attributes Name class(*), intent(inout), dimension(n) :: tab_inout reference array to sort integer(kind=I4), intent(inout), optional, dimension(n) :: tab0 second array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab1 third array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab2 4th array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab3 5th array to sort according the order of the first one integer(kind=I4), intent(in) :: n size of the arrays Calls proc~~sort_array2~~CallsGraph proc~sort_array2 sort_array2 proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sort_array2~~CalledByGraph proc~sort_array2 sort_array2 proc~from_elemental_to_assembled from_elemental_to_assembled proc~from_elemental_to_assembled->proc~sort_array2 proc~melange melange proc~melange->proc~sort_array2 proc~read_surf read_surf proc~read_surf->proc~sort_array2 program~main main program~main->proc~sort_array2 proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_algen test_algen program~test_algen->proc~melange program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine sort_array2 ( tab_inout , tab0 , tab1 , tab2 , tab3 , n ) !! Sort 1D arrays, real or integer, according the first one implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the arrays* class ( * ) , intent ( inout ), dimension ( n ) :: tab_inout !! *reference array to sort* integer ( kind = I4 ), intent ( inout ), dimension ( n ), optional :: tab0 !! *second array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab1 !! *third array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab2 !! *4th array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab3 !! *5th array to sort according the order of the first one* integer ( kind = I4 ), allocatable , dimension (:) :: tab_order allocate ( tab_order ( 1 : n ) ) if ( . not . present ( tab0 ) ) then call init_order ( order = tab_order ( 1 : n ), n = n ) else tab_order ( 1 : n ) = tab0 ( 1 : n ) endif select type ( tab_inout ) type is ( integer ( kind = I4 ) ) call sort_array_integer_with_order ( g = 1 , d = n , itabref = tab_inout ( 1 : n ), order = tab_order ( 1 : n )) type is ( real ( kind = R8 ) ) call sort_array_real_with_order ( g = 1 , d = n , rtabref = tab_inout ( 1 : n ), order = tab_order ( 1 : n )) endselect if ( present ( tab1 ) ) call change_array_order ( tab_inout = tab1 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab2 ) ) call change_array_order ( tab_inout = tab2 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab3 ) ) call change_array_order ( tab_inout = tab3 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab0 ) ) then tab0 ( 1 : n ) = tab_order ( 1 : n ) endif deallocate ( tab_order ) return endsubroutine sort_array2","tags":"","loc":"proc/sort_array2.html"},{"title":"sort_array_integer – TOOLIB","text":"private recursive subroutine sort_array_integer(g, d, itabref) Sort a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index integer(kind=I4), intent(inout), dimension(:) :: itabref vector to sort Source Code recursive subroutine sort_array_integer ( g , d , itabref ) !! Sort a vector of integers implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* integer ( kind = I4 ), intent ( inout ), dimension (:) :: itabref !! *vector to sort* integer ( kind = I4 ) :: i , j , mil integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_integer ( g , j , itabref ) if ( d > i ) call sort_array_integer ( i , d , itabref ) return endsubroutine sort_array_integer","tags":"","loc":"proc/sort_array_integer.html"},{"title":"sort_array_integer_with_order – TOOLIB","text":"private recursive subroutine sort_array_integer_with_order(g, d, itabref, order) Sort a vector of integers and store the order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index integer(kind=I4), intent(inout), dimension(:) :: itabref vector to sort integer(kind=I4), intent(inout), dimension(:) :: order sort order Called by proc~~sort_array_integer_with_order~~CalledByGraph proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array2 sort_array2 proc~sort_array2->proc~sort_array_integer_with_order proc~from_elemental_to_assembled from_elemental_to_assembled proc~from_elemental_to_assembled->proc~sort_array2 proc~melange melange proc~melange->proc~sort_array2 proc~read_surf read_surf proc~read_surf->proc~sort_array2 program~main main program~main->proc~sort_array2 proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_algen test_algen program~test_algen->proc~melange program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code recursive subroutine sort_array_integer_with_order ( g , d , itabref , order ) !! Sort a vector of integers and store the order implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* integer ( kind = I4 ), intent ( inout ), dimension (:) :: itabref !! *vector to sort* integer ( kind = I4 ), intent ( inout ), dimension (:) :: order !! *sort order* integer ( kind = I4 ) :: i , j , mil , itmp integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du tableau itmp = order ( i ) order ( i ) = order ( j ) order ( j ) = itmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_integer_with_order ( g , j , itabref , order ) if ( d > i ) call sort_array_integer_with_order ( i , d , itabref , order ) return endsubroutine sort_array_integer_with_order","tags":"","loc":"proc/sort_array_integer_with_order.html"},{"title":"sort_array_real – TOOLIB","text":"private recursive subroutine sort_array_real(g, d, rtabref) Sort a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index real(kind=R8), intent(inout), dimension(:) :: rtabref vector to sort Source Code recursive subroutine sort_array_real ( g , d , rtabref ) !! Sort a vector of reals implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* real ( kind = R8 ), intent ( inout ), dimension (:) :: rtabref !! *vector to sort* integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_real ( g , j , rtabref ) if ( d > i ) call sort_array_real ( i , d , rtabref ) return endsubroutine sort_array_real","tags":"","loc":"proc/sort_array_real.html"},{"title":"sort_array_real_with_order – TOOLIB","text":"private recursive subroutine sort_array_real_with_order(g, d, rtabref, order) Sort a vector of reals and store the order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index real(kind=R8), intent(inout), dimension(:) :: rtabref vector to sort integer(kind=I4), intent(inout), dimension(:) :: order sort order Called by proc~~sort_array_real_with_order~~CalledByGraph proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order proc~sort_array2 sort_array2 proc~sort_array2->proc~sort_array_real_with_order proc~from_elemental_to_assembled from_elemental_to_assembled proc~from_elemental_to_assembled->proc~sort_array2 proc~melange melange proc~melange->proc~sort_array2 proc~read_surf read_surf proc~read_surf->proc~sort_array2 program~main main program~main->proc~sort_array2 proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_algen test_algen program~test_algen->proc~melange program~test_surfile test_surfile program~test_surfile->proc~read_surf program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code recursive subroutine sort_array_real_with_order ( g , d , rtabref , order ) !! Sort a vector of reals and store the order implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* real ( kind = R8 ), intent ( inout ), dimension (:) :: rtabref !! *vector to sort* integer ( kind = I4 ), intent ( inout ), dimension (:) :: order !! *sort order* integer ( kind = I4 ) :: i , j , mil , itmp real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du tableau itmp = order ( i ) order ( i ) = order ( j ) order ( j ) = itmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_real_with_order ( g , j , rtabref , order ) if ( d > i ) call sort_array_real_with_order ( i , d , rtabref , order ) return endsubroutine sort_array_real_with_order","tags":"","loc":"proc/sort_array_real_with_order.html"},{"title":"pi – TOOLIB","text":"private  function pi() PI returns the value of pi. Arguments None Return Value real Called by proc~~pi~~CalledByGraph proc~pi pi proc~test03 test03 proc~test03->proc~pi program~test_gnufor test_gnufor program~test_gnufor->proc~test03 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function pi ( ) ! !******************************************************************************* ! !! PI returns the value of pi. ! ! !  Modified: ! !    04 December 1998 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Output, real PI, the value of pi. ! implicit none ! real pi ! pi = 3.14159265358979323846264338327950288419716939937510E+00 return endfunction pi","tags":"","loc":"proc/pi.html"},{"title":"get_unit – TOOLIB","text":"private  subroutine get_unit(iunit) GET_UNIT returns a free FORTRAN unit number. Arguments Type Intent Optional Attributes Name integer :: iunit Called by proc~~get_unit~2~~CalledByGraph proc~get_unit~2 get_unit proc~write_polar_data write_polar_data proc~write_polar_data->proc~get_unit~2 proc~write_polar_plot write_polar_plot proc~write_polar_plot->proc~get_unit~2 proc~write_vector_data write_vector_data proc~write_vector_data->proc~get_unit~2 proc~write_vector_plot write_vector_plot proc~write_vector_plot->proc~get_unit~2 proc~write_xy2_data write_xy2_data proc~write_xy2_data->proc~get_unit~2 proc~write_xy2_plot write_xy2_plot proc~write_xy2_plot->proc~get_unit~2 proc~write_xy_data write_xy_data proc~write_xy_data->proc~get_unit~2 proc~write_xy_plot write_xy_plot proc~write_xy_plot->proc~get_unit~2 proc~write_xyy_data write_xyy_data proc~write_xyy_data->proc~get_unit~2 proc~write_xyy_plots write_xyy_plots proc~write_xyy_plots->proc~get_unit~2 proc~write_xyz_data write_xyz_data proc~write_xyz_data->proc~get_unit~2 proc~write_xyz_plot write_xyz_plot proc~write_xyz_plot->proc~get_unit~2 proc~write_xyzgrid_contour write_xyzgrid_contour proc~write_xyzgrid_contour->proc~get_unit~2 proc~write_xyzgrid_data write_xyzgrid_data proc~write_xyzgrid_data->proc~get_unit~2 proc~write_xyzgrid_surface write_xyzgrid_surface proc~write_xyzgrid_surface->proc~get_unit~2 proc~write_y_plot write_y_plot proc~write_y_plot->proc~get_unit~2 proc~test01 test01 proc~test01->proc~write_xy_data proc~test01->proc~write_xy_plot proc~test02 test02 proc~test02->proc~write_xyy_data proc~test02->proc~write_xyy_plots proc~test03 test03 proc~test03->proc~write_xyz_data proc~test03->proc~write_xyz_plot proc~test04 test04 proc~test04->proc~write_vector_data proc~test04->proc~write_vector_plot proc~test05 test05 proc~test05->proc~write_xyzgrid_data proc~test05->proc~write_xyzgrid_surface proc~test06 test06 proc~test06->proc~write_xyzgrid_contour proc~test06->proc~write_xyzgrid_data program~test_gnufor test_gnufor program~test_gnufor->proc~test01 program~test_gnufor->proc~test02 program~test_gnufor->proc~test03 program~test_gnufor->proc~test04 program~test_gnufor->proc~test05 program~test_gnufor->proc~test06 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine get_unit ( iunit ) ! !******************************************************************************* ! !! GET_UNIT returns a free FORTRAN unit number. ! ! !  Discussion: ! !    A \"free\" FORTRAN unit number is an integer between 1 and 99 which !    is not currently associated with an I/O device.  A free FORTRAN unit !    number is needed in order to open a file with the OPEN command. ! !  Modified: ! !    02 March 1999 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Output, integer IUNIT. ! !    If IUNIT = 0, then no free FORTRAN unit could be found, although !    all 99 units were checked (except for units 5 and 6). ! !    Otherwise, IUNIT is an integer between 1 and 99, representing a !    free FORTRAN unit.  Note that GET_UNIT assumes that units 5 and 6 !    are special, and will never return those values. ! implicit none ! integer i integer ios integer iunit logical lopen iunit = 0 do i = 1 , 99 if ( i /= 5 . and . i /= 6 ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return end if end if end if end do return endsubroutine get_unit","tags":"","loc":"proc/get_unit~2.html"},{"title":"run_gnuplot – TOOLIB","text":"public  subroutine run_gnuplot(command_file_name) RUN_GNUPLOT runs GNUPLOT with a given command file. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name Called by proc~~run_gnuplot~~CalledByGraph proc~run_gnuplot run_gnuplot proc~test01 test01 proc~test01->proc~run_gnuplot proc~test02 test02 proc~test02->proc~run_gnuplot proc~test03 test03 proc~test03->proc~run_gnuplot proc~test04 test04 proc~test04->proc~run_gnuplot proc~test05 test05 proc~test05->proc~run_gnuplot proc~test06 test06 proc~test06->proc~run_gnuplot program~test_gnufor test_gnufor program~test_gnufor->proc~test01 program~test_gnufor->proc~test02 program~test_gnufor->proc~test03 program~test_gnufor->proc~test04 program~test_gnufor->proc~test05 program~test_gnufor->proc~test06 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine run_gnuplot ( command_file_name ) ! !******************************************************************************* ! !! RUN_GNUPLOT runs GNUPLOT with a given command file. ! ! !  Discussion: ! !    The GNUPLOT program, version 3.7, must be available.  To check whether !    this is so, try typing ! !      which gnuplot ! !    If the response is ! !      gnuplot: command not found ! !    then you're going to have to make GNUPLOT available. ! !    At ISU, this may require that you issue the command ! !      add gnu ! !    You may need to set the environment variable GNUTERM: ! !      setenv GNUTERM x11 ! !    so that GNUPLOT automatically displays to your X window terminal. ! ! !    This routine expects that there is a text file containing the appropriate !    commands to GNUPLOT to display your picture.  There are a number of !    routines in this package that will do this for simple plotting tasks. !    Most of them require that you also set up a file of data to be plotted. ! !    Once this routine invokes GNUPLOT, a graphics window should open !    up, and the FORTRAN program will pause.  Hitting RETURN should advance !    to the next picture, or terminate the window at the end, allowing the !    FORTRAN routine to proceed. ! ! !    You can look at the data and command files created by the routines. !    Moreover, you can easily modify the command file to change the options !    used in GNUPLOT, and then run GNUPLOT interactively, as in: ! !      gnuplot commands ! !    In particular, if you want a PostScript version of your graphics files, !    insert the command \"set term postscript\" at the beginning of the command !    file and run gnuplot as follows: ! !      gnuplot commands > mypicture.ps ! !    You will also have to hit RETURN once for each plot that is made. ! !  Modified: ! !    21 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! implicit none ! character ( len = 512 ) command character ( len = * ) command_file_name !integer status ! !  Issue a command to the system that will startup GNUPLOT, using !  the file we just wrote as input. ! write ( command , * ) 'gnuplot ' // '\"' // trim ( command_file_name ) // '\"' !~   call execute_command_line(trim ( command ), wait=.false., exitstat=status) call system ( trim ( command )) return endsubroutine run_gnuplot","tags":"","loc":"proc/run_gnuplot.html"},{"title":"test01 – TOOLIB","text":"public  subroutine test01() TEST01 demonstrates the plotting of Y(X) data. Arguments None Calls proc~~test01~~CallsGraph proc~test01 test01 proc~run_gnuplot run_gnuplot proc~test01->proc~run_gnuplot proc~write_xy_data write_xy_data proc~test01->proc~write_xy_data proc~write_xy_plot write_xy_plot proc~test01->proc~write_xy_plot proc~get_unit~2 get_unit proc~write_xy_data->proc~get_unit~2 proc~write_xy_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test01~~CalledByGraph proc~test01 test01 program~test_gnufor test_gnufor program~test_gnufor->proc~test01 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test01 ! !******************************************************************************* ! !! TEST01 demonstrates the plotting of Y(X) data. ! implicit none ! integer , parameter :: n = 101 ! !real angle !real area character ( len = 100 ) :: command_file_name = 'tmp/test01_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test01_data.txt' integer i integer ierror real x ( n ) real , parameter :: xmin = 0.0 + 00 real , parameter :: xmax = 2 0.0E+00 real y ( n ) ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a)' ) '  To plot a simple set of (X,Y) data,' write ( * , '(a)' ) '  WRITE_XY_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XY_PLOT writes the plot command file.' do i = 1 , n x ( i ) = ( real ( n - i ) * xmin + real ( i - 1 ) * xmax ) / real ( n - 1 ) y ( i ) = sin ( x ( i ) ) * sin ( 4.0 * x ( i ) ) end do call write_xy_data ( data_file_name , n , x , y , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a,i6)' ) '  WRITE_XY_DATA returned IERROR = ' , ierror end if call write_xy_plot ( command_file_name , data_file_name , . true ., ierror , '*' ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a,i6)' ) '  WRITE_XY_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test01","tags":"","loc":"proc/test01.html"},{"title":"test02 – TOOLIB","text":"public  subroutine test02() TEST02 demonstrates the plotting of a table of data. Arguments None Calls proc~~test02~~CallsGraph proc~test02 test02 proc~run_gnuplot run_gnuplot proc~test02->proc~run_gnuplot proc~write_xyy_data write_xyy_data proc~test02->proc~write_xyy_data proc~write_xyy_plots write_xyy_plots proc~test02->proc~write_xyy_plots proc~get_unit~2 get_unit proc~write_xyy_data->proc~get_unit~2 proc~write_xyy_plots->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test02~~CalledByGraph proc~test02 test02 program~test_gnufor test_gnufor program~test_gnufor->proc~test02 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test02 ! !******************************************************************************* ! !! TEST02 demonstrates the plotting of a table of data. ! implicit none ! integer , parameter :: nrow = 101 integer , parameter :: ncol = 4 ! integer , parameter :: lda = nrow ! real angle real area character ( len = 100 ) :: command_file_name = 'tmp/test02_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test02_data.txt' character ( len = 100 ), dimension ( 1 : ncol ) :: title real height integer i integer ierror real , parameter :: r = 5 0.0E+00 real width real x ( lda , ncol ) ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a)' ) '  To plot X versus multiple sets of Y data,' write ( * , '(a)' ) '  WRITE_XYY_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYY_PLOT writes the plot command file.' do i = 1 , nrow height = 2.0E+00 * r * real ( i - 1 ) / real ( nrow - 1 ) width = 2.0E+00 * sqrt ( r ** 2 - ( r - height ) ** 2 ) angle = acos ( ( r - height ) / r ) area = 0.5E+00 * r ** 2 * 2.0E+00 * acos ( ( r - height ) / r ) & - ( r - height ) * sqrt ( height * ( 2.0E+00 * r - height ) ) x ( i , 1 ) = height x ( i , 2 ) = width x ( i , 3 ) = angle x ( i , 4 ) = area end do title ( 1 ) = 'height' title ( 2 ) = 'width' title ( 3 ) = 'angle' title ( 4 ) = 'area' call write_xyy_data ( data_file_name , lda , nrow , ncol , x , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a,i6)' ) '  WRITE_XYY_DATA returned IERROR = ' , ierror end if call write_xyy_plots ( command_file_name = command_file_name , data_file_name = data_file_name , title = title , ncol = ncol , & ierror = ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a,i6)' ) '  WRITE_XYY_PLOTS returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test02","tags":"","loc":"proc/test02.html"},{"title":"test03 – TOOLIB","text":"public  subroutine test03() TEST03 plots parameter (X,Y,Z) data. Arguments None Calls proc~~test03~~CallsGraph proc~test03 test03 proc~pi pi proc~test03->proc~pi proc~run_gnuplot run_gnuplot proc~test03->proc~run_gnuplot proc~write_xyz_data write_xyz_data proc~test03->proc~write_xyz_data proc~write_xyz_plot write_xyz_plot proc~test03->proc~write_xyz_plot proc~get_unit~2 get_unit proc~write_xyz_data->proc~get_unit~2 proc~write_xyz_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test03~~CalledByGraph proc~test03 test03 program~test_gnufor test_gnufor program~test_gnufor->proc~test03 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test03 ! !******************************************************************************* ! !! TEST03 plots parameter (X,Y,Z) data. ! implicit none ! integer , parameter :: n = 101 ! character ( len = 100 ) :: command_file_name = 'tmp/test03_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test03_data.txt' integer i integer ierror integer , parameter :: nturn = 5 real , parameter :: r = 5.0E+00 real theta real x ( n ) real y ( n ) real z ( n ) real , parameter :: zmax = 1 0.0E+00 ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a)' ) '  To plot a (parametric) set of (X,Y,Z) data,' write ( * , '(a)' ) '  WRITE_XYZ_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZ_PLOT writes the plot command file.' do i = 1 , n z ( i ) = zmax * real ( i - 1 ) / real ( n - 1 ) theta = ( 2.0E+00 * pi () ) * z ( i ) * real ( nturn ) / zmax x ( i ) = r * cos ( theta ) y ( i ) = r * sin ( theta ) end do call write_xyz_data ( data_file_name , n , x , y , z , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a,i6)' ) '  WRITE_XYZ_DATA returned IERROR = ' , ierror end if call write_xyz_plot ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a,i6)' ) '  WRITE_XYZ_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test03","tags":"","loc":"proc/test03.html"},{"title":"test04 – TOOLIB","text":"public  subroutine test04() TEST04 plots vector data. Arguments None Calls proc~~test04~~CallsGraph proc~test04 test04 proc~run_gnuplot run_gnuplot proc~test04->proc~run_gnuplot proc~write_vector_data write_vector_data proc~test04->proc~write_vector_data proc~write_vector_plot write_vector_plot proc~test04->proc~write_vector_plot proc~get_unit~2 get_unit proc~write_vector_data->proc~get_unit~2 proc~write_vector_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test04~~CalledByGraph proc~test04 test04 program~test_gnufor test_gnufor program~test_gnufor->proc~test04 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test04 ! !******************************************************************************* ! !! TEST04 plots vector data. ! implicit none ! integer , parameter :: nx = 21 integer , parameter :: ny = 21 integer , parameter :: n = nx * ny ! character ( len = 100 ) :: command_file_name = 'tmp/test04_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test04_data.txt' real dx ( n ) real dy ( n ) integer i integer ierror integer j integer k real x ( n ) real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = - 1.0E+00 real xx real y ( n ) real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = - 1.0E+00 real yy ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a)' ) '  To plot a vector field,' write ( * , '(a)' ) '  WRITE_VECTOR_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_VECTOR_PLOT writes the plot command file.' k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 xx = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) yy = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) dx ( k ) = - 0.10E+00 * yy dy ( k ) = 0.10E+00 * xx x ( k ) = xx - 0.5E+00 * dx ( k ) y ( k ) = yy - 0.5E+00 * dy ( k ) end do end do call write_vector_data ( data_file_name , n , x , y , dx , dy , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a,i6)' ) '  WRITE_VECTOR_DATA returned IERROR = ' , ierror end if call write_vector_plot ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a,i6)' ) '  WRITE_VECTOR_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test04","tags":"","loc":"proc/test04.html"},{"title":"test05 – TOOLIB","text":"public  subroutine test05() TEST05 plots Z(X,Y) grid data as a surface. Arguments None Calls proc~~test05~~CallsGraph proc~test05 test05 proc~run_gnuplot run_gnuplot proc~test05->proc~run_gnuplot proc~write_xyzgrid_data write_xyzgrid_data proc~test05->proc~write_xyzgrid_data proc~write_xyzgrid_surface write_xyzgrid_surface proc~test05->proc~write_xyzgrid_surface proc~get_unit~2 get_unit proc~write_xyzgrid_data->proc~get_unit~2 proc~write_xyzgrid_surface->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test05~~CalledByGraph proc~test05 test05 program~test_gnufor test_gnufor program~test_gnufor->proc~test05 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test05 ! !******************************************************************************* ! !! TEST05 plots Z(X,Y) grid data as a surface. ! implicit none ! integer , parameter :: nx = 21 integer , parameter :: ny = 21 !integer, parameter :: nrow = nx * ny ! character ( len = 100 ) :: command_file_name = 'tmp/test05_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test05_data.txt' integer i integer ierror integer j real x real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = 0.0E+00 real xyz ( 3 , nx , ny ) real y real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = 0.0E+00 real z ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a)' ) '  To plot a gridded set of Z(X,Y) data as a surface,' write ( * , '(a)' ) '  WRITE_XYZGRID_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZGRID_SURFACE writes the plot command file.' do i = 1 , nx x = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) do j = 1 , ny y = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) z = sin ( 6 4.0E+00 * ( x - 0.5E+00 ) ** 2 * ( y - 0.5E+00 ) ** 2 ) xyz ( 1 , i , j ) = x xyz ( 2 , i , j ) = y xyz ( 3 , i , j ) = z end do end do call write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_DATA returned IERROR = ' , ierror end if call write_xyzgrid_surface ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_SURFACE returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test05","tags":"","loc":"proc/test05.html"},{"title":"test06 – TOOLIB","text":"public  subroutine test06() TEST06 plots Z(X,Y) grid data as contours. Arguments None Calls proc~~test06~~CallsGraph proc~test06 test06 proc~run_gnuplot run_gnuplot proc~test06->proc~run_gnuplot proc~write_xyzgrid_contour write_xyzgrid_contour proc~test06->proc~write_xyzgrid_contour proc~write_xyzgrid_data write_xyzgrid_data proc~test06->proc~write_xyzgrid_data proc~get_unit~2 get_unit proc~write_xyzgrid_contour->proc~get_unit~2 proc~write_xyzgrid_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~test06~~CalledByGraph proc~test06 test06 program~test_gnufor test_gnufor program~test_gnufor->proc~test06 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine test06 ! !******************************************************************************* ! !! TEST06 plots Z(X,Y) grid data as contours. ! implicit none ! integer , parameter :: nx = 41 integer , parameter :: ny = 41 ! character ( len = 100 ) :: command_file_name = 'tmp/test06_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test06_data.txt' integer i integer ierror integer j real x real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = 0.0E+00 real xyz ( 3 , nx , ny ) real y real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = 0.0E+00 real z ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a)' ) '  To plot gridded Z(X,Y) data as contours,' write ( * , '(a)' ) '  WRITE_XYZGRID_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZGRID_CONTOUR writes the plot command file.' do i = 1 , nx x = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) do j = 1 , ny y = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) z = sin ( 6 4.0E+00 * ( x - 0.5E+00 ) ** 2 * ( y - 0.5E+00 ) ** 2 ) xyz ( 1 , i , j ) = x xyz ( 2 , i , j ) = y xyz ( 3 , i , j ) = z end do end do call write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_DATA returned IERROR = ' , ierror end if call write_xyzgrid_contour ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_CONTOUR returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test06","tags":"","loc":"proc/test06.html"},{"title":"timestamp – TOOLIB","text":"private  subroutine timestamp() TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None Source Code subroutine timestamp ( ) ! !******************************************************************************* ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! ! !  Example: ! !    May 31 2001   9:45:54.872 AM ! !  Modified: ! !    31 May 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none ! character ( len = 8 ) ampm integer d character ( len = 8 ) date integer h integer m integer mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer n integer s character ( len = 10 ) time integer values ( 8 ) integer y character ( len = 5 ) zone ! call date_and_time ( date , time , zone , values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(a,1x,i2,1x,I4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & trim ( month ( m ) ), d , y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return endsubroutine timestamp","tags":"","loc":"proc/timestamp~2.html"},{"title":"write_polar_data – TOOLIB","text":"private  subroutine write_polar_data(data_file_name, n, x, y, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) integer :: ierror Calls proc~~write_polar_data~~CallsGraph proc~write_polar_data write_polar_data proc~get_unit~2 get_unit proc~write_polar_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_polar_data ( data_file_name , n , x , y , ierror ) implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT POLAR data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_polar_data","tags":"","loc":"proc/write_polar_data.html"},{"title":"write_polar_plot – TOOLIB","text":"private  subroutine write_polar_plot(command_file_name, data_file_name, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_polar_plot~~CallsGraph proc~write_polar_plot write_polar_plot proc~get_unit~2 get_unit proc~write_polar_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_polar_plot ( command_file_name , data_file_name , ierror ) implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set angles degrees' write ( file_unit , '(a)' ) 'set polar' write ( file_unit , '(a)' ) 'set grid polar' write ( file_unit , '(a)' ) 'set xlabel \"azimuth\"' write ( file_unit , '(a)' ) 'set ylabel \"r\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // & '\" using 1:2 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_polar_plot","tags":"","loc":"proc/write_polar_plot.html"},{"title":"write_vector_data – TOOLIB","text":"private  subroutine write_vector_data(data_file_name, n, x, y, dx, dy, ierror) WRITE_VECTOR_DATA writes vector data to a file, for plotting by GNUPLOT. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: dx (n) real :: dy (n) integer :: ierror Calls proc~~write_vector_data~~CallsGraph proc~write_vector_data write_vector_data proc~get_unit~2 get_unit proc~write_vector_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_vector_data~~CalledByGraph proc~write_vector_data write_vector_data proc~test04 test04 proc~test04->proc~write_vector_data program~test_gnufor test_gnufor program~test_gnufor->proc~test04 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_vector_data ( data_file_name , n , x , y , dx , dy , ierror ) ! !******************************************************************************* ! !! WRITE_VECTOR_DATA writes vector data to a file, for plotting by GNUPLOT. ! ! !  Discussion: ! !    Each vector is described by 4 values, X, Y, dX, dY, indicating that !    a vector is to be drawn from (X,Y) to (X+dX,Y+dY). ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of vectors. ! !    Input, real X(N), Y(N), DX(N), DY(N), the vector data. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name real dx ( n ) real dy ( n ) integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), dx ( i ), dy ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT vector data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_vector_data","tags":"","loc":"proc/write_vector_data.html"},{"title":"write_vector_plot – TOOLIB","text":"private  subroutine write_vector_plot(command_file_name, data_file_name, ierror) WRITE_VECTOR_PLOT writes GNUPLOT commands to plot vectors. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_vector_plot~~CallsGraph proc~write_vector_plot write_vector_plot proc~get_unit~2 get_unit proc~write_vector_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_vector_plot~~CalledByGraph proc~write_vector_plot write_vector_plot proc~test04 test04 proc~test04->proc~write_vector_plot program~test_gnufor test_gnufor program~test_gnufor->proc~test04 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_vector_plot ( command_file_name , data_file_name , & ierror ) ! !******************************************************************************* ! !! WRITE_VECTOR_PLOT writes GNUPLOT commands to plot vectors. ! ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set style arrow' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT table plots command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_vector_plot","tags":"","loc":"proc/write_vector_plot.html"},{"title":"write_xy2_data – TOOLIB","text":"private  subroutine write_xy2_data(data_file_name, n, x, y, y2, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: y2 (n) integer :: ierror Calls proc~~write_xy2_data~~CallsGraph proc~write_xy2_data write_xy2_data proc~get_unit~2 get_unit proc~write_xy2_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xy2_data ( data_file_name , n , x , y , y2 , ierror ) ! !******************************************************************************* implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) real y2 ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), y2 ( i ) end do close ( unit = file_unit ) return endsubroutine write_xy2_data","tags":"","loc":"proc/write_xy2_data.html"},{"title":"write_xy2_plot – TOOLIB","text":"private  subroutine write_xy2_plot(command_file_name, data_file_name, logscale, ierror, nom) Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name logical :: logscale integer :: ierror character(len=*) :: nom Calls proc~~write_xy2_plot~~CallsGraph proc~write_xy2_plot write_xy2_plot proc~get_unit~2 get_unit proc~write_xy2_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xy2_plot ( command_file_name , data_file_name , logscale , ierror , nom ) implicit none ! character ( len = * ) command_file_name character ( len = * ) nom character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios logical logscale ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if if ( trim ( nom ) /= '*' ) then write ( file_unit , '(a)' ) 'set term pngcairo' write ( file_unit , '(a)' ) 'set output \"' // trim ( nom ) // '.png\"' endif write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' if ( logscale ) write ( file_unit , '(a)' ) 'set logscale x' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:2 with lines,\\' write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : 3 with lines ' !write ( file_unit, ' ( a ) ' ) ' pause - 1 \"Hit return to continue\" ' write ( file_unit, ' ( a ) ' ) ' q ' close ( unit = file_unit ) return endsubroutine write_xy2_plot","tags":"","loc":"proc/write_xy2_plot.html"},{"title":"write_xy_data – TOOLIB","text":"public  subroutine write_xy_data(data_file_name, n, x, y, ierror) WRITE_XY_DATA writes X(1:N), Y(1:N) data to a file. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) integer :: ierror Calls proc~~write_xy_data~~CallsGraph proc~write_xy_data write_xy_data proc~get_unit~2 get_unit proc~write_xy_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xy_data~~CalledByGraph proc~write_xy_data write_xy_data proc~test01 test01 proc~test01->proc~write_xy_data program~test_gnufor test_gnufor program~test_gnufor->proc~test01 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xy_data ( data_file_name , n , x , y , ierror ) ! !******************************************************************************* ! !! WRITE_XY_DATA writes X(1:N), Y(1:N) data to a file. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of data items. ! !    Input, real X(N), Y(N), the X and Y data ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xy_data","tags":"","loc":"proc/write_xy_data.html"},{"title":"write_xy_plot – TOOLIB","text":"public  subroutine write_xy_plot(command_file_name, data_file_name, logscale, ierror, nom) WRITE_XY_PLOT writes GNUPLOT commands to plot X(1:N), Y(1:N) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name logical :: logscale integer :: ierror character(len=*) :: nom Calls proc~~write_xy_plot~~CallsGraph proc~write_xy_plot write_xy_plot proc~get_unit~2 get_unit proc~write_xy_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xy_plot~~CalledByGraph proc~write_xy_plot write_xy_plot proc~test01 test01 proc~test01->proc~write_xy_plot program~test_gnufor test_gnufor program~test_gnufor->proc~test01 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xy_plot ( command_file_name , data_file_name , logscale , ierror , nom ) ! !******************************************************************************* ! !! WRITE_XY_PLOT writes GNUPLOT commands to plot X(1:N), Y(1:N) data. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) nom character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios logical logscale ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if if ( trim ( nom ) /= '*' ) then write ( file_unit , '(a)' ) 'set term pngcairo' write ( file_unit , '(a)' ) 'set output \"' // trim ( nom ) // '.png\"' endif write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' if ( logscale ) write ( file_unit , '(a)' ) 'set logscale x' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:2 with lines' !write ( file_unit, '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // trim ( command_file_name ) // '\"' return endsubroutine write_xy_plot","tags":"","loc":"proc/write_xy_plot.html"},{"title":"write_xyy_data – TOOLIB","text":"public  subroutine write_xyy_data(data_file_name, lda, nrow, ncol, x, ierror) WRITE_XYY_DATA writes a table of data to a file, for plotting by GNUPLOT. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: lda integer :: nrow integer :: ncol real :: x (lda,ncol) integer :: ierror Calls proc~~write_xyy_data~~CallsGraph proc~write_xyy_data write_xyy_data proc~get_unit~2 get_unit proc~write_xyy_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyy_data~~CalledByGraph proc~write_xyy_data write_xyy_data proc~test02 test02 proc~test02->proc~write_xyy_data program~test_gnufor test_gnufor program~test_gnufor->proc~test02 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyy_data ( data_file_name , lda , nrow , ncol , x , ierror ) ! !******************************************************************************* ! !! WRITE_XYY_DATA writes a table of data to a file, for plotting by GNUPLOT. ! ! !  Discussion: ! !    The first column of data is assumed to be the independent variable, X. !    Separate plots are made of X versus all the other columns of data. ! !  Modified: ! !    21 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer LDA, the leading dimension of X. ! !    Input, integer NROW, NCOL, the dimensions of X. ! !    Input, real X(LDA,NCOL), the NROW by NCOL data to be written. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer lda integer ncol ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios integer nrow real x ( lda , ncol ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , nrow write ( file_unit , * ) x ( i , 1 : ncol ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYY data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyy_data","tags":"","loc":"proc/write_xyy_data.html"},{"title":"write_xyy_plots – TOOLIB","text":"public  subroutine write_xyy_plots(command_file_name, data_file_name, add_lines, title, ncol, ierror) WRITE_XYY_PLOTS writes GNUPLOT commands to make multiple (X,Y) plots. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name character(len=*), optional :: add_lines character(len=*), dimension(1:ncol) :: title integer :: ncol integer :: ierror Calls proc~~write_xyy_plots~~CallsGraph proc~write_xyy_plots write_xyy_plots proc~get_unit~2 get_unit proc~write_xyy_plots->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyy_plots~~CalledByGraph proc~write_xyy_plots write_xyy_plots proc~test02 test02 proc~test02->proc~write_xyy_plots program~test_gnufor test_gnufor program~test_gnufor->proc~test02 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyy_plots ( command_file_name , data_file_name , add_lines , title , & ncol , ierror ) ! !******************************************************************************* ! !! WRITE_XYY_PLOTS writes GNUPLOT commands to make multiple (X,Y) plots. ! ! !  Discussion: ! !    The first column of data is assumed to be the independent variable, X. !    Separate plots are made of X versus all the other columns of data. ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer NCOL, the number of columns of data. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name character ( len = * ), optional :: add_lines integer file_unit integer i integer ierror integer ios integer ncol character ( len = * ), dimension ( 1 : ncol ) :: title ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_PLOTS - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_PLOTS - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' if ( present ( add_lines )) then write ( file_unit , '(a)' ) trim ( add_lines ) endif do i = 1 , 1 write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:' , i + 1 , ' with lines title \"' // trim ( title ( i )) // '\", \\' end do do i = 2, ncol-2 write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : ', i+1, ' with lines title \"' // trim(title(i)) // '\" , \\ ' end do do i = ncol-1, ncol-1 write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : ', i+1, ' with lines title \"' // trim(title(i)) // '\" ' end do write ( file_unit, ' ( a ) ' ) ' pause - 1 \"Hit return to continue\" ' write ( file_unit, ' ( a ) ' ) ' q ' close ( unit = file_unit ) write ( *, ' ( a ) ' ) ' ' write ( *, ' ( a ) ' ) ' WRITE_XYY_PLOTS : ' write ( *, ' ( a ) ' ) ' Wrote the GNUPLOT XYY plots command file \"' // & trim ( command_file_name ) // '\" ' return endsubroutine write_xyy_plots","tags":"","loc":"proc/write_xyy_plots.html"},{"title":"write_xyz_data – TOOLIB","text":"private  subroutine write_xyz_data(data_file_name, n, x, y, z, ierror) WRITE_XYZ_DATA writes X(1:N), Y(1:N), Z(1:N) data to a file. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: z (n) integer :: ierror Calls proc~~write_xyz_data~~CallsGraph proc~write_xyz_data write_xyz_data proc~get_unit~2 get_unit proc~write_xyz_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyz_data~~CalledByGraph proc~write_xyz_data write_xyz_data proc~test03 test03 proc~test03->proc~write_xyz_data program~test_gnufor test_gnufor program~test_gnufor->proc~test03 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyz_data ( data_file_name , n , x , y , z , ierror ) ! !******************************************************************************* ! !! WRITE_XYZ_DATA writes X(1:N), Y(1:N), Z(1:N) data to a file. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of data items. ! !    Input, real X(N), Y(N), Z(N), the X, Y, Z data ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) real z ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), z ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZ data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyz_data","tags":"","loc":"proc/write_xyz_data.html"},{"title":"write_xyz_plot – TOOLIB","text":"private  subroutine write_xyz_plot(command_file_name, data_file_name, ierror) WRITE_XYZ_PLOT writes commands to plot parametric (X,Y,Z) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_xyz_plot~~CallsGraph proc~write_xyz_plot write_xyz_plot proc~get_unit~2 get_unit proc~write_xyz_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyz_plot~~CalledByGraph proc~write_xyz_plot write_xyz_plot proc~test03 test03 proc~test03->proc~write_xyz_plot program~test_gnufor test_gnufor program~test_gnufor->proc~test03 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyz_plot ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZ_PLOT writes commands to plot parametric (X,Y,Z) data. ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    a 3D arc specified by points (X,Y,Z).  A grid data file, containing !    values of X, Y and Z, will also be needed. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // & '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT SPLOT command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyz_plot","tags":"","loc":"proc/write_xyz_plot.html"},{"title":"write_xyzgrid_contour – TOOLIB","text":"private  subroutine write_xyzgrid_contour(command_file_name, data_file_name, ierror) WRITE_XYZGRID_CONTOUR writes commands to plot contours of Z(X,Y). Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_xyzgrid_contour~~CallsGraph proc~write_xyzgrid_contour write_xyzgrid_contour proc~get_unit~2 get_unit proc~write_xyzgrid_contour->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyzgrid_contour~~CalledByGraph proc~write_xyzgrid_contour write_xyzgrid_contour proc~test06 test06 proc~test06->proc~write_xyzgrid_contour program~test_gnufor test_gnufor program~test_gnufor->proc~test06 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyzgrid_contour ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_CONTOUR writes commands to plot contours of Z(X,Y). ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    contours of Z(X,Y) gridded data.  A grid data file, containing values !    of X, Y and Z, will also be needed. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'set nosurface' write ( file_unit , '(a)' ) 'set contour' write ( file_unit , '(a)' ) 'set cntrparam levels 10' !write ( file_unit, '(a)' ) 'set terminal table' !write ( file_unit, '(a)' ) 'set out \"table.txt\"' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // & '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'set term x11' !write ( file_unit, '(a)' ) 'plot \"table.txt\" with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZGRID contour plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyzgrid_contour","tags":"","loc":"proc/write_xyzgrid_contour.html"},{"title":"write_xyzgrid_data – TOOLIB","text":"private  subroutine write_xyzgrid_data(data_file_name, nx, ny, xyz, ierror) WRITE_XYZGRID_DATA writes a file of XYZ grid data. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: nx integer :: ny real :: xyz (3,nx,ny) integer :: ierror Calls proc~~write_xyzgrid_data~~CallsGraph proc~write_xyzgrid_data write_xyzgrid_data proc~get_unit~2 get_unit proc~write_xyzgrid_data->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyzgrid_data~~CalledByGraph proc~write_xyzgrid_data write_xyzgrid_data proc~test05 test05 proc~test05->proc~write_xyzgrid_data proc~test06 test06 proc~test06->proc~write_xyzgrid_data program~test_gnufor test_gnufor program~test_gnufor->proc~test05 program~test_gnufor->proc~test06 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_DATA writes a file of XYZ grid data. ! ! !  Discussion: ! !    It is assumed that values of Z are available on a regular NX by NY grid !    of (X,Y) points. ! !    The form of the data file requires that all the data for a given value !    of Y be listed, followed by a blank line, followed by the data for !    another value of Y. ! !  Example: ! !    Here is a grid data file for a 3 by 3 grid, with Z = X + Y. ! !    0.0 0.0 0.0 !    1.0 0.0 1.0 !    2.0 0.0 2.0 ! !    0.0 1.0 1.0 !    1.0 1.0 2.0 !    2.0 1.0 3.0 ! !    0.0 2.0 2.0 !    1.0 2.0 3.0 !    2.0 2.0 4.0 ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer NX, NY, the dimensions of the grid. ! !    Input, real XYZ(3,NX,NY), the XYZ grid data to be written. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer nx integer ny ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios integer j real xyz ( 3 , nx , ny ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do j = 1 , ny do i = 1 , nx write ( file_unit , * ) xyz ( 1 : 3 , i , j ) end do write ( file_unit , '(a)' ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZ grid data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyzgrid_data","tags":"","loc":"proc/write_xyzgrid_data.html"},{"title":"write_xyzgrid_surface – TOOLIB","text":"private  subroutine write_xyzgrid_surface(command_file_name, data_file_name, ierror) WRITE_XYZGRID_SURFACE writes a file of GNUPLOT commands to plot a 3D surface. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_xyzgrid_surface~~CallsGraph proc~write_xyzgrid_surface write_xyzgrid_surface proc~get_unit~2 get_unit proc~write_xyzgrid_surface->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_xyzgrid_surface~~CalledByGraph proc~write_xyzgrid_surface write_xyzgrid_surface proc~test05 test05 proc~test05->proc~write_xyzgrid_surface program~test_gnufor test_gnufor program~test_gnufor->proc~test05 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_xyzgrid_surface ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_SURFACE writes a file of GNUPLOT commands to plot a 3D surface. ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    a surface Z(X,Y).  A grid data file, containing values of X, Y and Z, !    will also be needed.  The routine WRITE_XYZGRID_DATA can write this file. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_SURFACE - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_SURFACE - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'set pm3d implicit at s' !; set palette gray' write ( file_unit , '(a)' ) 'set hidden3d' !write ( file_unit, '(a)' ) 'set contour' !~   write ( file_unit, '(a)' ) 'splot \"' // trim ( data_file_name ) // & !~     '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // '\"' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_SURFACE_COMMANDS:' write ( * , '(a)' ) '  Wrote the GNUPLOT surface plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyzgrid_surface","tags":"","loc":"proc/write_xyzgrid_surface.html"},{"title":"write_y_plot – TOOLIB","text":"private  subroutine write_y_plot(command_file_name, data_file_name, ierror) WRITE_Y_PLOT writes GNUPLOT commands to plot Y(1:N) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror Calls proc~~write_y_plot~~CallsGraph proc~write_y_plot write_y_plot proc~get_unit~2 get_unit proc~write_y_plot->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_y_plot ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_Y_PLOT writes GNUPLOT commands to plot Y(1:N) data. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // & '\" using 1 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_y_plot","tags":"","loc":"proc/write_y_plot.html"},{"title":"analyse_solver – TOOLIB","text":"private  subroutine analyse_solver(mat) Subroutine to analyse, factorize (symbolic) the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~analyse_solver~~CallsGraph proc~analyse_solver analyse_solver dmumps dmumps proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~analyse_solver~~CalledByGraph proc~analyse_solver analyse_solver proc~solve_syst solve_syst proc~solve_syst->proc~analyse_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine analyse_solver ( mat ) !! Subroutine to analyse, factorize (symbolic) the matrix of the system implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver","tags":"","loc":"proc/analyse_solver.html"},{"title":"close_solver – TOOLIB","text":"private  subroutine close_solver(mat) Subroutine to close the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~close_solver~~CallsGraph proc~close_solver close_solver dmumps dmumps proc~close_solver->dmumps infog infog proc~close_solver->infog ma48_finalize ma48_finalize proc~close_solver->ma48_finalize mpi_finalize mpi_finalize proc~close_solver->mpi_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~close_solver~~CalledByGraph proc~close_solver close_solver proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine close_solver ( mat ) !! Subroutine to close the solver implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr if ( allocated ( mat % eltptr ) ) deallocate ( mat % eltptr ) if ( allocated ( mat % eltvar ) ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver","tags":"","loc":"proc/close_solver.html"},{"title":"convert_matrice_format – TOOLIB","text":"public  subroutine convert_matrice_format(mat) Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. Elemental entries (example provided by MUMP):\nA1 = 1|-1  2  3| A2 = 3|2 -1  3|\n     2| 2  1  1|      4|1  2 -1|\n     3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) A  = 1|-1  2  3  0  0|\n     2| 2  1  1  0  0|\n     3| 1  1  3 -1  3|\n     4| 0  0  1  2 -1|\n     5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix\n                       => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last\n                                              position being size(eltvar)+1) Assembled matrix :\nA being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1)\n                   irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5)\n                   jptr = (1, 4, 7, 12, 15, 18) =======================================================================================================================\nTriplet form For each non zero a_elt entry, returns its row and column number\nA being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1)\n                   irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5)\n                   jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~convert_matrice_format~~CallsGraph proc~convert_matrice_format convert_matrice_format proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~sort_array2 sort_array2 proc~from_elemental_to_assembled->proc~sort_array2 proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~convert_matrice_format~~CalledByGraph proc~convert_matrice_format convert_matrice_format program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine convert_matrice_format ( mat ) !! Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i !< ======================================================================================================================= !< Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. !< ************************************************ !< Elemental entries (example provided by MUMP): !< A1 = 1|-1  2  3| A2 = 3|2 -1  3| !<      2| 2  1  1|      4|1  2 -1| !<      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) !< !< A  = 1|-1  2  3  0  0| !<      2| 2  1  1  0  0| !<      3| 1  1  3 -1  3| !<      4| 0  0  1  2 -1| !<      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !<                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !<                                               position being size(eltvar)+1) !< !< ************************************************ !< Assembled matrix : !< A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !<                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !<                    jptr = (1, 4, 7, 12, 15, 18) !< !< ======================================================================================================================= !< Triplet form !< ************************************************ !< For each non zero a_elt entry, returns its row and column number !< A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !<                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !<                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format","tags":"","loc":"proc/convert_matrice_format.html"},{"title":"factorize_solver – TOOLIB","text":"private  subroutine factorize_solver(mat) Subroutine to factorize the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~factorize_solver~~CallsGraph proc~factorize_solver factorize_solver dmumps dmumps proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~fact_superlu fact_superlu proc~factorize_solver->proc~fact_superlu proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~factorize_solver->proc~umfpack_di_free_numeric interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit interface~statprint StatPrint proc~fact_superlu->interface~statprint proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~factorize_solver~~CalledByGraph proc~factorize_solver factorize_solver proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine factorize_solver ( mat ) !! Subroutine to factorize the matrix of the system implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* !if ( mat%fac ) call freefact_solver(mat) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver","tags":"","loc":"proc/factorize_solver.html"},{"title":"freefact_solver – TOOLIB","text":"private  subroutine freefact_solver(mat) Subroutine to free the factors if applicable Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~freefact_solver~~CallsGraph proc~freefact_solver freefact_solver proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~freefact_solver->proc~umfpack_di_free_numeric interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~freefact_solver~~CalledByGraph proc~freefact_solver freefact_solver proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine freefact_solver ( mat ) !! Subroutine to free the factors if applicable implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver","tags":"","loc":"proc/freefact_solver.html"},{"title":"from_elemental_to_assembled – TOOLIB","text":"private  subroutine from_elemental_to_assembled(mat) Subroutine to transform the elemental entries into assembled CC vectors Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~from_elemental_to_assembled~~CallsGraph proc~from_elemental_to_assembled from_elemental_to_assembled proc~sort_array2 sort_array2 proc~from_elemental_to_assembled->proc~sort_array2 proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~from_elemental_to_assembled~~CalledByGraph proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format convert_matrice_format proc~convert_matrice_format->proc~from_elemental_to_assembled program~test_solvers test_solvers program~test_solvers->proc~convert_matrice_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine from_elemental_to_assembled ( mat ) !! Subroutine to transform the elemental entries into assembled CC vectors implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_array2 ( tab_inout = jcol ( 1 : ntot ), & ! tab1 = irow ( 1 : ntot ), & ! tab2 = a_elt ( 1 : ntot ), n = ntot ) ! ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_array2 ( tab_inout = irow ( i1 : i2 ), & ! tab1 = a_elt ( i1 : i2 ), n = i2 - i1 + 1 ) ! enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled","tags":"","loc":"proc/from_elemental_to_assembled.html"},{"title":"init_solver – TOOLIB","text":"private  subroutine init_solver(mat) Subroutine to initialize the matrices of the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type Calls proc~~init_solver~~CallsGraph proc~init_solver init_solver dmumps dmumps proc~init_solver->dmumps icntl icntl proc~init_solver->icntl infog infog proc~init_solver->infog ma48_initialize ma48_initialize proc~init_solver->ma48_initialize mpi_finalize mpi_finalize proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_solver~~CalledByGraph proc~init_solver init_solver proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_solver ( mat ) !! Subroutine to initialize the matrices of the solver implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect #else stop 'MA48_LIB not defined' #endif case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 1 ) = output_unit ! output stream for error messages mat % matmump % icntl ( 2 ) = error_unit ! output stream for diagnostic printing, statistics, and warning messages. mat % matmump % icntl ( 3 ) = error_unit ! output stream for global information, collected on the host. mat % matmump % icntl ( 4 ) = 1 ! level of printing for error, warning, and diagnostic messages. 1 : only errors mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver","tags":"","loc":"proc/init_solver.html"},{"title":"solution_solver – TOOLIB","text":"private  subroutine solution_solver(mat) Subroutine to solve the system (sparse A) Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type Calls proc~~solution_solver~~CallsGraph proc~solution_solver solution_solver dmumps dmumps proc~solution_solver->dmumps infog infog proc~solution_solver->infog ma48_solve ma48_solve proc~solution_solver->ma48_solve mpi_finalize mpi_finalize proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst rhs rhs proc~solution_solver->rhs proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~statinit StatInit proc~solv_superlu->interface~statinit interface~statprint StatPrint proc~solv_superlu->interface~statprint proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu proc~solve_syst->proc~solution_solver proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~analyse_solver->dmumps proc~analyse_solver->proc~prep_superlu ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~close_solver->dmumps proc~close_solver->infog proc~close_solver->mpi_finalize ma48_finalize ma48_finalize proc~close_solver->ma48_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~fact_superlu fact_superlu proc~factorize_solver->proc~fact_superlu proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~freefact_solver->proc~umfpack_di_free_numeric proc~init_solver->dmumps proc~init_solver->infog proc~init_solver->mpi_finalize icntl icntl proc~init_solver->icntl ma48_initialize ma48_initialize proc~init_solver->ma48_initialize mpi_init mpi_init proc~init_solver->mpi_init proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix proc~fact_superlu->interface~dgssvx proc~fact_superlu->interface~statfree proc~fact_superlu->interface~statinit proc~fact_superlu->interface~statprint interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solution_solver~~CalledByGraph proc~solution_solver solution_solver proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine solution_solver ( mat ) !! Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver","tags":"","loc":"proc/solution_solver.html"},{"title":"solve_syst – TOOLIB","text":"public  subroutine solve_syst(mat, step) Note General hat subroutine that handles the resolution steps: ini solver initialization ana solver analyzis when it’s proposed by the solver fac solver factorization sol solver solution fre solver memory release when it’s proposed by the solver end solver end Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step ‘ini’=initialize, ‘ana’=analyze, ‘fac’=factorize, ‘sol’=solve, ‘fre’=free memory, ‘end’=close solver Calls proc~~solve_syst~~CallsGraph proc~solve_syst solve_syst proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver dmumps dmumps proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~close_solver->dmumps infog infog proc~close_solver->infog ma48_finalize ma48_finalize proc~close_solver->ma48_finalize mpi_finalize mpi_finalize proc~close_solver->mpi_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~fact_superlu fact_superlu proc~factorize_solver->proc~fact_superlu proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~freefact_solver->proc~umfpack_di_free_numeric proc~init_solver->dmumps icntl icntl proc~init_solver->icntl proc~init_solver->infog ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~solution_solver->proc~solve_syst proc~solution_solver->dmumps proc~solution_solver->infog ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu rhs rhs proc~solution_solver->rhs interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit interface~statprint StatPrint proc~fact_superlu->interface~statprint interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~solv_superlu->proc~prep_superlu proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix proc~solv_superlu->interface~dgssvx proc~solv_superlu->interface~statfree proc~solv_superlu->interface~statinit proc~solv_superlu->interface~statprint interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solve_syst~~CalledByGraph proc~solve_syst solve_syst proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; mat % ini = . true . ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; mat % ana = . true . ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; mat % fac = . true . ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; mat % sol = . true . ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; mat % fre = . true . ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; mat % end = . true . ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst","tags":"","loc":"proc/solve_syst.html"},{"title":"modify_a_elt – TOOLIB","text":"subroutine modify_a_elt(tab, nz) mMltiplication of the system coefficient by a random factor Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout) :: tab (1:nz) integer(kind=I4), intent(in) :: nz Called by proc~~modify_a_elt~~CalledByGraph proc~modify_a_elt modify_a_elt program~test_solvers test_solvers program~test_solvers->proc~modify_a_elt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine modify_a_elt ( tab , nz ) !! mMltiplication of the system coefficient by a random factor implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt","tags":"","loc":"proc/modify_a_elt.html"},{"title":"prod_a_x – TOOLIB","text":"subroutine prod_a_x(n, nz, x, y, a_elt, irow, jptr, slvt) , assembled CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz) :: a_elt integer(kind=I4), intent(in), dimension(nz ) :: irow integer(kind=I4), intent(in), dimension(n+1) :: jptr integer(kind=I4), intent(in) :: slvt Called by proc~~prod_a_x~~CalledByGraph proc~prod_a_x prod_a_x proc~verif_solution verif_solution proc~verif_solution->proc~prod_a_x program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) !! [A] \\{x\\}, assembled CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x","tags":"","loc":"proc/prod_a_x.html"},{"title":"prod_elemental_x – TOOLIB","text":"subroutine prod_elemental_x(n, nz, nelt, nvar, x, y, a_elt, eltptr, eltvar) , elemental CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz integer(kind=I4), intent(in) :: nelt integer(kind=I4), intent(in) :: nvar real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz     ) :: a_elt integer(kind=I4), intent(in), dimension(nelt +1) :: eltptr integer(kind=I4), intent(in), dimension(nvar   ) :: eltvar Called by proc~~prod_elemental_x~~CalledByGraph proc~prod_elemental_x prod_elemental_x proc~verif_solution verif_solution proc~verif_solution->proc~prod_elemental_x program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) !! [A] \\{x\\}, elemental CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x","tags":"","loc":"proc/prod_elemental_x.html"},{"title":"verif_solution – TOOLIB","text":"subroutine verif_solution(slv_struct, a_elt, b, error) Note The product of the system matrix by the solution , is\n       calculated, and compared to the right hand side .\n       The calculated error is the absolute error in %. Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(in) :: slv_struct real(kind=R8), intent(in), dimension(:) :: a_elt real(kind=R8), intent(in), dimension(:) :: b real(kind=R8), intent(out) :: error Calls proc~~verif_solution~~CallsGraph proc~verif_solution verif_solution proc~prod_a_x prod_a_x proc~verif_solution->proc~prod_a_x proc~prod_elemental_x prod_elemental_x proc~verif_solution->proc~prod_elemental_x Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~verif_solution~~CalledByGraph proc~verif_solution verif_solution program~test_solvers test_solvers program~test_solvers->proc~verif_solution Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution","tags":"","loc":"proc/verif_solution.html"},{"title":"dir_separator – TOOLIB","text":"public  function dir_separator() Function that returns the system directory separator Arguments None Return Value character(len=1) Calls proc~~dir_separator~~CallsGraph proc~dir_separator dir_separator proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dir_separator~~CalledByGraph proc~dir_separator dir_separator proc~dirname dirname proc~dirname->proc~dir_separator proc~filename filename proc~filename->proc~dir_separator proc~make_path make_path proc~make_path->proc~dir_separator proc~path2vec path2vec proc~path2vec->proc~dir_separator proc~vec2path vec2path proc~vec2path->proc~dir_separator program~test_files test_files program~test_files->proc~dir_separator program~test_files->proc~filename program~test_files->proc~make_path program~test_files->proc~path2vec program~test_files->proc~vec2path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/dir_separator.html"},{"title":"dirname – TOOLIB","text":"public  function dirname(file_path) Subroutine that keeps only the directory from a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path Return Value character(len=:), allocatable Calls proc~~dirname~~CallsGraph proc~dirname dirname proc~dir_separator dir_separator proc~dirname->proc~dir_separator proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function dirname ( file_path ) !! Subroutine that keeps only the directory from a file path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = :), allocatable :: dirname character ( len = 1 ) :: sep integer ( kind = I4 ) :: ind sep = dir_separator () ind = index ( file_path , sep , back = . true . ) dirname = trim ( file_path ( : ind - 1 ) ) return endfunction dirname","tags":"","loc":"proc/dirname.html"},{"title":"filename – TOOLIB","text":"public  function filename(file_path) Subroutine that keeps only the file from a path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path Return Value character(len=:), allocatable Calls proc~~filename~~CallsGraph proc~filename filename proc~dir_separator dir_separator proc~filename->proc~dir_separator proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~filename~~CalledByGraph proc~filename filename program~test_files test_files program~test_files->proc~filename Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function filename ( file_path ) !! Subroutine that keeps only the file from a path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = :), allocatable :: filename character ( len = 1 ) :: sep integer ( kind = I4 ) :: ind sep = dir_separator () ind = index ( file_path , sep , back = . true . ) filename = trim ( file_path ( ind + 1 : ) ) return endfunction filename","tags":"","loc":"proc/filename.html"},{"title":"is_linux – TOOLIB","text":"public  function is_linux() Function that returns true if the operating system is linux Arguments None Return Value logical(kind=4) Called by proc~~is_linux~~CalledByGraph proc~is_linux is_linux proc~dir_separator dir_separator proc~dir_separator->proc~is_linux proc~dirname dirname proc~dirname->proc~dir_separator proc~filename filename proc~filename->proc~dir_separator proc~make_path make_path proc~make_path->proc~dir_separator proc~path2vec path2vec proc~path2vec->proc~dir_separator proc~vec2path vec2path proc~vec2path->proc~dir_separator program~test_files test_files program~test_files->proc~dir_separator program~test_files->proc~filename program~test_files->proc~make_path program~test_files->proc~path2vec program~test_files->proc~vec2path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/is_linux.html"},{"title":"str_remove_chars – TOOLIB","text":"public  function str_remove_chars(string, chars) Function that removes the characters of a string from another string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string string to be modified character(len=*), intent(in) :: chars list of characters to remove Return Value character(len=:), allocatable returned string Called by proc~~str_remove_chars~~CalledByGraph proc~str_remove_chars str_remove_chars program~test_files test_files program~test_files->proc~str_remove_chars Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function str_remove_chars ( string , chars ) !! Function that removes the characters of a string from another string implicit none character ( len = :), allocatable :: str_remove_chars !! returned string character ( len = * ), intent ( in ) :: string !! string to be modified character ( len = * ), intent ( in ) :: chars !! list of characters to remove integer ( kind = I4 ) :: i , j str_remove_chars = '' ! Loop through each character in the input string j = 1 do i = 1 , len_trim ( string ) if ( index ( chars , string ( i : i ) ) == 0 ) then str_remove_chars = str_remove_chars // String ( i : i ) j = j + 1 endif enddo return endfunction str_remove_chars","tags":"","loc":"proc/str_remove_chars.html"},{"title":"str_replace – TOOLIB","text":"public  function str_replace(string, old_str, new_str, place) Function that replaces a string with another string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string string to be modified character(len=*), intent(in) :: old_str character(len=*), intent(in) :: new_str integer(kind=I4), intent(in) :: place Return Value character(len=:), allocatable returned string Called by proc~~str_replace~~CalledByGraph proc~str_replace str_replace program~test_files test_files program~test_files->proc~str_replace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function str_replace ( string , old_str , new_str , place ) !! Function that replaces a string with another string implicit none character ( len = :), allocatable :: str_replace !! returned string character ( len = * ), intent ( in ) :: string !! string to be modified character ( len = * ), intent ( in ) :: old_str character ( len = * ), intent ( in ) :: new_str integer ( kind = I4 ), intent ( in ) :: place integer ( kind = I4 ) :: ind select case ( place ) case ( 0 , 2 ) ind = index ( string , old_str ) case ( 1 ) ind = index ( string , old_str , back = . true . ) case default stop 'str_replace bad choice' endselect str_replace = string ( 1 : ind - 1 ) // new_str // string ( ind + len ( old_str ): len ( string )) if ( place == 2 ) then do ind = index ( str_replace , old_str ) if ( ind == 0 ) exit str_replace = str_replace ( 1 : ind - 1 ) // new_str // str_replace ( ind + len ( old_str ): len ( str_replace )) enddo endif return endfunction str_replace","tags":"","loc":"proc/str_replace.html"},{"title":"clean_scratch – TOOLIB","text":"public  subroutine clean_scratch() Subroutine that removes all files with extension .scratch Arguments None Source Code subroutine clean_scratch () !! Subroutine that removes all files with extension .scratch implicit none call execute_command_line ( \"find -type f -name \"\"*.scratch\"\" | xargs rm > err.scratch\" ) return endsubroutine clean_scratch","tags":"","loc":"proc/clean_scratch.html"},{"title":"list_dirs – TOOLIB","text":"public  subroutine list_dirs(str) Subroutine that returns a list of subdirectories Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: str Source Code subroutine list_dirs ( str ) !! Subroutine that returns a list of subdirectories implicit none character ( len = * ), intent ( in ), optional :: str if ( present ( str ) ) then call execute_command_line ( \"find . -maxdepth 1 -type d -name \"\"*\" // trim ( str ) // \"*\"\" > \" // trim ( str ) // \".scratch\" ) else call execute_command_line ( \"find . -maxdepth 1 -type d > dirs.scratch\" ) endif return endsubroutine list_dirs","tags":"","loc":"proc/list_dirs.html"},{"title":"list_files – TOOLIB","text":"public  subroutine list_files(dir, list, ext) Subroutine that returns a list of files in a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir character(len=512), intent(out), allocatable, dimension(:) :: list character(len=*), intent(in), optional :: ext Calls proc~~list_files~~CallsGraph proc~list_files list_files proc~get_unit get_unit proc~list_files->proc~get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~list_files~~CalledByGraph proc~list_files list_files program~test_files test_files program~test_files->proc~list_files Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine list_files ( dir , list , ext ) !! Subroutine that returns a list of files in a directory implicit none character ( len = * ), intent ( in ) :: dir character ( len = 512 ), intent ( out ), allocatable , dimension (:) :: list character ( len = * ), intent ( in ), optional :: ext character ( len = :), allocatable :: out_file character ( len = 512 ) :: string integer ( kind = I4 ) :: ui , line , i , max_len , ierr if ( present ( ext ) ) then out_file = trim ( ext ) // \".scratch\" call execute_command_line ( \"find \" // trim ( dir ) // \" -maxdepth 1 -type f -name \"\"*.\" // trim ( ext ) // \"\"\" > \" // out_file ) else out_file = \"files.scratch\" call execute_command_line ( \"find \" // trim ( dir ) // \" -maxdepth 1 -type f > \" // out_file ) endif call get_unit ( ui ) open ( unit = ui , file = out_file ) line = 0 max_len = 0 do string = ' ' read ( unit = ui , fmt = '(a)' , iostat = ierr ) string if ( ierr /= 0 ) exit max_len = max ( max_len , len_trim ( string ) ) line = line + 1 enddo if ( max_len > 512 ) stop 'Error list_files: path too long' allocate ( list ( 1 : line ) ) rewind ( ui ) do i = 1 , line read ( unit = ui , fmt = '(a)' ) list ( i ) enddo close ( ui ) deallocate ( out_file ) return endsubroutine list_files","tags":"","loc":"proc/list_files.html"},{"title":"make_path – TOOLIB","text":"public  subroutine make_path(wkd, file_path, exit_status) Subroutine that creates the folders of a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wkd character(len=*), intent(in) :: file_path integer(kind=I4), intent(out) :: exit_status Calls proc~~make_path~~CallsGraph proc~make_path make_path proc~dir_separator dir_separator proc~make_path->proc~dir_separator proc~mkdir mkdir proc~make_path->proc~mkdir proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~make_path~~CalledByGraph proc~make_path make_path program~test_files test_files program~test_files->proc~make_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine make_path ( wkd , file_path , exit_status ) !! Subroutine that creates the folders of a file path implicit none character ( len = * ), intent ( in ) :: wkd character ( len = * ), intent ( in ) :: file_path integer ( kind = I4 ), intent ( out ) :: exit_status character ( len = 512 ) :: dir character ( len = 1 ) :: sep integer ( kind = I4 ) :: isep sep = dir_separator () isep = index ( file_path , sep , back = . true . ) dir = file_path ( 1 : isep - 1 ) call mkdir ( wkd = wkd , directory = trim ( dir ), sep = sep , exit_status = exit_status ) return endsubroutine make_path","tags":"","loc":"proc/make_path.html"},{"title":"mkdir – TOOLIB","text":"public  subroutine mkdir(wkd, directory, sep, exit_status) Subroutine that creates a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wkd character(len=*), intent(in) :: directory character(len=1), intent(in) :: sep integer(kind=I4), intent(out) :: exit_status Called by proc~~mkdir~~CalledByGraph proc~mkdir mkdir proc~make_path make_path proc~make_path->proc~mkdir program~test_files test_files program~test_files->proc~mkdir program~test_files->proc~make_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine mkdir ( wkd , directory , sep , exit_status ) !! Subroutine that creates a directory implicit none character ( len = * ), intent ( in ) :: wkd character ( len = * ), intent ( in ) :: directory character ( len = 1 ), intent ( in ) :: sep integer ( kind = I4 ), intent ( out ) :: exit_status character ( len = 512 ) :: dir dir = trim ( wkd ) // sep // trim ( directory ) call execute_command_line ( \"mkdir -p \" // sep // dir , exitstat = exit_status ) return endsubroutine mkdir","tags":"","loc":"proc/mkdir.html"},{"title":"path2vec – TOOLIB","text":"public  subroutine path2vec(file_path, vec_path) Subroutine that creates a vector containing the folders of a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path character(len=512), intent(out), dimension(:), allocatable :: vec_path Calls proc~~path2vec~~CallsGraph proc~path2vec path2vec proc~dir_separator dir_separator proc~path2vec->proc~dir_separator proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~path2vec~~CalledByGraph proc~path2vec path2vec program~test_files test_files program~test_files->proc~path2vec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine path2vec ( file_path , vec_path ) !! Subroutine that creates a vector containing the folders of a file path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = 512 ), intent ( out ), dimension (:), allocatable :: vec_path character ( len = 512 ) :: dir character ( len = 1 ) :: sep integer ( kind = I4 ) :: is1 , is2 , k sep = dir_separator () k = 0 is2 = len_trim ( file_path ) do is2 = index ( file_path ( 1 : is2 - 1 ), sep , back = . true . ) if ( is2 > 0 ) then k = k + 1 else exit endif enddo allocate ( vec_path ( 1 : k - 1 ) ) is2 = index ( file_path , sep , back = . true . ) dir = file_path ( 1 : is2 - 1 ) k = 0 do is1 = index ( file_path ( 1 : is2 - 1 ), sep , back = . true . ) if ( is1 > 0 ) then k = k + 1 vec_path ( k ) = file_path ( is1 + 1 : is2 - 1 ) is2 = is1 else exit endif enddo vec_path = vec_path ( size ( vec_path ): 1 : - 1 ) return endsubroutine path2vec","tags":"","loc":"proc/path2vec.html"},{"title":"vec2path – TOOLIB","text":"public  subroutine vec2path(file_path, vec_path) Subroutine that creates a path from vector of folders Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: file_path character(len=512), intent(in), dimension(:) :: vec_path Calls proc~~vec2path~~CallsGraph proc~vec2path vec2path proc~dir_separator dir_separator proc~vec2path->proc~dir_separator proc~is_linux is_linux proc~dir_separator->proc~is_linux Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~vec2path~~CalledByGraph proc~vec2path vec2path program~test_files test_files program~test_files->proc~vec2path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine vec2path ( file_path , vec_path ) !! Subroutine that creates a path from vector of folders implicit none character ( len = : ), intent ( out ), allocatable :: file_path character ( len = 512 ), intent ( in ), dimension (:) :: vec_path character ( len = 1 ) :: sep integer ( kind = I4 ) :: k sep = dir_separator () file_path = '' do k = 1 , size ( vec_path ) file_path = file_path // sep // trim ( vec_path ( k ) ) enddo return endsubroutine vec2path","tags":"","loc":"proc/vec2path.html"},{"title":"moindres_carres – TOOLIB","text":"public  subroutine moindres_carres(nb_var, nb_pts, hij, vec_xy, beta, f, df, typ, eps, relax, nb_var_der, info) Note Function that returns the parameters of a function that approximates a data set. The parameters\n       determination is achieved by non linear least squares approximation. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nb_var number of parameters to be determined integer(kind=I4), intent(in) :: nb_pts number of points for function evaluation real(kind=R8), intent(in), dimension(1:nb_pts) :: hij vector of evaluation points real(kind=R8), intent(in), dimension(1:nb_pts, 1:2) :: vec_xy x and y coordinates of evaluation points real(kind=R8), intent(inout), dimension(1:nb_var) :: beta parameters vector private  function f(xi, yi, var, nb_var, typ) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yi real(kind=R8), intent(inout), dimension(1:nb_var) :: var integer(kind=I4), intent(in) :: nb_var character(len=*), intent(in) :: typ Return Value real(kind=r8) private  function df(xi, yi, var, nb_var, ivar, typ) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yi real(kind=R8), intent(inout), dimension(1:nb_var) :: var integer(kind=I4), intent(in) :: nb_var integer(kind=I4), intent(in) :: ivar character(len=*), intent(in) :: typ Return Value real(kind=r8) character(len=*), intent(in) :: typ kind of function used real(kind=R8), intent(in) :: eps stop criterion real(kind=R8), intent(in) :: relax relaxation parameter integer(kind=I4), intent(in) :: nb_var_der number of derivatives integer(kind=I4), intent(out) :: info information from Cholesky resolution Calls proc~~moindres_carres~~CallsGraph proc~moindres_carres moindres_carres proc~choldc choldc proc~moindres_carres->proc~choldc proc~cholsl cholsl proc~moindres_carres->proc~cholsl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~moindres_carres~~CalledByGraph proc~moindres_carres moindres_carres program~test_least test_least program~test_least->proc~moindres_carres Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine moindres_carres ( nb_var , nb_pts , hij , vec_xy , beta , f , df , typ , eps , relax , nb_var_der , info ) !================================================================================================ !< @note Function that returns the parameters of a function that approximates a data set. The parameters !<        determination is achieved by non linear least squares approximation. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *number of points for function evaluation* integer ( kind = I4 ), intent ( in ) :: nb_var_der !! *number of derivatives* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts ) :: hij !! *vector of evaluation points* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts , 1 : 2 ) :: vec_xy !! *x and y coordinates of evaluation points* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: beta !! *parameters vector* real ( kind = R8 ), intent ( in ) :: eps !! *stop criterion* real ( kind = R8 ), intent ( in ) :: relax !! *relaxation parameter* character ( len =* ), intent ( in ) :: typ !! *kind of function used* integer ( kind = I4 ), intent ( out ) :: info !! *information from Cholesky resolution* interface real ( kind = R8 ) function f ( xi , yi , var , nb_var , typ ) use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: yi real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var character ( len =* ), intent ( in ) :: typ endfunction f real ( kind = R8 ) function df ( xi , yi , var , nb_var , ivar , typ ) use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var integer ( kind = I4 ), intent ( in ) :: ivar real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: yi real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var character ( len =* ), intent ( in ) :: typ endfunction df endinterface integer ( kind = I4 ) :: i , ii , j , compteur integer ( kind = I4 ) :: n , pseudo_newton real ( kind = R8 ) :: xi , yi , m_abs_scd real ( kind = R8 ), dimension ( 1 : nb_var_der ) :: scd real ( kind = R8 ), dimension ( 1 : nb_var_der , 1 : nb_var_der ) :: mat , sav_mat real ( kind = R8 ), allocatable , dimension (:,:) :: Jf , JfT real ( kind = R8 ), allocatable , dimension (:) :: vec_f , r , pt n = nint ( sqrt ( real ( nb_pts , kind = R8 )) ) allocate ( Jf ( 1 : nb_pts , 1 : nb_var_der ) ) allocate ( JfT ( 1 : nb_var_der , 1 : nb_pts ) ) allocate ( vec_f ( 1 : nb_pts ) ) allocate ( r ( 1 : nb_pts ) ) allocate ( pt ( 1 : nb_var_der )) compteur = 0 pseudo_newton = 10 w : do do ii = 1 , nb_pts xi = vec_xy ( ii , 1 ) yi = vec_xy ( ii , 2 ) vec_f ( ii ) = f ( xi = xi , & ! yi = yi , & ! var = beta ( 1 : nb_var ), & ! nb_var = nb_var , & ! typ = typ ) ! enddo if ( mod ( compteur , pseudo_newton ) == 0 ) then ! http://en.wikipedia.org/wiki/Least_squares do j = 1 , nb_var_der do ii = 1 , nb_pts xi = vec_xy ( ii , 1 ) yi = vec_xy ( ii , 2 ) Jf ( ii , j ) = df ( xi = xi , & ! yi = yi , & ! var = beta ( 1 : nb_var ), & ! nb_var = nb_var , & ! ivar = j , & ! typ = typ ) ! enddo enddo JfT ( 1 : nb_var_der , 1 : nb_pts ) = transpose ( Jf ( 1 : nb_pts , 1 : nb_var_der ) ) sav_mat ( 1 : nb_var_der , 1 : nb_var_der ) = matmul ( JfT ( 1 : nb_var_der , 1 : nb_pts ), Jf ( 1 : nb_pts , 1 : nb_var_der ) ) endif r ( 1 : nb_pts ) = hij ( 1 : nb_pts ) - vec_f ( 1 : nb_pts ) scd ( 1 : nb_var_der ) = matmul ( JfT ( 1 : nb_var_der , 1 : nb_pts ), r ( 1 : nb_pts ) ) mat ( 1 : nb_var_der , 1 : nb_var_der ) = sav_mat ( 1 : nb_var_der , 1 : nb_var_der ) forall ( i = 1 : nb_var_der ) mat ( i , i ) = 1.5 * mat ( i , i ) ! type levenberg-marquardt call choldc ( a = mat ( 1 : nb_var_der , 1 : nb_var_der ), & ! n = nb_var_der , & ! np = nb_var_der , & ! p = pt ( 1 : nb_var_der ), & ! info = info ) ! call cholsl ( a = mat ( 1 : nb_var_der , 1 : nb_var_der ), & ! n = nb_var_der , & ! np = nb_var_der , & ! p = pt ( 1 : nb_var_der ), & ! b = scd ( 1 : nb_var_der ), & ! x = scd ( 1 : nb_var_der ), & ! info = info ) ! beta ( 1 : nb_var_der ) = beta ( 1 : nb_var_der ) + relax * scd ( 1 : nb_var_der ) m_abs_scd = 100 * maxval ( abs ( scd ( 1 : nb_var_der ) / abs ( beta ( 1 : nb_var_der ))) ) if (( m_abs_scd ) < eps ) exit w compteur = compteur + 1 if ( mod ( compteur , 1000 ) == 0 ) then if ( verbose ) write ( * , * ) compteur , m_abs_scd endif enddo w deallocate ( Jf , JfT , vec_f , r , pt ) return endsubroutine moindres_carres","tags":"","loc":"proc/moindres_carres.html"},{"title":"moindres_carres_lineaire – TOOLIB","text":"public  subroutine moindres_carres_lineaire(nb_var, nb_pts, hij, beta, Jf) Note Function that returns the parameters of a function that approximates a data set. The parameters\n       determination is achieved by linear least squares approximation. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nb_var number of parameters to be determined integer(kind=I4), intent(in) :: nb_pts number of points for function evaluation real(kind=R8), intent(in), dimension(1:nb_pts) :: hij vector of evaluation points real(kind=R8), intent(out), dimension(1:nb_var) :: beta parameters vector real(kind=R8), intent(in), dimension(1:nb_pts, 1:nb_var) :: Jf Jacobian Calls proc~~moindres_carres_lineaire~~CallsGraph proc~moindres_carres_lineaire moindres_carres_lineaire proc~choldc choldc proc~moindres_carres_lineaire->proc~choldc proc~cholsl cholsl proc~moindres_carres_lineaire->proc~cholsl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~moindres_carres_lineaire~~CalledByGraph proc~moindres_carres_lineaire moindres_carres_lineaire proc~least_squares_tcheby least_squares_tcheby proc~least_squares_tcheby->proc~moindres_carres_lineaire program~test_least test_least program~test_least->proc~moindres_carres_lineaire program~test_tchebychev test_tchebychev program~test_tchebychev->proc~least_squares_tcheby Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine moindres_carres_lineaire ( nb_var , nb_pts , hij , beta , Jf ) !================================================================================================ !< @note Function that returns the parameters of a function that approximates a data set. The parameters !<        determination is achieved by linear least squares approximation. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *number of points for function evaluation* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts ) :: hij !! *vector of evaluation points* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts , 1 : nb_var ) :: Jf !! *Jacobian* real ( kind = R8 ), intent ( out ), dimension ( 1 : nb_var ) :: beta !! *parameters vector* integer ( kind = I4 ) :: info real ( kind = R8 ), dimension ( 1 : nb_var ) :: scd , pt real ( kind = R8 ), dimension ( 1 : nb_var , 1 : nb_var ) :: mat real ( kind = R8 ), allocatable , dimension (:,:) :: JfT allocate ( JfT ( 1 : nb_var , 1 : nb_pts ) ) JfT ( 1 : nb_var , 1 : nb_pts ) = transpose ( Jf ( 1 : nb_pts , 1 : nb_var ) ) mat ( 1 : nb_var , 1 : nb_var ) = matmul ( JfT ( 1 : nb_var , 1 : nb_pts ), Jf ( 1 : nb_pts , 1 : nb_var ) ) scd ( 1 : nb_var ) = matmul ( JfT ( 1 : nb_var , 1 : nb_pts ), hij ( 1 : nb_pts ) ) call choldc ( a = mat ( 1 : nb_var , 1 : nb_var ), & ! n = nb_var , & ! np = nb_var , & ! p = pt ( 1 : nb_var ), & ! info = info ) ! call cholsl ( a = mat ( 1 : nb_var , 1 : nb_var ), & ! n = nb_var , & ! np = nb_var , & ! p = pt ( 1 : nb_var ), & ! b = scd ( 1 : nb_var ), & ! x = scd ( 1 : nb_var ), & ! info = info ) ! beta ( 1 : nb_var ) = scd ( 1 : nb_var ) deallocate ( JfT ) return endsubroutine moindres_carres_lineaire","tags":"","loc":"proc/moindres_carres_lineaire.html"},{"title":"func – TOOLIB","text":"pure elemental function func(xi, yj) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yj Return Value real(kind=r8) Called by proc~~func~~CalledByGraph proc~func func proc~interp_surf interp_surf proc~interp_surf->proc~func program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/func.html"},{"title":"interp_surf – TOOLIB","text":"subroutine interp_surf(nx, ny, nnx, nny, deg, mad) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx integer(kind=I4), intent(in) :: ny integer(kind=I4), intent(in) :: nnx integer(kind=I4), intent(in) :: nny integer(kind=I4), intent(in) :: deg real(kind=R8), intent(out) :: mad Calls proc~~interp_surf~~CallsGraph proc~interp_surf interp_surf proc~db2ink db2ink proc~interp_surf->proc~db2ink proc~db2val db2val proc~interp_surf->proc~db2val proc~func func proc~interp_surf->proc~func proc~check_inputs check_inputs proc~db2ink->proc~check_inputs proc~dbknot dbknot proc~db2ink->proc~dbknot proc~dbtpcf dbtpcf proc~db2ink->proc~dbtpcf proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dintrv dintrv proc~db2val->proc~dintrv proc~dbintk dbintk proc~dbtpcf->proc~dbintk proc~dbnslv dbnslv proc~dbtpcf->proc~dbnslv proc~dbvalu->proc~dintrv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~interp_surf~~CalledByGraph proc~interp_surf interp_surf program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine interp_surf ( nx , ny , nnx , nny , deg , mad ) implicit none integer ( kind = I4 ), intent ( in ) :: nx , ny , nnx , nny , deg real ( kind = R8 ), intent ( out ) :: mad integer ( kind = I4 ) :: i , j , inbvx , inbvy , iloy , iflag real ( kind = R8 ) :: val real ( kind = R8 ), dimension ( 1 : nx , 1 : ny ) :: coeff , tab real ( kind = R8 ), dimension ( 1 : nnx , 1 : nny ) :: tab_ref , tab_int real ( kind = R8 ), dimension ( 1 :( nx + deg )) :: tx real ( kind = R8 ), dimension ( 1 :( ny + deg )) :: ty real ( kind = R8 ), dimension ( 1 : nx ) :: x real ( kind = R8 ), dimension ( 1 : ny ) :: y real ( kind = R8 ), dimension ( 1 : nnx ) :: xx real ( kind = R8 ), dimension ( 1 : nny ) :: yy x ( 1 : nx ) = [( - 1. + ( i - 1 ) * 2. / ( nx - 1 ), i = 1 , nx )] y ( 1 : ny ) = [( - 1. + ( j - 1 ) * 2. / ( ny - 1 ), j = 1 , ny )] do j = 1 , ny do i = 1 , nx tab ( i , j ) = func ( x ( i ), y ( j ) ) enddo enddo iflag = 0 call db2ink ( x = x ( 1 : nx ), & ! Array of x abcissae. Must be strictly increasing. nx = nx , & ! Number of x abcissae y = y ( 1 : ny ), & ! Array of y abcissae. Must be strictly increasing. ny = ny , & ! Number of y abcissae fcn = tab ( 1 : nx , 1 : ny ), & ! Array of function values to interpolate. fcn(i,j) should !    contain the function value at the point (x(i),y(j)) kx = deg , & ! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) ky = deg , & ! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) tx = tx ( 1 :( nx + deg )), & ! The knots in the x direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. ty = ty ( 1 :( ny + deg )), & ! The knots in the y direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. bcoef = coeff ( 1 : nx , 1 : ny ), & ! Array of coefficients of the b-spline interpolant. iflag = iflag ) ! **on input:**  0 = knot sequence chosen by [[db2ink]]. !                1 = knot sequence chosen by user. ! **on output:** 1 = successful execution. !                2 = iflag out of range. !                3 = nx out of range. !                4 = kx out of range. !                5 = x not strictly increasing. !                6 = tx not non-decreasing. !                7 = ny out of range. !                8 = ky out of range. !                9 = y not strictly increasing. !               10 = ty not non-decreasing. if ( iflag /= 1 ) error stop 'error calling db2ink' xx ( 1 : nnx ) = [( - 1. + ( i - 1 ) * 2. / ( nnx - 1 ), i = 1 , nnx )] yy ( 1 : nny ) = [( - 1. + ( j - 1 ) * 2. / ( nny - 1 ), j = 1 , nny )] inbvx = 1 inbvy = 1 iloy = 1 do j = 1 , nny do i = 1 , nnx call db2val ( xval = xx ( i ), & ! xval     !! x coordinate of evaluation point. yval = yy ( j ), & ! yval     !! y coordinate of evaluation point. idx = 0 , & ! idx      !! x derivative of piecewise polynomial to evaluate. idy = 0 , & ! idy      !! y derivative of piecewise polynomial to evaluate. tx = tx ( 1 :( nx + deg )), & ! tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) ty = ty ( 1 :( ny + deg )), & ! ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) nx = nx , & ! nx       !! the number of interpolation points in x. (same as in last call to [[db2ink]]) ny = ny , & ! ny       !! the number of interpolation points in y. (same as in last call to [[db2ink]]) kx = deg , & ! kx       !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) ky = deg , & ! ky       !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) bcoef = coeff ( 1 : nx , 1 : ny ), & ! bcoef    !! the b-spline coefficients computed by [[db2ink]]. f = val , & ! f        !! interpolated value & iflag = iflag , & ! iflag    !! status flag: 0 : no errors, /=0 : error inbvx = inbvx , & ! inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. inbvy = inbvy , & ! inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. iloy = iloy ) ! iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. tab_int ( i , j ) = val enddo enddo do j = 1 , nny do i = 1 , nnx tab_ref ( i , j ) = func ( xx ( i ), yy ( j ) ) enddo enddo mad = maxval ( abs ( tab_ref - tab_int ) ) return endsubroutine interp_surf","tags":"","loc":"proc/interp_surf.html"},{"title":"genrand64_int64 – TOOLIB","text":"private  function genrand64_int64(me) Generates a random number on [-2&#94;63, 2&#94;63-1]-interval Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value integer(kind=r8) Calls proc~~genrand64_int64~~CallsGraph proc~genrand64_int64 mt19937%genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~genrand64_int64~~CalledByGraph proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1 mt19937%genrand64_real1 proc~genrand64_real1->proc~genrand64_int64 proc~genrand64_real2 mt19937%genrand64_real2 proc~genrand64_real2->proc~genrand64_int64 proc~genrand64_real3 mt19937%genrand64_real3 proc~genrand64_real3->proc~genrand64_int64 proc~urand pikaia_class%urand proc~urand->proc~genrand64_real1 proc~cross pikaia_class%cross proc~cross->proc~urand proc~mutate pikaia_class%mutate proc~mutate->proc~urand proc~pikaia pikaia_class%pikaia proc~pikaia->proc~urand proc~pikaia->proc~cross proc~pikaia->proc~mutate proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~select_parents->proc~urand proc~stdrep->proc~urand proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code integer ( r8 ) function genrand64_int64 ( me ) !! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), parameter :: mag01 ( 0 : 1 ) = [ 0_i8 , matrix_a ] integer ( i8 ) :: x integer :: i if ( me % mti >= nn ) then ! generate nn words at one time ! if init_genrand64() has not been called, a default initial seed is used if ( me % mti == nn + 1 ) call me % init_genrand64 ( seed_def ) do i = 1 , nn - mm x = ior ( iand ( me % mt ( i ), um ), iand ( me % mt ( i + 1 ), lm )) me % mt ( i ) = ieor ( ieor ( me % mt ( i + mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) end do do i = nn - mm + 1 , nn - 1 x = ior ( iand ( me % mt ( i ), um ), iand ( me % mt ( i + 1 ), lm )) me % mt ( i ) = ieor ( ieor ( me % mt ( i + mm - nn ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) end do x = ior ( iand ( me % mt ( nn ), um ), iand ( me % mt ( 1 ), lm )) me % mt ( nn ) = ieor ( ieor ( me % mt ( mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) me % mti = 0 end if me % mti = me % mti + 1 x = me % mt ( me % mti ) x = ieor ( x , iand ( ishft ( x , - 29 ), 6148914691236517205_i8 )) x = ieor ( x , iand ( ishft ( x , 17 ), 8202884508482404352_i8 )) x = ieor ( x , iand ( ishft ( x , 37 ), - 2270628950310912_i8 )) x = ieor ( x , ishft ( x , - 43 )) genrand64_int64 = x end function genrand64_int64","tags":"","loc":"proc/genrand64_int64.html"},{"title":"genrand64_real1 – TOOLIB","text":"private  function genrand64_real1(me) Generates a random number on [0,1]-real-interval Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) Calls proc~~genrand64_real1~~CallsGraph proc~genrand64_real1 mt19937%genrand64_real1 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~genrand64_real1~~CalledByGraph proc~genrand64_real1 mt19937%genrand64_real1 proc~urand pikaia_class%urand proc~urand->proc~genrand64_real1 proc~cross pikaia_class%cross proc~cross->proc~urand proc~mutate pikaia_class%mutate proc~mutate->proc~urand proc~pikaia pikaia_class%pikaia proc~pikaia->proc~urand proc~pikaia->proc~cross proc~pikaia->proc~mutate proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~select_parents->proc~urand proc~stdrep->proc~urand proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r8 ) function genrand64_real1 ( me ) !! Generates a random number on [0,1]-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real1 = real ( ishft ( me % genrand64_int64 (), - 11 ), kind = r8 ) * pi253_1 end function genrand64_real1","tags":"","loc":"proc/genrand64_real1.html"},{"title":"genrand64_real2 – TOOLIB","text":"private  function genrand64_real2(me) Generates a random number on [0,1)-real-interval Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) Calls proc~~genrand64_real2~~CallsGraph proc~genrand64_real2 mt19937%genrand64_real2 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real2->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r8 ) function genrand64_real2 ( me ) !! Generates a random number on [0,1)-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real2 = real ( ishft ( me % genrand64_int64 (), - 11 ), kind = r8 ) * pi253 end function genrand64_real2","tags":"","loc":"proc/genrand64_real2.html"},{"title":"genrand64_real3 – TOOLIB","text":"private  function genrand64_real3(me) Generates a random number on (0,1)-real-interval Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) Calls proc~~genrand64_real3~~CallsGraph proc~genrand64_real3 mt19937%genrand64_real3 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real3->proc~genrand64_int64 proc~init_genrand64 mt19937%init_genrand64 proc~genrand64_int64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( r8 ) function genrand64_real3 ( me ) !! Generates a random number on (0,1)-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real3 = real ( ishft ( me % genrand64_int64 (), - 12 ), kind = r8 ) genrand64_real3 = ( genrand64_real3 + 0.5_r8 ) * pi252 end function genrand64_real3","tags":"","loc":"proc/genrand64_real3.html"},{"title":"init_by_array64 – TOOLIB","text":"private  subroutine init_by_array64(me, init_key) Initializes by an array with array-length init_key is the array for initializing keys Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: init_key (:) Calls proc~~init_by_array64~~CallsGraph proc~init_by_array64 mt19937%init_by_array64 proc~init_genrand64 mt19937%init_genrand64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_by_array64~~CalledByGraph proc~init_by_array64 mt19937%init_by_array64 none~initialize mt19937%initialize none~initialize->proc~init_by_array64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~init_genrand64_i4->none~initialize proc~rninit pikaia_class%rninit proc~rninit->none~initialize proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rninit proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_by_array64 ( me , init_key ) !! Initializes by an array with array-length !! `init_key` is the array for initializing keys implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), intent ( in ) :: init_key (:) integer ( i8 ), parameter :: c1 = 3935559000370003845_i8 integer ( i8 ), parameter :: c2 = 2862933555777941757_i8 integer ( i8 ) :: i , j , k , kk , key_length call me % init_genrand64 ( 19650218_i8 ) key_length = size ( init_key ) i = 1_i8 ; j = 0_i8 k = max ( nn , key_length ) do kk = 1 , k me % mt ( i + 1 ) = ieor ( me % mt ( i + 1 ), c1 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then me % mt ( 1 ) = me % mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 me % mt ( i + 1 ) = ieor ( me % mt ( i + 1 ), c2 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then me % mt ( 1 ) = me % mt ( nn ) i = 1 end if end do me % mt ( 1 ) = ishft ( 1_i8 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64","tags":"","loc":"proc/init_by_array64.html"},{"title":"init_genrand64 – TOOLIB","text":"private  subroutine init_genrand64(me, seed) Initializes me%mt(nn) with a seed Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: seed Called by proc~~init_genrand64~~CalledByGraph proc~init_genrand64 mt19937%init_genrand64 none~initialize mt19937%initialize none~initialize->proc~init_genrand64 proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_int64->proc~init_genrand64 proc~init_by_array64->proc~init_genrand64 proc~genrand64_real1 mt19937%genrand64_real1 proc~genrand64_real1->proc~genrand64_int64 proc~genrand64_real2 mt19937%genrand64_real2 proc~genrand64_real2->proc~genrand64_int64 proc~genrand64_real3 mt19937%genrand64_real3 proc~genrand64_real3->proc~genrand64_int64 proc~init_genrand64_i4->none~initialize proc~rninit pikaia_class%rninit proc~rninit->none~initialize proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rninit proc~urand pikaia_class%urand proc~pikaia->proc~urand proc~cross pikaia_class%cross proc~pikaia->proc~cross proc~mutate pikaia_class%mutate proc~pikaia->proc~mutate proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~urand->proc~genrand64_real1 proc~cross->proc~urand proc~mutate->proc~urand proc~select_parents->proc~urand proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia proc~stdrep->proc~urand program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_genrand64 ( me , seed ) !! Initializes `me%mt(nn)` with a seed implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), intent ( in ) :: seed integer :: i me % mt ( 1 ) = seed do i = 1 , nn - 1 me % mt ( i + 1 ) = 6364136223846793005_i8 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 )) + i end do me % mti = nn end subroutine init_genrand64","tags":"","loc":"proc/init_genrand64.html"},{"title":"init_genrand64_i4 – TOOLIB","text":"private  subroutine init_genrand64_i4(me, seed) Initializes me%mt(nn) with a seed Type Bound mt19937 Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i4), intent(in) :: seed Calls proc~~init_genrand64_i4~~CallsGraph proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize mt19937%initialize proc~init_genrand64_i4->none~initialize none~initialize->proc~init_genrand64_i4 proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64 mt19937%init_genrand64 none~initialize->proc~init_genrand64 proc~init_by_array64->proc~init_genrand64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_genrand64_i4~~CalledByGraph proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize mt19937%initialize proc~init_genrand64_i4->none~initialize none~initialize->proc~init_genrand64_i4 proc~rninit pikaia_class%rninit proc~rninit->none~initialize proc~pikaia pikaia_class%pikaia proc~pikaia->proc~rninit proc~solve_with_pikaia pikaia_class%solve_with_pikaia proc~solve_with_pikaia->proc~pikaia program~test_algen test_algen program~test_algen->proc~solve_with_pikaia Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_genrand64_i4 ( me , seed ) !! Initializes `me%mt(nn)` with a seed implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i4 ), intent ( in ) :: seed call me % initialize ( int ( seed , i8 )) end subroutine init_genrand64_i4","tags":"","loc":"proc/init_genrand64_i4.html"},{"title":"dbvalu – TOOLIB","text":"private  function dbvalu(t, a, n, k, ideriv, x, inbv, work, iflag) Evaluates the b-representation (t,a,n,k) of a b-spline\n  at x for the function value on ideriv=0 or any of its\n  derivatives on ideriv=1,2,…,k-1.  right limiting values\n  (right derivatives) are returned except at the right end\n  point x=t(n+1) where left limiting values are computed.  the\n  spline is defined on t(k) <= x <= t(n+1).  dbvalu returns\n  a fatal error message when x is outside of this interval. to compute left derivatives or left limiting values at a\n  knot t(i), replace n by i-1 and set x=t(i), i=k+1,n+1. Error Conditions improper input History bvalue written by carl de boor [5] dbvalu author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations.  (jec) Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: t knot vector of length n+k real(kind=wp), intent(in), dimension(n) :: a b-spline coefficient vector of length n integer, intent(in) :: n number of b-spline coefficients.\n(sum of knot multiplicities-k) integer, intent(in) :: k order of the b-spline, k >= 1 integer, intent(in) :: ideriv order of the derivative, 0 <= ideriv <= k-1.\nideriv = 0 returns the b-spline value real(kind=wp), intent(in) :: x argument, t(k) <= x <= t(n+1) integer, intent(inout) :: inbv an initialization parameter which must be set\nto 1 the first time dbvalu is called.\ninbv contains information for efficient process-\ning after the initial call and inbv must not\nbe changed by the user.  distinct splines require\ndistinct inbv parameters. real(kind=wp), dimension(:) :: work work vector of length 3*k integer, intent(out) :: iflag if   0: no errors\nif 401: k does not satisfy k>=1\nif 402: n does not satisfy n>=k\nif 403: ideriv does not satisfy 0<=ideriv<k\nif 404: x is not greater than or equal to t(k)\nif 405: x is not less than or equal to t(n+1)\nif 406: a left limiting value cannot be obtained at t(k) Return Value real(kind=wp) Calls proc~~dbvalu~~CallsGraph proc~dbvalu dbvalu proc~dintrv dintrv proc~dbvalu->proc~dintrv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dbvalu~~CalledByGraph proc~dbvalu dbvalu proc~db1val db1val proc~db1val->proc~dbvalu proc~db2val db2val proc~db2val->proc~dbvalu proc~interp_surf interp_surf proc~interp_surf->proc~db2val program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code real ( wp ) function dbvalu ( t , a , n , k , ideriv , x , inbv , work , iflag ) implicit none integer , intent ( in ) :: n !! number of b-spline coefficients. !! (sum of knot multiplicities-k) real ( wp ), dimension (:), intent ( in ) :: t !! knot vector of length n+k real ( wp ), dimension ( n ), intent ( in ) :: a !! b-spline coefficient vector of length n integer , intent ( in ) :: k !! order of the b-spline, k >= 1 integer , intent ( in ) :: ideriv !! order of the derivative, 0 <= ideriv <= k-1. !! ideriv = 0 returns the b-spline value real ( wp ), intent ( in ) :: x !! argument, t(k) <= x <= t(n+1) integer , intent ( inout ) :: inbv !! an initialization parameter which must be set !! to 1 the first time dbvalu is called. !! inbv contains information for efficient process- !! ing after the initial call and inbv must not !! be changed by the user.  distinct splines require !! distinct inbv parameters. real ( wp ), dimension (:) :: work !! work vector of length 3*k integer , intent ( out ) :: iflag !! if   0: no errors !! if 401: k does not satisfy k>=1 !! if 402: n does not satisfy n>=k !! if 403: ideriv does not satisfy 0<=ideriv<k !! if 404: x is not greater than or equal to t(k) !! if 405: x is not less than or equal to t(n+1) !! if 406: a left limiting value cannot be obtained at t(k) integer :: i , iderp1 , ihi , ihmkmj , ilo , imk , imkpj , ipj ,& ip1 , ip1mj , j , jj , j1 , j2 , kmider , kmj , km1 , kpk , mflag real ( wp ) :: fkmj dbvalu = 0.0_wp if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbvalu - k does not satisfy k>=1' iflag = 401 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbvalu - n does not satisfy n>=k' iflag = 402 return endif if ( ideriv < 0 . or . ideriv >= k ) then write ( error_unit , '(A)' ) 'dbvalu - ideriv does not satisfy 0<=ideriv<k' iflag = 403 return endif kmider = k - ideriv ! find *i* in (k,n) such that t(i) <= x < t(i+1) ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)). km1 = k - 1 call dintrv ( t , n + 1 , x , inbv , i , mflag ) if ( x < t ( k )) then write ( error_unit , '(A)' ) 'dbvalu - x is not greater than or equal to t(k)' iflag = 404 return endif if ( mflag /= 0 ) then if ( x > t ( i )) then write ( error_unit , '(A)' ) 'dbvalu - x is not less than or equal to t(n+1)' iflag = 405 return endif do if ( i == k ) then write ( error_unit , '(A)' ) 'dbvalu - a left limiting value cannot be obtained at t(k)' iflag = 406 return endif i = i - 1 if ( x /= t ( i )) exit enddo endif ! difference the coefficients *ideriv* times ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k imk = i - k do j = 1 , k imkpj = imk + j work ( j ) = a ( imkpj ) enddo if ( ideriv /= 0 ) then do j = 1 , ideriv kmj = k - j fkmj = real ( kmj , wp ) do jj = 1 , kmj ihi = i + jj ihmkmj = ihi - kmj work ( jj ) = ( work ( jj + 1 ) - work ( jj )) / ( t ( ihi ) - t ( ihmkmj )) * fkmj enddo enddo endif ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative, ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv). if ( ideriv /= km1 ) then ip1 = i + 1 kpk = k + k j1 = k + 1 j2 = kpk + 1 do j = 1 , kmider ipj = i + j work ( j1 ) = t ( ipj ) - x ip1mj = ip1 - j work ( j2 ) = x - t ( ip1mj ) j1 = j1 + 1 j2 = j2 + 1 enddo iderp1 = ideriv + 1 do j = iderp1 , km1 kmj = k - j ilo = kmj do jj = 1 , kmj work ( jj ) = ( work ( jj + 1 ) * work ( kpk + ilo ) + work ( jj ) * & work ( k + jj )) / ( work ( kpk + ilo ) + work ( k + jj )) ilo = ilo - 1 enddo enddo endif iflag = 0 dbvalu = work ( 1 ) endfunction dbvalu","tags":"","loc":"proc/dbvalu.html"},{"title":"check_inputs – TOOLIB","text":"private  subroutine check_inputs(routine, iflag, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, x, y, z, q, r, s, tx, ty, tz, tq, tr, ts, status_ok) Check the validity of the inputs to the “ink” routines.\n  Prints warning message if there is an error,\n  and also sets iflag and status_ok. Supports up to 6D: x,y,z,q,r,s Notes The code is new, but the logic is based on the original\n  logic in the CMLIB routines db2ink and db3ink. History Jacob Williams, 2/24/2015 : Created this routine. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer, intent(inout) :: iflag integer, intent(in), optional :: nx integer, intent(in), optional :: ny integer, intent(in), optional :: nz integer, intent(in), optional :: nq integer, intent(in), optional :: nr integer, intent(in), optional :: ns integer, intent(in), optional :: kx integer, intent(in), optional :: ky integer, intent(in), optional :: kz integer, intent(in), optional :: kq integer, intent(in), optional :: kr integer, intent(in), optional :: ks real(kind=wp), intent(in), optional, dimension(:) :: x real(kind=wp), intent(in), optional, dimension(:) :: y real(kind=wp), intent(in), optional, dimension(:) :: z real(kind=wp), intent(in), optional, dimension(:) :: q real(kind=wp), intent(in), optional, dimension(:) :: r real(kind=wp), intent(in), optional, dimension(:) :: s real(kind=wp), intent(in), optional, dimension(:) :: tx real(kind=wp), intent(in), optional, dimension(:) :: ty real(kind=wp), intent(in), optional, dimension(:) :: tz real(kind=wp), intent(in), optional, dimension(:) :: tq real(kind=wp), intent(in), optional, dimension(:) :: tr real(kind=wp), intent(in), optional, dimension(:) :: ts logical, intent(out) :: status_ok Called by proc~~check_inputs~~CalledByGraph proc~check_inputs check_inputs proc~db1ink db1ink proc~db1ink->proc~check_inputs proc~db2ink db2ink proc~db2ink->proc~check_inputs proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine check_inputs ( routine ,& iflag ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& x , y , z , q , r , s ,& tx , ty , tz , tq , tr , ts ,& status_ok ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( inout ) :: iflag integer , intent ( in ), optional :: nx , ny , nz , nq , nr , ns integer , intent ( in ), optional :: kx , ky , kz , kq , kr , ks real ( wp ), dimension (:), intent ( in ), optional :: x , y , z , q , r , s real ( wp ), dimension (:), intent ( in ), optional :: tx , ty , tz , tq , tr , ts logical , intent ( out ) :: status_ok logical :: error status_ok = . false . if (( iflag < 0 ) . or . ( iflag > 1 )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - iflag is out of range: ' , iflag iflag = 2 else call check ( 'x' , nx , kx , x , tx ,[ 3 , 4 , 5 , 6 ], error ); if ( error ) return call check ( 'y' , ny , ky , y , ty ,[ 7 , 8 , 9 , 10 ], error ); if ( error ) return call check ( 'z' , nz , kz , z , tz ,[ 11 , 12 , 13 , 14 ], error ); if ( error ) return call check ( 'q' , nq , kq , q , tq ,[ 15 , 16 , 17 , 18 ], error ); if ( error ) return call check ( 'r' , nr , kr , r , tr ,[ 19 , 20 , 21 , 22 ], error ); if ( error ) return call check ( 's' , ns , ks , s , ts ,[ 23 , 24 , 25 , 26 ], error ); if ( error ) return status_ok = . true . endif contains subroutine check ( s , n , k , x , t , ierrs , error ) !check t,x,n,k for validity implicit none character ( len = 1 ), intent ( in ), optional :: s !! coordinate string: 'x','y','z','q','r','s' integer , intent ( in ), optional :: n !! size of x integer , intent ( in ), optional :: k !! order real ( wp ), dimension (:), intent ( in ), optional :: x !! abcissae vector real ( wp ), dimension (:), intent ( in ), optional :: t !! knot vector size(n+k) integer , dimension (:), intent ( in ) :: ierrs !! int error codes for n,k,x,t checks logical , intent ( out ) :: error !! true if there was an error if ( present ( n )) then call check_n ( 'n' // s , n , ierrs ( 1 ), error ); if ( error ) return if ( present ( k )) then call check_k ( 'k' // s , k , n , ierrs ( 2 ), error ); if ( error ) return endif if ( present ( x )) then call check_x ( s , n , x , ierrs ( 3 ), error ); if ( error ) return endif if ( iflag /= 0 ) then if ( present ( k ) . and . present ( t )) then call check_t ( 't' // s , n , k , t , ierrs ( 4 ), error ); if ( error ) return endif endif endif endsubroutine check subroutine check_n ( s , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if ( n < 3 ) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , n iflag = ierr error = . true . else error = . false . endif endsubroutine check_n subroutine check_k ( s , k , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: k integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if (( k < 2 ) . or . ( k >= n )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , k iflag = ierr error = . true . else error = . false . endif endsubroutine check_k subroutine check_x ( s , n , x , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n if ( x ( i ) <= x ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be strictly increasing' return endif enddo error = . false . endsubroutine check_x subroutine check_t ( s , n , k , t , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension (:), intent ( in ) :: t integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n + k if ( t ( i ) < t ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be non-decreasing' return endif enddo error = . false . endsubroutine check_t endsubroutine check_inputs","tags":"","loc":"proc/check_inputs.html"},{"title":"db1ink – TOOLIB","text":"public  subroutine db1ink(x, nx, fcn, kx, tx, bcoef, iflag) Determines the parameters of a function that interpolates\n  the one-dimensional gridded data The interpolating function and its derivatives may\n  subsequently be evaluated by the function db1val . History Jacob Williams, 10/30/2015 : Created 1D routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(nx) :: fcn Array of function values to interpolate. fcn(i) should\n   contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n   If iflag=0 these are chosen by db1ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(nx) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db1ink .\n               1 = knot sequence chosen by user. on output: 1 = successful execution.\n               2 = iflag out of range.\n               3 = nx out of range.\n               4 = kx out of range.\n               5 = x not strictly increasing.\n               6 = tx not non-decreasing. Calls proc~~db1ink~~CallsGraph proc~db1ink db1ink proc~check_inputs check_inputs proc~db1ink->proc~check_inputs proc~dbknot dbknot proc~db1ink->proc~dbknot proc~dbtpcf dbtpcf proc~db1ink->proc~dbtpcf proc~dbintk dbintk proc~dbtpcf->proc~dbintk proc~dbnslv dbnslv proc~dbtpcf->proc~dbnslv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine db1ink ( x , nx , fcn , kx , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( nx ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i) should !!    contain the function value at the point x(i) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db1ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db1ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db1ink","tags":"","loc":"proc/db1ink.html"},{"title":"db1val – TOOLIB","text":"public  subroutine db1val(xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Evaluates the tensor product piecewise polynomial\n  interpolant constructed by the routine db1ink or one of its\n  derivatives at the point xval. To evaluate the interpolant itself, set idx=0,\n  to evaluate the first partial with respect to x, set idx=1, and so on. db1val returns 0.0 if (xval,yval) is out of range. that is, if xval < tx ( 1 ) . or . xval > tx ( nx + kx ) if the knots tx were chosen by db1ink , then this is equivalent to: xval < x ( 1 ) . or . xval > x ( nx ) + epsx where epsx = 0.1 * ( x ( nx ) - x ( nx - 1 )) The input quantities tx, nx, kx, and bcoef should be\n  unchanged since the last call of db1ink . History Jacob Williams, 10/30/2015 : Created 1D routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Calls proc~~db1val~~CallsGraph proc~db1val db1val proc~dbvalu dbvalu proc~db1val->proc~dbvalu proc~dintrv dintrv proc~dbvalu->proc~dintrv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db1val - x value out of bounds' iflag = 1 return endif f = dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag ) endsubroutine db1val","tags":"","loc":"proc/db1val.html"},{"title":"db2ink – TOOLIB","text":"public  subroutine db2ink(x, nx, y, ny, fcn, kx, ky, tx, ty, bcoef, iflag) Determines the parameters of a function that interpolates\n  the two-dimensional gridded data The interpolating function and its derivatives may\n  subsequently be evaluated by the function db2val . The interpolating function is a piecewise polynomial function\n  represented as a tensor product of one-dimensional b-splines. the\n  form of this function is where the functions and are one-dimensional b-spline\n  basis functions. the coefficients are chosen so that Note that for each fixed value of y, is a piecewise\n  polynomial function of x alone, and for each fixed value of x, is a piecewise polynomial function of y alone. in one dimension\n  a piecewise polynomial may be created by partitioning a given\n  interval into subintervals and defining a distinct polynomial piece\n  on each one. the points where adjacent subintervals meet are called\n  knots. each of the functions and above is a piecewise\n  polynomial. Users of db2ink choose the order (degree+1) of the polynomial\n  pieces used to define the piecewise polynomial in each of the x and\n  y directions (kx and ky). users also may define their own knot\n  sequence in x and y separately (tx and ty). if iflag=0, however,\n  db2ink will choose sequences of knots that result in a piecewise\n  polynomial interpolant with kx-2 continuous partial derivatives in\n  x and ky-2 continuous partial derivatives in y. (kx knots are taken\n  near each endpoint in the x direction, not-a-knot end conditions\n  are used, and the remaining knots are placed at data points if kx\n  is even or at midpoints between data points if kx is odd. the y\n  direction is treated similarly.) After a call to db2ink, all information necessary to define the\n  interpolating function are contained in the parameters nx, ny, kx,\n  ky, tx, ty, and bcoef. These quantities should not be altered until\n  after the last call of the evaluation routine db2val . History Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. JEC : 000330 modified array declarations. Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(ny) :: y Array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(nx,ny) :: fcn Array of function values to interpolate. fcn(i,j) should\n   contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n   If iflag=0 these are chosen by db2ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(inout), dimension(ny+ky) :: ty The knots in the y direction for the spline interpolant.\n   If iflag=0 these are chosen by db2ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(nx,ny) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db2ink .\n               1 = knot sequence chosen by user. on output: 1 = successful execution.\n               2 = iflag out of range.\n               3 = nx out of range.\n               4 = kx out of range.\n               5 = x not strictly increasing.\n               6 = tx not non-decreasing.\n               7 = ny out of range.\n               8 = ky out of range.\n               9 = y not strictly increasing.\n              10 = ty not non-decreasing. Calls proc~~db2ink~~CallsGraph proc~db2ink db2ink proc~check_inputs check_inputs proc~db2ink->proc~check_inputs proc~dbknot dbknot proc~db2ink->proc~dbknot proc~dbtpcf dbtpcf proc~db2ink->proc~dbtpcf proc~dbintk dbintk proc~dbtpcf->proc~dbintk proc~dbnslv dbnslv proc~dbtpcf->proc~dbnslv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~db2ink~~CalledByGraph proc~db2ink db2ink proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( ny ), intent ( in ) :: y !! Array of y abcissae. Must be strictly increasing. real ( wp ), dimension ( nx , ny ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i,j) should !!    contain the function value at the point (x(i),y(j)) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( ny + ky ), intent ( inout ) :: ty !! The knots in the y direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx , ny ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db2ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. !!                7 = ny out of range. !!                8 = ky out of range. !!                9 = y not strictly increasing. !!               10 = ty not non-decreasing. real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db2ink","tags":"","loc":"proc/db2ink.html"},{"title":"db2val – TOOLIB","text":"public  subroutine db2val(xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Evaluates the tensor product piecewise polynomial\n  interpolant constructed by the routine db2ink or one of its\n  derivatives at the point (xval,yval). To evaluate the interpolant\n  itself, set idx=idy=0, to evaluate the first partial with respect\n  to x, set idx=1,idy=0, and so on. db2val returns 0.0 if (xval,yval) is out of range. that is, if xval < tx ( 1 ) . or . xval > tx ( nx + kx ) . or . yval < ty ( 1 ) . or . yval > ty ( ny + ky ) if the knots tx and ty were chosen by db2ink , then this is equivalent to: xval < x ( 1 ) . or . xval > x ( nx ) + epsx . or . yval < y ( 1 ) . or . yval > y ( ny ) + epsy where epsx = 0.1 * ( x ( nx ) - x ( nx - 1 )) epsy = 0.1 * ( y ( ny ) - y ( ny - 1 )) The input quantities tx, ty, nx, ny, kx, ky, and bcoef should be\n  unchanged since the last call of db2ink . History Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. JEC : 000330 modified array declarations. Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. Calls proc~~db2val~~CallsGraph proc~db2val db2val proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dintrv dintrv proc~db2val->proc~dintrv proc~dbvalu->proc~dintrv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~db2val~~CalledByGraph proc~db2val db2val proc~interp_surf interp_surf proc~interp_surf->proc~db2val program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db2val - x value out of bounds' iflag = 1 return endif if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then write ( error_unit , '(A)' ) 'db2val - y value out of bounds' iflag = 2 return endif iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 temp ( k ) = dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag ) if ( iflag /= 0 ) return !error enddo kcol = lefty - ky + 1 f = dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag ) endsubroutine db2val","tags":"","loc":"proc/db2val.html"},{"title":"dbintk – TOOLIB","text":"private  subroutine dbintk(x, y, t, n, k, bcoef, q, work, iflag) dbintk produces the b-spline coefficients, bcoef, of the\n  b-spline of order k with knots t(i), i=1,…,n+k, which\n  takes on the value y(i) at x(i), i=1,…,n.  the spline or\n  any of its derivatives can be evaluated by calls to dbvalu . the i-th equation of the linear system a*bcoef = b for the\n  coefficients of the interpolant enforces interpolation at\n  x(i), i=1,…,n.  hence, b(i) = y(i), for all i, and a is\n  a band matrix with 2k-1 bands if a is invertible.  the matrix\n  a is generated row by row and stored, diagonal by diagonal,\n  in the rows of q, with the main diagonal going into row k.\n  the banded system is then solved by a call to dbnfac (which\n  constructs the triangular factorization for a and stores it\n  again in q), followed by a call to dbnslv (which then\n  obtains the solution bcoef by substitution).  dbnfac does no\n  pivoting, since the total positivity of the matrix a makes\n  this unnecessary.  the linear system to be solved is\n  (theoretically) invertible if and only if\n          t(i) < x(i) < t(i+k),        for all i.\n  equality is permitted on the left for i=1 and on the right\n  for i=n when k knots are used at x(1) or x(n).  otherwise,\n  violation of this condition is certain to lead to an error. Error conditions improper input singular system of equations History splint written by carl de boor [5] dbintk author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations. (jec) Jacob Williams, 5/10/2015 : converted to free-form Fortran. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x vector of length n containing data point abscissa\nin strictly increasing order. real(kind=wp), intent(in), dimension(n) :: y corresponding vector of length n containing data\npoint ordinates. real(kind=wp), intent(in), dimension(*) :: t knot vector of length n+k\nsince t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) = x(n), this leaves only n-k knots (not\nnecessarily x(i) values) interior to (x(1),x(n)) integer, intent(in) :: n number of data points, n >= k integer, intent(in) :: k order of the spline, k >= 1 real(kind=wp), intent(out), dimension(n) :: bcoef a vector of length n containing the b-spline coefficients real(kind=wp), intent(out), dimension(*) :: q a work vector of length (2 k-1) n, containing\nthe triangular factorization of the coefficient\nmatrix of the linear system being solved.  the\ncoefficients for the interpolant of an\nadditional data set (x(i),yy(i)), i=1,…,n\nwith the same abscissa can be obtained by loading\nyy into bcoef and then executing\ncall dbnslv(q,2k-1,n,k-1,k-1,bcoef) real(kind=wp), intent(out), dimension(*) :: work work vector of length 2*k integer, intent(out) :: iflag if   0: no errors.\nif 100: k does not satisfy k>=1.\nif 101: n does not satisfy n>=k.\nif 102: x(i) does not satisfy x(i)<x(i+1) for some i.\nif 103: some abscissa was not in the support of the.\ncorresponding basis function and the system is singular.\nif 104: the system of solver detects a singular system.\nalthough the theoretical conditions for a solution were satisfied. Calls proc~~dbintk~~CallsGraph proc~dbintk dbintk proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbnslv dbnslv proc~dbintk->proc~dbnslv proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dbintk~~CalledByGraph proc~dbintk dbintk proc~dbtpcf dbtpcf proc~dbtpcf->proc~dbintk proc~db1ink db1ink proc~db1ink->proc~dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbintk ( x , y , t , n , k , bcoef , q , work , iflag ) implicit none integer , intent ( in ) :: n !! number of data points, n >= k real ( wp ), dimension ( n ), intent ( in ) :: x !! vector of length n containing data point abscissa !! in strictly increasing order. real ( wp ), dimension ( n ), intent ( in ) :: y !! corresponding vector of length n containing data !! point ordinates. real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) !! >= x(n), this leaves only n-k knots (not !! necessarily x(i) values) interior to (x(1),x(n)) integer , intent ( in ) :: k !! order of the spline, k >= 1 real ( wp ), dimension ( n ), intent ( out ) :: bcoef !! a vector of length n containing the b-spline coefficients real ( wp ), dimension ( * ), intent ( out ) :: q !! a work vector of length (2*k-1)*n, containing !! the triangular factorization of the coefficient !! matrix of the linear system being solved.  the !! coefficients for the interpolant of an !! additional data set (x(i),yy(i)), i=1,...,n !! with the same abscissa can be obtained by loading !! yy into bcoef and then executing !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real ( wp ), dimension ( * ), intent ( out ) :: work !! work vector of length 2*k integer , intent ( out ) :: iflag !! if   0: no errors. !! if 100: k does not satisfy k>=1. !! if 101: n does not satisfy n>=k. !! if 102: x(i) does not satisfy x(i)<x(i+1) for some i. !! if 103: some abscissa was not in the support of the. !! corresponding basis function and the system is singular. !! if 104: the system of solver detects a singular system. !! although the theoretical conditions for a solution were satisfied. integer :: iwork , i , ilp1mx , j , jj , km1 , kpkm2 , left , lenq , np1 real ( wp ) :: xi if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbintk - k does not satisfy k>=1' iflag = 100 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbintk - n does not satisfy n>=k' iflag = 101 return endif jj = n - 1 if ( jj /= 0 ) then do i = 1 , jj if ( x ( i ) >= x ( i + 1 )) then write ( error_unit , '(A)' ) 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i' iflag = 102 return endif enddo endif np1 = n + 1 km1 = k - 1 kpkm2 = 2 * km1 left = k ! zero out all entries of q lenq = n * ( k + km1 ) do i = 1 , lenq q ( i ) = 0.0_wp enddo ! loop over i to construct the n interpolation equations do i = 1 , n xi = x ( i ) ilp1mx = min ( i + k , np1 ) ! *** find  left  in the closed interval (i,i+k-1) such that !         t(left) <= x(i) < t(left+1) ! matrix is singular if this is not possible left = max ( left , i ) if ( xi < t ( left )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif do if ( xi < t ( left + 1 )) go to 30 left = left + 1 if ( left >= ilp1mx ) exit enddo left = left - 1 if ( xi > t ( left + 1 )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif ! *** the i-th equation enforces interpolation at xi, hence ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j = ! left-k+1,...,left actually might be nonzero. these  k  numbers ! are returned, in  bcoef (used for temp.storage here), by the ! following 30 call dbspvn ( t , k , k , 1 , xi , left , bcoef , work , iwork , iflag ) if ( iflag /= 0 ) return ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q ! as a two-dim. array , with  2*k-1  rows (see comments in ! dbnfac). in the present program, we treat  q  as an equivalent ! one-dimensional array (because of fortran restrictions on ! dimension statements) . we therefore want  bcoef(j) to go into ! entry !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1) !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j ! of q. jj = i - left + 1 + ( left - k ) * ( k + km1 ) do j = 1 , k jj = jj + kpkm2 q ( jj ) = bcoef ( j ) enddo enddo ! obtain factorization of a, stored again in q. call dbnfac ( q , k + km1 , n , km1 , km1 , iflag ) if ( iflag == 1 ) then !success ! *** solve  a*bcoef = y  by backsubstitution do i = 1 , n bcoef ( i ) = y ( i ) enddo call dbnslv ( q , k + km1 , n , km1 , km1 , bcoef ) iflag = 0 else !failure write ( error_unit , '(A)' ) 'dbintk - the system of solver detects a singular system' // & ' although the theoretical conditions for a solution were satisfied' iflag = 104 endif endsubroutine dbintk","tags":"","loc":"proc/dbintk.html"},{"title":"dbknot – TOOLIB","text":"private  subroutine dbknot(x, n, k, t) dbknot chooses a knot sequence for interpolation of order k at the\n  data points x(i), i=1,..,n.  the n+k knots are placed in the array\n  t.  k knots are placed at each endpoint and not-a-knot end\n  conditions are used.  the remaining knots are placed at data points\n  if n is even and between data points if n is odd.  the rightmost\n  knot is shifted slightly to the right to insure proper interpolation\n  at x(n) (see page 350 of the reference). History Jacob Williams, 2/24/2015 : Refactored this routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(out), dimension(:) :: t Called by proc~~dbknot~~CalledByGraph proc~dbknot dbknot proc~db1ink db1ink proc~db1ink->proc~dbknot proc~db2ink db2ink proc~db2ink->proc~dbknot proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbknot ( x , n , k , t ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: t integer :: i , j , ipj , npj , ip1 , jstrt real ( wp ) :: rnot !put k knots at each endpoint !(shift right endpoints slightly -- see pg 350 of reference) rnot = x ( n ) + 0.1_wp * ( x ( n ) - x ( n - 1 ) ) do j = 1 , k t ( j ) = x ( 1 ) npj = n + j t ( npj ) = rnot enddo !distribute remaining knots if ( mod ( k , 2 ) == 1 ) then !case of odd k --  knots between data points i = ( k - 1 ) / 2 - k ip1 = i + 1 jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = 0.5_wp * ( x ( ipj ) + x ( ipj + 1 ) ) enddo else !case of even k --  knots at data points i = ( k / 2 ) - k jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = x ( ipj ) enddo endif endsubroutine dbknot","tags":"","loc":"proc/dbknot.html"},{"title":"dbnfac – TOOLIB","text":"private  subroutine dbnfac(w, nroww, nrow, nbandl, nbandu, iflag) Returns in w the LU-factorization (without pivoting) of the banded\n  matrix a of order nrow with (nbandl + 1 + nbandu) bands or diagonals\n  in the work array w . gauss elimination without pivoting is used. the routine is\n  intended for use with matrices a which do not require row inter-\n  changes during factorization, especially for the totally\n  positive matrices which occur in spline calculations.\n  the routine should not be used for an arbitrary banded matrix. Work array Input w array of size ( nroww , nrow ) contains the interesting part of a banded matrix a , with the diagonals or bands of a stored in the rows of w , while columns of a correspond to columns of w . this is the storage mode used in linpack and results in efficient innermost loops . explicitly , a has nbandl bands below the diagonal + 1 ( main ) diagonal + nbandu bands above the diagonal and thus , with middle = nbandu + 1 , a ( i + j , j ) is in w ( i + middle , j ) for i =- nbandu ,..., nbandl j = 1 ,..., nrow . for example , the interesting entries of a ( 1 , 2 ) - banded matrix of order 9 would appear in the first 1 + 1 + 2 = 4 rows of w as follows . 13 24 35 46 57 68 79 12 23 34 45 56 67 78 89 11 22 33 44 55 66 77 88 99 21 32 43 54 65 76 87 98 all other entries of w not identified in this way with an en - try of a are never referenced . Output if  iflag = 1, then\n        w contains the lu-factorization of  a  into a unit lower triangu-\n        lar matrix  l  and an upper triangular matrix  u (both banded)\n        and stored in customary fashion over the corresponding entries\n        of  a . this makes it possible to solve any particular linear\n        system  a*x = b  for  x  by a\n              call dbnslv ( w, nroww, nrow, nbandl, nbandu, b )\n        with the solution x  contained in  b  on return . if  iflag = 2, then\n        one of  nrow-1, nbandl,nbandu failed to be nonnegative, or else\n        one of the potential pivots was found to be zero indicating\n        that  a  does not have an lu-factorization. this implies that\n        a  is singular in case it is totally positive . History banfac written by carl de boor [5] dbnfac from CMLIB [1] Jacob Williams, 5/10/2015 : converted to free-form Fortran. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(nroww,nrow) :: w work array. See header for details. integer, intent(in) :: nroww row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer, intent(in) :: nrow matrix order integer, intent(in) :: nbandl number of bands of a below the main diagonal integer, intent(in) :: nbandu number of bands of a above the main diagonal integer, intent(out) :: iflag indicating success(=1) or failure (=2) Called by proc~~dbnfac~~CalledByGraph proc~dbnfac dbnfac proc~dbintk dbintk proc~dbintk->proc~dbnfac proc~dbtpcf dbtpcf proc~dbtpcf->proc~dbintk proc~db1ink db1ink proc~db1ink->proc~dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbnfac ( w , nroww , nrow , nbandl , nbandu , iflag ) integer , intent ( in ) :: nroww !! row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer , intent ( in ) :: nrow !! matrix order integer , intent ( in ) :: nbandl !! number of bands of a below the main diagonal integer , intent ( in ) :: nbandu !! number of bands of a above the main diagonal integer , intent ( out ) :: iflag !! indicating success(=1) or failure (=2) real ( wp ), dimension ( nroww , nrow ), intent ( inout ) :: w !! work array. See header for details. integer :: i , ipk , j , jmax , k , kmax , middle , midmk , nrowm1 real ( wp ) :: factor , pivot iflag = 1 middle = nbandu + 1 ! w(middle,.) contains the main diagonal of a. nrowm1 = nrow - 1 if ( nrowm1 < 0 ) then iflag = 2 return elseif ( nrowm1 == 0 ) then if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandl <= 0 ) then ! a is upper triangular. check that diagonal is nonzero . do i = 1 , nrowm1 if ( w ( middle , i ) == 0.0_wp ) then iflag = 2 return endif enddo if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandu <= 0 ) then ! a is lower triangular. check that diagonal is nonzero and ! divide each column by its diagonal. do i = 1 , nrowm1 pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif jmax = min ( nbandl , nrow - i ) do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo enddo return endif ! a is not just a triangular matrix. construct lu factorization do i = 1 , nrowm1 ! w(middle,i)  is pivot for i-th step . pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif ! jmax is the number of (nonzero) entries in column i ! below the diagonal. jmax = min ( nbandl , nrow - i ) ! divide each entry in column i below diagonal by pivot. do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo ! kmax is the number of (nonzero) entries in row i to ! the right of the diagonal. kmax = min ( nbandu , nrow - i ) ! subtract a(i,i+k)*(i-th column) from (i+k)-th column ! (below row i). do k = 1 , kmax ipk = i + k midmk = middle - k factor = w ( midmk , ipk ) do j = 1 , jmax w ( midmk + j , ipk ) = w ( midmk + j , ipk ) - w ( middle + j , i ) * factor enddo enddo enddo ! check the last diagonal entry. if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 endsubroutine dbnfac","tags":"","loc":"proc/dbnfac.html"},{"title":"dbnslv – TOOLIB","text":"private  subroutine dbnslv(w, nroww, nrow, nbandl, nbandu, b) Companion routine to dbnfac . it returns the solution x of the\n  linear system a*x = b in place of b, given the lu-factorization\n  for a in the work array w from dbnfac. (with , as stored in w), the unit lower triangular system is solved for , and y stored in b. then the\n  upper triangular system is solved for x. the calculations\n  are so arranged that the innermost loops stay within columns. History banslv written by carl de boor [5] dbnslv from SLATEC library [1] Jacob Williams, 5/10/2015 : converted to free-form Fortran. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nroww,nrow) :: w describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nroww describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nrow describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandl describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandu describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . real(kind=wp), intent(inout), dimension(nrow) :: b in : right side of the system to be solved out : the solution x, of order nrow Called by proc~~dbnslv~~CalledByGraph proc~dbnslv dbnslv proc~dbintk dbintk proc~dbintk->proc~dbnslv proc~dbtpcf dbtpcf proc~dbtpcf->proc~dbnslv proc~dbtpcf->proc~dbintk proc~db1ink db1ink proc~db1ink->proc~dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbnslv ( w , nroww , nrow , nbandl , nbandu , b ) integer , intent ( in ) :: nroww !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nrow !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandl !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandu !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nroww , nrow ), intent ( in ) :: w !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nrow ), intent ( inout ) :: b !! **in**: right side of the system to be solved !! **out**: the solution x, of order nrow integer :: i , j , jmax , middle , nrowm1 middle = nbandu + 1 if ( nrow /= 1 ) then nrowm1 = nrow - 1 if ( nbandl /= 0 ) then ! forward pass ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l) !                       from right side (below i-th row). do i = 1 , nrowm1 jmax = min ( nbandl , nrow - i ) do j = 1 , jmax b ( i + j ) = b ( i + j ) - b ( i ) * w ( middle + j , i ) enddo enddo endif ! backward pass ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal !                          entry of u, then subtract right side(i)*(i-th column !                          of u) from right side (above i-th row). if ( nbandu <= 0 ) then ! a is lower triangular. do i = 1 , nrow b ( i ) = b ( i ) / w ( 1 , i ) enddo return endif i = nrow do b ( i ) = b ( i ) / w ( middle , i ) jmax = min ( nbandu , i - 1 ) do j = 1 , jmax b ( i - j ) = b ( i - j ) - b ( i ) * w ( middle - j , i ) enddo i = i - 1 if ( i <= 1 ) exit enddo endif b ( 1 ) = b ( 1 ) / w ( middle , 1 ) endsubroutine dbnslv","tags":"","loc":"proc/dbnslv.html"},{"title":"dbspvn – TOOLIB","text":"private  subroutine dbspvn(t, jhigh, k, index, x, ileft, vnikx, work, iwork, iflag) Calculates the value of all (possibly) nonzero basis\n  functions at x of order max(jhigh,(j+1)*(index-1)), where t(k)\n  <= x <= t(n+1) and j=iwork is set inside the routine on\n  the first call when index=1.  ileft is such that t(ileft) <=\n  x < t(ileft+1).  a call to dintrv(t,n+1,x,ilo,ileft,mflag)\n  produces the proper ileft.  dbspvn calculates using the basic\n  algorithm needed in dbspvd.  if only basis functions are\n  desired, setting jhigh=k and index=1 can be faster than\n  calling dbspvd, but extra coding is required for derivatives\n  (index=2) and dbspvd is set up for this purpose. left limiting values are set up as described in dbspvd. Error Conditions improper input History bsplvn written by carl de boor [5] dbspvn author: amos, d. e., (snla) : date written 800901 revision date 820801 000330 modified array declarations.  (jec) Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t (*) knot vector of length n+k, where\nn = number of b-spline basis functions\nn = sum of knot multiplicities-k\ndimension t(ileft+jhigh) integer, intent(in) :: jhigh order of b-spline, 1 <= jhigh <= k integer, intent(in) :: k highest possible order integer, intent(in) :: index index = 1 gives basis functions of order jhigh\n      = 2 denotes previous entry with work, iwork\n        values saved for subsequent calls to\n        dbspvn. real(kind=wp), intent(in) :: x argument of basis functions, t(k) <= x <= t(n+1) integer, intent(in) :: ileft largest integer such that t(ileft) <= x < t(ileft+1) real(kind=wp), intent(out) :: vnikx (k) vector of length k for spline values. real(kind=wp), intent(out) :: work (*) a work vector of length 2*k integer, intent(out) :: iwork a work parameter.  both work and iwork contain\ninformation necessary to continue for index = 2.\nwhen index = 1 exclusively, these are scratch\nvariables and can be used for other purposes. integer, intent(out) :: iflag if   0: no errors\nif 201: k does not satisfy k>=1\nif 202: jhigh does not satisfy 1<=jhigh<=k\nif 203: index is not 1 or 2\nif 204: x does not satisfy t(ileft)<=x<=t(ileft+1) Called by proc~~dbspvn~~CalledByGraph proc~dbspvn dbspvn proc~dbintk dbintk proc~dbintk->proc~dbspvn proc~dbtpcf dbtpcf proc~dbtpcf->proc~dbintk proc~db1ink db1ink proc~db1ink->proc~dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbspvn ( t , jhigh , k , index , x , ileft , vnikx , work , iwork , iflag ) implicit none real ( wp ), intent ( in ) :: t ( * ) !! knot vector of length n+k, where !! n = number of b-spline basis functions !! n = sum of knot multiplicities-k !! dimension t(ileft+jhigh) integer , intent ( in ) :: jhigh !! order of b-spline, 1 <= jhigh <= k integer , intent ( in ) :: k !! highest possible order integer , intent ( in ) :: index !! index = 1 gives basis functions of order jhigh !!       = 2 denotes previous entry with work, iwork !!         values saved for subsequent calls to !!         dbspvn. real ( wp ), intent ( in ) :: x !! argument of basis functions, t(k) <= x <= t(n+1) integer , intent ( in ) :: ileft !! largest integer such that t(ileft) <= x < t(ileft+1) real ( wp ), intent ( out ) :: vnikx ( k ) !! vector of length k for spline values. real ( wp ), intent ( out ) :: work ( * ) !! a work vector of length 2*k integer , intent ( out ) :: iwork !! a work parameter.  both work and iwork contain !! information necessary to continue for index = 2. !! when index = 1 exclusively, these are scratch !! variables and can be used for other purposes. integer , intent ( out ) :: iflag !! if   0: no errors !! if 201: k does not satisfy k>=1 !! if 202: jhigh does not satisfy 1<=jhigh<=k !! if 203: index is not 1 or 2 !! if 204: x does not satisfy t(ileft)<=x<=t(ileft+1) integer :: imjp1 , ipj , jp1 , jp1ml , l real ( wp ) :: vm , vmprev ! content of j, deltam, deltap is expected unchanged between calls. ! work(i) = deltap(i), ! work(k+i) = deltam(i), i = 1,k if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - k does not satisfy k>=1' iflag = 201 return endif if ( jhigh > k . or . jhigh < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - jhigh does not satisfy 1<=jhigh<=k' iflag = 202 return endif if ( index < 1 . or . index > 2 ) then write ( error_unit , '(A)' ) 'dbspvn - index is not 1 or 2' iflag = 203 return endif if ( x < t ( ileft ) . or . x > t ( ileft + 1 )) then write ( error_unit , '(A)' ) 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)' iflag = 204 return endif iflag = 0 if ( index == 1 ) then iwork = 1 vnikx ( 1 ) = 1.0_wp if ( iwork >= jhigh ) return endif do ipj = ileft + iwork work ( iwork ) = t ( ipj ) - x imjp1 = ileft - iwork + 1 work ( k + iwork ) = x - t ( imjp1 ) vmprev = 0.0_wp jp1 = iwork + 1 do l = 1 , iwork jp1ml = jp1 - l vm = vnikx ( l ) / ( work ( l ) + work ( k + jp1ml )) vnikx ( l ) = vm * work ( l ) + vmprev vmprev = vm * work ( k + jp1ml ) enddo vnikx ( jp1 ) = vmprev iwork = jp1 if ( iwork >= jhigh ) exit enddo endsubroutine dbspvn","tags":"","loc":"proc/dbspvn.html"},{"title":"dbtpcf – TOOLIB","text":"private  subroutine dbtpcf(x, n, fcn, ldf, nf, t, k, bcoef, work, iflag) dbtpcf computes b-spline interpolation coefficients for nf sets\n  of data stored in the columns of the array fcn. the b-spline\n  coefficients are stored in the rows of bcoef however.\n  each interpolation is based on the n abcissa stored in the\n  array x, and the n+k knots stored in the array t. the order\n  of each interpolation is k. the work array must be of length\n  at least 2 k (n+1). History Jacob Williams, 2/24/2015 : Refactored this routine. Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) integer, intent(in) :: n real(kind=wp) :: fcn (ldf,nf) integer, intent(in) :: ldf integer, intent(in) :: nf real(kind=wp) :: t (*) integer, intent(in) :: k real(kind=wp) :: bcoef (nf,n) real(kind=wp) :: work (*) integer, intent(out) :: iflag if   0: no errors\nif 301: n should be >0 Calls proc~~dbtpcf~~CallsGraph proc~dbtpcf dbtpcf proc~dbintk dbintk proc~dbtpcf->proc~dbintk proc~dbnslv dbnslv proc~dbtpcf->proc~dbnslv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dbtpcf~~CalledByGraph proc~dbtpcf dbtpcf proc~db1ink db1ink proc~db1ink->proc~dbtpcf proc~db2ink db2ink proc~db2ink->proc~dbtpcf proc~interp_surf interp_surf proc~interp_surf->proc~db2ink program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dbtpcf ( x , n , fcn , ldf , nf , t , k , bcoef , work , iflag ) integer , intent ( in ) :: n integer , intent ( in ) :: nf integer , intent ( in ) :: ldf integer , intent ( in ) :: k real ( wp ) :: x ( n ) real ( wp ) :: fcn ( ldf , nf ) real ( wp ) :: t ( * ) real ( wp ) :: bcoef ( nf , n ) real ( wp ) :: work ( * ) integer , intent ( out ) :: iflag !! if   0: no errors !! if 301: n should be >0 integer :: i , j , m1 , m2 , iq , iw ! check for null input if ( nf > 0 ) then ! partition work array m1 = k - 1 m2 = m1 + k iq = 1 + n iw = iq + m2 * n + 1 ! compute b-spline coefficients ! first data set call dbintk ( x , fcn , t , n , k , work , work ( iq ), work ( iw ), iflag ) if ( iflag == 0 ) then do i = 1 , n bcoef ( 1 , i ) = work ( i ) enddo !  all remaining data sets by back-substitution if ( nf == 1 ) return do j = 2 , nf do i = 1 , n work ( i ) = fcn ( i , j ) enddo call dbnslv ( work ( iq ), m2 , n , m1 , m1 , work ) do i = 1 , n bcoef ( j , i ) = work ( i ) enddo enddo endif else write ( error_unit , '(A)' ) 'dbtpcf - n should be >0' iflag = 301 endif endsubroutine dbtpcf","tags":"","loc":"proc/dbtpcf.html"},{"title":"dintrv – TOOLIB","text":"private  subroutine dintrv(XT, lxt, x, ilo, ileft, mflag) Computes the largest integer ileft in 1 <= ileft <= lxt\n  such that XT(ileft) <= x where XT(*) is a subdivision of\n  the x interval.\n  precisely, if x < XT ( 1 ) then ileft = 1 , mflag =- 1 if XT ( i ) <= x < XT ( i + 1 ) then ileft = i , mflag = 0 if XT ( lxt ) <= x then ileft = lxt , mflag = 1 that is, when multiplicities are present in the break point\n  to the left of x, the largest index is taken for ileft. History interv written by carl de boor [5] dintrv author: amos, d. e., (snla) : date written 800901 revision date 820801 Jacob Williams, 2/24/2015 : updated to free-form Fortran. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(lxt) :: XT a knot or break point vector of length lxt integer, intent(in) :: lxt length of the XT vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\nto 1 the first time the spline array XT is\nprocessed by dintrv. ilo contains information for\nefficient processing after the initial call and ilo\nmust not be changed by the user.  distinct splines\nrequire distinct ilo parameters. integer, intent(out) :: ileft largest integer satisfying XT(ileft) <= x integer, intent(out) :: mflag signals when x lies out of bounds Called by proc~~dintrv~~CalledByGraph proc~dintrv dintrv proc~db2val db2val proc~db2val->proc~dintrv proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dbvalu->proc~dintrv proc~db1val db1val proc~db1val->proc~dbvalu proc~interp_surf interp_surf proc~interp_surf->proc~db2val program~test_bspline test_bspline program~test_bspline->proc~interp_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine dintrv ( XT , lxt , x , ilo , ileft , mflag ) implicit none integer , intent ( in ) :: lxt !! length of the XT vector real ( wp ), dimension ( lxt ), intent ( in ) :: XT !! a knot or break point vector of length lxt real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the spline array XT is !! processed by dintrv. ilo contains information for !! efficient processing after the initial call and ilo !! must not be changed by the user.  distinct splines !! require distinct ilo parameters. integer , intent ( out ) :: ileft !! largest integer satisfying XT(ileft) <= x integer , intent ( out ) :: mflag !! signals when x lies out of bounds integer :: ihi , istep , middle ihi = ilo + 1 if ( ihi < lxt ) go to 10 if ( x >= XT ( lxt )) go to 110 if ( lxt <= 1 ) go to 90 ilo = lxt - 1 ihi = lxt 10 if ( x >= XT ( ihi )) go to 40 if ( x >= XT ( ilo )) go to 100 ! *** now x < XT(ihi) . find lower bound istep = 1 20 ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) go to 30 if ( x >= XT ( ilo )) go to 70 istep = istep * 2 go to 20 30 ilo = 1 if ( x < XT ( 1 )) go to 90 go to 70 ! *** now x >= XT(ilo) . find upper bound 40 istep = 1 50 ilo = ihi ihi = ilo + istep if ( ihi >= lxt ) go to 60 if ( x < XT ( ihi )) go to 70 istep = istep * 2 go to 50 60 if ( x >= XT ( lxt )) go to 110 ihi = lxt ! *** now XT(ilo) <= x < XT(ihi) . narrow the interval 70 middle = ( ilo + ihi ) / 2 if ( middle == ilo ) go to 100 !     note. it is assumed that middle = ilo in case ihi = ilo+1 if ( x < XT ( middle )) go to 80 ilo = middle go to 70 80 ihi = middle go to 70 ! *** set output and return 90 mflag = - 1 ileft = 1 return 100 mflag = 0 ileft = ilo return 110 mflag = 1 ileft = lxt endsubroutine dintrv","tags":"","loc":"proc/dintrv.html"},{"title":"close_superlu – TOOLIB","text":"public  subroutine close_superlu(sulu) Subroutine to close the SuperLU process, with memory release Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~close_superlu~~CallsGraph proc~close_superlu close_superlu interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~close_superlu~~CalledByGraph proc~close_superlu close_superlu proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine close_superlu ( sulu ) !! Subroutine to close the SuperLU process, with memory release implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu","tags":"","loc":"proc/close_superlu.html"},{"title":"fact_superlu – TOOLIB","text":"public  subroutine fact_superlu(sulu, verbose) Note Subroutine to factorize the system note the directives: sulu%options%Fact = DOFACT sulu%SMB%ncol     = 0 Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~fact_superlu~~CallsGraph proc~fact_superlu fact_superlu interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit interface~statprint StatPrint proc~fact_superlu->interface~statprint Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fact_superlu~~CalledByGraph proc~fact_superlu fact_superlu proc~factorize_solver factorize_solver proc~factorize_solver->proc~fact_superlu proc~solve_syst solve_syst proc~solve_syst->proc~factorize_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu","tags":"","loc":"proc/fact_superlu.html"},{"title":"free_superlu – TOOLIB","text":"public  subroutine free_superlu() Subroutine that actually does nothing yet. Maybe, there will be extra memory that\ncould be released here? Arguments None Called by proc~~free_superlu~~CalledByGraph proc~free_superlu free_superlu proc~freefact_solver freefact_solver proc~freefact_solver->proc~free_superlu proc~solve_syst solve_syst proc~solve_syst->proc~freefact_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine free_superlu () !! Subroutine that actually does nothing yet. Maybe, there will be extra memory that !! could be released here? implicit none return endsubroutine free_superlu","tags":"","loc":"proc/free_superlu.html"},{"title":"init_superlu – TOOLIB","text":"public  subroutine init_superlu(sulu) Note Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~init_superlu~~CallsGraph proc~init_superlu init_superlu interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~init_superlu~~CalledByGraph proc~init_superlu init_superlu proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu","tags":"","loc":"proc/init_superlu.html"},{"title":"prep_superlu – TOOLIB","text":"public  subroutine prep_superlu(sulu) Subroutine to prepare the SULU_ENV components Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu Calls proc~~prep_superlu~~CallsGraph proc~prep_superlu prep_superlu interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~prep_superlu~~CalledByGraph proc~prep_superlu prep_superlu proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine prep_superlu ( sulu ) !! Subroutine to prepare the [[SULU_ENV]] components implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) allocate ( sulu % perm_c ( 1 : nn ) ) if (. not . allocated ( sulu % perm_r )) allocate ( sulu % perm_r ( 1 : nn ) ) if (. not . allocated ( sulu % etree )) allocate ( sulu % etree ( 1 : nn ) ) if (. not . allocated ( sulu % RR )) allocate ( sulu % RR ( 1 : nn ) ) if (. not . allocated ( sulu % CC )) allocate ( sulu % CC ( 1 : nn ) ) if (. not . allocated ( sulu % ferr )) allocate ( sulu % ferr ( 1 : nb ) ) if (. not . allocated ( sulu % berr )) allocate ( sulu % berr ( 1 : nb ) ) if (. not . allocated ( sulu % rpg )) allocate ( sulu % rpg ( 1 : nb ) ) if (. not . allocated ( sulu % rcond )) allocate ( sulu % rcond ( 1 : nb ) ) if (. not . allocated ( sulu % x )) allocate ( sulu % x ( 1 : nn ) ) sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu","tags":"","loc":"proc/prep_superlu.html"},{"title":"solv_superlu – TOOLIB","text":"public  subroutine solv_superlu(sol_x, sulu, verbose) Note Subroutine to solve the system If no resolution has yet occured, sulu%first= true sulu%options%Fact = FACTORED sulu%SMB%ncol     = sulu%nrhs (usually 1 ) otherwise sulu%options%Fact = SAMEPATTERN sma, smb and smx are recreated but do not forget that we still have: mat%matsulu%irow   => mat%irow mat%matsulu%jptr   => mat%jptr mat%matsulu%a_elt  => mat%a_elt mat%matsulu%b      => mat%b Note The solution is retrieved with the pointer store of type NCFORMAT which\ngives access to nzval Warning At the end, the memory is released with the dstruction of sml and smu Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose Calls proc~~solv_superlu~~CallsGraph proc~solv_superlu solv_superlu interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix interface~dgssvx dgssvx proc~solv_superlu->interface~dgssvx interface~statfree StatFree proc~solv_superlu->interface~statfree interface~statinit StatInit proc~solv_superlu->interface~statinit interface~statprint StatPrint proc~solv_superlu->interface~statprint proc~prep_superlu prep_superlu proc~solv_superlu->proc~prep_superlu interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~solv_superlu~~CalledByGraph proc~solv_superlu solv_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu","tags":"","loc":"proc/solv_superlu.html"},{"title":"Destroy_CompCol_Matrix – TOOLIB","text":"interface Called by interface~~destroy_compcol_matrix~~CalledByGraph interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_compcol_matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_compcol_matrix proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~close_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"Destroy_CompCol_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":"","loc":"interface/destroy_compcol_matrix.html"},{"title":"Destroy_Dense_Matrix – TOOLIB","text":"interface Called by interface~~destroy_dense_matrix~~CalledByGraph interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu close_superlu proc~close_superlu->interface~destroy_dense_matrix proc~close_solver close_solver proc~close_solver->proc~close_superlu proc~solve_syst solve_syst proc~solve_syst->proc~close_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine Destroy_Dense_Matrix(A) bind(c, name=\"Destroy_Dense_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":"","loc":"interface/destroy_dense_matrix.html"},{"title":"Destroy_SuperMatrix_Store – TOOLIB","text":"interface private  subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"Destroy_SuperMatrix_Store\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":"","loc":"interface/destroy_supermatrix_store.html"},{"title":"Destroy_SuperNode_Matrix – TOOLIB","text":"interface Called by interface~~destroy_supernode_matrix~~CalledByGraph interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu solv_superlu proc~solv_superlu->interface~destroy_supernode_matrix proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public  subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"Destroy_SuperNode_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A","tags":"","loc":"interface/destroy_supernode_matrix.html"},{"title":"StatFree – TOOLIB","text":"interface Called by interface~~statfree~~CalledByGraph interface~statfree StatFree proc~fact_superlu fact_superlu proc~fact_superlu->interface~statfree proc~solv_superlu solv_superlu proc~solv_superlu->interface~statfree proc~factorize_solver factorize_solver proc~factorize_solver->proc~fact_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine StatFree(stat) bind(c, name=\"StatFree\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","tags":"","loc":"interface/statfree.html"},{"title":"StatInit – TOOLIB","text":"interface Called by interface~~statinit~~CalledByGraph interface~statinit StatInit proc~fact_superlu fact_superlu proc~fact_superlu->interface~statinit proc~solv_superlu solv_superlu proc~solv_superlu->interface~statinit proc~factorize_solver factorize_solver proc~factorize_solver->proc~fact_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine StatInit(stat) bind(c, name=\"StatInit\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat","tags":"","loc":"interface/statinit.html"},{"title":"StatPrint – TOOLIB","text":"interface Called by interface~~statprint~~CalledByGraph interface~statprint StatPrint proc~fact_superlu fact_superlu proc~fact_superlu->interface~statprint proc~solv_superlu solv_superlu proc~solv_superlu->interface~statprint proc~factorize_solver factorize_solver proc~factorize_solver->proc~fact_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine StatPrint(stat) bind(c, name=\"StatPrint\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat","tags":"","loc":"interface/statprint.html"},{"title":"dCreate_CompCol_Matrix – TOOLIB","text":"interface Called by interface~~dcreate_compcol_matrix~~CalledByGraph interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_compcol_matrix proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"dCreate_CompCol_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","tags":"","loc":"interface/dcreate_compcol_matrix.html"},{"title":"dCreate_Dense_Matrix – TOOLIB","text":"interface Called by interface~~dcreate_dense_matrix~~CalledByGraph interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu prep_superlu proc~prep_superlu->interface~dcreate_dense_matrix proc~analyse_solver analyse_solver proc~analyse_solver->proc~prep_superlu proc~solv_superlu solv_superlu proc~solv_superlu->proc~prep_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~analyse_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name='dCreate_Dense_Matrix') Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype","tags":"","loc":"interface/dcreate_dense_matrix.html"},{"title":"dgssvx – TOOLIB","text":"interface Called by interface~~dgssvx~~CalledByGraph interface~dgssvx dgssvx proc~fact_superlu fact_superlu proc~fact_superlu->interface~dgssvx proc~solv_superlu solv_superlu proc~solv_superlu->interface~dgssvx proc~factorize_solver factorize_solver proc~factorize_solver->proc~fact_superlu proc~solution_solver solution_solver proc~solution_solver->proc~solv_superlu proc~solve_syst solve_syst proc~solution_solver->proc~solve_syst proc~solve_syst->proc~factorize_solver proc~solve_syst->proc~solution_solver program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name='dgssvx') Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR, len=1), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info","tags":"","loc":"interface/dgssvx.html"},{"title":"set_default_options – TOOLIB","text":"interface Called by interface~~set_default_options~~CalledByGraph interface~set_default_options set_default_options proc~init_superlu init_superlu proc~init_superlu->interface~set_default_options proc~init_solver init_solver proc~init_solver->proc~init_superlu proc~solve_syst solve_syst proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~solution_solver->proc~solve_syst program~test_solvers test_solvers program~test_solvers->proc~solve_syst Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private  subroutine set_default_options(options) bind(c, name='set_default_options') Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options","tags":"","loc":"interface/set_default_options.html"},{"title":"read_surf – TOOLIB","text":"subroutine read_surf(nom_fic, tab_s, nx, ny) Subroutine that opens a surface file .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y Calls proc~~read_surf~2~~CallsGraph proc~read_surf~2 read_surf proc~get_unit get_unit proc~read_surf~2->proc~get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_surf~2~~CalledByGraph proc~read_surf~2 read_surf program~test_fftw3 test_fftw3 program~test_fftw3->proc~read_surf~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine read_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that opens a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( out ), dimension (:,:), allocatable :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: x , y allocate ( tab_s ( 1 : nx , 1 : ny ) ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) do i = 1 , nx do j = 1 , ny read ( k , * ) x , y , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine read_surf","tags":"","loc":"proc/read_surf~2.html"},{"title":"save_surf – TOOLIB","text":"subroutine save_surf(nom_fic, tab_s, nx, ny) Subroutine that saves a surface file .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab_s height array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y Calls proc~~save_surf~~CallsGraph proc~save_surf save_surf proc~get_unit get_unit proc~save_surf->proc~get_unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~save_surf~~CalledByGraph proc~save_surf save_surf program~test_fftw3 test_fftw3 program~test_fftw3->proc~save_surf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine save_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that saves a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'unknown' ) do i = 1 , nx do j = 1 , ny write ( k , * ) i , j , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine save_surf","tags":"","loc":"proc/save_surf.html"},{"title":"miscellaneous – TOOLIB","text":"Various subroutines Uses data_arch module~~miscellaneous~~UsesGraph module~miscellaneous miscellaneous module~data_arch data_arch module~miscellaneous->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~miscellaneous~~UsedByGraph module~miscellaneous miscellaneous module~files files module~files->module~miscellaneous module~surfile surfile module~surfile->module~miscellaneous module~tchebychev tchebychev module~tchebychev->module~miscellaneous program~main main program~main->module~miscellaneous program~test_algen test_algen program~test_algen->module~miscellaneous program~test_data_arch test_data_arch program~test_data_arch->module~miscellaneous program~test_fftw3 test_fftw3 program~test_fftw3->module~miscellaneous program~test_solvers test_solvers program~test_solvers->module~miscellaneous program~test_tchebychev test_tchebychev program~test_tchebychev->module~miscellaneous program~test_tchebychev->module~tchebychev program~test_files test_files program~test_files->module~files program~test_surfile test_surfile program~test_surfile->module~surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine get_unit (iunit) Provide for a free unit, from here John Burkardt website Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out) :: iunit free unit to use public  subroutine progress_bar_terminal (val, max_val, init) Print a progress bar on the terminal Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: val actual position integer(kind=I4), intent(in) :: max_val maximum value reached logical(kind=I4), intent(in) :: init progress bar initialization public  subroutine trans_center2corner (tab_in, tab_out, long, larg) Generic subroutine for real or complex arrays that shift the center to the corners Arguments Type Intent Optional Attributes Name class(*), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform class(*), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width private  subroutine trans_center2corner_cmpl (tab_in, tab_out, long, larg) Subroutine to transform an array of complexes so that the center is in the corners Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width private  subroutine trans_center2corner_real (tab_in, tab_out, long, larg) Subroutine to transform an array of reals so that the center is in the corners Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width public  subroutine trans_corner2center (tab_in, tab_out, long, larg) Generic subroutine for real or complex arrays that shift the corners to the center Arguments Type Intent Optional Attributes Name class(*), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform class(*), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width private  subroutine trans_corner2center_cmpl (tab_in, tab_out, long, larg) Function to transform an acf complex array so that the acf maximum is in the center Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width private  subroutine trans_corner2center_real (tab_in, tab_out, long, larg) Function to transform an acf real array so that the acf maximum is in the center Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in 2D array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out transformed 2D array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width","tags":"","loc":"module/miscellaneous.html"},{"title":"minpack – TOOLIB","text":"A fortran collection of functions for minimization problems Note MINPACK is a FORTRAN90 library which solves systems of nonlinear equations,\nor carries out the least squares minimization of the residual of a set of linear or nonlinear equations,\nby Jorge More, Danny Sorenson, Burton Garbow, Kenneth Hillstrom. link Used by module~~minpack~~UsedByGraph module~minpack minpack program~test_minpack test_minpack program~test_minpack->module~minpack Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function enorm (n, x) ENORM computes the Euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x (n) Return Value real(kind=8) public  function enorm2 (n, x) ENORM2 computes the Euclidean norm of a vector. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: x (n) Return Value real(kind=8) public  function r8_uniform_01 (seed) R8_UNIFORM_01 returns a unit pseudorandom R8. Arguments Type Intent Optional Attributes Name integer(kind=4) :: seed Return Value real(kind=8) Subroutines public  subroutine chkder (m, n, x, fvec, fjac, ldfjac, xp, fvecp, mode, err) CHKDER checks the gradients of M functions of N variables. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: xp (n) real(kind=8) :: fvecp (m) integer(kind=4) :: mode real(kind=8) :: err (m) public  subroutine dogleg (n, r, lr, diag, qtb, delta, x) DOGLEG finds the minimizing combination of Gauss-Newton and gradient steps. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: delta real(kind=8) :: x (n) public  subroutine fdjac1 (fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn) FDJAC1 estimates an N by N jacobian matrix using forward differences. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: iflag integer(kind=4) :: ml integer(kind=4) :: mu real(kind=8) :: epsfcn public  subroutine fdjac2 (fcn, m, n, x, fvec, fjac, ldfjac, iflag, epsfcn) FDJAC2 estimates an M by N jacobian matrix using forward differences. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: iflag real(kind=8) :: epsfcn public  subroutine hybrd (fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf) HYBRD seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: xtol integer(kind=4) :: maxfev integer(kind=4) :: ml integer(kind=4) :: mu real(kind=8) :: epsfcn real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: qtf (n) public  subroutine hybrd1 (fcn, n, x, fvec, tol, info) HYBRD1 seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: tol integer(kind=4) :: info public  subroutine hybrj (fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf) HYBRJ seeks a zero of N nonlinear equations in N variables. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: xtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev real(kind=8) :: r (lr) integer(kind=4) :: lr real(kind=8) :: qtf (n) public  subroutine hybrj1 (fcn, n, x, fvec, fjac, ldfjac, tol, info) HYBRJ1 seeks a zero of N equations in N variables by Powell’s method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (n) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info public  subroutine lmder (fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf) LMDER minimizes M functions in N variables by the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) public  subroutine lmder1 (fcn, m, n, x, fvec, fjac, ldfjac, tol, info) LMDER1 minimizes M functions in N variables by Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info public  subroutine lmdif (fcn, m, n, x, fvec, ftol, xtol, gtol, maxfev, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, ipvt, qtf) LMDIF minimizes M functions in N variables by the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: epsfcn real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) public  subroutine lmdif1 (fcn, m, n, x, fvec, tol, info) LMDIF1 minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: tol integer(kind=4) :: info public  subroutine lmpar (n, r, ldr, ipvt, diag, qtb, delta, par, x, sdiag) LMPAR computes a parameter for the Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr integer(kind=4) :: ipvt (n) real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: delta real(kind=8) :: par real(kind=8) :: x (n) real(kind=8) :: sdiag (n) public  subroutine lmstr (fcn, m, n, x, fvec, fjac, ldfjac, ftol, xtol, gtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, ipvt, qtf) LMSTR minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: ftol real(kind=8) :: xtol real(kind=8) :: gtol integer(kind=4) :: maxfev real(kind=8) :: diag (n) integer(kind=4) :: mode real(kind=8) :: factor integer(kind=4) :: nprint integer(kind=4) :: info integer(kind=4) :: nfev integer(kind=4) :: njev integer(kind=4) :: ipvt (n) real(kind=8) :: qtf (n) public  subroutine lmstr1 (fcn, m, n, x, fvec, fjac, ldfjac, tol, info) LMSTR1 minimizes M functions in N variables using Levenberg-Marquardt method. Arguments Type Intent Optional Attributes Name real :: fcn integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: x (n) real(kind=8) :: fvec (m) real(kind=8) :: fjac (ldfjac,n) integer(kind=4) :: ldfjac real(kind=8) :: tol integer(kind=4) :: info public  subroutine qform (m, n, q, ldq) QFORM produces the explicit QR factorization of a matrix. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: q (ldq,m) integer(kind=4) :: ldq public  subroutine qrfac (m, n, a, lda, pivot, ipvt, lipvt, rdiag, acnorm) QRFAC computes a QR factorization using Householder transformations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (lda,n) integer(kind=4) :: lda logical :: pivot integer(kind=4) :: ipvt (lipvt) integer(kind=4) :: lipvt real(kind=8) :: rdiag (n) real(kind=8) :: acnorm (n) public  subroutine qrsolv (n, r, ldr, ipvt, diag, qtb, x, sdiag) QRSOLV solves a rectangular linear system A*x=b in the least squares sense. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr integer(kind=4) :: ipvt (n) real(kind=8) :: diag (n) real(kind=8) :: qtb (n) real(kind=8) :: x (n) real(kind=8) :: sdiag (n) public  subroutine r1mpyq (m, n, a, lda, v, w) R1MPYQ computes A*Q, where Q is the product of Householder transformations. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (lda,n) integer(kind=4) :: lda real(kind=8) :: v (n) real(kind=8) :: w (n) public  subroutine r1updt (m, n, s, ls, u, v, w, sing) R1UPDT re-triangularizes a matrix after a rank one update. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: s (ls) integer(kind=4) :: ls real(kind=8) :: u (m) real(kind=8) :: v (n) real(kind=8) :: w (m) logical :: sing public  subroutine r8mat_print (m, n, a, title) R8MAT_PRINT prints an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) character(len=*) :: title public  subroutine r8mat_print_some (m, n, a, ilo, jlo, ihi, jhi, title) R8MAT_PRINT_SOME prints some of an R8MAT. Arguments Type Intent Optional Attributes Name integer(kind=4) :: m integer(kind=4) :: n real(kind=8) :: a (m,n) integer(kind=4) :: ilo integer(kind=4) :: jlo integer(kind=4) :: ihi integer(kind=4) :: jhi character(len=*) :: title public  subroutine r8vec_print (n, a, title) R8VEC_PRINT prints an R8VEC. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: a (n) character(len=*) :: title public  subroutine rwupdt (n, r, ldr, w, b, alpha, c, s) RWUPDT computes the decomposition of triangular matrix augmented by one row. Arguments Type Intent Optional Attributes Name integer(kind=4) :: n real(kind=8) :: r (ldr,n) integer(kind=4) :: ldr real(kind=8) :: w (n) real(kind=8) :: b (n) real(kind=8) :: alpha real(kind=8) :: c (n) real(kind=8) :: s (n) public  subroutine timestamp () TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None","tags":"","loc":"module/minpack.html"},{"title":"pikaia_oop – TOOLIB","text":"PIKAIA is a general purpose unconstrained optimization\n  method based on a genetic algorithm.\n  This is an object-oriented version of the algorithm for Fortran 2003/2008. See also Original description page Original sourcecode License Copyright ( c ) 2015-2020 , Jacob Williams http :// github . com / jacobwilliams / pikaia All rights reserved . Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : * Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . * Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer in the documentation and / or other materials provided with the distribution . * Neither the name of pikaia nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission . THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED . IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . ------------------------------------------------------------------------------ The original version of the PIKAIA software is public domain software and is available electronically from the High Altitude Observatory . http :// www . hao . ucar . edu / modeling / pikaia / pikaia . php History Jacob Williams : 3/8/2015 : Significant refactoring of original PIKAIA code.\n    Converted to free-form source, double precision real variables, added various\n    new features, and an object-oriented interface. Uses mt19937_64 iso_fortran_env module~~pikaia_oop~~UsesGraph module~pikaia_oop pikaia_oop iso_fortran_env iso_fortran_env module~pikaia_oop->iso_fortran_env module~mt19937_64 mt19937_64 module~pikaia_oop->module~mt19937_64 module~mt19937_64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pikaia_oop~~UsedByGraph module~pikaia_oop pikaia_oop program~test_algen test_algen program~test_algen->module~pikaia_oop Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 Default real kind [8 bytes]. Abstract Interfaces abstract interface private  subroutine iter_func(me, iter, x, f) The interface for the function that user can specify\nto report each iteration when pikaia is running.\nThe best (fittest) population member is passed to\nthis routine in each generation. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me pikaia class integer, intent(in) :: iter iteration number real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(in) :: f fitness value abstract interface private  subroutine pikaia_func(me, x, f) The interface for the function that pikaia will be maximizing. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me pikaia class real(kind=wp), intent(in), dimension(:) :: x optimization variable vector real(kind=wp), intent(out) :: f fitness value Derived Types type, public :: pikaia_class Main class for using the Pikaia algorithm.\nINIT and SOLVE are the only public methods. Components Type Visibility Attributes Name Initial real(kind=wp), private :: bestft = huge(1.0_wp) real(kind=wp), private :: convergence_tol = 0.0001_wp integer, private :: convergence_window = 20 real(kind=wp), private, dimension(:), allocatable :: del real(kind=wp), private :: fdif = 1.0_wp integer, private :: ielite = 1 integer, private :: imut = 2 real(kind=wp), private :: initial_guess_frac = 0.1_wp integer, private :: irep = 1 integer, private :: iseed = 999 procedure( iter_func ), private, pointer :: iter_f => null() reporting function (best member of population) integer, private :: ivrb = 0 integer, private :: n = 0 integer, private :: nd = 5 integer, private :: ngen = 500 integer, private :: np = 100 real(kind=wp), private :: pcross = 0.85_wp real(kind=wp), private :: pmut = -huge(1.0_wp) real(kind=wp), private :: pmuti = 0.005_wp initial value of pmut real(kind=wp), private :: pmutmn = 0.0005_wp real(kind=wp), private :: pmutmx = 0.25_wp real(kind=wp), private :: pmutpv = huge(1.0_wp) type( mt19937 ), private :: rand random number generator procedure( pikaia_func ), private, pointer :: user_f => null() fitness function real(kind=wp), private, dimension(:), allocatable :: xl lower bounds of x real(kind=wp), private, dimension(:), allocatable :: xu upper bound of x Type-Bound Procedures procedure, public, non_overridable :: adjmut procedure, public, non_overridable :: cross procedure, public, non_overridable :: decode procedure, public, non_overridable :: encode procedure, public, non_overridable :: ff => func_wrapper ../../ internal pikaia function (x:[0,1]) procedure, public, non_overridable :: genrep procedure, public, non_overridable :: init => set_inputs procedure, public, non_overridable :: mutate procedure, public, non_overridable :: newpop procedure, public, non_overridable :: pikaia procedure, public, non_overridable :: report procedure, public, non_overridable :: rninit procedure, public, non_overridable :: rnkpop procedure, public, non_overridable :: select_parents procedure, public, non_overridable :: solve => solve_with_pikaia procedure, public, non_overridable :: stdrep procedure, public, non_overridable :: urand Functions private  function urand (me) result(r) Return the next pseudo-random deviate from a sequence which is\nuniformly distributed in the interval [0,1] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me Return Value real(kind=wp) Subroutines private  subroutine adjmut (me, oldph, fitns, ifit) Dynamical adjustment of mutation rate: Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit private  subroutine cross (me, gn1, gn2) breeds two parent chromosomes into two offspring chromosomes.\n  breeding occurs through crossover. If the crossover probability\n  test yields true (crossover taking place), either one-point or\n  two-point crossover is used, with equal probabilities. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn1 integer, intent(inout), dimension(me%n*me%nd) :: gn2 private  subroutine decode (me, gn, ph) decode genotype into phenotype parameters\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me integer, intent(in), dimension(me%n*me%nd) :: gn real(kind=wp), intent(out), dimension(me%n) :: ph private  subroutine encode (me, ph, gn) Encode phenotype parameters into integer genotype\nph(k) are x,y coordinates [ 0 < x,y < 1 ] Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(in) :: me real(kind=wp), intent(in), dimension(me%n) :: ph integer, intent(out), dimension(me%n*me%nd) :: gn private  subroutine func_wrapper (me, x, f) Author Jacob Williams Wrapper for the user’s function that is used by the main pikaia routine\nThe x input to this function comes from pikaia, and will be between [0,1]. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(:) :: x real(kind=wp), intent(out) :: f private  subroutine genrep (me, ip, ph, newph) Full generational replacement: accumulate offspring into new\npopulation array Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in) :: ip real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(out), dimension(me%n,me%np) :: newph private  subroutine mutate (me, gn) Introduces random mutation in a genotype.\n  Mutations occur at rate pmut at all gene loci. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(inout), dimension(me%n*me%nd) :: gn private  subroutine newpop (me, oldph, newph, ifit, jfit, fitns, nnew) Replaces old population by new; recomputes fitnesses & ranks Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%n,me%np) :: newph integer, intent(out), dimension(me%np) :: ifit integer, intent(out), dimension(me%np) :: jfit real(kind=wp), intent(out), dimension(me%np) :: fitns integer, intent(out) :: nnew private  subroutine pikaia (me, x, f, status, omp) Optimization (maximization) of user-supplied “fitness” function\n  over n-dimensional parameter space x using a basic genetic\n  algorithm method. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x Input - initial guess for solution vector.\nOutput - the “fittest” (optimal) solution found,\ni.e., the solution which maximizes the fitness function. real(kind=wp), intent(out) :: f the (scalar) value of the fitness function at x integer, intent(out) :: status an indicator of the success or failure\nof the call to pikaia (0=success; non-zero=failure) logical, intent(in), optional :: omp if OpenMP is being used private  subroutine report (me, oldph, fitns, ifit, ig, nnew) Write generation report to standard output Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,me%np) :: oldph real(kind=wp), intent(in), dimension(me%np) :: fitns integer, intent(in), dimension(me%np) :: ifit integer, intent(in) :: ig integer, intent(in) :: nnew private  subroutine rninit (me) Initialize the random number generator with the input seed value. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me private  subroutine rnkpop (me, arrin, indx, rank) Ranks initial population.\nCalls external sort routine to produce key index and rank order\nof input array arrin (which is not altered). Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%np) :: arrin integer, intent(out), dimension(me%np) :: indx integer, intent(out), dimension(me%np) :: rank private  subroutine rqsort (n, a, p) Author B. G. Knapp Date 86/12/23 Return integer array p which indexes array a in increasing order.\n  Array a is not disturbed.  The Quicksort algorithm is used. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: a integer, intent(out), dimension(n) :: p private  subroutine select_parents (me, jfit, imom, idad) Selects two parents from the population, using roulette wheel\n  algorithm with the relative fitnesses of the phenotypes as\n  the “hit” probabilities. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me integer, intent(in), dimension(me%np) :: jfit integer, intent(out) :: imom integer, intent(out) :: idad private  subroutine set_inputs (me, n, xl, xu, f, status, iter_f, np, ngen, nd, pcross, pmutmn, pmutmx, pmut, imut, fdif, irep, ielite, ivrb, convergence_tol, convergence_window, initial_guess_frac, iseed) Author Jacob Williams Constructor for the pikaia_class .\n  The routine must be called before the solve routine can be used. Read more… Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(out) :: me pikaia class integer, intent(in) :: n the parameter space dimension, i.e., the number\nof adjustable parameters (size of the x vector). real(kind=wp), intent(in), dimension(n) :: xl vector of lower bounds for x real(kind=wp), intent(in), dimension(n) :: xu vector of upper bounds for x procedure( pikaia_func ) :: f user-supplied scalar function of n variables,\nwhich must have the pikaia_func procedure interface.\nBy convention, f should return higher values for more optimal\nparameter values (i.e., individuals which are more “fit”).\nFor example, in fitting a function through data points, f\ncould return the inverse of chi**2. integer, intent(out) :: status status output flag (0 if there were no errors) procedure( iter_func ), optional :: iter_f user-supplied subroutine that will report the\nbest solution for each generation.\nIt must have the iter_func procedure interface.  If not present,\nthen it is not used.  (note: this is independent of ivrb). integer, intent(in), optional :: np number of individuals in a population (default is 100) integer, intent(in), optional :: ngen maximum number of iterations integer, intent(in), optional :: nd number of significant digits (i.e., number of\ngenes) retained in chromosomal encoding (default is 6). real(kind=wp), intent(in), optional :: pcross crossover probability; must be  <= 1.0 (default\nis 0.85). If crossover takes place, either one\nor two splicing points are used, with equal\nprobabilities real(kind=wp), intent(in), optional :: pmutmn minimum mutation rate; must be >= 0.0 (default is 0.0005) real(kind=wp), intent(in), optional :: pmutmx maximum mutation rate; must be <= 1.0 (default is 0.25) real(kind=wp), intent(in), optional :: pmut initial mutation rate; should be small (default\nis 0.005) (Note: the mutation rate is the probability\nthat any one gene locus will mutate in\nany one generation.) integer, intent(in), optional :: imut mutation mode; 1/2/3/4/5 (default is 2).\n 1=one-point mutation, fixed rate.\n 2=one-point, adjustable rate based on fitness.\n 3=one-point, adjustable rate based on distance.\n 4=one-point+creep, fixed rate.\n 5=one-point+creep, adjustable rate based on fitness.\n 6=one-point+creep, adjustable rate based on distance. real(kind=wp), intent(in), optional :: fdif relative fitness differential; range from 0\n(none) to 1 (maximum).  (default is 1.0) integer, intent(in), optional :: irep reproduction plan; 1/2/3=Full generational\nreplacement/Steady-state-replace-random/Steady-\nstate-replace-worst (default is 3) integer, intent(in), optional :: ielite elitism flag; 0/1=off/on (default is 0)\n(Applies only to reproduction plans 1 and 2) integer, intent(in), optional :: ivrb printed output 0/1/2=None/Minimal/Verbose\n(default is 0) real(kind=wp), intent(in), optional :: convergence_tol convergence tolerance; must be > 0.0 (default is 0.0001) integer, intent(in), optional :: convergence_window convergence window; must be >= 0\nThis is the number of consecutive solutions\nwithin the tolerance for convergence to\nbe declared (default is 20) real(kind=wp), intent(in), optional :: initial_guess_frac fraction of the initial population\nto set equal to the initial guess.  Range from 0\n(none) to 1.0 (all). (default is 0.1 or 10%). integer, intent(in), optional :: iseed random seed value; must be > 0 (default is 999) private  subroutine solve_with_pikaia (me, x, f, status, omp) Author Jacob Williams Main pikaia wrapper used by the class. Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(out) :: f integer, intent(out) :: status logical, intent(in), optional :: omp if OpenMP is being used private  subroutine stdrep (me, ph, fits, oldph, fitns, ifit, jfit, nnew) Steady-state reproduction: insert offspring pair into population\nonly if they are fit enough (replace-random if irep=2 or\nreplace-worst if irep=3). Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=wp), intent(in), dimension(me%n,2) :: ph real(kind=wp), intent(in), dimension(2) :: fits real(kind=wp), intent(inout), dimension(me%n,me%np) :: oldph real(kind=wp), intent(inout), dimension(me%np) :: fitns integer, intent(inout), dimension(me%np) :: ifit integer, intent(inout), dimension(me%np) :: jfit integer, intent(out) :: nnew","tags":"","loc":"module/pikaia_oop.html"},{"title":"gen_param – TOOLIB","text":"Uses data_arch module~~gen_param~~UsesGraph module~gen_param gen_param module~data_arch data_arch module~gen_param->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~gen_param~~UsedByGraph module~gen_param gen_param module~solver solver module~solver->module~gen_param program~test_solvers test_solvers program~test_solvers->module~gen_param program~test_solvers->module~solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: NO_MESS = 0 code for no message on screen during problem solving character(len=128), public :: OUTPUT_FILE When needed, output file integer(kind=I4), public, parameter :: PRINT_MESS = 1 code for printing message during problem solving integer(kind=I4), public :: SOLV_MESS = NO_MESS Solver output detail control integer(kind=I4), public :: VERBOSE Output detail control","tags":"","loc":"module/gen_param.html"},{"title":"fftw3 – TOOLIB","text":"A fortran api to FFTW3 FFT distributed on multiple threads multiple FFT simultaneously computed. Uses iso_c_binding data_arch module~~fftw3~~UsesGraph module~fftw3 fftw3 iso_c_binding iso_c_binding module~fftw3->iso_c_binding module~data_arch data_arch module~fftw3->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fftw3~~UsedByGraph module~fftw3 fftw3 program~test_fftw3 test_fftw3 program~test_fftw3->module~fftw3 Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), public, parameter :: BACKWARD = -1 just as suggested, it means backward transformation required integer, private, parameter :: C_FFTW_R2R_KIND = C_INT32_T integer(kind=C_INT), private, parameter :: FFTW_ALLOW_LARGE_GENERIC = 8192 integer(kind=C_INT), private, parameter :: FFTW_ALLOW_PRUNING = 1048576 integer(kind=C_INT), private, parameter :: FFTW_BACKWARD = +1 integer(kind=C_INT), private, parameter :: FFTW_BELIEVE_PCOST = 256 integer(kind=C_INT), private, parameter :: FFTW_CONSERVE_MEMORY = 4 integer(kind=C_INT), private, parameter :: FFTW_DESTROY_INPUT = 1 integer(kind=C_INT), private, parameter :: FFTW_DHT = 2 integer(kind=C_INT), public, parameter :: FFTW_ESTIMATE = 64 integer(kind=C_INT), private, parameter :: FFTW_ESTIMATE_PATIENT = 128 integer(kind=C_INT), public, parameter :: FFTW_EXHAUSTIVE = 8 integer(kind=C_INT), private, parameter :: FFTW_FORWARD = -1 integer(kind=C_INT), private, parameter :: FFTW_HC2R = 1 integer(kind=C_INT), public, parameter :: FFTW_MEASURE = 0 integer(kind=C_INT), private, parameter :: FFTW_NO_BUFFERING = 2048 integer(kind=C_INT), private, parameter :: FFTW_NO_DFT_R2HC = 512 integer(kind=C_INT), private, parameter :: FFTW_NO_FIXED_RADIX_LARGE_N = 524288 integer(kind=C_INT), private, parameter :: FFTW_NO_INDIRECT_OP = 4096 integer(kind=C_INT), private, parameter :: FFTW_NO_NONTHREADED = 1024 integer(kind=C_INT), private, parameter :: FFTW_NO_RANK_SPLITS = 16384 integer(kind=C_INT), private, parameter :: FFTW_NO_SIMD = 131072 integer(kind=C_INT), private, parameter :: FFTW_NO_SLOW = 262144 integer(kind=C_INT), private, parameter :: FFTW_NO_VRANK_SPLITS = 32768 integer(kind=C_INT), private, parameter :: FFTW_NO_VRECURSE = 65536 integer(kind=C_INT), private, parameter :: FFTW_PATIENT = 32 integer(kind=C_INT), private, parameter :: FFTW_PRESERVE_INPUT = 16 integer(kind=C_INT), private, parameter :: FFTW_R2HC = 0 integer(kind=C_INT), private, parameter :: FFTW_REDFT00 = 3 integer(kind=C_INT), private, parameter :: FFTW_REDFT01 = 4 integer(kind=C_INT), private, parameter :: FFTW_REDFT10 = 5 integer(kind=C_INT), private, parameter :: FFTW_REDFT11 = 6 integer(kind=C_INT), private, parameter :: FFTW_RODFT00 = 7 integer(kind=C_INT), private, parameter :: FFTW_RODFT01 = 8 integer(kind=C_INT), private, parameter :: FFTW_RODFT10 = 9 integer(kind=C_INT), private, parameter :: FFTW_RODFT11 = 10 integer(kind=C_INT), private, parameter :: FFTW_UNALIGNED = 2 integer(kind=C_INT), private, parameter :: FFTW_WISDOM_ONLY = 2097152 integer(kind=I4), public, dimension(2) :: FFT_DIM = [0, 0] Sizes currently allocated integer(kind=I4), public, parameter :: FORWARD = +1 just as suggested, it means  forward transformation required logical(kind=I4), public :: MULTI_FFTW_ALLOCATED = .false. the fftw arrays are allocated and the plans are defined integer(kind=I4), public :: NB_THREADS_FFT = 4 real(kind=R8), public, parameter :: PAD_FFT = 1.50_R8 dimension multiplier for 0-padding logical(kind=I4), public :: SINGL_FFTW_ALLOCATED = .false. the fftw arrays are allocated and the plans are defined complex(kind=C_DOUBLE_COMPLEX), private, dimension(:,:), pointer :: cmp_b_i memory address of the input  array for a BACKWARD transformation complex(kind=C_DOUBLE_COMPLEX), private, dimension(:,:), pointer :: cmp_b_o memory address of the output array for a BACKWARD transformation complex(kind=C_DOUBLE_COMPLEX), private, dimension(:,:), pointer :: cmp_f_i memory address of the input  array for a FORWARD transformation complex(kind=C_DOUBLE_COMPLEX), private, dimension(:,:), pointer :: cmp_f_o memory address of the output array for a FORWARD transformation type(C_PTR), private :: p_b_i memory address for a plan BACKWARD in  input type(C_PTR), private :: p_b_o memory address for a plan BACKWARD in output type(C_PTR), private :: p_f_i memory address for a plan FORWARD in  input type(C_PTR), private :: p_f_o memory address for a plan FORWARD in output type(C_PTR), private :: plan_b plan BACKWARD type(C_PTR), private :: plan_f plan FORWARD real(kind=C_DOUBLE), private, dimension(:,:), pointer :: rea_b_o memory address of the output array for a BACKWARD transformation real(kind=C_DOUBLE), private, dimension(:,:), pointer :: rea_f_i memory address of the input  array for a FORWARD transformation type( tab_fftw ), private, dimension(:), allocatable :: tab_cmp_b_i array of memory addresses of the  input arrays for a BACKWARD transformation type( tab_fftw ), private, dimension(:), allocatable :: tab_cmp_b_o array of memory addresses of the output arrays for a BACKWARD transformation type( tab_fftw ), private, dimension(:), allocatable :: tab_cmp_f_i array of memory addresses of the  input arrays for a FORWARD transformation type( tab_fftw ), private, dimension(:), allocatable :: tab_cmp_f_o array of memory addresses of the output arrays for a FORWARD transformation type(C_PTR), private, dimension(:), allocatable :: tab_p_b_i array of memory addresses for a plan BACKWARD in  input type(C_PTR), private, dimension(:), allocatable :: tab_p_b_o array of memory addresses for a plan BACKWARD in output type(C_PTR), private, dimension(:), allocatable :: tab_p_f_i array of memory addresses for a plan FORWARD in  input type(C_PTR), private, dimension(:), allocatable :: tab_p_f_o array of memory addresses for a plan FORWARD in output type(C_PTR), private, dimension(:), allocatable :: tab_plan_b plan BACKWARD type(C_PTR), private, dimension(:), allocatable :: tab_plan_f plan FORWARD type( tab_fftw_real ), private, dimension(:), allocatable :: tab_rea_b_i array of memory addresses of the  input arrays for a BACKWARD transformation type( tab_fftw_real ), private, dimension(:), allocatable :: tab_rea_b_o array of memory addresses of the output arrays for a BACKWARD transformation type( tab_fftw_real ), private, dimension(:), allocatable :: tab_rea_f_i array of memory addresses of the  input arrays for a FORWARD transformation type( tab_fftw_real ), private, dimension(:), allocatable :: tab_rea_f_o array of memory addresses of the output arrays for a FORWARD transformation Interfaces interface private  function fftw_alignment_of(p) bind(C, name='fftw_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), intent(out), dimension(*) :: p Return Value integer(kind=c_int) interface private  function fftw_alloc_complex(n) bind(C, name='fftw_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  function fftw_alloc_real(n) bind(C, name='fftw_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  subroutine fftw_cleanup() bind(C, name='fftw_cleanup') Arguments None interface private  subroutine fftw_cleanup_threads() bind(C, name='fftw_cleanup_threads') Arguments None interface private  function fftw_cost(p) bind(C, name='fftw_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface private  subroutine fftw_destroy_plan(p) bind(C, name='fftw_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  function fftw_estimate_cost(p) bind(C, name='fftw_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface private  subroutine fftw_execute_dft(p, in, out) bind(C, name='fftw_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface private  subroutine fftw_execute_dft_c2r(p, in, out) bind(C, name='fftw_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_DOUBLE_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface private  subroutine fftw_execute_dft_r2c(p, in, out) bind(C, name='fftw_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out interface private  subroutine fftw_execute_r2r(p, in, out) bind(C, name='fftw_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface private  subroutine fftw_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftw_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface private  subroutine fftw_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftw_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: ri real(kind=C_DOUBLE), intent(inout), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out interface private  subroutine fftw_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftw_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(inout), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io interface private  subroutine fftw_export_wisdom(write_char, data) bind(C, name='fftw_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface private  subroutine fftw_export_wisdom_to_file(output_file) bind(C, name='fftw_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface private  function fftw_export_wisdom_to_filename(filename) bind(C, name='fftw_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface private  function fftw_export_wisdom_to_string() bind(C, name='fftw_export_wisdom_to_string') Arguments None Return Value type(c_ptr) interface private  subroutine fftw_flops(p, add, mul, fmas) bind(C, name='fftw_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas interface private  subroutine fftw_forget_wisdom() bind(C, name='fftw_forget_wisdom') Arguments None interface private  subroutine fftw_fprint_plan(p, output_file) bind(C, name='fftw_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface private  subroutine fftw_free(p) bind(C, name='fftw_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  function fftw_import_system_wisdom() bind(C, name='fftw_import_system_wisdom') Arguments None Return Value integer(kind=c_int) interface private  function fftw_import_wisdom(read_char, data) bind(C, name='fftw_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int) interface private  function fftw_import_wisdom_from_file(input_file) bind(C, name='fftw_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int) interface private  function fftw_import_wisdom_from_filename(filename) bind(C, name='fftw_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface private  function fftw_import_wisdom_from_string(input_string) bind(C, name='fftw_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int) interface private  function fftw_init_threads() bind(C, name='fftw_init_threads') Arguments None Return Value integer(kind=c_int) interface private  subroutine fftw_make_planner_thread_safe() bind(C, name='fftw_make_planner_thread_safe') Arguments None interface private  function fftw_malloc(n) bind(C, name='fftw_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  function fftw_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftw_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftw_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftw_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftw_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftw_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftw_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftw_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftw_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftw_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftw_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftw_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftw_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: ri real(kind=C_DOUBLE), intent(out), dimension(*) :: ii real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftw_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftw_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftw_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: ro real(kind=C_DOUBLE), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftw_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftw_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_DOUBLE_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftw_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_DOUBLE), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftw_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftw_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftw_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftw_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftw_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_DOUBLE), intent(out), dimension(*) :: in real(kind=C_DOUBLE), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface public  subroutine fftw_plan_with_nthreads(nthreads) bind(C, name='fftw_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface private  function fftw_planner_nthreads() bind(C, name='fftw_planner_nthreads') Arguments None Return Value integer(kind=c_int) interface private  subroutine fftw_print_plan(p) bind(C, name='fftw_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  subroutine fftw_set_timelimit(t) bind(C, name='fftw_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface private  function fftw_sprint_plan(p) bind(C, name='fftw_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr) interface private  function fftwf_alignment_of(p) bind(C, name='fftwf_alignment_of') Arguments Type Intent Optional Attributes Name real(kind=C_FLOAT), intent(out), dimension(*) :: p Return Value integer(kind=c_int) interface private  function fftwf_alloc_complex(n) bind(C, name='fftwf_alloc_complex') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  function fftwf_alloc_real(n) bind(C, name='fftwf_alloc_real') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  subroutine fftwf_cleanup() bind(C, name='fftwf_cleanup') Arguments None interface private  subroutine fftwf_cleanup_threads() bind(C, name='fftwf_cleanup_threads') Arguments None interface private  function fftwf_cost(p) bind(C, name='fftwf_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface private  subroutine fftwf_destroy_plan(p) bind(C, name='fftwf_destroy_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  function fftwf_estimate_cost(p) bind(C, name='fftwf_estimate_cost') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value real(kind=c_double) interface private  subroutine fftwf_execute_dft(p, in, out) bind(C, name='fftwf_execute_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface private  subroutine fftwf_execute_dft_c2r(p, in, out) bind(C, name='fftwf_execute_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p complex(kind=C_FLOAT_COMPLEX), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface private  subroutine fftwf_execute_dft_r2c(p, in, out) bind(C, name='fftwf_execute_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out interface private  subroutine fftwf_execute_r2r(p, in, out) bind(C, name='fftwf_execute_r2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out interface private  subroutine fftwf_execute_split_dft(p, ri, ii, ro, io) bind(C, name='fftwf_execute_split_dft') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface private  subroutine fftwf_execute_split_dft_c2r(p, ri, ii, out) bind(C, name='fftwf_execute_split_dft_c2r') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: ri real(kind=C_FLOAT), intent(inout), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out interface private  subroutine fftwf_execute_split_dft_r2c(p, in, ro, io) bind(C, name='fftwf_execute_split_dft_r2c') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_FLOAT), intent(inout), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io interface private  subroutine fftwf_export_wisdom(write_char, data) bind(C, name='fftwf_export_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: write_char type(C_PTR), value :: data interface private  subroutine fftwf_export_wisdom_to_file(output_file) bind(C, name='fftwf_export_wisdom_to_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: output_file interface private  function fftwf_export_wisdom_to_filename(filename) bind(C, name='fftwf_export_wisdom_to_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface private  function fftwf_export_wisdom_to_string() bind(C, name='fftwf_export_wisdom_to_string') Arguments None Return Value type(c_ptr) interface private  subroutine fftwf_flops(p, add, mul, fmas) bind(C, name='fftwf_flops') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p real(kind=C_DOUBLE), intent(out) :: add real(kind=C_DOUBLE), intent(out) :: mul real(kind=C_DOUBLE), intent(out) :: fmas interface private  subroutine fftwf_forget_wisdom() bind(C, name='fftwf_forget_wisdom') Arguments None interface private  subroutine fftwf_fprint_plan(p, output_file) bind(C, name='fftwf_fprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p type(C_PTR), value :: output_file interface private  subroutine fftwf_free(p) bind(C, name='fftwf_free') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  function fftwf_import_system_wisdom() bind(C, name='fftwf_import_system_wisdom') Arguments None Return Value integer(kind=c_int) interface private  function fftwf_import_wisdom(read_char, data) bind(C, name='fftwf_import_wisdom') Arguments Type Intent Optional Attributes Name type(C_FUNPTR), value :: read_char type(C_PTR), value :: data Return Value integer(kind=c_int) interface private  function fftwf_import_wisdom_from_file(input_file) bind(C, name='fftwf_import_wisdom_from_file') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: input_file Return Value integer(kind=c_int) interface private  function fftwf_import_wisdom_from_filename(filename) bind(C, name='fftwf_import_wisdom_from_filename') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: filename Return Value integer(kind=c_int) interface private  function fftwf_import_wisdom_from_string(input_string) bind(C, name='fftwf_import_wisdom_from_string') Arguments Type Intent Optional Attributes Name character(len=C_CHAR), intent(in), dimension(*) :: input_string Return Value integer(kind=c_int) interface private  function fftwf_init_threads() bind(C, name='fftwf_init_threads') Arguments None Return Value integer(kind=c_int) interface private  subroutine fftwf_make_planner_thread_safe() bind(C, name='fftwf_make_planner_thread_safe') Arguments None interface private  function fftwf_malloc(n) bind(C, name='fftwf_malloc') Arguments Type Intent Optional Attributes Name integer(kind=C_SIZE_T), value :: n Return Value type(c_ptr) interface private  function fftwf_plan_dft(rank, n, in, out, sign, flags) bind(C, name='fftwf_plan_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_1d(n, in, out, sign, flags) bind(C, name='fftwf_plan_dft_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_2d(n0, n1, in, out, sign, flags) bind(C, name='fftwf_plan_dft_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_3d(n0, n1, n2, in, out, sign, flags) bind(C, name='fftwf_plan_dft_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_c2r(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_c2r_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_c2r_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_c2r_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_c2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_r2c(rank, n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_r2c_1d(n, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_r2c_2d(n0, n1, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_dft_r2c_3d(n0, n1, n2, in, out, flags) bind(C, name='fftwf_plan_dft_r2c_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru64_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru64_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru64_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru64_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru64_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru64_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim64 ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim64 ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_dft(rank, dims, howmany_rank, howmany_dims, in, out, sign, flags) bind(C, name='fftwf_plan_guru_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_dft_c2r(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, out, flags) bind(C, name='fftwf_plan_guru_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_r2r(rank, dims, howmany_rank, howmany_dims, in, out, kind, flags) bind(C, name='fftwf_plan_guru_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_split_dft(rank, dims, howmany_rank, howmany_dims, ri, ii, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_split_dft_c2r(rank, dims, howmany_rank, howmany_dims, ri, ii, out, flags) bind(C, name='fftwf_plan_guru_split_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: ri real(kind=C_FLOAT), intent(out), dimension(*) :: ii real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_guru_split_dft_r2c(rank, dims, howmany_rank, howmany_dims, in, ro, io, flags) bind(C, name='fftwf_plan_guru_split_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank type( fftwf_iodim ), intent(in), dimension(*) :: dims integer(kind=C_INT), value :: howmany_rank type( fftwf_iodim ), intent(in), dimension(*) :: howmany_dims real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: ro real(kind=C_FLOAT), intent(out), dimension(*) :: io integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_many_dft(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, sign, flags) bind(C, name='fftwf_plan_many_dft') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: sign integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_many_dft_c2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_c2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_many_dft_r2c(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, flags) bind(C, name='fftwf_plan_many_dft_r2c') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist complex(kind=C_FLOAT_COMPLEX), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_many_r2r(rank, n, howmany, in, inembed, istride, idist, out, onembed, ostride, odist, kind, flags) bind(C, name='fftwf_plan_many_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n integer(kind=C_INT), value :: howmany real(kind=C_FLOAT), intent(out), dimension(*) :: in integer(kind=C_INT), intent(in), dimension(*) :: inembed integer(kind=C_INT), value :: istride integer(kind=C_INT), value :: idist real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_INT), intent(in), dimension(*) :: onembed integer(kind=C_INT), value :: ostride integer(kind=C_INT), value :: odist integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_r2r(rank, n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: rank integer(kind=C_INT), intent(in), dimension(*) :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), intent(in), dimension(*) :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_r2r_1d(n, in, out, kind, flags) bind(C, name='fftwf_plan_r2r_1d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_r2r_2d(n0, n1, in, out, kind0, kind1, flags) bind(C, name='fftwf_plan_r2r_2d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  function fftwf_plan_r2r_3d(n0, n1, n2, in, out, kind0, kind1, kind2, flags) bind(C, name='fftwf_plan_r2r_3d') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: n0 integer(kind=C_INT), value :: n1 integer(kind=C_INT), value :: n2 real(kind=C_FLOAT), intent(out), dimension(*) :: in real(kind=C_FLOAT), intent(out), dimension(*) :: out integer(kind=C_FFTW_R2R_KIND), value :: kind0 integer(kind=C_FFTW_R2R_KIND), value :: kind1 integer(kind=C_FFTW_R2R_KIND), value :: kind2 integer(kind=C_INT), value :: flags Return Value type(c_ptr) interface private  subroutine fftwf_plan_with_nthreads(nthreads) bind(C, name='fftwf_plan_with_nthreads') Arguments Type Intent Optional Attributes Name integer(kind=C_INT), value :: nthreads interface private  function fftwf_planner_nthreads() bind(C, name='fftwf_planner_nthreads') Arguments None Return Value integer(kind=c_int) interface private  subroutine fftwf_print_plan(p) bind(C, name='fftwf_print_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p interface private  subroutine fftwf_set_timelimit(t) bind(C, name='fftwf_set_timelimit') Arguments Type Intent Optional Attributes Name real(kind=C_DOUBLE), value :: t interface private  function fftwf_sprint_plan(p) bind(C, name='fftwf_sprint_plan') Arguments Type Intent Optional Attributes Name type(C_PTR), value :: p Return Value type(c_ptr) Derived Types type, private, bind(C) :: fftw_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: is integer(kind=C_INT), public :: n integer(kind=C_INT), public :: os type, private, bind(C) :: fftw_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: os type, private, bind(C) :: fftwf_iodim Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: is integer(kind=C_INT), public :: n integer(kind=C_INT), public :: os type, private, bind(C) :: fftwf_iodim64 Components Type Visibility Attributes Name Initial integer(kind=C_INTPTR_T), public :: is integer(kind=C_INTPTR_T), public :: n integer(kind=C_INTPTR_T), public :: os type, private :: tab_fftw Because FFTW3 is built so that it works on the same memory zone, for concurrent executions,\n  a zone per thread is created. Read more… Components Type Visibility Attributes Name Initial complex(kind=C_DOUBLE_COMPLEX), public, dimension(:,:), pointer :: tab type, private :: tab_fftw_real Because FFTW3 is built so that it works on the same memory zone, for concurrent executions,\n  a zone per thread is created. Read more… Components Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, dimension(:,:), pointer :: tab Subroutines private  subroutine alloc_fftw3 (long, larg) Allocation of the memory needed by the transformations, forward and backward. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension private  subroutine alloc_fftw3_real (long, larg) Allocation of the memory needed by the transformations, forward and backward, for the\n  real case. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine apod (tab_in, tab_out, long, larg, type_apo, param) Function that returns an apodized array. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in input array real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_out apodized array integer(kind=I4), intent(in) :: long 2D array length integer(kind=I4), intent(in) :: larg 2D array width character(len=*), intent(in) :: type_apo apodization type real(kind=R8), intent(in), optional :: param apodized array public  subroutine calc_fftw3 (sens, tab_in, tab_ou, long, larg) Subroutine that transforms forward or backward a double complex array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: sens =FORWARD or =BACKWARD complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine calc_fftw3_real_bwd (tab_in, tab_ou, long, larg, planner_flag) Subroutine that transforms backward a double real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in), optional :: planner_flag planning option, FFTW_ESTIMATE for example public  subroutine calc_fftw3_real_fwd (tab_in, tab_ou, long, larg, planner_flag) Subroutine that transforms forward a double real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in), optional :: planner_flag planning option, FFTW_ESTIMATE for example private  subroutine desalloc_fftw3 () When no more transformation is needed, the memory is released. 1 FFT distributed on several threads Read more… Arguments None private  subroutine destroy_plan_fftw3 () Plans are no more needed as no additional transformation will occur. 1 FFT distributed on several threads Arguments None public  subroutine end_fftw3 () FFTW3 is no more useful from here. 1 FFT distributed on several threads Arguments None public  subroutine extend (tab_in, tab_out, nx, ny, nx2, ny2, ext, type_apo) Function that extends an array for FFT processing. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:nx,  1:ny ) :: tab_in input array real(kind=R8), intent(out), dimension(1:nx2, 1:ny2) :: tab_out apodized array integer(kind=I4), intent(in) :: nx 2D input array length integer(kind=I4), intent(in) :: ny 2D input array width integer(kind=I4), intent(in) :: nx2 2D output array length integer(kind=I4), intent(in) :: ny2 2D output array width character(len=*), intent(in) :: ext extension character(len=*), intent(in), optional :: type_apo apodization type public  subroutine init_fftw3 (long, larg) Subroutine to initialize the FFTW3 process 1 FFT distributed on several threads .\nComplex case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine init_fftw3_real (long, larg, plan_flag) Subroutine to initialize the FFTW3 process 1 FFT distributed on several threads Real case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example private  subroutine make_plan_fftw3 (long, larg) Creates forward and backward plans. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension private  subroutine make_plan_fftw3_real (long, larg, plan_flag) Creates forward and backward plans. 1 FFT distributed on several threads Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example private  subroutine tab_alloc_fftw3 (long, larg) Allocation of the memory needed by the transformations, forward and backward. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension private  subroutine tab_alloc_fftw3_real (long, larg) Allocation of the memory needed by the transformations, forward and backward, for the\n  real case. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine tab_calc_fftw3 (sens, tab_in, tab_ou, long, larg) Subroutine that transforms forward or bacward a double complex array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: sens =FORWARD or =BACKWARD complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine tab_calc_fftw3_real_bwd (tab_in, tab_ou, long, larg) Subroutine that transforms backward a real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name complex(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform real(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension public  subroutine tab_calc_fftw3_real_fwd (tab_in, tab_ou, long, larg) Subroutine that transforms forward a real array. For speed reasons\n  FFTW will always work on the same memory area, until the plans are destroyed of course. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long, 1:larg) :: tab_in array to transform complex(kind=R8), intent(out), dimension(1:long, 1:larg) :: tab_ou transformed array integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension private  subroutine tab_desalloc_fftw3 () When no more transformation is needed, the memory is released. several FFT on single thread each Read more… Arguments None private  subroutine tab_destroy_plan_fftw3 () Plans are no more needed as no additional transformation will occur. several FFT on single thread each Arguments None public  subroutine tab_end_fftw3 () FFTW3 is no more useful from here. several FFT on single thread each Arguments None public  subroutine tab_end_fftw3_real () FFTW3 is no more useful from here. several FFT on single thread each Arguments None public  subroutine tab_init_fftw3 (long, larg, plan_flag) Subroutine to initialize the FFTW3 process several FFT on single thread each Complex case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example public  subroutine tab_init_fftw3_real (long, larg, plan_flag) Subroutine to initialize the FFTW3 process several FFT on single thread each Real case. Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example private  subroutine tab_make_plan_fftw3 (long, larg, plan_flag) Creates forward and backward plans. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example private  subroutine tab_make_plan_fftw3_real (long, larg, plan_flag) Creates forward and backward plans. several FFT on single thread each Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long first  2D array dimension integer(kind=I4), intent(in) :: larg second 2D array dimension integer(kind=I4), intent(in) :: plan_flag planning option, FFTW_ESTIMATE for example","tags":"","loc":"module/fftw3.html"},{"title":"intpl – TOOLIB","text":"Interpolation/weighting functions Uses data_arch module~~intpl~~UsesGraph module~intpl intpl module~data_arch data_arch module~intpl->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~intpl~~UsedByGraph module~intpl intpl program~test_intpl test_intpl program~test_intpl->module~intpl Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=R8), private, parameter :: ci1_00 = +1.0_R8/2.0_R8 real(kind=R8), private, parameter :: ci1_01 = +1.0_R8/2.0_R8 real(kind=R8), private, parameter :: ci3_00 = -1.0_R8/16.0_R8 real(kind=R8), private, parameter :: ci3_01 = +9.0_R8/16.0_R8 real(kind=R8), private, parameter :: ci3_02 = +9.0_R8/16.0_R8 real(kind=R8), private, parameter :: ci3_03 = -1.0_R8/16.0_R8 real(kind=R8), private, parameter :: ci5_00 = +3.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci5_01 = -25.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci5_02 = +150.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci5_03 = +150.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci5_04 = -25.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci5_05 = +3.0_R8/256.0_R8 real(kind=R8), private, parameter :: ci7_00 = -5.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_01 = +49.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_02 = -245.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_03 = +1225.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_04 = +1225.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_05 = -245.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_06 = +49.0_R8/2048.0_R8 real(kind=R8), private, parameter :: ci7_07 = -5.0_R8/2048.0_R8 real(kind=R8), private, parameter :: cp0_00 = +1.0_R8 real(kind=R8), private, parameter :: cp1_00 = +1.0_R8/4.0_R8 real(kind=R8), private, parameter :: cp1_01 = +2.0_R8/4.0_R8 real(kind=R8), private, parameter :: cp1_02 = +1.0_R8/4.0_R8 real(kind=R8), private, parameter :: cp3_00 = -1.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_01 = +0.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_02 = +9.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_03 = +16.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_04 = +9.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_05 = +0.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp3_06 = -1.0_R8/32.0_R8 real(kind=R8), private, parameter :: cp5_00 = +3.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_01 = +0.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_02 = -25.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_03 = +0.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_04 = +150.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_05 = +256.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_06 = +150.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_07 = +0.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_08 = -25.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_09 = +0.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp5_10 = +3.0_R8/512.0_R8 real(kind=R8), private, parameter :: cp7_00 = -5.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_01 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_02 = +49.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_03 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_04 = -245.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_05 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_06 = +1225.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_07 = +2048.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_08 = +1225.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_09 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_10 = -245.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_11 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_12 = +49.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_13 = +0.0_R8/4096.0_R8 real(kind=R8), private, parameter :: cp7_14 = -5.0_R8/4096.0_R8 Derived Types type, public :: tborne Components Type Visibility Attributes Name Initial integer(kind=I4), public :: lb1 lower bound 1 integer(kind=I4), public :: lb2 lower bound 2 integer(kind=I4), public :: ub1 upper bound 1 integer(kind=I4), public :: ub2 upper bound 2 Functions private  function interp (tab, lb, ind, ordre) Interpolate evenly spaced points Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb:) :: tab tableau 1D à interpoler integer(kind=I4), intent(in) :: lb borne inférieure integer(kind=4), intent(in) :: ind position de l’élément “milieu” integer(kind=4), intent(in) :: ordre ordre de l’interp 1, 3, 5 ou 7 Return Value real(kind=R8) valeur particulière interpolée private  function restrict (tab, lb, ind, ordre) Restrict evenly spaced points Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb:) :: tab tableau 1D à réduire integer(kind=4), intent(in) :: lb borne inférieure integer(kind=4), intent(in) :: ind position de l’élément “milieu” integer(kind=4), intent(in) :: ordre ordre de la restriction 1, 3, 5 ou 7 Return Value real(kind=R8) valeur particulière pondérée Subroutines private  subroutine genere_coeff_lagrange () subroutine generating coefficients for kth-order interpolation Arguments None public  subroutine interp1D (tabgros, lb_gros, tabfin, lb_fin, ub_gros, ordre) Interpolate evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb_gros:) :: tabgros tableau grossier à interpoler integer(kind=I4), intent(in) :: lb_gros indice inférieur real(kind=R8), intent(out), dimension(lb_fin :) :: tabfin tableau résultant, 2 fois plus fin integer(kind=I4), intent(in) :: lb_fin indice inférieur de tab_fin integer(kind=I4), intent(in) :: ub_gros taille de tabgros integer(kind=I4), intent(in) :: ordre ordre de l’interpolation public  subroutine interp2D (tabgro, bgro, tabfin, bfin, ordre) Interpolate 2D evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(bgro%lb1:bgro%ub1, bgro%lb2:bgro%ub2) :: tabgro tableau grossier départ type( tborne ), intent(in) :: bgro indices des tableaux real(kind=R8), intent(out), dimension(bfin%lb1:bfin%ub1, bfin%lb2:bfin%ub2) :: tabfin tableau résultant fin type( tborne ), intent(in) :: bfin indices des tableaux integer(kind=I4), intent(in) :: ordre ordre de l’interpolation public  subroutine restrict1D (tabfin, lb_fin, tabgros, lb_gros, ub_gros, ordre) Restrict evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(lb_fin:) :: tabfin tableau de départ integer(kind=I4), intent(in) :: lb_fin indice inférieur de tab_fin real(kind=R8), intent(out), dimension(lb_gros:) :: tabgros tableau grossier résultant integer(kind=I4), intent(in) :: lb_gros indice inférieur integer(kind=I4), intent(in) :: ub_gros taille de tabgros integer(kind=I4), intent(in) :: ordre ordre de la restriction public  subroutine restrict2D (tabfin, bfin, tabgros, bgros, ordre) Interpolate 2D evenly spaced points, taking into account the borders Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension( bfin%lb1: bfin%ub1,  bfin%lb2: bfin%ub2) :: tabfin tableau de départ fin type( tborne ), intent(in) :: bfin indices des tableaux real(kind=R8), intent(out), dimension(bgros%lb1:bgros%ub1, bgros%lb2:bgros%ub2) :: tabgros tableau grossier résultant type( tborne ), intent(in) :: bgros indices des tableaux integer(kind=I4), intent(in) :: ordre ordre de l’interpolation","tags":"","loc":"module/intpl.html"},{"title":"mumfpack – TOOLIB","text":"Note UMFPACK Fortran interface via the mUMFPACK module\nVersion 1.0 (Apr 23, 2014) for UMFPACK version 5.6.2\nCompile with any Fortran compiler with support of iso_c_binding module\nand link with the UMFPACK C library:\ne.g., gfortran umfpack.f90 my_code.f90 -lumfpack Uses iso_c_binding module~~mumfpack~~UsesGraph module~mumfpack mumfpack iso_c_binding iso_c_binding module~mumfpack->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mumfpack~~UsedByGraph module~mumfpack mumfpack module~solver solver module~solver->module~mumfpack program~test_solvers test_solvers program~test_solvers->module~solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: UMFPACK_CONTROL = 20 character(len=79), public, parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character(len=12), public, parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer, public, parameter :: UMFPACK_INFO = 90 integer, public, parameter :: UMFPACK_MAIN_VERSION = 5 integer, public, parameter :: UMFPACK_SUBSUB_VERSION = 2 integer, public, parameter :: UMFPACK_SUB_VERSION = 6 character(len=30), public, parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" integer, private, parameter :: i4 = 4 integer, private, parameter :: i8 = 8 type(c_ptr), private :: iNumeric = c_null_ptr type(c_ptr), private :: iSymbolic = c_null_ptr integer, private, parameter :: ip = c_intptr_t integer, private, parameter :: r4 = 4 integer, private, parameter :: r8 = 8 Enumerations enum, bind(c) Enumerators enumerator :: UMFPACK_STATUS = 0 enumerator :: UMFPACK_NROW = 1 enumerator :: UMFPACK_NCOL = 16 enumerator :: UMFPACK_NZ = 2 enumerator :: UMFPACK_SIZE_OF_UNIT = 3 enumerator :: UMFPACK_SIZE_OF_INT = 4 enumerator :: UMFPACK_SIZE_OF_LONG = 5 enumerator :: UMFPACK_SIZE_OF_POINTER = 6 enumerator :: UMFPACK_SIZE_OF_ENTRY = 7 enumerator :: UMFPACK_NDENSE_ROW = 8 enumerator :: UMFPACK_NEMPTY_ROW = 9 enumerator :: UMFPACK_NDENSE_COL = 10 enumerator :: UMFPACK_NEMPTY_COL = 11 enumerator :: UMFPACK_SYMBOLIC_DEFRAG = 12 enumerator :: UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 enumerator :: UMFPACK_SYMBOLIC_SIZE = 14 enumerator :: UMFPACK_SYMBOLIC_TIME = 15 enumerator :: UMFPACK_SYMBOLIC_WALLTIME = 17 enumerator :: UMFPACK_STRATEGY_USED = 18 enumerator :: UMFPACK_ORDERING_USED = 19 enumerator :: UMFPACK_QFIXED = 31 enumerator :: UMFPACK_DIAG_PREFERRED = 32 enumerator :: UMFPACK_PATTERN_SYMMETRY = 33 enumerator :: UMFPACK_NZ_A_PLUS_AT = 34 enumerator :: UMFPACK_NZDIAG = 35 enumerator :: UMFPACK_SYMMETRIC_LUNZ = 36 enumerator :: UMFPACK_SYMMETRIC_FLOPS = 37 enumerator :: UMFPACK_SYMMETRIC_NDENSE = 38 enumerator :: UMFPACK_SYMMETRIC_DMAX = 39 enumerator :: UMFPACK_COL_SINGLETONS = 56 enumerator :: UMFPACK_ROW_SINGLETONS = 57 enumerator :: UMFPACK_N2 = 58 enumerator :: UMFPACK_S_SYMMETRIC = 59 enumerator :: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 enumerator :: UMFPACK_PEAK_MEMORY_ESTIMATE = 21 enumerator :: UMFPACK_FLOPS_ESTIMATE = 22 enumerator :: UMFPACK_LNZ_ESTIMATE = 23 enumerator :: UMFPACK_UNZ_ESTIMATE = 24 enumerator :: UMFPACK_VARIABLE_INIT_ESTIMATE = 25 enumerator :: UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 enumerator :: UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 enumerator :: UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 enumerator :: UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 enumerator :: UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 enumerator :: UMFPACK_NUMERIC_SIZE = 40 enumerator :: UMFPACK_PEAK_MEMORY = 41 enumerator :: UMFPACK_FLOPS = 42 enumerator :: UMFPACK_LNZ = 43 enumerator :: UMFPACK_UNZ = 44 enumerator :: UMFPACK_VARIABLE_INIT = 45 enumerator :: UMFPACK_VARIABLE_PEAK = 46 enumerator :: UMFPACK_VARIABLE_FINAL = 47 enumerator :: UMFPACK_MAX_FRONT_SIZE = 48 enumerator :: UMFPACK_MAX_FRONT_NROWS = 49 enumerator :: UMFPACK_MAX_FRONT_NCOLS = 50 enumerator :: UMFPACK_NUMERIC_DEFRAG = 60 enumerator :: UMFPACK_NUMERIC_REALLOC = 61 enumerator :: UMFPACK_NUMERIC_COSTLY_REALLOC = 62 enumerator :: UMFPACK_COMPRESSED_PATTERN = 63 enumerator :: UMFPACK_LU_ENTRIES = 64 enumerator :: UMFPACK_NUMERIC_TIME = 65 enumerator :: UMFPACK_UDIAG_NZ = 66 enumerator :: UMFPACK_RCOND = 67 enumerator :: UMFPACK_WAS_SCALED = 68 enumerator :: UMFPACK_RSMIN = 69 enumerator :: UMFPACK_RSMAX = 70 enumerator :: UMFPACK_UMIN = 71 enumerator :: UMFPACK_UMAX = 72 enumerator :: UMFPACK_ALLOC_INIT_USED = 73 enumerator :: UMFPACK_FORCED_UPDATES = 74 enumerator :: UMFPACK_NUMERIC_WALLTIME = 75 enumerator :: UMFPACK_NOFF_DIAG = 76 enumerator :: UMFPACK_ALL_LNZ = 77 enumerator :: UMFPACK_ALL_UNZ = 78 enumerator :: UMFPACK_NZDROPPED = 79 enumerator :: UMFPACK_IR_TAKEN = 80 enumerator :: UMFPACK_IR_ATTEMPTED = 81 enumerator :: UMFPACK_OMEGA1 = 82 enumerator :: UMFPACK_OMEGA2 = 83 enumerator :: UMFPACK_SOLVE_FLOPS = 84 enumerator :: UMFPACK_SOLVE_TIME = 85 enumerator :: UMFPACK_SOLVE_WALLTIME = 86 enum, bind(c) Enumerators enumerator :: UMFPACK_PRL = 0 enumerator :: UMFPACK_DENSE_ROW = 1 enumerator :: UMFPACK_DENSE_COL = 2 enumerator :: UMFPACK_BLOCK_SIZE = 4 enumerator :: UMFPACK_STRATEGY = 5 enumerator :: UMFPACK_ORDERING = 10 enumerator :: UMFPACK_FIXQ = 13 enumerator :: UMFPACK_AMD_DENSE = 14 enumerator :: UMFPACK_AGGRESSIVE = 19 enumerator :: UMFPACK_SINGLETONS = 11 enumerator :: UMFPACK_PIVOT_TOLERANCE = 3 enumerator :: UMFPACK_ALLOC_INIT = 6 enumerator :: UMFPACK_SYM_PIVOT_TOLERANCE = 15 enumerator :: UMFPACK_SCALE = 16 enumerator :: UMFPACK_FRONT_ALLOC_INIT = 17 enumerator :: UMFPACK_DROPTOL = 18 enumerator :: UMFPACK_IRSTEP = 7 enumerator :: UMFPACK_COMPILED_WITH_BLAS = 8 enum, bind(c) Enumerators enumerator :: UMFPACK_STRATEGY_AUTO = 0 enumerator :: UMFPACK_STRATEGY_UNSYMMETRIC = 1 enumerator :: UMFPACK_STRATEGY_OBSOLETE = 2 enumerator :: UMFPACK_STRATEGY_SYMMETRIC = 3 enum, bind(c) Enumerators enumerator :: UMFPACK_SCALE_NONE = 0 enumerator :: UMFPACK_SCALE_SUM = 1 enumerator :: UMFPACK_SCALE_MAX = 2 enum, bind(c) Enumerators enumerator :: UMFPACK_ORDERING_CHOLMOD = 0 enumerator :: UMFPACK_ORDERING_AMD = 1 enumerator :: UMFPACK_ORDERING_GIVEN = 2 enumerator :: UMFPACK_ORDERING_METIS = 3 enumerator :: UMFPACK_ORDERING_BEST = 4 enumerator :: UMFPACK_ORDERING_NONE = 5 enumerator :: UMFPACK_ORDERING_USER = 6 enum, bind(c) Enumerators enumerator :: UMFPACK_OK = 0 enumerator :: UMFPACK_WARNING_singular_matrix = 1 enumerator :: UMFPACK_WARNING_determinant_underflow = 2 enumerator :: UMFPACK_WARNING_determinant_overflow = 3 enumerator :: UMFPACK_ERROR_out_of_memory = -1 enumerator :: UMFPACK_ERROR_invalid_Numeric_object = -3 enumerator :: UMFPACK_ERROR_invalid_Symbolic_object = -4 enumerator :: UMFPACK_ERROR_argument_missing = -5 enumerator :: UMFPACK_ERROR_n_nonpositive = -6 enumerator :: UMFPACK_ERROR_invalid_matrix = -8 enumerator :: UMFPACK_ERROR_different_pattern = -11 enumerator :: UMFPACK_ERROR_invalid_system = -13 enumerator :: UMFPACK_ERROR_invalid_permutation = -15 enumerator :: UMFPACK_ERROR_internal_error = -911 enumerator :: UMFPACK_ERROR_file_IO = -17 enumerator :: UMFPACK_ERROR_ordering_failed = -18 enum, bind(c) Enumerators enumerator :: UMFPACK_A = 0 enumerator :: UMFPACK_At = 1 enumerator :: UMFPACK_Aat = 2 enumerator :: UMFPACK_Pt_L = 3 enumerator :: UMFPACK_L = 4 enumerator :: UMFPACK_Lt_P = 5 enumerator :: UMFPACK_Lat_P = 6 enumerator :: UMFPACK_Lt = 7 enumerator :: UMFPACK_Lat = 8 enumerator :: UMFPACK_U_Qt = 9 enumerator :: UMFPACK_U = 10 enumerator :: UMFPACK_Q_Ut = 11 enumerator :: UMFPACK_Q_Uat = 12 enumerator :: UMFPACK_Ut = 13 enumerator :: UMFPACK_Uat = 14 Interfaces interface public  subroutine c_umfpack_di_defaults(Control) bind(c,name='umfpack_di_defaults') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public  subroutine c_umfpack_di_free_numeric(Numeric) bind(c,name='umfpack_di_free_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public  subroutine c_umfpack_di_free_symbolic(Symbolic) bind(c,name='umfpack_di_free_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public  function c_umfpack_di_load_numeric(Numeric, filename) bind(c,name='umfpack_di_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_di_load_symbolic(Symbolic, filename) bind(c,name='umfpack_di_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_di_numeric(Ap, Ai, Ax, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_di_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public  subroutine c_umfpack_di_report_control(Control) bind(c,name='umfpack_di_report_control') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public  subroutine c_umfpack_di_report_info(Control, Info) bind(c,name='umfpack_di_report_info') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info interface public  function c_umfpack_di_report_numeric(Numeric, Control) bind(c,name='umfpack_di_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public  subroutine c_umfpack_di_report_status(Control, status) bind(c,name='umfpack_di_report_status') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public  function c_umfpack_di_report_symbolic(Symbolic, Control) bind(c,name='umfpack_di_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public  function c_umfpack_di_save_numeric(Numeric, filename) bind(c,name='umfpack_di_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_di_save_symbolic(Symbolic, filename) bind(c,name='umfpack_di_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_di_scale(X, B, Numeric) bind(c,name='umfpack_di_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public  function c_umfpack_di_solve(sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) bind(c,name='umfpack_di_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), value :: X type(c_ptr), intent(in), value :: B type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public  function c_umfpack_di_symbolic(n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) bind(c,name='umfpack_di_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public  subroutine c_umfpack_zi_defaults(Control) bind(c,name='umfpack_zi_defaults') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public  subroutine c_umfpack_zi_free_numeric(Numeric) bind(c,name='umfpack_zi_free_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric interface public  subroutine c_umfpack_zi_free_symbolic(Symbolic) bind(c,name='umfpack_zi_free_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic interface public  function c_umfpack_zi_load_numeric(Numeric, filename) bind(c,name='umfpack_zi_load_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_zi_load_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_load_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_zi_numeric(Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) bind(c,name='umfpack_zi_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), intent(in), value :: Symbolic type(c_ptr) :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public  subroutine c_umfpack_zi_report_control(Control) bind(c,name='umfpack_zi_report_control') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control interface public  subroutine c_umfpack_zi_report_info(Control, Info) bind(c,name='umfpack_zi_report_info') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control type(c_ptr), value :: Info interface public  function c_umfpack_zi_report_numeric(Numeric, Control) bind(c,name='umfpack_zi_report_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public  subroutine c_umfpack_zi_report_status(Control, status) bind(c,name='umfpack_zi_report_status') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Control integer(kind=c_int), value :: status interface public  function c_umfpack_zi_report_symbolic(Symbolic, Control) bind(c,name='umfpack_zi_report_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic type(c_ptr), value :: Control Return Value integer(kind=c_int) interface public  function c_umfpack_zi_save_numeric(Numeric, filename) bind(c,name='umfpack_zi_save_numeric') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Numeric character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_zi_save_symbolic(Symbolic, filename) bind(c,name='umfpack_zi_save_symbolic') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Symbolic character(kind=c_char, len=1) :: filename (*) Return Value integer(kind=c_int) interface public  function c_umfpack_zi_scale(Xx, Xz, Bx, Bz, Numeric) bind(c,name='umfpack_zi_scale') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric Return Value integer(kind=c_int) interface public  function c_umfpack_zi_solve(sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) bind(c,name='umfpack_zi_solve') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: sys type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr), value :: Xx type(c_ptr), value :: Xz type(c_ptr), intent(in), value :: Bx type(c_ptr), intent(in), value :: Bz type(c_ptr), intent(in), value :: Numeric type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) interface public  function c_umfpack_zi_symbolic(n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) bind(c,name='umfpack_zi_symbolic') Arguments Type Intent Optional Attributes Name integer(kind=c_int), value :: n_row integer(kind=c_int), value :: n_col type(c_ptr), intent(in), value :: Ap type(c_ptr), intent(in), value :: Ai type(c_ptr), intent(in), value :: Ax type(c_ptr), intent(in), value :: Az type(c_ptr) :: Symbolic type(c_ptr), value :: Control type(c_ptr), value :: Info Return Value integer(kind=c_int) public        interface operator(.umfpack.) public  function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public        interface pCSC public  function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public  function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public  function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public        interface pCSR public  function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public  function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public  function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public        interface pVec public  function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) public        interface s_umfpack_defaults public  subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public        interface s_umfpack_di_defaults public  subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public        interface s_umfpack_di_free_numeric public  subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public        interface s_umfpack_di_free_symbolic public  subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public        interface s_umfpack_di_report_control public  subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public        interface s_umfpack_di_report_info public  subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public        interface s_umfpack_free_numeric public  subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public        interface s_umfpack_free_symbolic public  subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public        interface s_umfpack_numeric public  subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_numeric () Arguments None public  subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface s_umfpack_report_control public  subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public        interface s_umfpack_report_info public  subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public        interface s_umfpack_scale public  subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public  interface s_umfpack_zi_scale () Arguments None public  subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public        interface s_umfpack_solve public  subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_solve () Arguments None public  subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface s_umfpack_symbolic public  subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  interface s_umfpack_zi_symbolic () Arguments None public  subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface s_umfpack_zi_defaults public  subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public        interface s_umfpack_zi_free_numeric public  subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public        interface s_umfpack_zi_free_symbolic public  subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public        interface s_umfpack_zi_numeric public  interface s_umfpack_zi_numeric () Arguments None public  subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface s_umfpack_zi_report_control public  subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public        interface s_umfpack_zi_report_info public  subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public        interface s_umfpack_zi_scale public  interface s_umfpack_zi_scale () Arguments None public  subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public        interface s_umfpack_zi_solve public  interface s_umfpack_zi_solve () Arguments None public  subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface s_umfpack_zi_symbolic public  interface s_umfpack_zi_symbolic () Arguments None public  subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public        interface umf4cfnum public  interface umf4cfnum () Arguments None public  subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public        interface umf4cfsym public  interface umf4cfsym () Arguments None public  subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public        interface umf4clnum public  interface umf4clnum () Arguments None public  subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4clsym public  interface umf4clsym () Arguments None public  subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4cnum public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4cscal public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public        interface umf4csnum public  interface umf4csnum () Arguments None public  subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4csol public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4csolr public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4cssym public  interface umf4cssym () Arguments None public  subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4csym public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4fnum public  interface umf4fnum () Arguments None public  subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public        interface umf4fsym public  interface umf4fsym () Arguments None public  subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public        interface umf4lnum public  interface umf4lnum () Arguments None public  subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4lsym public  interface umf4lsym () Arguments None public  subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4num public  interface umf4num () Arguments None public  subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4znum () Arguments None public  subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4scal public  interface umf4scal () Arguments None public  subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4zscal () Arguments None public  subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public        interface umf4snum public  interface umf4snum () Arguments None public  subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4sol public  interface umf4sol () Arguments None public  subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsol () Arguments None public  subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4solr public  interface umf4solr () Arguments None public  subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsolr () Arguments None public  subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4ssym public  interface umf4ssym () Arguments None public  subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4sym public  interface umf4sym () Arguments None public  subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4zsym () Arguments None public  subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4zfnum public  interface umf4zfnum () Arguments None public  subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public        interface umf4zfsym public  interface umf4zfsym () Arguments None public  subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public        interface umf4zlnum public  interface umf4zlnum () Arguments None public  subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4zlsym public  interface umf4zlsym () Arguments None public  subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4znum public  interface umf4znum () Arguments None public  subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4cnum () Arguments None public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4zscal public  interface umf4zscal () Arguments None public  subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  interface umf4cscal () Arguments None public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public        interface umf4zsnum public  interface umf4zsnum () Arguments None public  subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4zsol public  interface umf4zsol () Arguments None public  subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csol () Arguments None public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4zsolr public  interface umf4zsolr () Arguments None public  subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csolr () Arguments None public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umf4zssym public  interface umf4zssym () Arguments None public  subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public        interface umf4zsym public  interface umf4zsym () Arguments None public  subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  interface umf4csym () Arguments None public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public        interface umfpack_numeric public  function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_numeric () Arguments None public  function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public        interface umfpack_scale_function public  function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public  interface umfpack_zi_scale () Arguments None public  function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public        interface umfpack_solve public  function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_solve () Arguments None public  function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public        interface umfpack_symbolic public  function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  interface umfpack_zi_symbolic () Arguments None public  function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public        interface umfpack_zi_numeric public  interface umfpack_zi_numeric () Arguments None public  function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public        interface umfpack_zi_scale public  interface umfpack_zi_scale () Arguments None public  function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public        interface umfpack_zi_solve public  interface umfpack_zi_solve () Arguments None public  function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public        interface umfpack_zi_symbolic public  interface umfpack_zi_symbolic () Arguments None public  function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Derived Types type, public :: pCSC_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pCSC_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSC_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pCSR_ci Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) complex(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_di Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) type, public :: pCSR_zi Components Type Visibility Attributes Name Initial integer, public, pointer :: Ai (:) integer, public, pointer :: Ap (:) real(kind=r8), public, pointer :: Ax (:) real(kind=r8), public, pointer :: Az (:) type, public :: pVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, pointer :: x (:) real(kind=r8), public, pointer :: z (:) type, public :: tCSC_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tCSC_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSC_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tCSR_ci Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) complex(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_di Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) type, public :: tCSR_zi Components Type Visibility Attributes Name Initial integer, public, allocatable :: Ai (:) integer, public, allocatable :: Ap (:) real(kind=r8), public, allocatable :: Ax (:) real(kind=r8), public, allocatable :: Az (:) type, public :: tVec_zi Components Type Visibility Attributes Name Initial real(kind=r8), public, allocatable :: x (:) real(kind=r8), public, allocatable :: z (:) Functions public  function make_CSC_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_ci ) public  function make_CSC_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSC_di ) public  function make_CSC_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSC_zi ) public  function make_CSR_ci (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) complex(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_ci ) public  function make_CSR_di (Ap, Ai, Ax) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) Return Value type( pCSR_di ) public  function make_CSR_zi (Ap, Ai, Ax, Az) result(result) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (:) integer, intent(in), target :: Ai (:) real(kind=r8), intent(in), target :: Ax (:) real(kind=r8), intent(in), target :: Az (:) Return Value type( pCSR_zi ) public  function make_Vec_zi (bx, bz) result(result) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(in), target :: bx (:) real(kind=r8), intent(in), target :: bz (:) Return Value type( pVec_zi ) public  function umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_ci_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_ci_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_ci_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_ci_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_ci ), intent(in) :: A complex(kind=c_double), intent(in) :: B (*) Return Value complex(kind=c_double), (size(A%Ap)-1) public  function umfpack_ci_scale (Xx, Bx, Numeric) Arguments Type Intent Optional Attributes Name complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public  function umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) complex(kind=r8), intent(in), optional, target :: Ax (*) complex(kind=r8), target :: Xx (*) complex(kind=r8), intent(in), target :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) complex(kind=r8), intent(in), target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_di_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public  function umfpack_di_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public  function umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_di_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (*) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_di ), intent(in) :: A real(kind=c_double), intent(in) :: B (:) Return Value real(kind=c_double), (size(A%Ap)-1) public  function umfpack_di_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public  function umfpack_di_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public  function umfpack_di_scale (X, B, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public  function umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), target :: X (*) real(kind=r8), intent(in), target :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_load_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public  function umfpack_load_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public  function umfpack_save_numeric (Numeric, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public  function umfpack_save_symbolic (Symbolic, filename, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename character(len=*), optional :: version Return Value integer public  function umfpack_zi_load_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public  function umfpack_zi_load_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public  function umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_zi_operator_CSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSC_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_zi_operator_CSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( tCSR_zi ), intent(in) :: A type( tVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_zi_operator_pCSC (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSC_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_zi_operator_pCSR (A, B) result(X) Arguments Type Intent Optional Attributes Name type( pCSR_zi ), intent(in) :: A type( pVec_zi ), intent(in) :: B Return Value type( tVec_zi ) public  function umfpack_zi_save_numeric (Numeric, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename Return Value integer public  function umfpack_zi_save_symbolic (Symbolic, filename) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename Return Value integer public  function umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric) Arguments Type Intent Optional Attributes Name real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric Return Value integer public  function umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional, target :: Ap (*) integer, intent(in), optional, target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), intent(in), optional, target :: Az (*) real(kind=r8), target :: Xx (*) real(kind=r8), target :: Xz (*) real(kind=r8), intent(in), target :: Bx (*) real(kind=r8), intent(in), target :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer public  function umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in), target :: Ap (*) integer, intent(in), target :: Ai (*) real(kind=r8), intent(in), optional, target :: Ax (*) real(kind=r8), intent(in), target :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional, target :: Info (0:UMFPACK_INFO-1) Return Value integer Subroutines public  subroutine s_umfpack_ci_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_ci_scale (Xx, Bx, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public  subroutine s_umfpack_ci_solve (sys, Ap, Ai, Ax, Xx, Bx, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) complex(kind=r8), intent(in), optional :: Ax (*) complex(kind=r8), intent(out) :: Xx (*) complex(kind=r8), intent(in) :: Bx (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_ci_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_di_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_di_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_di_numeric (Ap, Ai, Ax, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_di_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_di_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_di_scale (X, B, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public  subroutine s_umfpack_di_solve (sys, Ap, Ai, Ax, X, B, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(out) :: X (*) real(kind=r8), intent(in) :: B (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_di_symbolic (n_row, n_col, Ap, Ai, Ax, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_load_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public  subroutine s_umfpack_load_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public  subroutine s_umfpack_save_numeric (Numeric, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public  subroutine s_umfpack_save_symbolic (Symbolic, filename, status, version) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status character(len=*), optional :: version public  subroutine s_umfpack_zi_load_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_zi_load_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_zi_numeric (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), intent(in), optional :: Symbolic type(c_ptr), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_zi_save_numeric (Numeric, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Numeric character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_zi_save_symbolic (Symbolic, filename, status) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: Symbolic character(len=*), intent(in) :: filename integer, optional :: status public  subroutine s_umfpack_zi_scale (Xx, Xz, Bx, Bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric integer, optional :: status public  subroutine s_umfpack_zi_solve (sys, Ap, Ai, Ax, Az, Xx, Xz, Bx, Bz, Numeric, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: sys integer, intent(in), optional :: Ap (*) integer, intent(in), optional :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in), optional :: Az (*) real(kind=r8), intent(out) :: Xx (*) real(kind=r8), intent(out) :: Xz (*) real(kind=r8), intent(in) :: Bx (*) real(kind=r8), intent(in) :: Bz (*) type(c_ptr), intent(in), optional :: Numeric real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine s_umfpack_zi_symbolic (n_row, n_col, Ap, Ai, Ax, Az, Symbolic, Control, Info, status) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n_row integer, intent(in) :: n_col integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in), optional :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr), optional :: Symbolic real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), optional :: Info (0:UMFPACK_INFO-1) integer, optional :: status public  subroutine umf4cdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4cfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public  subroutine umf4cfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public  subroutine umf4cfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public  subroutine umf4cfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public  subroutine umf4clnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4clnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4clsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4clsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4cnum (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4cnum_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4cpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4cpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4cscal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public  subroutine umf4cscal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  subroutine umf4csnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4csnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4csol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4csol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4csolr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4csolr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) complex(kind=r8), intent(out) :: x (*) complex(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4cssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4cssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4csym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4csym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) complex(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4def (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4fnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public  subroutine umf4fnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public  subroutine umf4fsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public  subroutine umf4fsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public  subroutine umf4lnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4lnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4lsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4lsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4num (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4num_ip (Ap, Ai, Ax, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4pcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4pinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4scal (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric integer, intent(out) :: status public  subroutine umf4scal_ip (x, b, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  subroutine umf4snum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4snum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4sol (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4sol_ip (sys, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4solr (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4solr_ip (sys, Ap, Ai, Ax, x, b, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(in) :: b (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4ssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4ssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4sym (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4sym_ip (m, n, Ap, Ai, Ax, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zdef (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4zfnum (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric public  subroutine umf4zfnum_ip (Numeric) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric public  subroutine umf4zfsym (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic public  subroutine umf4zfsym_ip (Symbolic) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic public  subroutine umf4zlnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zlnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zlsym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zlsym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4znum (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4znum_ip (Ap, Ai, Ax, Az, Symbolic, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zpcon (Control) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) public  subroutine umf4zpinf (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zscal (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric integer, intent(out) :: status public  subroutine umf4zscal_ip (x, xz, b, bz, Numeric, status) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric integer, intent(out) :: status public  subroutine umf4zsnum (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zsnum_ip (Numeric, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Numeric integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zsol (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zsol_ip (sys, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zsolr (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) type(c_ptr) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zsolr_ip (sys, Ap, Ai, Ax, Az, x, xz, b, bz, Numeric, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: sys integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) real(kind=r8), intent(out) :: x (*) real(kind=r8), intent(out) :: xz (*) real(kind=r8), intent(in) :: b (*) real(kind=r8), intent(in) :: bz (*) integer(kind=ip) :: Numeric real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zssym (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name type(c_ptr) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zssym_ip (Symbolic, filenum, status) Arguments Type Intent Optional Attributes Name integer(kind=ip) :: Symbolic integer, intent(in) :: filenum integer, intent(out) :: status public  subroutine umf4zsym (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) type(c_ptr) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umf4zsym_ip (m, n, Ap, Ai, Ax, Az, Symbolic, Control, Info) Arguments Type Intent Optional Attributes Name integer, intent(in) :: m integer, intent(in) :: n integer, intent(in) :: Ap (*) integer, intent(in) :: Ai (*) real(kind=r8), intent(in) :: Ax (*) real(kind=r8), intent(in) :: Az (*) integer(kind=ip) :: Symbolic real(kind=r8) :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) public  subroutine umfpack_defaults (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public  subroutine umfpack_di_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public  subroutine umfpack_di_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public  subroutine umfpack_di_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public  subroutine umfpack_di_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public  subroutine umfpack_di_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1) public  subroutine umfpack_free_numeric (Numeric, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric character(len=*), optional :: version public  subroutine umfpack_free_symbolic (Symbolic, version) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic character(len=*), optional :: version public  subroutine umfpack_report_control (Control, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) character(len=*), optional :: version public  subroutine umfpack_report_info (Control, Info, version) Arguments Type Intent Optional Attributes Name real(kind=r8), optional :: Control (0:UMFPACK_CONTROL-1) real(kind=r8) :: Info (0:UMFPACK_INFO-1) character(len=*), optional :: version public  subroutine umfpack_zi_defaults (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public  subroutine umfpack_zi_free_numeric (Numeric) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Numeric public  subroutine umfpack_zi_free_symbolic (Symbolic) Arguments Type Intent Optional Attributes Name type(c_ptr), optional :: Symbolic public  subroutine umfpack_zi_report_control (Control) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) public  subroutine umfpack_zi_report_info (Control, Info) Arguments Type Intent Optional Attributes Name real(kind=r8), optional, target :: Control (0:UMFPACK_CONTROL-1) real(kind=r8), target :: Info (0:UMFPACK_INFO-1)","tags":"","loc":"module/mumfpack.html"},{"title":"surfile – TOOLIB","text":"Routines to handle Digital Surf binary format (.sur) Uses sort_arrays iso_c_binding data_arch miscellaneous module~~surfile~~UsesGraph module~surfile surfile iso_c_binding iso_c_binding module~surfile->iso_c_binding module~data_arch data_arch module~surfile->module~data_arch module~miscellaneous miscellaneous module~surfile->module~miscellaneous module~sort_arrays sort_arrays module~surfile->module~sort_arrays iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch module~sort_arrays->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~surfile~~UsedByGraph module~surfile surfile program~test_surfile test_surfile program~test_surfile->module~surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=4), private, parameter :: SURF_DAT = 1 ‘.dat’ format, txt integer(kind=4), private, parameter :: SURF_SUR = 2 ‘.sur’ format, binary Derived Types type, public :: OBJ_SURF C like surface object: header and heights Read more… Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: XOffset real(kind=C_FLOAT), public :: YOffset real(kind=C_FLOAT), public :: ZOffset integer(kind=C_SHORT), public :: absolute integer(kind=C_SHORT), public :: acquisition character(kind=C_CHAR, len=1), public, dimension(128) :: client_zone integer(kind=C_SHORT), public :: comment_size integer(kind=C_SHORT), public :: day integer(kind=C_SHORT), public :: dayof real(kind=C_FLOAT), public :: dx character(kind=C_CHAR, len=1), public, dimension( 16) :: dx_unit real(kind=C_FLOAT), public :: dy character(kind=C_CHAR, len=1), public, dimension( 16) :: dy_unit real(kind=C_FLOAT), public :: dz character(kind=C_CHAR, len=1), public, dimension( 16) :: dz_unit integer(kind=C_SHORT), public :: format integer(kind=C_SHORT), public :: hours integer(kind=C_SHORT), public :: imprint integer(kind=C_SHORT), public :: inversion integer(kind=C_SHORT), public :: leveling integer(kind=C_SHORT), public :: material_code real(kind=C_FLOAT), public :: measurement_duration integer(kind=C_SHORT), public :: minutes integer(kind=C_SHORT), public :: month integer(kind=C_SHORT), public :: nobjects integer(kind=C_INT), public :: nofpoints character(kind=C_CHAR, len=1), public, dimension( 30) :: object_name character(kind=C_CHAR, len=1), public, dimension( 12) :: obsolete character(kind=C_CHAR, len=1), public, dimension( 10) :: obsolete2 character(kind=C_CHAR, len=1), public, dimension( 30) :: operator_name integer(kind=C_SHORT), public :: pointsize integer(kind=C_SHORT), public :: private_size integer(kind=C_SHORT), public :: range character(kind=C_CHAR, len=1), public, dimension(  8) :: reserved character(kind=C_CHAR, len=1), public, dimension( 34) :: reservedzone integer(kind=C_SHORT), public :: seconds character(kind=C_CHAR, len=1), public, dimension( 12) :: signature integer(kind=C_SHORT), public :: special_points integer(kind=C_SHORT), public :: type integer(kind=C_INT), public, allocatable :: val (:) heights integer(kind=C_SHORT), public :: version character(kind=C_CHAR, len=1), public, dimension( 16) :: xaxis character(kind=C_CHAR, len=1), public, dimension( 16) :: xlength_unit integer(kind=C_INT), public :: xres real(kind=C_FLOAT), public :: xunit_ratio character(kind=C_CHAR, len=1), public, dimension( 16) :: yaxis integer(kind=C_SHORT), public :: year character(kind=C_CHAR, len=1), public, dimension( 16) :: ylength_unit integer(kind=C_INT), public :: yres real(kind=C_FLOAT), public :: yunit_ratio character(kind=C_CHAR, len=1), public, dimension( 16) :: zaxis character(kind=C_CHAR, len=1), public, dimension( 16) :: zlength_unit integer(kind=C_INT), public :: zmax integer(kind=C_INT), public :: zmin real(kind=C_FLOAT), public :: zunit_ratio type, public :: SCALE_SURF Fortran typed surface object: header, dimensions, mean and std Read more… Components Type Visibility Attributes Name Initial real(kind=R4), public :: XOffset real(kind=R4), public :: YOffset real(kind=R4), public :: ZOffset integer(kind=2), public :: absolute integer(kind=2), public :: acquisition character(len=128), public :: client_zone integer(kind=2), public :: comment_size integer(kind=2), public :: day integer(kind=2), public :: dayof real(kind=R4), public :: dx character(len=16), public :: dx_unit real(kind=R4), public :: dy character(len=16), public :: dy_unit real(kind=R4), public :: dz character(len=16), public :: dz_unit integer(kind=2), public :: format integer(kind=2), public :: hours integer(kind=2), public :: imprint integer(kind=2), public :: inversion integer(kind=2), public :: leveling real(kind=R8), public :: lx surface length real(kind=R8), public :: ly surface width real(kind=R8), public :: lz surface height (max -min) integer(kind=2), public :: material_code real(kind=R4), public :: measurement_duration integer(kind=2), public :: minutes integer(kind=2), public :: month real(kind=R8), public :: mu surface mean height integer(kind=2), public :: nobjects integer(kind=I4), public :: nofpoints character(len=30), public :: object_name character(len=12), public :: obsolete character(len=10), public :: obsolete2 character(len=30), public :: operator_name integer(kind=2), public :: pointsize integer(kind=2), public :: private_size integer(kind=2), public :: range character(len=8), public :: reserved character(len=34), public :: reservedzone integer(kind=2), public :: seconds real(kind=R8), public :: si surface mean height character(len=12), public :: signature integer(kind=2), public :: special_points integer(kind=2), public :: type integer(kind=2), public :: version character(len=16), public :: xaxis character(len=16), public :: xlength_unit integer(kind=I4), public :: xres real(kind=R4), public :: xunit_ratio character(len=16), public :: yaxis integer(kind=2), public :: year character(len=16), public :: ylength_unit integer(kind=I4), public :: yres real(kind=R4), public :: yunit_ratio character(len=16), public :: zaxis character(len=16), public :: zlength_unit integer(kind=I4), public :: zmax integer(kind=I4), public :: zmin real(kind=R4), public :: zunit_ratio Functions private  function lower (s1) result(s2) Converts uppercase to lowercase, adapted from here Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s1 string to transform to lower case Return Value character(len=len(s1)) result: same string but each character is lower case public  function unit2IUc (string) result(met) Convert a C type unit string into value (m) Arguments Type Intent Optional Attributes Name character(kind=C_CHAR, len=1), intent(in), dimension(:) :: string Return Value real(kind=R8) public  function unit2IUf (string) result(met) Convert a unit string into value (m) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value real(kind=R8) Subroutines private  subroutine build_surf (surf, tab) Creates an object OBJ_SURF from an array Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf resulting object OBJ_SURF real(kind=R8), intent(in), dimension(1:surf%xres, 1:surf%yres) :: tab private  subroutine c_f_string (cs, fs, lngth_s) Converts a C string to a Fortran string Read more… Arguments Type Intent Optional Attributes Name character(kind=C_CHAR, len=1), intent(in), dimension(:) :: cs C string character(len=*), intent(out) :: fs Fortran string integer(kind=I4), intent(out) :: lngth_s resulting Fortran string length public  subroutine empty (charinout) Just empties a string Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: charinout private  subroutine f_c_string (fs, cs) Converts a Fortran string to a C string Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fs fortran string character(kind=C_CHAR, len=1), intent(out), dimension(:) :: cs resulting C string public  subroutine init_scal (scal, nx, ny, lx, ly, unit_z) OBJ_SURF initialization, every unit is m Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF integer(kind=I4), intent(in), optional :: nx integer(kind=I4), intent(in), optional :: ny real(kind=R8), intent(in), optional :: lx real(kind=R8), intent(in), optional :: ly character(len=*), intent(in), optional :: unit_z private  subroutine open_surffile (fichier, surf, scal, dump) Subroutine that opens a .sur file and transfers it contents into an object OBJ_SURF Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be read type( OBJ_SURF ), intent(out) :: surf object that will contain the file infos and heights type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF logical(kind=I4), intent(in), optional :: dump whether to transform the data in a text file public  subroutine read_surf (nom_fic, mu, sq, tab_s, scal) Subroutine that opens a surface file .sur or .dat Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), optional :: mu desired mean real(kind=R8), intent(in), optional :: sq desired height standard deviation real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF public  subroutine scal2surf (scal, surf) Transform a SCALE_SURF object into a OBJ_SURF object Arguments Type Intent Optional Attributes Name type( SCALE_SURF ), intent(in) :: scal object SCALE_SURF type( OBJ_SURF ), intent(out) :: surf object OBJ_SURF public  subroutine surf2scal (surf, scal) Transform a OBJ_SURF object into a SCALE_SURF object Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF type( SCALE_SURF ), intent(out) :: scal object SCALE_SURF private  subroutine trans_surf_tab (surf, tab) Write the heights of an OBJ_SURF object into a 2D array Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF that contains the heights real(kind=R8), intent(out), dimension(:, :), allocatable :: tab height array public  subroutine trans_surf_txt (surf, fichier, xyz) Writes an OBJ_SURF object in a text file Read more… Arguments Type Intent Optional Attributes Name type( OBJ_SURF ), intent(in) :: surf object OBJ_SURF character(len=*), intent(in) :: fichier text file to write logical(kind=I4), intent(in) :: xyz whether to also write the heights (maybe huge) public  subroutine write_surf (nom_fic, tab_s, scal) Writes a height array into a surface file .sur or .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:scal%xres, 1:scal%yres) :: tab_s type( SCALE_SURF ), intent(inout) :: scal object SCALE_SURF private  subroutine write_surffile (fichier, surf) Write an object OBJ_SURF in a file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fichier file to be written type( OBJ_SURF ), intent(inout) :: surf object OBJ_SURF to write","tags":"","loc":"module/surfile.html"},{"title":"tchebychev – TOOLIB","text":"Routines to subtract a least square polynomial from a surface Uses least_squares data_arch miscellaneous module~~tchebychev~~UsesGraph module~tchebychev tchebychev module~data_arch data_arch module~tchebychev->module~data_arch module~least_squares least_squares module~tchebychev->module~least_squares module~miscellaneous miscellaneous module~tchebychev->module~miscellaneous iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~least_squares->module~data_arch module~cholesky cholesky module~least_squares->module~cholesky module~miscellaneous->module~data_arch module~cholesky->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~tchebychev~~UsedByGraph module~tchebychev tchebychev program~test_tchebychev test_tchebychev program~test_tchebychev->module~tchebychev Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function tcheby (n, x) Valeur en x du polynôme de Tchebichev de degré n Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n degré du polynôme real(kind=R8), intent(in) :: x variable Return Value real(kind=R8) Subroutines public  subroutine coeff_poly_tcheby_xy_vers_poly_monome (var, coeff_m, deg_x, deg_y) Transformation d’une CL de produits de polynômes de Tchebychev en x et y en polynôme classique Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:(deg_x+1)*(deg_y+1)) :: var coefficients du produits de polynômes de Tchebychev real(kind=R8), intent(out), dimension(1:(deg_x+1)*(deg_y+1)) :: coeff_m coefficients du polynôme classique en x et y integer(kind=I4), intent(in) :: deg_x degré du polynôme en x integer(kind=I4), intent(in) :: deg_y degré du polynôme en y public  subroutine coeff_tcheby_vers_monome (coeff_t, coeff_m, deg) Transformation des coefficients de Tchebychev en coefficients de monômes Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(0:deg) :: coeff_t coefficients de la CL de polynômes de Tchebychev real(kind=R8), intent(out), dimension(0:deg) :: coeff_m coefficients de la CL de monômes integer(kind=I4), intent(in) :: deg degré du polynôme public  subroutine coeff_tcheby_xy_vers_monome (tab_coeff_m, deg_x, deg_y) Transformation du produit de Tchebychev en coefficients de monômes Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(0:deg_x, 0:deg_y) :: tab_coeff_m *coefficients de la CL de monômes integer(kind=I4), intent(in) :: deg_x *degré du polynôme en integer(kind=I4), intent(in) :: deg_y *degré du polynôme en public  subroutine least_squares_tcheby (tab_in, tab_out, long1, long2, nvarx, nvary, imask, verif, multi_thread) Resulting polynomial surface, determined by linear least squares Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:long1, 1:long2) :: tab_in surface dont on a fait une approximation qui lui est soustraite real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: nvarx degré du polynôme en x integer(kind=I4), intent(in) :: nvary degré du polynôme en y integer(kind=I4), intent(in), optional, dimension(1:long1, 1:long2) :: imask masque logical(kind=I4), intent(in), optional :: verif dump logical(kind=I4), intent(in), optional :: multi_thread use multithread? public  subroutine tab_Jf_tcheby (nx1, nx2, nb_pts, nvarx, nvary, nb_var, tab_tche1, tab_tche2, tab_Jf, imask, multi_thread) Tableau des dérivées par rapport aux coefficients de tab_tche Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx1 nbre de points de calcul selon x integer(kind=I4), intent(in) :: nx2 nbre de points de calcul selon y integer(kind=I4), intent(in) :: nb_pts nbre de points integer(kind=I4), intent(in) :: nvarx degré max de Tchebychev utilisé selon x integer(kind=I4), intent(in) :: nvary degré max de Tchebychev utilisé selon y integer(kind=I4), intent(in) :: nb_var nombre de fonctions de base utilisées real(kind=R8), intent(in), dimension(1:nx1, 1:nvarx+1) :: tab_tche1 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nx2, 1:nvary+1) :: tab_tche2 tableau des valeurs calculées real(kind=R8), intent(out), allocatable, dimension(:,:) :: tab_Jf tableau des dérivées integer(kind=I4), intent(in), optional, dimension(1:nx1, 1:nx2) :: imask masque logical(kind=I4), intent(in), optional :: multi_thread public  subroutine tab_poly_tcheby (nx1, nx2, nvarx, nvary, nb_var, tab_tche1, tab_tche2, var, tab_poly_tche, multi_thread) Surface définie par un produit de polynômes de Tchebychev en x et y Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx1 nbre de points de calcul selon x integer(kind=I4), intent(in) :: nx2 nbre de points de calcul selon y integer(kind=I4), intent(in) :: nvarx degré max de Tchebychev utilisé selon x integer(kind=I4), intent(in) :: nvary degré max de Tchebychev utilisé selon y integer(kind=I4), intent(in) :: nb_var nbre de coefficients real(kind=R8), intent(in), dimension(1:nx1, 1:nvarx+1) :: tab_tche1 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nx2, 1:nvary+1) :: tab_tche2 tableau des valeurs calculées real(kind=R8), intent(in), dimension(1:nb_var) :: var vecteur des coefficients real(kind=R8), intent(out), dimension(1:nx1, 1:nx2) :: tab_poly_tche tableau résultant : surface logical(kind=I4), intent(in), optional :: multi_thread public  subroutine tab_tcheby (deg, nx, vec_x, tab_tche) Valeurs tabulées de polynômes de Tchebychev Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: deg degré max du polynôme integer(kind=I4), intent(in) :: nx nbre de points de calcul real(kind=R8), intent(in), dimension(1:nx) :: vec_x vecteur des points de calcul real(kind=R8), intent(out), allocatable, dimension(:,:) :: tab_tche tableau des valeurs calculées","tags":"","loc":"module/tchebychev.html"},{"title":"cholesky – TOOLIB","text":"Cholesky decomposition and resolution Description The Cholesky decomposition is a method for solving systems of linear equations, particularly when the coefficient matrix is symmetric and positive definite. The method involves decomposing the matrix into a product of a lower triangular matrix and its transpose. More ... Here's a detailed description of the Cholesky method for solving the system  Ax = b . Decompose  A  Given a symmetric positive definite matrix  A , we can decompose it to find  L  in  A = L L&#94;T , where  L  is a lower triangular matrix. Forward Substitution Solve the system  Ly = b  for  y . This can be done using forward substitution since  L  is a lower triangular matrix.\n\n  y_1 = \\frac{b_1}{L_{11}} \\qquad y_2 = \\frac{b_2 - L_{21}y_1}{L_{22}} \\qquad y_3 = \\frac{b_3 - L_{31}y_1 - L_{32}y_2}{L_{33}}  \\ldots  Backward Substitution Once  y  is found, solve the system  L&#94;T x = y  for  x  using backward substitution since  L&#94;T  is an upper triangular matrix.\n\n  x_n = \\frac{y_n}{L_{nn}} \\qquad x_{n-1} = \\frac{y_{n-1} - L_{n-1,n}x_n}{L_{n-1,n-1}} \\qquad x_{n-2} = \\frac{y_{n-2} - L_{n-2,n-1}x_{n-1} - L_{n-2,n}x_n}{L_{n-2,n-2}}  \\ldots  Uses data_arch module~~cholesky~~UsesGraph module~cholesky cholesky module~data_arch data_arch module~cholesky->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~cholesky~~UsedByGraph module~cholesky cholesky module~least_squares least_squares module~least_squares->module~cholesky program~test_utils test_utils program~test_utils->module~cholesky module~tchebychev tchebychev module~tchebychev->module~least_squares program~test_least test_least program~test_least->module~least_squares program~test_tchebychev test_tchebychev program~test_tchebychev->module~tchebychev Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine choldc (a, n, np, p, info) Given a positive definite symmetric matrix a(1:n,1:n), with\n physical dimensions np, this routine constructs its Cholesky\n decomposition, A=L L&#94;T. On input, only the upper triangle of\n a need to be given; it is not modified. The Cholesky factor L\n is returned in the lower triangle of a, except for its diagonal\n elements which are returned in p(1:n). Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(np, np) :: a system matrix integer(kind=I4), intent(in) :: n system size integer(kind=I4), intent(in) :: np matrix size real(kind=R8), intent(out), dimension(np) :: p diagonal elements integer(kind=I4), intent(out) :: info information ouput public  subroutine cholsl (a, n, np, p, b, x, info) Solves the set of linear equations A x = b, where A is a positive-\n definite symmetric matrix with physical dimensions np. A and P are\n are input as the output from choldc. Only the lower triangle of A\n is accessed. B(1:n) is inout as the right-hand side vector. The\n solution vector is returned in X(1:n). A, n, np, and P are not\n modified and can be left in place for successive calls with different\n right-hand sides B. B is not modified unless you identify B and X in\n the calling sequence, which is allowed. Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(np, np) :: a system matrix integer(kind=I4), intent(in) :: n system size integer(kind=I4), intent(in) :: np matrix size real(kind=R8), intent(in), dimension(np) :: p diagonal elements real(kind=R8), intent(inout), dimension(np) :: b rhs real(kind=R8), intent(inout), dimension(np) :: x solution vector integer(kind=I4), intent(inout) :: info information ouput","tags":"","loc":"module/cholesky.html"},{"title":"sort_arrays – TOOLIB","text":"Various routines to sort real/integer arrays Uses data_arch module~~sort_arrays~~UsesGraph module~sort_arrays sort_arrays module~data_arch data_arch module~sort_arrays->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~sort_arrays~~UsedByGraph module~sort_arrays sort_arrays module~solver solver module~solver->module~sort_arrays module~surfile surfile module~surfile->module~sort_arrays program~main main program~main->module~sort_arrays program~test_algen test_algen program~test_algen->module~sort_arrays program~test_solvers test_solvers program~test_solvers->module~solver program~test_surfile test_surfile program~test_surfile->module~surfile Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private  subroutine change_array_order (tab_inout, order, n) Given an order vector, sort a real or integer vector Arguments Type Intent Optional Attributes Name class(*), intent(inout), dimension(n) :: tab_inout array to sort integer(kind=I4), intent(inout), dimension(n) :: order order vector integer(kind=I4), intent(in) :: n size of the arrays public  subroutine init_order (order, n) Vector initialization: 1 … n Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(out), dimension(n) :: order order vector integer(kind=I4), intent(in) :: n size of the vector public  subroutine sort_array2 (tab_inout, tab0, tab1, tab2, tab3, n) Sort 1D arrays, real or integer, according the first one Arguments Type Intent Optional Attributes Name class(*), intent(inout), dimension(n) :: tab_inout reference array to sort integer(kind=I4), intent(inout), optional, dimension(n) :: tab0 second array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab1 third array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab2 4th array to sort according the order of the first one class(*), intent(inout), optional, dimension(n) :: tab3 5th array to sort according the order of the first one integer(kind=I4), intent(in) :: n size of the arrays private recursive subroutine sort_array_integer (g, d, itabref) Sort a vector of integers Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index integer(kind=I4), intent(inout), dimension(:) :: itabref vector to sort private recursive subroutine sort_array_integer_with_order (g, d, itabref, order) Sort a vector of integers and store the order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index integer(kind=I4), intent(inout), dimension(:) :: itabref vector to sort integer(kind=I4), intent(inout), dimension(:) :: order sort order private recursive subroutine sort_array_real (g, d, rtabref) Sort a vector of reals Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index real(kind=R8), intent(inout), dimension(:) :: rtabref vector to sort private recursive subroutine sort_array_real_with_order (g, d, rtabref, order) Sort a vector of reals and store the order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: g left index integer(kind=I4), intent(in) :: d right index real(kind=R8), intent(inout), dimension(:) :: rtabref vector to sort integer(kind=I4), intent(inout), dimension(:) :: order sort order","tags":"","loc":"module/sort_arrays.html"},{"title":"gnufor – TOOLIB","text":"A fortran api to GNUPLOT Note GNUFOR makes it possible, while running a FORTRAN90 program on a UNIX system, to generate some data and request an immediate plot.\nThis is done by issuing a SYSTEM command that starts up GNUPLOT, and feeding it the appropriate commands and data.\nThe FORTRAN90 program pauses while the graph is displayed in an X window, and the user can admire the plots for a while,\nbefore hitting return and giving control back to the FORTRAN90 program. link Warning To use this program, the command “gnuplot” must be in your path. Used by module~~gnufor~~UsedByGraph module~gnufor gnufor program~test_gnufor test_gnufor program~test_gnufor->module~gnufor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private  function pi () PI returns the value of pi. Arguments None Return Value real Subroutines private  subroutine get_unit (iunit) GET_UNIT returns a free FORTRAN unit number. Arguments Type Intent Optional Attributes Name integer :: iunit public  subroutine run_gnuplot (command_file_name) RUN_GNUPLOT runs GNUPLOT with a given command file. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name public  subroutine test01 () TEST01 demonstrates the plotting of Y(X) data. Arguments None public  subroutine test02 () TEST02 demonstrates the plotting of a table of data. Arguments None public  subroutine test03 () TEST03 plots parameter (X,Y,Z) data. Arguments None public  subroutine test04 () TEST04 plots vector data. Arguments None public  subroutine test05 () TEST05 plots Z(X,Y) grid data as a surface. Arguments None public  subroutine test06 () TEST06 plots Z(X,Y) grid data as contours. Arguments None private  subroutine timestamp () TIMESTAMP prints the current YMDHMS date as a time stamp. Arguments None private  subroutine write_polar_data (data_file_name, n, x, y, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) integer :: ierror private  subroutine write_polar_plot (command_file_name, data_file_name, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror private  subroutine write_vector_data (data_file_name, n, x, y, dx, dy, ierror) WRITE_VECTOR_DATA writes vector data to a file, for plotting by GNUPLOT. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: dx (n) real :: dy (n) integer :: ierror private  subroutine write_vector_plot (command_file_name, data_file_name, ierror) WRITE_VECTOR_PLOT writes GNUPLOT commands to plot vectors. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror private  subroutine write_xy2_data (data_file_name, n, x, y, y2, ierror) Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: y2 (n) integer :: ierror private  subroutine write_xy2_plot (command_file_name, data_file_name, logscale, ierror, nom) Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name logical :: logscale integer :: ierror character(len=*) :: nom public  subroutine write_xy_data (data_file_name, n, x, y, ierror) WRITE_XY_DATA writes X(1:N), Y(1:N) data to a file. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) integer :: ierror public  subroutine write_xy_plot (command_file_name, data_file_name, logscale, ierror, nom) WRITE_XY_PLOT writes GNUPLOT commands to plot X(1:N), Y(1:N) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name logical :: logscale integer :: ierror character(len=*) :: nom public  subroutine write_xyy_data (data_file_name, lda, nrow, ncol, x, ierror) WRITE_XYY_DATA writes a table of data to a file, for plotting by GNUPLOT. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: lda integer :: nrow integer :: ncol real :: x (lda,ncol) integer :: ierror public  subroutine write_xyy_plots (command_file_name, data_file_name, add_lines, title, ncol, ierror) WRITE_XYY_PLOTS writes GNUPLOT commands to make multiple (X,Y) plots. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name character(len=*), optional :: add_lines character(len=*), dimension(1:ncol) :: title integer :: ncol integer :: ierror private  subroutine write_xyz_data (data_file_name, n, x, y, z, ierror) WRITE_XYZ_DATA writes X(1:N), Y(1:N), Z(1:N) data to a file. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: n real :: x (n) real :: y (n) real :: z (n) integer :: ierror private  subroutine write_xyz_plot (command_file_name, data_file_name, ierror) WRITE_XYZ_PLOT writes commands to plot parametric (X,Y,Z) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror private  subroutine write_xyzgrid_contour (command_file_name, data_file_name, ierror) WRITE_XYZGRID_CONTOUR writes commands to plot contours of Z(X,Y). Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror private  subroutine write_xyzgrid_data (data_file_name, nx, ny, xyz, ierror) WRITE_XYZGRID_DATA writes a file of XYZ grid data. Arguments Type Intent Optional Attributes Name character(len=*) :: data_file_name integer :: nx integer :: ny real :: xyz (3,nx,ny) integer :: ierror private  subroutine write_xyzgrid_surface (command_file_name, data_file_name, ierror) WRITE_XYZGRID_SURFACE writes a file of GNUPLOT commands to plot a 3D surface. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror private  subroutine write_y_plot (command_file_name, data_file_name, ierror) WRITE_Y_PLOT writes GNUPLOT commands to plot Y(1:N) data. Arguments Type Intent Optional Attributes Name character(len=*) :: command_file_name character(len=*) :: data_file_name integer :: ierror","tags":"","loc":"module/gnufor.html"},{"title":"solver – TOOLIB","text":"Api for different sparse matrix solvers Warning If WITH_MA48 has been set to true, you are supposed to have the license for\nthe HSL MA48 use.\nBy default the HSL MA48 are not provided here. Uses mumfpack sulu_wrapper sort_arrays hsl_ma48_double data_arch mumps_wrapper iso_fortran_env iso_c_binding gen_param module~~solver~~UsesGraph module~solver solver hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double iso_c_binding iso_c_binding module~solver->iso_c_binding iso_fortran_env iso_fortran_env module~solver->iso_fortran_env module~data_arch data_arch module~solver->module~data_arch module~gen_param gen_param module~solver->module~gen_param module~mumfpack mumfpack module~solver->module~mumfpack module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~sort_arrays sort_arrays module~solver->module~sort_arrays module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~data_arch->iso_fortran_env module~gen_param->module~data_arch module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch module~sulu_wrapper->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~solver~~UsedByGraph module~solver solver program~test_solvers test_solvers program~test_solvers->module~solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=I4), private, parameter :: MA48 = 0 code for     Ma48 solver type integer(kind=I4), public, parameter :: MUMP = 2 code for    MUMPS solver type integer(kind=I4), public :: SOLVER_BS = -1 solver used for bottom scale grids [not used by the present module] integer(kind=I4), public :: SOLVER_TS = -1 solver used for top scale grids [not used by the present module] integer(kind=I4), public, parameter :: SULU = 1 code for SUPER LU solver type integer(kind=I4), public, parameter :: UMFP = 3 code for  UMFPACK solver type Derived Types type, private :: MAT_MA48 All the stuff needed by HSL_MA48 Components Type Visibility Attributes Name Initial type(MA48_AINFO), public :: ainf type(MA48_CONTROL), public :: ctrl type(MA48_FACTORS), public :: fact integer(kind=I4), public :: fast type(MA48_FINFO), public :: finf real(kind=R8), public, dimension(2) :: resid type(MA48_SINFO), public :: sinf type(ZD11_TYPE), public :: zmat type, private :: MAT_MA48 type, public :: MAT_SOLV MUSST high level system type Components Type Visibility Attributes Name Initial real(kind=R8), public, dimension(:), allocatable :: a_elt unassembled rigidity matrix logical(kind=I4), public :: ana = .false. the system is analyzed real(kind=R8), public, dimension(:), allocatable :: b right hand side vector integer(kind=I4), public :: code error code [not used yet] integer(kind=I4), public, dimension(:), allocatable :: eltptr element rows pointer integer(kind=I4), public, dimension(:), allocatable :: eltvar rows in assembled matrix logical(kind=I4), public :: end = .false. the system is closed real(kind=R8), public :: error error value [not used yet] logical(kind=I4), public :: fac = .false. the system is factorized logical(kind=I4), public :: fre = .false. the system is freed logical(kind=I4), public :: ini = .false. the system is initialized integer(kind=I4), public, dimension(:), allocatable :: irow line number integer(kind=I4), public, dimension(:), allocatable :: jcol column number integer(kind=I4), public, dimension(:), allocatable :: jptr line pointer type( MAT_MA48 ), public :: matma48 matrices for ma48 solver type(MAT_MUMP), public :: matmump matrices for mumps solver type(MAT_SULU), public :: matsulu matrices for SuperLu solver type( MAT_UMFP ), public :: matumfp matrices for Umfpack solver character(len=1024), public :: mess message [not used yet] integer(kind=I4), public :: ne number of elements integer(kind=I4), public :: nn number of nodes integer(kind=I4), public :: nt number of a priori non-zero terms in the matrix integer(kind=I4), public :: nvar eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices) integer(kind=I4), public :: nz number of non-zero terms in the matrix integer(kind=I4), public :: slv_t solver type logical(kind=I4), public :: sol = .false. the system is solved real(kind=R8), public, dimension(:), allocatable :: x unknwon vector type, private :: MAT_UMFP All the stuff needed by UMFPACK Components Type Visibility Attributes Name Initial real(kind=R8), public, dimension(0:UMFPACK_CONTROL-1) :: c_control real(kind=R8), public, dimension(0:UMFPACK_INFO   -1) :: c_info type(c_ptr), public :: c_numeric type(c_ptr), public :: c_symbolic type, public :: MS_MAT_SOLV MUSST multiscale high level solver type Components Type Visibility Attributes Name Initial type( MAT_SOLV ), public, dimension(:), allocatable :: bs_mat bottom-scale solver type matrices (table) type( MAT_SOLV ), public :: ts_mat top-scale solver type matrices Subroutines private  subroutine analyse_solver (mat) Subroutine to analyse, factorize (symbolic) the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private  subroutine close_solver (mat) Subroutine to close the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type public  subroutine convert_matrice_format (mat) Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private  subroutine factorize_solver (mat) Subroutine to factorize the matrix of the system Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private  subroutine freefact_solver (mat) Subroutine to free the factors if applicable Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private  subroutine from_elemental_to_assembled (mat) Subroutine to transform the elemental entries into assembled CC vectors Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type private  subroutine init_solver (mat) Subroutine to initialize the matrices of the solver Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type private  subroutine solution_solver (mat) Subroutine to solve the system (sparse A) Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout), target :: mat high level system type public  subroutine solve_syst (mat, step) General hat subroutine that handles the resolution steps: Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(inout) :: mat high level system type character(len=*), intent(in) :: step ‘ini’=initialize, ‘ana’=analyze, ‘fac’=factorize, ‘sol’=solve, ‘fre’=free memory, ‘end’=close solver","tags":"","loc":"module/solver.html"},{"title":"mumps_wrapper – TOOLIB","text":"Note This file is part of MUMPS 5.5.1, released\n on Tue Jul 12 13:17:24 UTC 2022 Copyright 1991-2022 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria,\n Mumps Technologies, University of Bordeaux. This version of MUMPS is provided to you free of charge. It is\n released under the CeCILL-C license\n (see doc/CeCILL-C_V1-en.txt, doc/CeCILL-C_V1-fr.txt, and\n https://cecill.info/licences/Licence_CeCILL-C_V1-en.html) Used by module~~mumps_wrapper~~UsedByGraph module~mumps_wrapper mumps_wrapper module~solver solver module~solver->module~mumps_wrapper program~test_solvers test_solvers program~test_solvers->module~solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Common Blocks common /mpif_libseq/ Type Attributes Name Initial integer :: MPI_IN_PLACE Variables Type Visibility Attributes Name Initial integer, public, parameter :: MPI_2DOUBLE_PRECISION = 1 integer, public, parameter :: MPI_2INTEGER = 2 integer, public, parameter :: MPI_2REAL = 3 integer, public, parameter :: MPI_ANY_SOURCE = 4 integer, public, parameter :: MPI_ANY_TAG = 5 integer, public, parameter :: MPI_BSEND_OVERHEAD = 0 integer, public, parameter :: MPI_BYTE = 6 integer, public, parameter :: MPI_CHARACTER = 7 integer, public, parameter :: MPI_COMM_NULL = 8 integer, public, parameter :: MPI_COMM_SELF = 35 integer, public, parameter :: MPI_COMM_WORLD = 9 integer, public, parameter :: MPI_COMPLEX = 10 integer, public, parameter :: MPI_DOUBLE_COMPLEX = 11 integer, public, parameter :: MPI_DOUBLE_PRECISION = 12 integer, public, parameter :: MPI_INTEGER = 13 integer, public, parameter :: MPI_INTEGER8 = 33 integer, public :: MPI_IN_PLACE integer, public, parameter :: MPI_LAND = 32 integer, public, parameter :: MPI_LOGICAL = 14 integer, public, parameter :: MPI_LOR = 31 integer, public, parameter :: MPI_MAX = 15 integer, public, parameter :: MPI_MAXLOC = 16 integer, public, parameter :: MPI_MAX_PROCESSOR_NAME = 31 integer, public, parameter :: MPI_MIN = 17 integer, public, parameter :: MPI_MINLOC = 18 integer, public, parameter :: MPI_PACKED = 19 integer, public, parameter :: MPI_PROD = 20 integer, public, parameter :: MPI_REAL = 21 integer, public, parameter :: MPI_REAL8 = 34 integer, public, parameter :: MPI_REPLACE = 22 integer, public, parameter :: MPI_REQUEST_NULL = 23 integer, public, parameter :: MPI_SOURCE = 1 integer, public, parameter :: MPI_STATUS_SIZE = 2 integer, public, parameter :: MPI_SUM = 26 integer, public, parameter :: MPI_TAG = 2 integer, public, parameter :: MPI_THREAD_FUNNELED = 37 integer, public, parameter :: MPI_THREAD_MULTIPLE = 38 integer, public, parameter :: MPI_THREAD_SINGLE = 36 integer, public, parameter :: MPI_UNDEFINED = 28 integer, public, parameter :: MPI_WTIME_IS_GLOBAL = 30 Derived Types type, public, sequence  :: DMUMPS_L0OMPFAC_T Components Type Visibility Attributes Name Initial double precision, public, POINTER, DIMENSION(:) :: A integer(kind=8), public :: LA type, public, sequence  :: DMUMPS_ROOT_STRUC Components Type Visibility Attributes Name Initial integer, public :: CNTXT_BLACS integer, public, DIMENSION( 9 ) :: DESCRIPTOR integer, public, DIMENSION(:), POINTER :: IPIV integer, public :: LPIV integer, public :: MBLOCK integer, public :: MYCOL integer, public :: MYROW integer, public :: NBLOCK integer, public :: NB_SINGULAR_VALUES integer, public :: NPCOL integer, public :: NPROW double precision, public :: QR_RCOND double precision, public, DIMENSION(:), POINTER :: QR_TAU integer, public, DIMENSION(:), POINTER :: RG2L_COL integer, public, DIMENSION(:), POINTER :: RG2L_ROW double precision, public, DIMENSION(:), POINTER :: RHS_CNTR_MASTER_ROOT integer, public :: RHS_NLOC double precision, public, DIMENSION(:,:), POINTER :: RHS_ROOT integer, public :: ROOT_SIZE integer, public :: SCHUR_LLD integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC double precision, public, DIMENSION(:), POINTER :: SCHUR_POINTER double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES double precision, public, DIMENSION(:,:), POINTER :: SVD_U double precision, public, DIMENSION(:,:), POINTER :: SVD_VT integer, public :: TOT_ROOT_SIZE logical, public :: gridinit_done double precision, public, DIMENSION(:,:), POINTER :: rootpad integer, public :: rootpad0 integer, public, DIMENSION(:), POINTER :: rootpad1 double precision, public, DIMENSION(:), POINTER :: rootpad2 double precision, public :: rootpad3 integer, public :: rootpad4 logical, public :: yes type, public, sequence  :: DMUMPS_STRUC Components Type Visibility Attributes Name Initial double precision, public, DIMENSION(:), POINTER :: A logical, public :: ASSOCIATED_OOC_FILES integer, public :: ASS_IRECV double precision, public, DIMENSION(:), POINTER :: A_ELT double precision, public, DIMENSION(:), POINTER :: A_loc integer, public, DIMENSION(:), POINTER :: BLKPTR integer, public, DIMENSION(:), POINTER :: BLKVAR character(len=1), public, DIMENSION(:), POINTER :: BLRARRAY_ENCODING integer, public, DIMENSION(:,:), POINTER :: CANDIDATES double precision, public, DIMENSION(:), POINTER :: CB_SON_SIZE double precision, public :: CNTL (15) double precision, public, DIMENSION(:), POINTER :: COLSCA integer, public :: COMM integer, public :: COMM_LOAD integer, public :: COMM_NODES double precision, public :: COST_SUBTREES double precision, public, DIMENSION(:), POINTER :: COST_TRAV integer, public, DIMENSION(:), POINTER :: CROIX_MANU integer, public, POINTER, DIMENSION(:) :: DAD_STEPS double precision, public, DIMENSION(:), POINTER :: DBLARR integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST integer, public, DIMENSION(:), POINTER :: DEPTH_FIRST_SEQ double precision, public :: DKEEP (230) integer, public :: Deficiency integer, public, DIMENSION(:), POINTER :: ELTPROC integer, public, DIMENSION(:), POINTER :: ELTPTR integer, public, DIMENSION(:), POINTER :: ELTVAR character(len=1), public, DIMENSION(:), POINTER :: FDM_F_ENCODING integer, public, POINTER, DIMENSION(:) :: FILS integer, public, POINTER, DIMENSION(:) :: FRERE_STEPS integer, public, POINTER, DIMENSION(:) :: FRTELT integer, public, POINTER, DIMENSION(:) :: FRTPTR integer, public, DIMENSION(:), POINTER :: FUTURE_NIV2 integer, public, DIMENSION(:,:), POINTER :: I4_L0_OMP integer(kind=8), public, DIMENSION(:,:), POINTER :: I8_L0_OMP integer, public :: ICNTL (60) integer, public :: INFO (80) integer, public :: INFOG (80) integer, public :: INSTANCE_NUMBER integer, public :: INST_Number integer, public, DIMENSION(:), POINTER :: INTARR integer, public, DIMENSION(:), POINTER :: IPOOL_A_L0_OMP integer, public, DIMENSION(:), POINTER :: IPOOL_B_L0_OMP integer, public, DIMENSION(:), POINTER :: IPTR_WORKING integer, public, DIMENSION(:), POINTER :: IRHS_PTR integer, public, DIMENSION(:), POINTER :: IRHS_SPARSE integer, public, DIMENSION(:), POINTER :: IRHS_loc integer, public, DIMENSION(:), POINTER :: IRN integer, public, DIMENSION(:), POINTER :: IRN_loc integer, public, DIMENSION(:), POINTER :: IS integer, public, DIMENSION(:), POINTER :: ISOL_loc integer, public, DIMENSION(:), POINTER :: ISTEP_TO_INIV2 logical, public, DIMENSION(:), POINTER :: I_AM_CAND integer, public, DIMENSION(:), POINTER :: JCN integer, public, DIMENSION(:), POINTER :: JCN_loc integer, public :: JOB integer, public :: KEEP (500) integer(kind=8), public :: KEEP8 (150) type( DMUMPS_L0OMPFAC_T ), public, DIMENSION(:), POINTER :: L0_OMP_FACTORS integer, public, DIMENSION(:), POINTER :: L0_OMP_MAPPING integer, public :: LELTVAR integer, public, DIMENSION(:), POINTER :: LISTVAR_SCHUR integer, public :: LL0_OMP_FACTORS integer, public :: LL0_OMP_MAPPING integer, public :: LNA integer, public :: LPOOL_A_L0_OMP integer, public :: LPOOL_B_L0_OMP integer, public :: LREDRHS integer, public, POINTER, DIMENSION(:) :: LRGROUPS integer, public :: LRHS integer, public :: LRHS_loc integer, public :: LSOL_loc integer, public :: LWK_USER integer, public :: L_PHYS_L0_OMP integer, public :: L_VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: MAPPING integer(kind=8), public :: MAX_SURF_MASTER integer, public :: MBLOCK integer, public, DIMENSION(:), POINTER :: MEM_DIST double precision, public, DIMENSION(:), POINTER :: MEM_SUBTREE integer, public :: METIS_OPTIONS (40) integer, public, DIMENSION(:), POINTER :: MPITOOMP_PROCS_MAP integer, public :: MYID integer, public :: MYID_NODES integer, public, DIMENSION(:), POINTER :: MY_FIRST_LEAF integer, public, DIMENSION(:), POINTER :: MY_NB_LEAF integer, public, DIMENSION(:), POINTER :: MY_ROOT_SBTR integer, public :: N integer, public, POINTER, DIMENSION(:) :: NA integer, public :: NBGRP integer, public :: NBLK integer, public :: NBLOCK integer, public :: NBSA integer, public :: NBSA_LOCAL integer, public :: NB_SINGULAR_VALUES integer, public, POINTER, DIMENSION(:) :: ND_STEPS integer, public :: NELT integer, public :: NELT_loc integer, public, POINTER, DIMENSION(:) :: NE_STEPS integer(kind=8), public :: NNZ integer(kind=8), public :: NNZ_loc integer, public :: NPCOL integer, public :: NPROCS integer, public :: NPROW integer, public :: NRHS integer, public :: NSLAVES integer, public :: NZ integer, public :: NZ_RHS integer, public :: NZ_loc integer, public :: Nloc_RHS character(len=1), public, DIMENSION(:,:), POINTER :: OOC_FILE_NAMES integer, public, DIMENSION(:), POINTER :: OOC_FILE_NAME_LENGTH integer, public, DIMENSION(:,:), POINTER :: OOC_INODE_SEQUENCE integer, public :: OOC_MAX_NB_NODES_FOR_ZONE integer, public, DIMENSION(:), POINTER :: OOC_NB_FILES integer, public :: OOC_NB_FILE_TYPE character(len=63), public :: OOC_PREFIX integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_SIZE_OF_BLOCK character(len=255), public :: OOC_TMPDIR integer, public, DIMENSION(:), POINTER :: OOC_TOTAL_NB_NODES integer(kind=8), public, DIMENSION(:,:), POINTER :: OOC_VADDR integer, public :: PAR integer, public, DIMENSION(:), POINTER :: PERM_IN integer, public, DIMENSION(:), POINTER :: PERM_L0_OMP integer, public, DIMENSION(:), POINTER :: PHYS_L0_OMP integer, public, DIMENSION(:), POINTER :: PIVNUL_LIST integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_COL logical, public :: POSINRHSCOMP_COL_ALLOC integer, public, DIMENSION(:), POINTER :: POSINRHSCOMP_ROW integer, public, DIMENSION(:), POINTER :: PROCNODE integer, public, POINTER, DIMENSION(:) :: PROCNODE_STEPS integer, public, DIMENSION(:), POINTER :: PTLUST_S integer(kind=8), public, POINTER, DIMENSION(:) :: PTRAR integer(kind=8), public, DIMENSION(:), POINTER :: PTRFAC integer, public, DIMENSION(:), POINTER :: PTR_LEAFS_L0_OMP double precision, public, DIMENSION(:), POINTER :: REDRHS double precision, public, DIMENSION(:), POINTER :: RHS double precision, public, DIMENSION(:), POINTER :: RHSCOMP double precision, public, DIMENSION(:), POINTER :: RHS_SPARSE double precision, public, DIMENSION(:), POINTER :: RHS_loc double precision, public :: RINFO (40) double precision, public :: RINFOG (40) double precision, public, DIMENSION(:), POINTER :: ROWSCA double precision, public, DIMENSION(:), POINTER :: S character(len=255), public :: SAVE_DIR character(len=255), public :: SAVE_PREFIX integer, public, DIMENSION(:), POINTER :: SBTR_ID integer, public, DIMENSION(:), POINTER :: SCHED_DEP integer, public, DIMENSION(:), POINTER :: SCHED_GRP integer, public, DIMENSION(:), POINTER :: SCHED_SBTR double precision, public, DIMENSION(:), POINTER :: SCHUR double precision, public, DIMENSION(:), POINTER :: SCHUR_CINTERFACE integer, public :: SCHUR_LLD integer, public :: SCHUR_MLOC integer, public :: SCHUR_NLOC double precision, public, DIMENSION(:), POINTER :: SINGULAR_VALUES integer, public :: SIZE_SCHUR double precision, public, DIMENSION(:), POINTER :: SOL_loc integer, public, POINTER, DIMENSION(:) :: STEP integer, public, DIMENSION(:,:), POINTER :: SUP_PROC integer, public :: SYM integer, public, DIMENSION(:), POINTER :: SYM_PERM integer, public, POINTER, DIMENSION(:) :: Step2node integer, public, DIMENSION(:,:), POINTER :: TAB_POS_IN_PERE integer(kind=8), public :: THREAD_LA integer, public, DIMENSION(:), POINTER :: UNS_PERM character(len=30), public :: VERSION_NUMBER integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP integer, public, DIMENSION(:), POINTER :: VIRT_L0_OMP_MAPPING double precision, public, DIMENSION(:), POINTER :: WK_USER integer, public, DIMENSION(:), POINTER :: WORKING character(len=255), public :: WRITE_PROBLEM double precision, public, DIMENSION(:), POINTER :: pad0 integer, public :: pad1 logical, public :: pad11 integer, public :: pad12 integer, public :: pad13 integer, public, DIMENSION(:,:), POINTER :: pad14 integer, public :: pad16 double precision, public, DIMENSION(:), POINTER :: pad2 integer, public :: pad3 double precision, public, DIMENSION(:), POINTER :: pad4 integer, public :: pad5 integer, public :: pad6 character(len=7), public :: pad7 type( DMUMPS_ROOT_STRUC ), public :: root","tags":"","loc":"module/mumps_wrapper.html"},{"title":"files – TOOLIB","text":"Some routines to deal with files Todo rm -rf dir-name Uses data_arch miscellaneous module~~files~~UsesGraph module~files files module~data_arch data_arch module~files->module~data_arch module~miscellaneous miscellaneous module~files->module~miscellaneous iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~files~~UsedByGraph module~files files program~test_files test_files program~test_files->module~files Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function dir_separator () Function that returns the system directory separator Arguments None Return Value character(len=1) public  function dirname (file_path) Subroutine that keeps only the directory from a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path Return Value character(len=:), allocatable public  function filename (file_path) Subroutine that keeps only the file from a path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path Return Value character(len=:), allocatable public  function is_linux () Function that returns true if the operating system is linux Arguments None Return Value logical(kind=4) public  function str_remove_chars (string, chars) Function that removes the characters of a string from another string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string string to be modified character(len=*), intent(in) :: chars list of characters to remove Return Value character(len=:), allocatable returned string public  function str_replace (string, old_str, new_str, place) Function that replaces a string with another string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string string to be modified character(len=*), intent(in) :: old_str character(len=*), intent(in) :: new_str integer(kind=I4), intent(in) :: place Return Value character(len=:), allocatable returned string Subroutines public  subroutine clean_scratch () Subroutine that removes all files with extension .scratch Arguments None public  subroutine list_dirs (str) Subroutine that returns a list of subdirectories Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: str public  subroutine list_files (dir, list, ext) Subroutine that returns a list of files in a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: dir character(len=512), intent(out), allocatable, dimension(:) :: list character(len=*), intent(in), optional :: ext public  subroutine make_path (wkd, file_path, exit_status) Subroutine that creates the folders of a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wkd character(len=*), intent(in) :: file_path integer(kind=I4), intent(out) :: exit_status public  subroutine mkdir (wkd, directory, sep, exit_status) Subroutine that creates a directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: wkd character(len=*), intent(in) :: directory character(len=1), intent(in) :: sep integer(kind=I4), intent(out) :: exit_status public  subroutine path2vec (file_path, vec_path) Subroutine that creates a vector containing the folders of a file path Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_path character(len=512), intent(out), dimension(:), allocatable :: vec_path public  subroutine vec2path (file_path, vec_path) Subroutine that creates a path from vector of folders Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: file_path character(len=512), intent(in), dimension(:) :: vec_path","tags":"","loc":"module/files.html"},{"title":"least_squares – TOOLIB","text":"Least squares, linear and non linear Uses data_arch cholesky module~~least_squares~~UsesGraph module~least_squares least_squares module~cholesky cholesky module~least_squares->module~cholesky module~data_arch data_arch module~least_squares->module~data_arch module~cholesky->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~least_squares~~UsedByGraph module~least_squares least_squares module~tchebychev tchebychev module~tchebychev->module~least_squares program~test_least test_least program~test_least->module~least_squares program~test_tchebychev test_tchebychev program~test_tchebychev->module~tchebychev Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical(kind=I4), private, parameter :: verbose = .false. Subroutines public  subroutine moindres_carres (nb_var, nb_pts, hij, vec_xy, beta, f, df, typ, eps, relax, nb_var_der, info) Function that returns the parameters of a function that approximates a data set. The parameters\n       determination is achieved by non linear least squares approximation. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nb_var number of parameters to be determined integer(kind=I4), intent(in) :: nb_pts number of points for function evaluation real(kind=R8), intent(in), dimension(1:nb_pts) :: hij vector of evaluation points real(kind=R8), intent(in), dimension(1:nb_pts, 1:2) :: vec_xy x and y coordinates of evaluation points real(kind=R8), intent(inout), dimension(1:nb_var) :: beta parameters vector private  function f(xi, yi, var, nb_var, typ) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yi real(kind=R8), intent(inout), dimension(1:nb_var) :: var integer(kind=I4), intent(in) :: nb_var character(len=*), intent(in) :: typ Return Value real(kind=r8) private  function df(xi, yi, var, nb_var, ivar, typ) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yi real(kind=R8), intent(inout), dimension(1:nb_var) :: var integer(kind=I4), intent(in) :: nb_var integer(kind=I4), intent(in) :: ivar character(len=*), intent(in) :: typ Return Value real(kind=r8) character(len=*), intent(in) :: typ kind of function used real(kind=R8), intent(in) :: eps stop criterion real(kind=R8), intent(in) :: relax relaxation parameter integer(kind=I4), intent(in) :: nb_var_der number of derivatives integer(kind=I4), intent(out) :: info information from Cholesky resolution public  subroutine moindres_carres_lineaire (nb_var, nb_pts, hij, beta, Jf) Function that returns the parameters of a function that approximates a data set. The parameters\n       determination is achieved by linear least squares approximation. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nb_var number of parameters to be determined integer(kind=I4), intent(in) :: nb_pts number of points for function evaluation real(kind=R8), intent(in), dimension(1:nb_pts) :: hij vector of evaluation points real(kind=R8), intent(out), dimension(1:nb_var) :: beta parameters vector real(kind=R8), intent(in), dimension(1:nb_pts, 1:nb_var) :: Jf Jacobian","tags":"","loc":"module/least_squares.html"},{"title":"data_arch – TOOLIB","text":"General parameters definition Uses iso_fortran_env module~~data_arch~~UsesGraph module~data_arch data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~data_arch~~UsedByGraph module~data_arch data_arch module~cholesky cholesky module~cholesky->module~data_arch module~fftw3 fftw3 module~fftw3->module~data_arch module~files files module~files->module~data_arch module~miscellaneous miscellaneous module~files->module~miscellaneous module~gen_param gen_param module~gen_param->module~data_arch module~intpl intpl module~intpl->module~data_arch module~least_squares least_squares module~least_squares->module~data_arch module~least_squares->module~cholesky module~miscellaneous->module~data_arch module~solver solver module~solver->module~data_arch module~solver->module~gen_param module~sort_arrays sort_arrays module~solver->module~sort_arrays module~sort_arrays->module~data_arch module~surfile surfile module~surfile->module~data_arch module~surfile->module~miscellaneous module~surfile->module~sort_arrays module~tchebychev tchebychev module~tchebychev->module~data_arch module~tchebychev->module~least_squares module~tchebychev->module~miscellaneous proc~df df proc~df->module~data_arch proc~f f proc~f->module~data_arch program~main main program~main->module~data_arch program~main->module~miscellaneous program~main->module~sort_arrays program~test_algen test_algen program~test_algen->module~data_arch program~test_algen->module~miscellaneous program~test_algen->module~sort_arrays program~test_bspline test_bspline program~test_bspline->module~data_arch program~test_data_arch test_data_arch program~test_data_arch->module~data_arch program~test_data_arch->module~miscellaneous program~test_fftw3 test_fftw3 program~test_fftw3->module~data_arch program~test_fftw3->module~fftw3 program~test_fftw3->module~miscellaneous program~test_intpl test_intpl program~test_intpl->module~data_arch program~test_intpl->module~intpl program~test_least test_least program~test_least->module~data_arch program~test_least->module~least_squares program~test_solvers test_solvers program~test_solvers->module~data_arch program~test_solvers->module~gen_param program~test_solvers->module~miscellaneous program~test_solvers->module~solver program~test_surfile test_surfile program~test_surfile->module~data_arch program~test_surfile->module~surfile program~test_tchebychev test_tchebychev program~test_tchebychev->module~data_arch program~test_tchebychev->module~miscellaneous program~test_tchebychev->module~tchebychev program~test_utils test_utils program~test_utils->module~data_arch program~test_utils->module~cholesky program~test_files test_files program~test_files->module~files Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=R8), public, parameter :: EPS_E8 = log(EPS_R8) real(kind=R4), public, parameter :: EPS_R4 = tiny(1._R4) real(kind=R8), public, parameter :: EPS_R8 = tiny(1._R8) integer(kind=I4), public, parameter :: ERU = error_unit Error unit integer(kind=I4), public, parameter :: EXPO_MAX = exponent(HIG_R8) real(kind=R8), public, parameter :: HIG_E8 = log(HIG_R8) integer(kind=I4), public, parameter :: HIG_I4 = huge(1) real(kind=R8), public, parameter :: HIG_R8 = huge(1._R8) integer(kind=int32), public, parameter :: I4 = int32 integer(kind=I4), public, parameter :: I8 = int64 integer(kind=I4), public, parameter :: IPU = input_unit Input unit integer(kind=I4), public, parameter :: OPU = output_unit Output unit real(kind=R4), public, parameter :: PI_R4 = acos(-1._R4) real(kind=R8), public, parameter :: PI_R8 = acos(-1._R8) integer(kind=I4), public, parameter :: R4 = real32 integer(kind=I4), public, parameter :: R8 = real64 real(kind=R8), public, parameter :: UN = 1.0_R8","tags":"","loc":"module/data_arch.html"},{"title":"mt19937_64 – TOOLIB","text":"64-bit version of the Mersenne Twister pseudorandom number generator. History Contributors: Rémi Piatek, Takuji Nishimura, Makoto Matsumoto, Jacob Williams\n    See LICENSE file for details. References T. Nishimura, “Tables of 64-bit Mersenne Twisters” ACM Transactions on Modeling and\n    Computer Simulation 10. (2000) 348–357. M. Matsumoto and T. Nishimura,\n    “Mersenne Twister: a 623-dimensionally equidistributed uniform pseudorandom number generator”\n    ACM Transactions on Modeling and Computer Simulation 8. (Jan. 1998) 3–30. Original source: http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/FORTRAN/mt19937-64.f95 Uses iso_fortran_env module~~mt19937_64~~UsesGraph module~mt19937_64 mt19937_64 iso_fortran_env iso_fortran_env module~mt19937_64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~mt19937_64~~UsedByGraph module~mt19937_64 mt19937_64 module~pikaia_oop pikaia_oop module~pikaia_oop->module~mt19937_64 program~test_algen test_algen program~test_algen->module~pikaia_oop Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: i4 = int32 integer, private, parameter :: i8 = int64 integer(kind=i8), private, parameter :: lm = 2147483647_i8 least significant 31 bits integer(kind=i8), private, parameter :: matrix_a = -5403634167711393303_i8 integer(kind=i8), private, parameter :: mm = 156_i8 integer(kind=i8), private, parameter :: nn = 312_i8 real(kind=r8), private, parameter :: pi252 = 1.0_r8/(2.0_r8**52) real(kind=r8), private, parameter :: pi253 = 1.0_r8/(2.0_r8**53) real(kind=r8), private, parameter :: pi253_1 = 1.0_r8/(2.0_r8**53-1.0_r8) integer, private, parameter :: r8 = real64 integer(kind=i8), private, parameter :: seed_def = 5489_i8 integer(kind=i8), private, parameter :: um = -2147483648_i8 most significant 33 bits Derived Types type, public :: mt19937 main class for random number generator Components Type Visibility Attributes Name Initial integer(kind=i8), private :: mt (nn) = 0_i8 array for the state vector integer, private :: mti = nn+1 mti==nn+1 means mt(nn) is not initialized Type-Bound Procedures procedure, public :: genrand64_int64 procedure, public :: genrand64_real1 procedure, public :: genrand64_real2 procedure, public :: genrand64_real3 procedure, private :: init_by_array64 procedure, private :: init_genrand64 procedure, private :: init_genrand64_i4 generic, public :: initialize => init_genrand64_i4 , init_genrand64 , init_by_array64 ../../ call first to initialize Functions private  function genrand64_int64 (me) Generates a random number on [-2&#94;63, 2&#94;63-1]-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value integer(kind=r8) private  function genrand64_real1 (me) Generates a random number on [0,1]-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) private  function genrand64_real2 (me) Generates a random number on [0,1)-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) private  function genrand64_real3 (me) Generates a random number on (0,1)-real-interval Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me Return Value real(kind=r8) Subroutines private  subroutine init_by_array64 (me, init_key) Initializes by an array with array-length init_key is the array for initializing keys Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: init_key (:) private  subroutine init_genrand64 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i8), intent(in) :: seed private  subroutine init_genrand64_i4 (me, seed) Initializes me%mt(nn) with a seed Arguments Type Intent Optional Attributes Name class( mt19937 ), intent(inout) :: me integer(kind=i4), intent(in) :: seed","tags":"","loc":"module/mt19937_64.html"},{"title":"bspline – TOOLIB","text":"Description Multidimensional (1D-6D) B-Spline interpolation of data on a regular grid.\n  Basic subroutine interface. Notes This module is based on the bspline and spline routines from [1].\n  The original Fortran 77 routines were converted to free-form source.\n  Some of them are relatively unchanged from the originals, but some have\n  been extensively refactored. In addition, new routines for\n  1d, 4d, 5d, and 6d interpolation were also created (these are simply\n  extensions of the same algorithm into higher dimensions). See also An object-oriented interface can be found in [bspline_oo_module]. References DBSPLIN and DTENSBS from the NIST Core Math Library .\n     Original code is public domain. Carl de Boor, “A Practical Guide to Splines”,\n     Springer-Verlag, New York, 1978. Carl de Boor, Efficient Computer Manipulation of Tensor\n     Products ,\n     ACM Transactions on Mathematical Software,\n     Vol. 5 (1979), p. 173-182. D.E. Amos, “Computation with Splines and B-Splines”,\n     SAND78-1968, Sandia Laboratories, March, 1979. Carl de Boor, Package for calculating with B-splines ,\n     SIAM Journal on Numerical Analysis 14, 3 (June 1977), p. 441-472. Uses iso_fortran_env module~~bspline~~UsesGraph module~bspline bspline iso_fortran_env iso_fortran_env module~bspline->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~bspline~~UsedByGraph module~bspline bspline program~test_bspline test_bspline program~test_bspline->module~bspline Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 Real precision Functions private  function dbvalu (t, a, n, k, ideriv, x, inbv, work, iflag) Evaluates the b-representation (t,a,n,k) of a b-spline\n  at x for the function value on ideriv=0 or any of its\n  derivatives on ideriv=1,2,…,k-1.  right limiting values\n  (right derivatives) are returned except at the right end\n  point x=t(n+1) where left limiting values are computed.  the\n  spline is defined on t(k) <= x <= t(n+1).  dbvalu returns\n  a fatal error message when x is outside of this interval. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: t knot vector of length n+k real(kind=wp), intent(in), dimension(n) :: a b-spline coefficient vector of length n integer, intent(in) :: n number of b-spline coefficients.\n(sum of knot multiplicities-k) integer, intent(in) :: k order of the b-spline, k >= 1 integer, intent(in) :: ideriv order of the derivative, 0 <= ideriv <= k-1.\nideriv = 0 returns the b-spline value real(kind=wp), intent(in) :: x argument, t(k) <= x <= t(n+1) integer, intent(inout) :: inbv an initialization parameter which must be set\nto 1 the first time dbvalu is called.\ninbv contains information for efficient process-\ning after the initial call and inbv must not\nbe changed by the user.  distinct splines require\ndistinct inbv parameters. real(kind=wp), dimension(:) :: work work vector of length 3*k integer, intent(out) :: iflag if   0: no errors\nif 401: k does not satisfy k>=1\nif 402: n does not satisfy n>=k\nif 403: ideriv does not satisfy 0<=ideriv<k\nif 404: x is not greater than or equal to t(k)\nif 405: x is not less than or equal to t(n+1)\nif 406: a left limiting value cannot be obtained at t(k) Return Value real(kind=wp) Subroutines private  subroutine check_inputs (routine, iflag, nx, ny, nz, nq, nr, ns, kx, ky, kz, kq, kr, ks, x, y, z, q, r, s, tx, ty, tz, tq, tr, ts, status_ok) Check the validity of the inputs to the “ink” routines.\n  Prints warning message if there is an error,\n  and also sets iflag and status_ok. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: routine integer, intent(inout) :: iflag integer, intent(in), optional :: nx integer, intent(in), optional :: ny integer, intent(in), optional :: nz integer, intent(in), optional :: nq integer, intent(in), optional :: nr integer, intent(in), optional :: ns integer, intent(in), optional :: kx integer, intent(in), optional :: ky integer, intent(in), optional :: kz integer, intent(in), optional :: kq integer, intent(in), optional :: kr integer, intent(in), optional :: ks real(kind=wp), intent(in), optional, dimension(:) :: x real(kind=wp), intent(in), optional, dimension(:) :: y real(kind=wp), intent(in), optional, dimension(:) :: z real(kind=wp), intent(in), optional, dimension(:) :: q real(kind=wp), intent(in), optional, dimension(:) :: r real(kind=wp), intent(in), optional, dimension(:) :: s real(kind=wp), intent(in), optional, dimension(:) :: tx real(kind=wp), intent(in), optional, dimension(:) :: ty real(kind=wp), intent(in), optional, dimension(:) :: tz real(kind=wp), intent(in), optional, dimension(:) :: tq real(kind=wp), intent(in), optional, dimension(:) :: tr real(kind=wp), intent(in), optional, dimension(:) :: ts logical, intent(out) :: status_ok public  subroutine db1ink (x, nx, fcn, kx, tx, bcoef, iflag) Determines the parameters of a function that interpolates\n  the one-dimensional gridded data The interpolating function and its derivatives may\n  subsequently be evaluated by the function db1val . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(nx) :: fcn Array of function values to interpolate. fcn(i) should\n   contain the function value at the point x(i) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n   If iflag=0 these are chosen by db1ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(nx) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db1ink .\n               1 = knot sequence chosen by user. on output: 1 = successful execution.\n               2 = iflag out of range.\n               3 = nx out of range.\n               4 = kx out of range.\n               5 = x not strictly increasing.\n               6 = tx not non-decreasing. public  subroutine db1val (xval, idx, tx, nx, kx, bcoef, f, iflag, inbvx) Evaluates the tensor product piecewise polynomial\n  interpolant constructed by the routine db1ink or one of its\n  derivatives at the point xval. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db1ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db1ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db1ink ) real(kind=wp), intent(in), dimension(nx) :: bcoef the b-spline coefficients computed by db1ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. public  subroutine db2ink (x, nx, y, ny, fcn, kx, ky, tx, ty, bcoef, iflag) Determines the parameters of a function that interpolates\n  the two-dimensional gridded data The interpolating function and its derivatives may\n  subsequently be evaluated by the function db2val . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nx) :: x Array of x abcissae. Must be strictly increasing. integer, intent(in) :: nx Number of x abcissae real(kind=wp), intent(in), dimension(ny) :: y Array of y abcissae. Must be strictly increasing. integer, intent(in) :: ny Number of y abcissae real(kind=wp), intent(in), dimension(nx,ny) :: fcn Array of function values to interpolate. fcn(i,j) should\n   contain the function value at the point (x(i),y(j)) integer, intent(in) :: kx The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer, intent(in) :: ky The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real(kind=wp), intent(inout), dimension(nx+kx) :: tx The knots in the x direction for the spline interpolant.\n   If iflag=0 these are chosen by db2ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(inout), dimension(ny+ky) :: ty The knots in the y direction for the spline interpolant.\n   If iflag=0 these are chosen by db2ink .\n   If iflag=1 these are specified by the user.\n   Must be non-decreasing. real(kind=wp), intent(out), dimension(nx,ny) :: bcoef Array of coefficients of the b-spline interpolant. integer, intent(inout) :: iflag on input: 0 = knot sequence chosen by db2ink .\n               1 = knot sequence chosen by user. on output: 1 = successful execution.\n               2 = iflag out of range.\n               3 = nx out of range.\n               4 = kx out of range.\n               5 = x not strictly increasing.\n               6 = tx not non-decreasing.\n               7 = ny out of range.\n               8 = ky out of range.\n               9 = y not strictly increasing.\n              10 = ty not non-decreasing. public  subroutine db2val (xval, yval, idx, idy, tx, ty, nx, ny, kx, ky, bcoef, f, iflag, inbvx, inbvy, iloy) Evaluates the tensor product piecewise polynomial\n  interpolant constructed by the routine db2ink or one of its\n  derivatives at the point (xval,yval). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: xval x coordinate of evaluation point. real(kind=wp), intent(in) :: yval y coordinate of evaluation point. integer, intent(in) :: idx x derivative of piecewise polynomial to evaluate. integer, intent(in) :: idy y derivative of piecewise polynomial to evaluate. real(kind=wp), intent(in), dimension(nx+kx) :: tx sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(ny+ky) :: ty sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to db2ink ) integer, intent(in) :: nx the number of interpolation points in x. (same as in last call to db2ink ) integer, intent(in) :: ny the number of interpolation points in y. (same as in last call to db2ink ) integer, intent(in) :: kx order of polynomial pieces in x. (same as in last call to db2ink ) integer, intent(in) :: ky order of polynomial pieces in y. (same as in last call to db2ink ) real(kind=wp), intent(in), dimension(nx,ny) :: bcoef the b-spline coefficients computed by db2ink . real(kind=wp), intent(out) :: f interpolated value integer, intent(out) :: iflag status flag: 0 : no errors, /=0 : error integer, intent(inout) :: inbvx initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: inbvy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer, intent(inout) :: iloy initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. private  subroutine dbintk (x, y, t, n, k, bcoef, q, work, iflag) dbintk produces the b-spline coefficients, bcoef, of the\n  b-spline of order k with knots t(i), i=1,…,n+k, which\n  takes on the value y(i) at x(i), i=1,…,n.  the spline or\n  any of its derivatives can be evaluated by calls to dbvalu . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x vector of length n containing data point abscissa\nin strictly increasing order. real(kind=wp), intent(in), dimension(n) :: y corresponding vector of length n containing data\npoint ordinates. real(kind=wp), intent(in), dimension(*) :: t knot vector of length n+k\nsince t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) Read more… integer, intent(in) :: n number of data points, n >= k integer, intent(in) :: k order of the spline, k >= 1 real(kind=wp), intent(out), dimension(n) :: bcoef a vector of length n containing the b-spline coefficients real(kind=wp), intent(out), dimension(*) :: q a work vector of length (2 k-1) n, containing\nthe triangular factorization of the coefficient\nmatrix of the linear system being solved.  the\ncoefficients for the interpolant of an\nadditional data set (x(i),yy(i)), i=1,…,n\nwith the same abscissa can be obtained by loading\nyy into bcoef and then executing\ncall dbnslv(q,2k-1,n,k-1,k-1,bcoef) real(kind=wp), intent(out), dimension(*) :: work work vector of length 2*k integer, intent(out) :: iflag if   0: no errors.\nif 100: k does not satisfy k>=1.\nif 101: n does not satisfy n>=k.\nif 102: x(i) does not satisfy x(i)<x(i+1) for some i.\nif 103: some abscissa was not in the support of the.\ncorresponding basis function and the system is singular.\nif 104: the system of solver detects a singular system.\nalthough the theoretical conditions for a solution were satisfied. private  subroutine dbknot (x, n, k, t) dbknot chooses a knot sequence for interpolation of order k at the\n  data points x(i), i=1,..,n.  the n+k knots are placed in the array\n  t.  k knots are placed at each endpoint and not-a-knot end\n  conditions are used.  the remaining knots are placed at data points\n  if n is even and between data points if n is odd.  the rightmost\n  knot is shifted slightly to the right to insure proper interpolation\n  at x(n) (see page 350 of the reference). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(n) :: x integer, intent(in) :: n integer, intent(in) :: k real(kind=wp), intent(out), dimension(:) :: t private  subroutine dbnfac (w, nroww, nrow, nbandl, nbandu, iflag) Returns in w the LU-factorization (without pivoting) of the banded\n  matrix a of order nrow with (nbandl + 1 + nbandu) bands or diagonals\n  in the work array w . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(nroww,nrow) :: w work array. See header for details. integer, intent(in) :: nroww row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer, intent(in) :: nrow matrix order integer, intent(in) :: nbandl number of bands of a below the main diagonal integer, intent(in) :: nbandu number of bands of a above the main diagonal integer, intent(out) :: iflag indicating success(=1) or failure (=2) private  subroutine dbnslv (w, nroww, nrow, nbandl, nbandu, b) Companion routine to dbnfac . it returns the solution x of the\n  linear system a*x = b in place of b, given the lu-factorization\n  for a in the work array w from dbnfac. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(nroww,nrow) :: w describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nroww describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nrow describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandl describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . integer, intent(in) :: nbandu describes the lu-factorization of a banded matrix a of order nrow as constructed in dbnfac . real(kind=wp), intent(inout), dimension(nrow) :: b in : right side of the system to be solved out : the solution x, of order nrow private  subroutine dbspvn (t, jhigh, k, index, x, ileft, vnikx, work, iwork, iflag) Calculates the value of all (possibly) nonzero basis\n  functions at x of order max(jhigh,(j+1)*(index-1)), where t(k)\n  <= x <= t(n+1) and j=iwork is set inside the routine on\n  the first call when index=1.  ileft is such that t(ileft) <=\n  x < t(ileft+1).  a call to dintrv(t,n+1,x,ilo,ileft,mflag)\n  produces the proper ileft.  dbspvn calculates using the basic\n  algorithm needed in dbspvd.  if only basis functions are\n  desired, setting jhigh=k and index=1 can be faster than\n  calling dbspvd, but extra coding is required for derivatives\n  (index=2) and dbspvd is set up for this purpose. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t (*) knot vector of length n+k, where\nn = number of b-spline basis functions\nn = sum of knot multiplicities-k\ndimension t(ileft+jhigh) integer, intent(in) :: jhigh order of b-spline, 1 <= jhigh <= k integer, intent(in) :: k highest possible order integer, intent(in) :: index index = 1 gives basis functions of order jhigh\n      = 2 denotes previous entry with work, iwork\n        values saved for subsequent calls to\n        dbspvn. real(kind=wp), intent(in) :: x argument of basis functions, t(k) <= x <= t(n+1) integer, intent(in) :: ileft largest integer such that t(ileft) <= x < t(ileft+1) real(kind=wp), intent(out) :: vnikx (k) vector of length k for spline values. real(kind=wp), intent(out) :: work (*) a work vector of length 2*k integer, intent(out) :: iwork a work parameter.  both work and iwork contain\ninformation necessary to continue for index = 2.\nwhen index = 1 exclusively, these are scratch\nvariables and can be used for other purposes. integer, intent(out) :: iflag if   0: no errors\nif 201: k does not satisfy k>=1\nif 202: jhigh does not satisfy 1<=jhigh<=k\nif 203: index is not 1 or 2\nif 204: x does not satisfy t(ileft)<=x<=t(ileft+1) private  subroutine dbtpcf (x, n, fcn, ldf, nf, t, k, bcoef, work, iflag) dbtpcf computes b-spline interpolation coefficients for nf sets\n  of data stored in the columns of the array fcn. the b-spline\n  coefficients are stored in the rows of bcoef however.\n  each interpolation is based on the n abcissa stored in the\n  array x, and the n+k knots stored in the array t. the order\n  of each interpolation is k. the work array must be of length\n  at least 2 k (n+1). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: x (n) integer, intent(in) :: n real(kind=wp) :: fcn (ldf,nf) integer, intent(in) :: ldf integer, intent(in) :: nf real(kind=wp) :: t (*) integer, intent(in) :: k real(kind=wp) :: bcoef (nf,n) real(kind=wp) :: work (*) integer, intent(out) :: iflag if   0: no errors\nif 301: n should be >0 private  subroutine dintrv (XT, lxt, x, ilo, ileft, mflag) Computes the largest integer ileft in 1 <= ileft <= lxt\n  such that XT(ileft) <= x where XT(*) is a subdivision of\n  the x interval.\n  precisely, Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(lxt) :: XT a knot or break point vector of length lxt integer, intent(in) :: lxt length of the XT vector real(kind=wp), intent(in) :: x argument integer, intent(inout) :: ilo an initialization parameter which must be set\nto 1 the first time the spline array XT is\nprocessed by dintrv. ilo contains information for\nefficient processing after the initial call and ilo\nmust not be changed by the user.  distinct splines\nrequire distinct ilo parameters. integer, intent(out) :: ileft largest integer satisfying XT(ileft) <= x integer, intent(out) :: mflag signals when x lies out of bounds","tags":"","loc":"module/bspline.html"},{"title":"sulu_wrapper – TOOLIB","text":"Uses iso_c_binding module~~sulu_wrapper~~UsesGraph module~sulu_wrapper sulu_wrapper iso_c_binding iso_c_binding module~sulu_wrapper->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~sulu_wrapper~~UsedByGraph module~sulu_wrapper sulu_wrapper module~solver solver module~solver->module~sulu_wrapper program~test_solvers test_solvers program~test_solvers->module~solver Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=4), private, parameter :: I4 = 4 integer(kind=4), private, parameter :: R4 = 4 integer(kind=4), private, parameter :: R8 = 8 Enumerations enum, bind(c) Enumerators enumerator :: NOTRANS = 0 enumerator :: TRANS = 1 enumerator :: CONJ = 2 enum, bind(c) Enumerators enumerator :: DOFACT = 0 enumerator :: SAMEPATTERN = 1 enumerator :: SAMEPATTERN_SAMEROWPERM = 2 enumerator :: FACTORED = 3 enum, bind(c) Enumerators enumerator :: SLU_NC = 0 column-wise, no supernode enumerator :: SLU_NCP = 1 column-wise, column-permuted, no supernode enumerator :: SLU_NR = 2 row-wize, no supernode enumerator :: SLU_SC = 3 column-wise, supernode enumerator :: SLU_SCP = 4 supernode, column-wise, permuted enumerator :: SLU_SR = 5 row-wise, supernode enumerator :: SLU_DN = 6 Fortran style column-wise storage for dense matrix enumerator :: SLU_NR_loc = 7 distributed compressed row format enum, bind(c) Enumerators enumerator :: SLU_S = 0 single enumerator :: SLU_D = 1 double enumerator :: SLU_C = 2 single complex enumerator :: SLU_Z = 3 double complex enum, bind(c) Enumerators enumerator :: SLU_GE = 0 general enumerator :: SLU_TRLU = 1 lower triangular, unit diagonal enumerator :: SLU_TRUU = 2 upper triangular, unit diagonal enumerator :: SLU_TRL = 3 lower triangular enumerator :: SLU_TRU = 4 upper triangular enumerator :: SLU_SYL = 5 symmetric, store lower half enumerator :: SLU_SYU = 6 symmetric, store upper half enumerator :: SLU_HEL = 7 Hermitian, store lower half enumerator :: SLU_HEU = 8 Hermitian, store upper half Interfaces interface public  subroutine Destroy_CompCol_Matrix(A) bind(c, name=\"Destroy_CompCol_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private  subroutine Destroy_Dense_Matrix(A) bind(c, name=\"Destroy_Dense_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private  subroutine Destroy_SuperMatrix_Store(A) bind(c, name=\"Destroy_SuperMatrix_Store\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface public  subroutine Destroy_SuperNode_Matrix(A) bind(c, name=\"Destroy_SuperNode_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(in) :: A interface private  subroutine StatFree(stat) bind(c, name=\"StatFree\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat interface private  subroutine StatInit(stat) bind(c, name=\"StatInit\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(out) :: stat interface private  subroutine StatPrint(stat) bind(c, name=\"StatPrint\") Arguments Type Intent Optional Attributes Name type( SUPERLUSTAT_T ), intent(in) :: stat interface private  subroutine dCreate_CompCol_Matrix(A, m, n, nnz, nzval, rowind, colptr, stype, dtype, mtype) bind(c, name=\"dCreate_CompCol_Matrix\") Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: A integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n integer(kind=C_INT), intent(in), value :: nnz real(kind=C_DOUBLE), intent(in) :: nzval (*) integer(kind=C_INT), intent(in) :: rowind (*) integer(kind=C_INT), intent(in) :: colptr (*) integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private  subroutine dCreate_Dense_Matrix(BX, m, n, x, ldx, stype, dtype, mtype) bind(c, name='dCreate_Dense_Matrix') Arguments Type Intent Optional Attributes Name type( SUPERMATRIX ), intent(out) :: BX integer(kind=C_INT), intent(in), value :: m integer(kind=C_INT), intent(in), value :: n real(kind=C_DOUBLE), intent(in) :: x (*) integer(kind=C_INT), intent(in), value :: ldx integer(kind=C_INT), intent(in), value :: stype integer(kind=C_INT), intent(in), value :: dtype integer(kind=C_INT), intent(in), value :: mtype interface private  subroutine dgssvx(options, A, perm_c, perm_r, etree, equed, R, C, L, U, work, lwork, B, X, recip_pivot_growth, rcond, ferr, berr, Glu, mem_usage, stat, info) bind(c, name='dgssvx') Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(in) :: options type( SUPERMATRIX ), intent(inout) :: A integer(kind=C_INT), intent(inout) :: perm_c (*) integer(kind=C_INT), intent(inout) :: perm_r (*) integer(kind=C_INT), intent(inout) :: etree (*) character(kind=C_CHAR, len=1), intent(inout) :: equed (*) real(kind=C_DOUBLE), intent(inout) :: R (*) real(kind=C_DOUBLE), intent(inout) :: C (*) type( SUPERMATRIX ), intent(inout) :: L type( SUPERMATRIX ), intent(inout) :: U type(C_PTR), intent(out) :: work integer(kind=C_INT), intent(in), value :: lwork type( SUPERMATRIX ), intent(inout) :: B type( SUPERMATRIX ), intent(out) :: X real(kind=C_DOUBLE), intent(out) :: recip_pivot_growth (*) real(kind=C_DOUBLE), intent(out) :: rcond (*) real(kind=C_DOUBLE), intent(out) :: ferr (*) real(kind=C_DOUBLE), intent(out) :: berr (*) type( GLOBALLU_T ), intent(inout) :: Glu type( MEM_USAGE_T ), intent(out) :: mem_usage type( SUPERLUSTAT_T ), intent(out) :: stat integer(kind=C_INT), intent(out) :: info interface private  subroutine set_default_options(options) bind(c, name='set_default_options') Arguments Type Intent Optional Attributes Name type( SUPERLU_OPTIONS_T ), intent(inout) :: options Derived Types type, private, bind(c) :: EXPHEADER Components Type Visibility Attributes Name Initial type(C_PTR), public :: mem integer(kind=C_INT), public :: size type, private, bind(c) :: GLOBALLU_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: MemModel = 0 type( EXPHEADER ), public :: expanders integer(kind=C_INT), public :: lsub type(C_PTR), public :: lusup integer(kind=C_INT), public :: num_expansions integer(kind=C_INT), public :: nzlmax integer(kind=C_INT), public :: nzlumax integer(kind=C_INT), public :: nzumax type( LU_STACK_T ), public :: stack integer(kind=C_INT), public :: supno type(C_PTR), public :: ucol integer(kind=C_INT), public :: usub integer(kind=C_INT), public :: xlsub integer(kind=C_INT), public :: xlusup integer(kind=C_INT), public :: xsup integer(kind=C_INT), public :: xusub type, private, bind(c) :: LU_STACK_T Components Type Visibility Attributes Name Initial type(C_PTR), public :: array integer(kind=C_INT), public :: size integer(kind=C_INT), public :: top1 integer(kind=C_INT), public :: top2 integer(kind=C_INT), public :: used type, private, bind(c) :: MEM_USAGE_T Components Type Visibility Attributes Name Initial real(kind=C_FLOAT), public :: for_lu real(kind=C_FLOAT), public :: total_needed type, private, bind(c) :: NCFORMAT Read more… Components Type Visibility Attributes Name Initial type(C_PTR), public :: colptr pointer to array of beginning of columns in nzval[] and rowind[] integer(kind=C_INT), public :: nnz number of nonzeros in the matrix type(C_PTR), public :: nzval pointer to array of nonzero values, packed by column type(C_PTR), public :: rowind pointer to array of row indices of the nonzeros type, public :: SULU_ENV Global type for SuperLU which covers all the stuff needed Components Type Visibility Attributes Name Initial real(kind=C_DOUBLE), public, allocatable, dimension(:) :: CC column scale factors for A type( GLOBALLU_T ), public :: Glu first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity real(kind=C_DOUBLE), public, allocatable, dimension(:) :: RR *row scale factors for A * real(kind=R8), public, dimension(:), pointer :: a_elt CC system matrix: points to a_elt real(kind=R8), public, dimension(:), pointer :: b right hand side: points to b real(kind=C_DOUBLE), public, allocatable, dimension(:) :: berr componentwise relative backward error of each solution character(kind=C_CHAR, len=1), public :: equed form of equilibration integer(kind=C_INT), public, allocatable, dimension(:) :: etree Elimination tree real(kind=C_DOUBLE), public, allocatable, dimension(:) :: ferr estimated forward error bound for each solution vector logical(kind=I4), public :: first if false the system has been factorized at least once integer(kind=C_INT), public :: info info returned by dgssvx integer(kind=I4), public, dimension(:), pointer :: irow matrix line of an a_elt element: points to irow integer(kind=I4), public, dimension(:), pointer :: jptr matrix column pointers: points to jptr integer(kind=C_INT), public :: lwork size of workspace, not used here type( MEM_USAGE_T ), public :: mem_usage memory usage statistics integer(kind=C_INT), public :: n system size integer(kind=C_INT), public :: nrhs number of right hand sides integer(kind=C_INT), public :: nz number on non-zero entries type( SUPERLU_OPTIONS_T ), public :: options LU controls integer(kind=C_INT), public, allocatable, dimension(:) :: perm_c If A->Stype = SLU_NC , Column permutation vector of size A->ncol integer(kind=C_INT), public, allocatable, dimension(:) :: perm_r If A->Stype = SLU_NC , row permutation vector of size A->nrow real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rcond estimate of the reciprocal condition number of the matrix A real(kind=C_DOUBLE), public, allocatable, dimension(:) :: rpg reciprocal pivot growth factor type( SUPERMATRIX ), public :: sma Matrix A in A X=B* type( SUPERMATRIX ), public :: smb On entry, the right hand side matrix type( SUPERMATRIX ), public :: sml factor L from the factorization type( SUPERMATRIX ), public :: smu factor U from the factorization type( SUPERMATRIX ), public :: smx olution matrix to the original system type( SUPERLUSTAT_T ), public :: stat statistics on runtime and floating-point operation count type(C_PTR), public :: work User supplied workspace real(kind=R8), public, allocatable, dimension(:) :: x solution type, private, bind(c) :: SUPERLUSTAT_T Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: RefineSteps number of iterative refinement steps integer(kind=C_INT), public :: TinyPivots number of tiny pivots integer(kind=C_INT), public :: expansions number of memory expansions type(C_PTR), public :: ops operation count at various phases type(C_PTR), public :: panel_histo histogram of panel size distribution type(C_PTR), public :: utime running time at various phases type, private, bind(c) :: SUPERLU_OPTIONS_T Read more… Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: ColPerm integer(kind=C_INT), public :: ConditionNumber real(kind=C_DOUBLE), public :: DiagPivotThresh integer(kind=C_INT), public :: Equil integer(kind=C_INT), public :: Fact integer(kind=C_INT), public :: ILU_DropRule real(kind=C_DOUBLE), public :: ILU_DropTol real(kind=C_DOUBLE), public :: ILU_FillFactor real(kind=C_DOUBLE), public :: ILU_FillTol integer(kind=C_INT), public :: ILU_MILU real(kind=C_DOUBLE), public :: ILU_MILU_Dim integer(kind=C_INT), public :: ILU_Norm integer(kind=C_INT), public :: IterRefine integer(kind=C_INT), public :: ParSymbFact integer(kind=C_INT), public :: PivotGrowth integer(kind=C_INT), public :: PrintStat integer(kind=C_INT), public :: RefineInitialized integer(kind=C_INT), public :: ReplaceTinyPivot integer(kind=C_INT), public :: RowPerm integer(kind=C_INT), public :: SolveInitialized integer(kind=C_INT), public :: SymPattern symmetric factorization integer(kind=C_INT), public :: SymmetricMode integer(kind=C_INT), public :: Trans integer(kind=C_INT), public :: lookahead_etree use etree computed from the serial symbolic factorization integer(kind=C_INT), public :: nnzL used to store nnzs for now integer(kind=C_INT), public :: nnzU used to store nnzs for now integer(kind=C_INT), public :: num_lookaheads num of levels in look-ahead type, private, bind(c) :: SUPERMATRIX Components Type Visibility Attributes Name Initial integer(kind=C_INT), public :: Dtype Data type integer(kind=C_INT), public :: Mtype Matrix type: describes the mathematical property of the matrix type(C_PTR), public :: Store pointer to the actual storage of the matrix, here, pointer to NCFORMAT integer(kind=C_INT), public :: Stype Storage type: interprets the storage structure pointed to by Store integer(kind=C_INT), public :: ncol number of columns integer(kind=C_INT), public :: nrow number of rows Subroutines public  subroutine close_superlu (sulu) Subroutine to close the SuperLU process, with memory release Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public  subroutine fact_superlu (sulu, verbose) Subroutine to factorize the system Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose public  subroutine free_superlu () Subroutine that actually does nothing yet. Maybe, there will be extra memory that\ncould be released here? Arguments None public  subroutine init_superlu (sulu) Read more… Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public  subroutine prep_superlu (sulu) Subroutine to prepare the SULU_ENV components Arguments Type Intent Optional Attributes Name type( SULU_ENV ), intent(inout) :: sulu public  subroutine solv_superlu (sol_x, sulu, verbose) Subroutine to solve the system Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(:) :: sol_x type( SULU_ENV ), intent(inout) :: sulu logical(kind=I4), intent(in) :: verbose","tags":"","loc":"module/sulu_wrapper.html"},{"title":"test_least – TOOLIB","text":"Uses data_arch least_squares program~~test_least~~UsesGraph program~test_least test_least module~data_arch data_arch program~test_least->module~data_arch module~least_squares least_squares program~test_least->module~least_squares iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~least_squares->module~data_arch module~cholesky cholesky module~least_squares->module~cholesky module~cholesky->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Least squares, linear and non linear. Example of use. Calls program~~test_least~~CallsGraph program~test_least test_least proc~calc_imp_acf calc_imp_acf program~test_least->proc~calc_imp_acf proc~calc_jf calc_Jf program~test_least->proc~calc_jf proc~moindres_carres moindres_carres program~test_least->proc~moindres_carres proc~moindres_carres_lineaire moindres_carres_lineaire program~test_least->proc~moindres_carres_lineaire proc~autocov_impo autocov_impo proc~calc_imp_acf->proc~autocov_impo proc~df df proc~calc_jf->proc~df proc~choldc choldc proc~moindres_carres->proc~choldc proc~cholsl cholsl proc~moindres_carres->proc~cholsl proc~moindres_carres_lineaire->proc~choldc proc~moindres_carres_lineaire->proc~cholsl proc~df->proc~autocov_impo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), dimension(:,:), allocatable :: Jf real(kind=R8), dimension(:), allocatable :: beta real(kind=R8), dimension(:), allocatable :: hij integer(kind=I4) :: info integer(kind=I4) :: n1 integer(kind=I4) :: n2 real(kind=R8), dimension(:,:), allocatable :: vec_xy Functions function autocov_impo (xi, xj, tau1, tau2, alpha, ang) Function that returns Read more… Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi coordinate real(kind=R8), intent(in) :: xj coordinate real(kind=R8), intent(in) :: tau1 correlation length along real(kind=R8), intent(in) :: tau2 correlation length along real(kind=R8), intent(in) :: alpha log(z) where z is often 0.2 real(kind=R8), intent(in) :: ang angle (rad) Return Value real(kind=r8) function df (xi, yi, var, nb_var, ivar, typ) Kind of particular 2D autocorrelation function. Numerical derivatives. Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi x coordinates real(kind=R8), intent(in) :: yi y coordinates real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameter vector integer(kind=I4), intent(in) :: nb_var number of parameters integer(kind=I4), intent(in) :: ivar ith parameter character(len=*), intent(in) :: typ not used here Return Value real(kind=r8) function f (xi, yi, var, nb_var, typ) Kind of particular 2D autocorrelation function Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi x coordinates real(kind=R8), intent(in) :: yi y coordinates real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameter vector integer(kind=I4), intent(in) :: nb_var number of parameters character(len=*), intent(in) :: typ not used here Return Value real(kind=r8) Subroutines subroutine calc_Jf (long, larg, nb_var, vec_xy, var, Jf) Determine the Jacobian matrix of f Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long number of points along x integer(kind=I4), intent(in) :: larg number of points along y integer(kind=I4), intent(in) :: nb_var number of parameters to be determined real(kind=R8), intent(in), dimension(1:long * larg, 1:2) :: vec_xy x and y coordinates of evaluation points real(kind=R8), intent(inout), dimension(1:nb_var) :: var parameters vector real(kind=R8), intent(out), dimension(1:long * larg, 1:nb_var) :: Jf Jacobian matrix subroutine calc_imp_acf (long, larg, tau1, tau2, alpha, ang, vec_acf, vec_xy) Function that returns the theoretical autocorrelation function in an array. The autocorrelation function is supposed to be obtained from a real surface which must be periodic\n or nearly periodic (because of the use of FFTs).\n In addition, the surface is supposed to be 0 mean and normalized ( ),\n therefore acf is zero-mean and normalized so that its max value is 1. Read more… Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long surface acf width integer(kind=I4), intent(in) :: larg surface acf height real(kind=R8), intent(in) :: tau1 first correlation length real(kind=R8), intent(in) :: tau2 surface second correlation length real(kind=R8), intent(in) :: alpha parameter that controls the expondential decrease real(kind=R8), intent(in) :: ang acf ellipsis angle real(kind=R8), intent(out), dimension(1:long * larg) :: vec_acf resulting acf real(kind=R8), intent(out), dimension(1:long * larg, 1:2) :: vec_xy points coordinates Source Code program test_least use data_arch , only : I4 , R8 , PI_R8 use least_squares , only : moindres_carres , moindres_carres_lineaire implicit none integer ( kind = I4 ) :: n1 , n2 , info real ( kind = R8 ), dimension (:), allocatable :: hij , beta real ( kind = R8 ), dimension (:,:), allocatable :: vec_xy , Jf n1 = 128 n2 = 128 allocate ( hij ( 1 : n1 * n2 ) ) allocate ( vec_xy ( 1 : n1 * n2 , 1 : 2 ) ) allocate ( beta ( 1 : 3 ) ) call calc_imp_acf ( long = n1 , & ! larg = n2 , & ! tau1 = 0.3_R8 , & ! tau2 = 0.1_R8 , & ! alpha = - 0.2_R8 , & ! ang = PI_R8 / 6. , & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! vec_acf = hij ( 1 : n1 * n2 ) ) ! beta ( 1 : 3 ) = [ 0.1 , 0.1 , 0.1 ] call moindres_carres ( nb_var = 3 , & ! nb_pts = n1 * n2 , & ! hij = hij ( 1 : n1 * n2 ), & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! beta = beta ( 1 : 3 ), & ! f = f , & ! df = df , & ! typ = 'no_type' , & ! eps = 0.001_R8 , & ! relax = 0.5_R8 , & ! nb_var_der = 3 , & ! info = info ) ! write ( * , * ) 'Non linear approach to a non linear problem. Solution is 0.3 0.1 +/-0.5' write ( * , * ) beta ( 1 ), beta ( 2 ), sin ( mod ( beta ( 3 ), 2 * PI_R8 )) !======================================================= allocate ( Jf ( 1 : n1 * n2 , 1 : 3 ) ) beta ( 1 : 3 ) = [ 0.1 , 0.1 , 0.1 ] call calc_Jf ( long = n1 , & ! larg = n2 , & ! nb_var = 3 , & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! var = beta ( 1 : 3 ), & ! Jf = Jf ( 1 : n1 * n2 , 1 : 3 ) ) ! call moindres_carres_lineaire ( nb_var = 3 , & ! nb_pts = n1 * n2 , & ! hij = hij ( 1 : n1 * n2 ), & ! beta = beta ( 1 : 3 ), & ! Jf = Jf ( 1 : n1 * n2 , 1 : 3 ) ) ! write ( * , * ) 'Linear approach to a non linear problem. Solution is 0.3 0.1 +/-0.5' write ( * , * ) beta ( 1 ), beta ( 2 ), sin ( mod ( beta ( 3 ), 2 * PI_R8 )) !======================================================= deallocate ( hij , vec_xy , beta , Jf ) contains real ( kind = R8 ) function f ( xi , yi , var , nb_var , typ ) !! Kind of particular 2D autocorrelation function use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters* real ( kind = R8 ), intent ( in ) :: xi !! *x coordinates* real ( kind = R8 ), intent ( in ) :: yi !! *y coordinates* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameter vector* character ( len =* ), intent ( in ) :: typ !! *not used here* f = autocov_impo ( xi = xi , xj = yi , tau1 = var ( 1 ), tau2 = var ( 2 ), alpha =- 0.2_R8 , ang = var ( 3 )) return endfunction f real ( kind = R8 ) function df ( xi , yi , var , nb_var , ivar , typ ) !! Kind of particular 2D autocorrelation function. Numerical derivatives. use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ivar !! *ith parameter* real ( kind = R8 ), intent ( in ) :: xi !! *x coordinates* real ( kind = R8 ), intent ( in ) :: yi !! *y coordinates* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameter vector* character ( len =* ), intent ( in ) :: typ !! *not used here* real ( kind = R8 ) :: v1 , v2 , v3 , dv1 , dv2 , dv3 v1 = var ( 1 ) ; dv1 = 0.001 !v1 / 100 v2 = var ( 2 ) ; dv2 = 0.001 !v2 / 100 v3 = var ( 3 ) ; dv3 = 0.100 !v3 / 100 select case ( ivar ) case ( 1 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 + 0.5 * dv1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 - 0.5 * dv1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 ) ) / dv1 ! case ( 2 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 + 0.5 * dv2 , alpha =- 0.2_R8 , ang = v3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 - 0.5 * dv2 , alpha =- 0.2_R8 , ang = v3 ) ) / dv2 ! case ( 3 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 + 0.5 * dv3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 - 0.5 * dv3 ) ) / dv3 ! endselect return endfunction df subroutine calc_Jf ( long , larg , nb_var , vec_xy , var , Jf ) !! Determine the Jacobian matrix of f implicit none integer ( kind = I4 ), intent ( in ) :: long !! *number of points along x* integer ( kind = I4 ), intent ( in ) :: larg !! *number of points along y* integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* real ( kind = R8 ), intent ( in ), dimension ( 1 : long * larg , 1 : 2 ) :: vec_xy !! *x and y coordinates of evaluation points* real ( kind = R8 ), intent ( out ), dimension ( 1 : long * larg , 1 : nb_var ) :: Jf !! *Jacobian matrix* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameters vector* integer ( kind = I4 ) :: i , j , k , ivar k = 0 do j = 1 , larg do i = 1 , long k = k + 1 do ivar = 1 , nb_var Jf ( k , ivar ) = df ( xi = vec_xy ( k , 1 ), & ! yi = vec_xy ( k , 2 ), & ! var = var ( 1 : 3 ), & ! nb_var = 3 , & ! ivar = ivar , & ! typ = \"no_type\" ) ! enddo enddo enddo return endsubroutine calc_Jf real ( kind = R8 ) function autocov_impo ( xi , xj , tau1 , tau2 , alpha , ang ) !================================================================================================ !<@note Function that returns  \\exp \\left(\\alpha \\sqrt{\\left(\\frac{x}{\\tau_1}\\right)&#94;2+ !<                                                        \\left(\\frac{y}{\\tau_2}\\right)&#94;2} !<                                      \\right)  !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: tau1 !! *correlation length along x* real ( kind = R8 ), intent ( in ) :: tau2 !! *correlation length along y* real ( kind = R8 ), intent ( in ) :: alpha !! *log(z)* where *z* is often 0.2 real ( kind = R8 ), intent ( in ) :: xi !! *x coordinate* real ( kind = R8 ), intent ( in ) :: xj !! *y coordinate* real ( kind = R8 ), intent ( in ) :: ang !! *angle* (rad) real ( kind = R8 ) :: x , y x = + cos ( ang ) * xi + sin ( ang ) * xj y = - sin ( ang ) * xi + cos ( ang ) * xj autocov_impo = exp ( alpha * sqrt ( ( x / tau1 ) ** 2 + ( y / tau2 ) ** 2 ) ) return endfunction autocov_impo subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , vec_acf , vec_xy ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> !< The autocorrelation function is supposed to be obtained from a real surface which must be periodic !< or nearly periodic (because of the use of FFTs). !< In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), !< therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long * larg ), intent ( out ) :: vec_acf !! *resulting acf* real ( kind = R8 ), dimension ( 1 : long * larg , 1 : 2 ), intent ( out ) :: vec_xy !! *points coordinates* integer ( kind = I4 ) :: i , j , k , long2 , larg2 real ( kind = R8 ) :: xi , xj , r long2 = long / 2 + 1 larg2 = larg / 2 + 1 k = 0 do j = 1 , larg do i = 1 , long k = k + 1 xi = real ( i - long2 , kind = R8 ) / long xj = real ( j - larg2 , kind = R8 ) / larg vec_xy ( k , 1 ) = xi vec_xy ( k , 2 ) = xj call random_number ( r ) r = 1. + 0.05 * ( 2 * ( 0.5 - r )) vec_acf ( k ) = r * autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo return endsubroutine calc_imp_acf endprogram test_least","tags":"","loc":"program/test_least.html"},{"title":"test_tchebychev – TOOLIB","text":"Uses tchebychev data_arch miscellaneous program~~test_tchebychev~~UsesGraph program~test_tchebychev test_tchebychev module~data_arch data_arch program~test_tchebychev->module~data_arch module~miscellaneous miscellaneous program~test_tchebychev->module~miscellaneous module~tchebychev tchebychev program~test_tchebychev->module~tchebychev iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch module~tchebychev->module~data_arch module~tchebychev->module~miscellaneous module~least_squares least_squares module~tchebychev->module~least_squares module~least_squares->module~data_arch module~cholesky cholesky module~least_squares->module~cholesky module~cholesky->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_tchebychev~~CallsGraph program~test_tchebychev test_tchebychev proc~convert_to_poly convert_to_poly program~test_tchebychev->proc~convert_to_poly proc~genere_surf_poly genere_surf_poly program~test_tchebychev->proc~genere_surf_poly proc~get_unit get_unit program~test_tchebychev->proc~get_unit proc~least_squares_tcheby least_squares_tcheby program~test_tchebychev->proc~least_squares_tcheby proc~coeff_tcheby_vers_monome coeff_tcheby_vers_monome proc~genere_surf_poly->proc~coeff_tcheby_vers_monome proc~tcheby tcheby proc~genere_surf_poly->proc~tcheby proc~least_squares_tcheby->proc~get_unit proc~coeff_poly_tcheby_xy_vers_poly_monome coeff_poly_tcheby_xy_vers_poly_monome proc~least_squares_tcheby->proc~coeff_poly_tcheby_xy_vers_poly_monome proc~moindres_carres_lineaire moindres_carres_lineaire proc~least_squares_tcheby->proc~moindres_carres_lineaire proc~tab_jf_tcheby tab_Jf_tcheby proc~least_squares_tcheby->proc~tab_jf_tcheby proc~tab_poly_tcheby tab_poly_tcheby proc~least_squares_tcheby->proc~tab_poly_tcheby proc~tab_tcheby tab_tcheby proc~least_squares_tcheby->proc~tab_tcheby proc~coeff_tcheby_xy_vers_monome coeff_tcheby_xy_vers_monome proc~coeff_poly_tcheby_xy_vers_poly_monome->proc~coeff_tcheby_xy_vers_monome proc~choldc choldc proc~moindres_carres_lineaire->proc~choldc proc~cholsl cholsl proc~moindres_carres_lineaire->proc~cholsl omp_get_num_procs omp_get_num_procs proc~tab_jf_tcheby->omp_get_num_procs proc~tab_poly_tcheby->omp_get_num_procs proc~tab_tcheby->proc~tcheby proc~coeff_tcheby_xy_vers_monome->proc~coeff_tcheby_vers_monome Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4) :: i integer(kind=I4), parameter :: i1 = 9 integer(kind=I4), parameter :: i2 = 11 integer(kind=I4) :: iu integer(kind=I4), parameter :: n1 = 1024 integer(kind=I4), parameter :: n2 = 512 integer(kind=I4) :: nbvar character(len=128) :: str real(kind=R8), allocatable, dimension(:) :: tab_coef1 real(kind=R8), allocatable, dimension(:) :: tab_coef2 real(kind=R8), allocatable, dimension(:,:) :: tab_height real(kind=R8), allocatable, dimension(:,:) :: tab_result Subroutines subroutine convert_to_poly (long1, long2, deg1, deg2, tab_coef, tab_out) Génération d’une surface polynômiale pour vérification des procédures d’approximation Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: deg1 degré selon x integer(kind=I4), intent(in) :: deg2 degré selon y real(kind=R8), intent(in), dimension(1:(deg1+1) * (deg2+1)) :: tab_coef tableau des coefficients real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface subroutine genere_surf_poly (long1, long2, deg1, deg2, tab_out, tab_coef) génère une surface Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: long1 taille x integer(kind=I4), intent(in) :: long2 taille y integer(kind=I4), intent(in) :: deg1 degré selon x integer(kind=I4), intent(in) :: deg2 degré selon y real(kind=R8), intent(out), dimension(1:long1, 1:long2) :: tab_out tableau résultant : surface real(kind=R8), intent(out), dimension(1:(deg1+1) * (deg2+1)) :: tab_coef tableau des coefficients Source Code program test_tchebychev use data_arch , only : I4 , R8 , HIG_R8 use miscellaneous , only : get_unit use tchebychev , only : least_squares_tcheby , tcheby , coeff_tcheby_vers_monome implicit none integer ( kind = I4 ) :: i , iu , nbvar integer ( kind = I4 ), parameter :: n1 = 1024 , n2 = 512 , i1 = 9 , i2 = 11 real ( kind = R8 ), allocatable , dimension (:,:) :: tab_height , tab_result real ( kind = R8 ), allocatable , dimension (:) :: tab_coef1 , tab_coef2 character ( len = 128 ) :: str nbvar = ( i1 + 1 ) * ( i2 + 1 ) allocate ( tab_height ( 1 : n1 , 1 : n2 ) ) ; tab_height ( 1 : n1 , 1 : n2 ) = HIG_R8 allocate ( tab_result ( 1 : n1 , 1 : n2 ) ) ; tab_result ( 1 : n1 , 1 : n2 ) = HIG_R8 allocate ( tab_coef1 ( 1 : nbvar ) ) ; tab_coef1 ( 1 : nbvar ) = HIG_R8 allocate ( tab_coef2 ( 1 : nbvar ) ) ; tab_coef2 ( 1 : nbvar ) = HIG_R8 call genere_surf_poly ( long1 = n1 , & ! long2 = n2 , & ! deg1 = i1 , & ! deg2 = i2 , & ! tab_out = tab_height ( 1 : n1 , 1 : n2 ), & ! tab_coef = tab_coef1 ( 1 : nbvar ) ) ! call least_squares_tcheby ( tab_in = tab_height ( 1 : n1 , 1 : n2 ), & ! tab_out = tab_result ( 1 : n1 , 1 : n2 ), & ! long1 = n1 , & ! long2 = n2 , & ! nvarx = i1 , & ! nvary = i2 , & ! verif = . true ., & ! multi_thread = . true .) ! write ( * , * ) write ( * , * ) 'If the surface is well approximated, the differences are very small.' write ( * , * ) 'Indeed, the approximated surface is a polynomial of the same degree along x, y as the approximating one.' write ( * , * ) 'Result :' , sum ( abs ( tab_result - tab_height ) ) write ( * , * ) write ( * , * ) 'If the translation from Tchebychev to ordinary polynomial is well carried out,' write ( * , * ) 'there should be no big difference between the two surfaces.' call get_unit ( iu ) open ( iu , file = 'verif_tcheby_vers_monome.txt' ) write ( str , '(a,i3.3,a)' ) '(' , nbvar , 'E18.8,a)' read ( iu , trim ( str )) ( tab_coef2 ( i ), i = 1 , nbvar ) close ( iu ) call convert_to_poly ( long1 = n1 , & ! long2 = n2 , & ! deg1 = i1 , & ! deg2 = i2 , & ! tab_coef = tab_coef2 ( 1 : nbvar ), & ! tab_out = tab_height ( 1 : n1 , 1 : n2 ) ) ! write ( * , * ) 'Max. abs. diff. :' , maxval ( abs (( tab_result - tab_height ) / ( 1._R8 + tab_height ) ) ) write ( * , * ) write ( * , * ) 'Given the fact that the reference surface is made of the product of two polynomials,' write ( * , * ) 'the coefficients found must be the same as the imposed ones.' write ( * , * ) 'Max. abs. diff. :' , maxval ( abs (( tab_coef1 - tab_coef2 ) / tab_coef1 ) ) deallocate ( tab_height , tab_result , tab_coef1 , tab_coef2 ) contains !================================================================================================== subroutine convert_to_poly ( long1 , long2 , deg1 , deg2 , tab_coef , tab_out ) !! Génération d'une surface polynômiale pour vérification des procédures d'approximation implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , k1 , k2 , k1k2 tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine convert_to_poly subroutine genere_surf_poly ( long1 , long2 , deg1 , deg2 , tab_out , tab_coef ) !! génère une surface implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ), intent ( out ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , ij , k1 , k2 , k1k2 real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai real ( kind = R8 ), dimension ( 0 : deg2 ) :: aj real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai_m real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_t real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_m call random_number ( ai ( 0 : deg1 ) ) call random_number ( aj ( 0 : deg2 ) ) ai = + 9 * ai - 4._R8 aj = - 5 * aj + 8._R8 ! =========================== SIMPLE CHECK ===================================================== ! A combination of Tchebychev polynomials must ! yield the same results as a classical polynomial !-------------------------------------------- val_xi_t = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_t ( i ) = val_xi_t ( i ) + ai ( k1 ) * tcheby ( n = k1 , x = xi ) enddo enddo !-------------------------------------------- ! Towards equivalent classical polynomial call coeff_tcheby_vers_monome ( coeff_t = ai ( 0 : deg1 ), coeff_m = ai_m ( 0 : deg1 ), deg = deg1 ) val_xi_m = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_m ( i ) = val_xi_m ( i ) + ai_m ( k1 ) * ( xi ** k1 ) enddo enddo !-------------------------------------------- write ( * , * ) 'Equivalence of Tchebychev and classical polynomials' write ( * , * ) 'Difference must be negligible' write ( * , * ) ' Diff = ' , maxval ( abs ( val_xi_m - val_xi_t ) ) !-------------------------------------------- ! =========================== END SIMPLE CHECK ================================================== tab_coef = 0._R8 ij = 0 do j = 0 , deg2 do i = 0 , deg1 ij = ij + 1 tab_coef ( ij ) = ai ( i ) * aj ( j ) enddo enddo tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine genere_surf_poly endprogram test_tchebychev","tags":"","loc":"program/test_tchebychev.html"},{"title":"test_intpl – TOOLIB","text":"Uses data_arch intpl program~~test_intpl~~UsesGraph program~test_intpl test_intpl module~data_arch data_arch program~test_intpl->module~data_arch module~intpl intpl program~test_intpl->module~intpl iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~intpl->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interpolation/weighting functions. Example of use. Calls program~~test_intpl~~CallsGraph program~test_intpl test_intpl proc~test_interp_pond test_interp_pond program~test_intpl->proc~test_interp_pond proc~def_tab1d def_tab1D proc~test_interp_pond->proc~def_tab1d proc~def_tab2d def_tab2D proc~test_interp_pond->proc~def_tab2d proc~interp1d interp1D proc~test_interp_pond->proc~interp1d proc~interp2d interp2D proc~test_interp_pond->proc~interp2d proc~restrict1d restrict1D proc~test_interp_pond->proc~restrict1d proc~restrict2d restrict2D proc~test_interp_pond->proc~restrict2d proc~interp interp proc~interp1d->proc~interp proc~interp2d->proc~interp1d proc~restrict restrict proc~restrict1d->proc~restrict proc~restrict2d->proc~restrict1d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4), parameter :: n1 = 1024 integer(kind=I4), parameter :: n2 = 2*n1 Functions function def_tab1D (i) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: i Return Value real(kind=r8) function def_tab2D (i, j) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: i integer(kind=I4), intent(in) :: j Return Value real(kind=r8) Subroutines subroutine test_interp_pond (ordre) Test interpolation/weighting function for a particular order Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: ordre order Source Code program test_intpl use data_arch , only : I4 , R8 , PI_R8 use intpl implicit none integer ( kind = I4 ), parameter :: n1 = 1024 , n2 = 2 * n1 write ( * , * ) ' ORDER 1' ; call test_interp_pond ( ordre = 1 ) write ( * , * ) ' ORDER 3' ; call test_interp_pond ( ordre = 3 ) write ( * , * ) ' ORDER 5' ; call test_interp_pond ( ordre = 5 ) write ( * , * ) ' ORDER 7' ; call test_interp_pond ( ordre = 7 ) stop contains subroutine test_interp_pond ( ordre ) !! Test interpolation/weighting function for a particular order implicit none integer ( kind = I4 ), intent ( in ) :: ordre !! order integer ( kind = I4 ) :: i , ii , j , jj , istat1 , istat2 real ( kind = R8 ), allocatable , dimension (:) :: tableau1D , tab_f1D , tab_g1D , erreur1D real ( kind = R8 ), allocatable , dimension (:,:) :: tableau2D , tab_f2D , tab_g2D , erreur2D type ( tborne ) :: bfin , bgro allocate ( tableau1D ( 0 : n2 ), tab_f1D ( 0 : n2 ), & ! tab_g1D ( 0 : n1 ), erreur1D ( 0 : n2 ), & ! stat = istat1 ) ! allocate ( tableau2D ( 0 : n2 , 0 : n2 ), tab_f2D ( 0 : n2 , 0 : n2 ), & ! tab_g2D ( 0 : n1 , 0 : n1 ), erreur2D ( 0 : n2 , 0 : n2 ), & ! stat = istat2 ) ! if ( istat1 + istat2 /= 0 ) stop '\"test_interp_pond\" problem of allocation' !............................................................. do ii = 0 , n1 i = 2 * ii tableau1D ( ii ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call interp1D ( tabgros = tableau1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( def_tab1D ( i ) - tab_f1D ( i ) ) / & ! ( def_tab1D ( i ) + tab_f1D ( i ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'interp 1D - max err, mean err: :         ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau do ii = 0 , n1 erreur1D ( ii ) = 200 * abs ( ( def_tab1D ( 2 * ii ) - tab_g1D ( ii ) ) / & ! ( def_tab1D ( 2 * ii ) + tab_g1D ( ii ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'weight 1D - max err, mean err:           ' , maxval ( erreur1D ( 0 : n1 ) ), sum ( erreur1D ( 0 : n1 ) ) / ( n1 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau call interp1D ( tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( tableau1D ( i ) - tab_f1D ( i ) ) / & ! ( tableau1D ( i ) + tab_f1D ( i ) ) ) ! comparaison avant/après enddo write ( * , * ) 'weight + interp 1D - max err, mean err:  ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !............................................................. ! Idem 2D !............................................................. do jj = 0 , n1 do ii = 0 , n1 i = 2 * ii j = 2 * jj tableau2D ( ii , jj ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call interp2D ( tabgro = tableau2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( def_tab2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( def_tab2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'interp 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! do jj = 0 , n1 do ii = 0 , n1 erreur2D ( ii , jj ) = 200 * abs ( ( def_tab2D ( 2 * ii , 2 * jj ) - tab_g2D ( ii , jj ) ) / & ! ( def_tab2D ( 2 * ii , 2 * jj ) + tab_g2D ( ii , jj ) ) ) ! enddo enddo write ( * , * ) 'weight 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n1 , 0 : n1 ) ), sum ( erreur2D ( 0 : n1 , 0 : n1 ) ) / ( n1 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! call interp2D ( tabgro = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( tableau2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( tableau2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'weight + interp 2D - max err, mean err:  ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 deallocate ( tableau1D , tab_f1D , tab_g1D , erreur1D ) deallocate ( tableau2D , tab_f2D , tab_g2D , erreur2D ) return endsubroutine test_interp_pond real ( kind = R8 ) function def_tab1D ( i ) implicit none integer ( kind = I4 ), intent ( in ) :: i !~       def_tab1D = 1._R8 / ( 1._R8 + (i/64._R8)**2._R8 ) def_tab1D = sin ( 2 * i * PI_R8 / n1 ) + 1.1_R8 return endfunction def_tab1D real ( kind = R8 ) function def_tab2D ( i , j ) implicit none integer ( kind = I4 ), intent ( in ) :: i , j !~       def_tab2D = 1._R8 / (1._R8 + ( (i-j)/64._R8 )**2._R8 ) def_tab2D = sin ( 2 * i * PI_R8 / n1 ) * cos ( 2 * j * PI_R8 / n1 ) + 1.1_R8 return endfunction def_tab2D endprogram test_intpl","tags":"","loc":"program/test_intpl.html"},{"title":"test_data_arch – TOOLIB","text":"Uses data_arch miscellaneous program~~test_data_arch~~UsesGraph program~test_data_arch test_data_arch module~data_arch data_arch program~test_data_arch->module~data_arch module~miscellaneous miscellaneous program~test_data_arch->module~miscellaneous iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Various subroutines. Example of use. Calls program~~test_data_arch~~CallsGraph program~test_data_arch test_data_arch proc~get_unit get_unit program~test_data_arch->proc~get_unit proc~progress_bar_terminal progress_bar_terminal program~test_data_arch->proc~progress_bar_terminal proc~trans_center2corner trans_center2corner program~test_data_arch->proc~trans_center2corner proc~trans_corner2center trans_corner2center program~test_data_arch->proc~trans_corner2center proc~trans_center2corner_cmpl trans_center2corner_cmpl proc~trans_center2corner->proc~trans_center2corner_cmpl proc~trans_center2corner_real trans_center2corner_real proc~trans_center2corner->proc~trans_center2corner_real proc~trans_corner2center_cmpl trans_corner2center_cmpl proc~trans_corner2center->proc~trans_corner2center_cmpl proc~trans_corner2center_real trans_corner2center_real proc~trans_corner2center->proc~trans_corner2center_real Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), dimension(nx, ny) :: array_in real(kind=R8), dimension(nx, ny) :: array_out integer(kind=I4) :: i integer(kind=I4) :: j integer(kind=I4), parameter :: nx = 11 integer(kind=I4), parameter :: ny = 11 character(len=3) :: snx integer(kind=I4) :: uu Source Code program test_data_arch use data_arch use miscellaneous , only : get_unit , trans_center2corner , trans_corner2center , progress_bar_terminal implicit none integer ( kind = I4 ) :: uu , i , j integer ( kind = I4 ), parameter :: nx = 11 , ny = 11 character ( len = 3 ) :: snx real ( kind = R8 ), dimension ( nx , ny ) :: array_in , array_out call get_unit ( uu ) open ( unit = uu , file = 'out/GLOB_VAR_VALUES.txt' ) write ( uu , '(I9,T40,a)' ) I4 , 'I4' write ( uu , '(I9,T40,a)' ) I8 , 'I8' write ( uu , '(I9,T40,a)' ) R4 , 'R4' write ( uu , '(I9,T40,a)' ) R8 , 'R8' write ( uu , '(I12,T40,a)' ) HIG_I4 , 'HIG_I4' write ( uu , '(I9,T40,a)' ) OPU , 'OPU' write ( uu , '(I9,T40,a)' ) IPU , 'IPU' write ( uu , '(I9,T40,a)' ) ERU , 'ERU' write ( uu , '(E20.12,T40,a)' ) UN , 'UN' write ( uu , '(E20.12,T40,a)' ) PI_R4 , 'PI_R4' write ( uu , '(E20.12,T40,a)' ) PI_R8 , 'PI_R8' write ( uu , '(E20.12,T40,a)' ) EPS_R4 , 'EPS_R4' write ( uu , '(E20.12,T40,a)' ) EPS_R8 , 'EPS_R8' write ( uu , '(E20.12,T40,a)' ) HIG_R8 , 'HIG_R8' write ( uu , '(E20.12,T40,a)' ) HIG_E8 , 'HIG_E8' write ( uu , '(E20.12,T40,a)' ) EPS_E8 , 'EPS_E8' write ( uu , '(I9,T40,a)' ) EXPO_MAX , 'EXPO_MAX' close ( uu ) write ( snx , '(I3.3)' ) nx write ( * , * ) '============== INITIAL ARRAY ==================' array_in = reshape ( [ ( 0. , i = 1 , nx * ny ) ], [ nx , ny ] ) array_in ( nx / 2 : nx / 2 + 2 , ny / 2 : ny / 2 + 2 ) = 1. do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_in ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============ CENTER => CORNER =================' call trans_center2corner ( tab_in = array_in , tab_out = array_out , long = nx , larg = ny ) do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_out ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============== INITIAL ARRAY ==================' array_in = array_out do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_in ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============ CORNER => CENTER =================' call trans_corner2center ( tab_in = array_in , tab_out = array_out , long = nx , larg = ny ) do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_out ( i , j )), j = 1 , ny ) enddo call progress_bar_terminal ( val = 0 , max_val = 100 , init = . true .) do i = 10 , 100 , 10 call sleep ( 1 ) call progress_bar_terminal ( val = i , max_val = 100 , init = . false .) enddo stop endprogram test_data_arch","tags":"","loc":"program/test_data_arch.html"},{"title":"test_gnufor – TOOLIB","text":"Uses gnufor program~~test_gnufor~~UsesGraph program~test_gnufor test_gnufor module~gnufor gnufor program~test_gnufor->module~gnufor Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A fortran api to GNUPLOT. Example of use. Calls program~~test_gnufor~~CallsGraph program~test_gnufor test_gnufor proc~test01 test01 program~test_gnufor->proc~test01 proc~test02 test02 program~test_gnufor->proc~test02 proc~test03 test03 program~test_gnufor->proc~test03 proc~test04 test04 program~test_gnufor->proc~test04 proc~test05 test05 program~test_gnufor->proc~test05 proc~test06 test06 program~test_gnufor->proc~test06 proc~run_gnuplot run_gnuplot proc~test01->proc~run_gnuplot proc~write_xy_data write_xy_data proc~test01->proc~write_xy_data proc~write_xy_plot write_xy_plot proc~test01->proc~write_xy_plot proc~test02->proc~run_gnuplot proc~write_xyy_data write_xyy_data proc~test02->proc~write_xyy_data proc~write_xyy_plots write_xyy_plots proc~test02->proc~write_xyy_plots proc~pi pi proc~test03->proc~pi proc~test03->proc~run_gnuplot proc~write_xyz_data write_xyz_data proc~test03->proc~write_xyz_data proc~write_xyz_plot write_xyz_plot proc~test03->proc~write_xyz_plot proc~test04->proc~run_gnuplot proc~write_vector_data write_vector_data proc~test04->proc~write_vector_data proc~write_vector_plot write_vector_plot proc~test04->proc~write_vector_plot proc~test05->proc~run_gnuplot proc~write_xyzgrid_data write_xyzgrid_data proc~test05->proc~write_xyzgrid_data proc~write_xyzgrid_surface write_xyzgrid_surface proc~test05->proc~write_xyzgrid_surface proc~test06->proc~run_gnuplot proc~write_xyzgrid_contour write_xyzgrid_contour proc~test06->proc~write_xyzgrid_contour proc~test06->proc~write_xyzgrid_data proc~get_unit~2 get_unit proc~write_vector_data->proc~get_unit~2 proc~write_vector_plot->proc~get_unit~2 proc~write_xy_data->proc~get_unit~2 proc~write_xy_plot->proc~get_unit~2 proc~write_xyy_data->proc~get_unit~2 proc~write_xyy_plots->proc~get_unit~2 proc~write_xyz_data->proc~get_unit~2 proc~write_xyz_plot->proc~get_unit~2 proc~write_xyzgrid_contour->proc~get_unit~2 proc~write_xyzgrid_data->proc~get_unit~2 proc~write_xyzgrid_surface->proc~get_unit~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_gnufor use gnufor implicit none call test01 () call test02 () call test03 () call test04 () call test05 () call test06 () stop endprogram test_gnufor","tags":"","loc":"program/test_gnufor.html"},{"title":"test_algen – TOOLIB","text":"Uses sort_arrays data_arch omp_lib pikaia_oop miscellaneous program~~test_algen~~UsesGraph program~test_algen test_algen module~data_arch data_arch program~test_algen->module~data_arch module~miscellaneous miscellaneous program~test_algen->module~miscellaneous module~pikaia_oop pikaia_oop program~test_algen->module~pikaia_oop module~sort_arrays sort_arrays program~test_algen->module~sort_arrays omp_lib omp_lib program~test_algen->omp_lib iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch module~pikaia_oop->iso_fortran_env module~mt19937_64 mt19937_64 module~pikaia_oop->module~mt19937_64 module~sort_arrays->module~data_arch module~mt19937_64->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. PIKAIA oop example of use Note The example chosen is the generation of a surface with given statistical moments.\n The implementation is part of the analytical developments presented in: A. Francisco and N. Brunetière, “A hybrid method for fast and efficient rough surface generation”,\n Proc IMechE Part J:J Engineering Tribology, 2016, Vol. 230(7) 747–768, DOI: 10.1177/1350650115612116 The surface heights are generated thanks the tangent function. This function is indeed very near the common material\n curves. Thus, providing the right lower and upper bounds makes it possible to match the desired statistical moments. Note The main difficulty to cope with is the high non linearity and the convergence only possible near the solution.\n Classical optimization methods fail in reaching the true solution: the lower and upper limits x(1:2 . The PIKAIA program, which implements a genetic algorithm, is utilized to found a “good” solution, then a\n very classical optimization routine is used to find the nearly exact solution. Warning PIKAIA cost function must be chosen so as to be maximized. For clarity reasons, the optimization function must be minimized because it is the deviation to the solution.\n @note Warning Note First each thread runs the PIKAIA program to find a rather good starting point x . The parameters\n (as defined by CTRL ) are the same. The only difference is the starting population. Thus, several concurrent\n populations evolve during CTRL(02) generations. Then, the optimization subroutine starts from the best population. Note make all ./prg The surface is in ascii mode in the “/out” directory Calls program~~test_algen~~CallsGraph program~test_algen test_algen proc~abs_diff_sk_ku abs_diff_sk_ku program~test_algen->proc~abs_diff_sk_ku proc~get_unit get_unit program~test_algen->proc~get_unit proc~melange melange program~test_algen->proc~melange proc~newton_raphson_downhill newton_raphson_downhill program~test_algen->proc~newton_raphson_downhill proc~profil_theo_trie_1d profil_theo_trie_1D program~test_algen->proc~profil_theo_trie_1d proc~set_inputs pikaia_class%set_inputs program~test_algen->proc~set_inputs proc~solve_with_pikaia pikaia_class%solve_with_pikaia program~test_algen->proc~solve_with_pikaia proc~sk_ku sk_ku proc~abs_diff_sk_ku->proc~sk_ku proc~sort_array2 sort_array2 proc~melange->proc~sort_array2 proc~newton_raphson_downhill->proc~abs_diff_sk_ku proc~calc_moments_1d calc_moments_1D proc~profil_theo_trie_1d->proc~calc_moments_1d proc~pikaia pikaia_class%pikaia proc~solve_with_pikaia->proc~pikaia proc~adjmut pikaia_class%adjmut proc~pikaia->proc~adjmut proc~cross pikaia_class%cross proc~pikaia->proc~cross proc~decode pikaia_class%decode proc~pikaia->proc~decode proc~encode pikaia_class%encode proc~pikaia->proc~encode proc~func_wrapper pikaia_class%func_wrapper proc~pikaia->proc~func_wrapper proc~genrep pikaia_class%genrep proc~pikaia->proc~genrep proc~mutate pikaia_class%mutate proc~pikaia->proc~mutate proc~newpop pikaia_class%newpop proc~pikaia->proc~newpop proc~report pikaia_class%report proc~pikaia->proc~report proc~rninit pikaia_class%rninit proc~pikaia->proc~rninit proc~rnkpop pikaia_class%rnkpop proc~pikaia->proc~rnkpop proc~select_parents pikaia_class%select_parents proc~pikaia->proc~select_parents proc~stdrep pikaia_class%stdrep proc~pikaia->proc~stdrep proc~urand pikaia_class%urand proc~pikaia->proc~urand proc~add_tang add_tang proc~sk_ku->proc~add_tang proc~tang tang proc~sk_ku->proc~tang proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~add_tang->proc~tang proc~cross->proc~urand proc~mutate->proc~urand proc~newpop->proc~func_wrapper proc~newpop->proc~rnkpop none~initialize mt19937%initialize proc~rninit->none~initialize proc~rqsort rqsort proc~rnkpop->proc~rqsort proc~select_parents->proc~urand proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order proc~stdrep->proc~urand proc~genrand64_real1 mt19937%genrand64_real1 proc~urand->proc~genrand64_real1 proc~init_by_array64 mt19937%init_by_array64 none~initialize->proc~init_by_array64 proc~init_genrand64 mt19937%init_genrand64 none~initialize->proc~init_genrand64 proc~init_genrand64_i4 mt19937%init_genrand64_i4 none~initialize->proc~init_genrand64_i4 proc~genrand64_int64 mt19937%genrand64_int64 proc~genrand64_real1->proc~genrand64_int64 proc~genrand64_int64->proc~init_genrand64 proc~init_by_array64->proc~init_genrand64 proc~init_genrand64_i4->none~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), parameter :: SKU = +20.0_R8 Imposed surface height kurtosis real(kind=R8), parameter :: SSK = -01.0_R8 Imposed surface height skewness real(kind=R8) :: f best cost real(kind=R8) :: f_xx cost function or optimization function at xx integer(kind=I4) :: i loop indices integer(kind=I4) :: iu i/o unit integer(kind=I4) :: j loop indices integer(kind=I4) :: k loop indices type( moment_stat ) :: mom a statistical moment variable integer(kind=I4) :: nb_th nb threads integer(kind=I4), parameter :: nn = 512 Surface side dimension type( pikaia_class ) :: p PIKAIA class instanciation integer(kind=I4) :: status PIKAIA status real(kind=R8) :: tab_sur (1:nn*nn) output surface heights real(kind=R8) :: tend time variables real(kind=R8) :: tstart time variables real(kind=R8), dimension(1:2) :: xl lower and upper bonds of xx real(kind=R8), dimension(1:2) :: xu lower and upper bonds of xx real(kind=R8), dimension(1:2) :: xx chromosom for PIKAIA Derived Types type :: moment_stat Statistical moment type Components Type Visibility Attributes Name Initial real(kind=R8), public :: ku kurtosis real(kind=R8), public :: mu mean real(kind=R8), public :: si standard deviation real(kind=R8), public :: sk skewness real(kind=R8), public :: va variance Functions function abs_diff_sk_ku (chrom) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: chrom Return Value real(kind=r8) function add_tang (n, deb, fin, alp, bet, mu, si) Arguments Type Intent Optional Attributes Name integer(kind=i4), intent(in) :: n integer(kind=i4), intent(in) :: deb integer(kind=i4), intent(in) :: fin real(kind=R8), intent(in) :: alp real(kind=R8), intent(in) :: bet real(kind=R8), intent(in) :: mu real(kind=R8), intent(in) :: si Return Value real(kind=r8) function cost_func (chrom) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: chrom Return Value real(kind=r8) function tang (xi, n, alp, bet, mu, si) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi integer(kind=i4), intent(in) :: n real(kind=R8), intent(in) :: alp real(kind=R8), intent(in) :: bet real(kind=R8), intent(in) :: mu real(kind=R8), intent(in) :: si Return Value real(kind=r8) Subroutines subroutine calc_moments_1D (tab, mx, nb_mom, lg) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:lg) :: tab type( moment_stat ), intent(out) :: mx integer(kind=I4), intent(in) :: nb_mom integer(kind=I4), intent(in) :: lg subroutine cost (me, x, f) Arguments Type Intent Optional Attributes Name class( pikaia_class ), intent(inout) :: me real(kind=R8), intent(in), dimension(:) :: x real(kind=R8), intent(out) :: f subroutine melange (tab, lg) Arguments Type Intent Optional Attributes Name real(kind=r8), intent(inout), dimension(1:lg) :: tab integer(kind=i4), intent(in) :: lg subroutine newton_raphson_downhill (x, fvec, eps, ndir, rel) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout), dimension(1:2) :: x real(kind=R8), intent(out) :: fvec real(kind=R8), intent(in) :: eps integer(kind=I4), intent(in) :: ndir real(kind=R8), intent(in) :: rel subroutine profil_theo_trie_1D (tab, lg, x, mx) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(out), dimension(1:lg) :: tab integer(kind=I4), intent(in) :: lg real(kind=R8), intent(in), dimension(1:2) :: x type( moment_stat ), intent(out) :: mx subroutine sk_ku (xx, sk, ku) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in), dimension(1:2) :: xx real(kind=R8), intent(out) :: sk real(kind=R8), intent(out) :: ku Source Code program test_algen use omp_lib use sort_arrays , only : sort_array2 use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use pikaia_oop , only : pikaia_class implicit none integer ( kind = I4 ), parameter :: nn = 512 !! *Surface side dimension* real ( kind = R8 ), parameter :: SSK = - 0 1.0_R8 !! *Imposed surface height skewness* real ( kind = R8 ), parameter :: SKU = + 2 0.0_R8 !! *Imposed surface height kurtosis* integer ( kind = I4 ) :: status !! **PIKAIA** *status* integer ( kind = I4 ) :: i , j , k !! *loop indices* integer ( kind = I4 ) :: iu !! *i/o unit* integer ( kind = I4 ) :: nb_th !! *nb threads* real ( kind = R8 ), dimension ( 1 : 2 ) :: xx !! *chromosom for* **PIKAIA** real ( kind = R8 ), dimension ( 1 : 2 ) :: xl , xu !! *lower and upper bonds of xx* real ( kind = R8 ) :: f_xx !! *cost function or optimization function at* ```xx``` real ( kind = R8 ) :: tab_sur ( 1 : nn * nn ) !! *output surface heights* type moment_stat !! <span style=\"color:green\">Statistical moment type</span> real ( kind = R8 ) :: mu !! *mean* real ( kind = R8 ) :: va !! *variance* real ( kind = R8 ) :: si !! *standard deviation* real ( kind = R8 ) :: sk !! *skewness* real ( kind = R8 ) :: ku !! *kurtosis* endtype moment_stat type ( moment_stat ) :: mom !! *a statistical moment variable* type ( pikaia_class ) :: p !! **PIKAIA** *class instanciation* real ( kind = R8 ) :: f !! *best cost* real ( kind = R8 ) :: tstart , tend !! *time variables* !$ real(kind=R8)    :: ostart,oend    !! *openmp time variables* !$ integer(kind=I4) :: tid            !! *active thread* nb_th = 1 ! get the number of available threads !$OMP PARALLEL PRIVATE(nb_th, TID) !$ !$ tid = omp_get_thread_num() !$ !$ if (tid == 0) then !$    nb_th = omp_get_num_threads() !$    write(*,'(A)') '--------------' !$    write(*,'(A,1X,I5)') 'number of OMP threads: ', nb_th !$    write(*,'(A)') '--------------' !$ endif !$OMP END PARALLEL xx ( 1 : 2 ) = 0.0_R8 xl ( 1 : 2 ) = 0.0_R8 xu ( 1 : 2 ) = 1.0_R8 !initialize the class: call p % init ( n = 2 , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = status , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) !Now call pikaia: call cpu_time ( tstart ) !$ ostart = omp_get_wtime() call p % solve ( x = xx ( 1 : 2 ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = status ) !,   &  !   OUT         ; !~                     omp = .false. )    ! IN, OPTIONAL !$ oend = omp_get_wtime() call cpu_time ( tend ) write ( * , * ) 'Total time spent: ' , tend - tstart write ( * , * ) 'Real time spent:  ' , oend - ostart write ( * , * ) 'Absolute diff after GA: ' , abs_diff_sk_ku ( chrom = xx ( 1 : 2 )) ! optimization function ran with this \"good\" solution call newton_raphson_downhill ( x = xx ( 1 : 2 ), & ! starting/ending point fvec = f_xx , & ! best deviation to the wanted solution eps = 1.e-6_R8 , & ! dx ndir = 32 * nb_th , & ! number of directions to explore rel = 0.9_R8 ) ! relaxation parameter write ( * , * ) 'Absolute diff after refinement: ' , abs_diff_sk_ku ( chrom = xx ( 1 : 2 )) write ( * , * ) 'A (nn x nn) SSK, SKU random surface will be now generated' ! generation of nn*nn heights with the tangent function with xx(1:2) as bound parameters. ! mu = 0. ! va = si = 1. ! sk = SSK ! ku = SKU call profil_theo_trie_1D ( tab = tab_sur ( 1 : nn * nn ), & ! resulting vector of heights lg = nn * nn , & ! vector length x = xx ( 1 : 2 ), & ! best variable couple mx = mom ) ! resulting moment ! height shuffle call melange ( tab = tab_sur ( 1 : nn * nn ), & ! lg = nn * nn ) ! ! random surface output in ascii format call get_unit ( iunit = iu ) open ( unit = iu , file = 'out/surf.dat' ) k = 1 do i = 1 , nn do j = 1 , nn write ( iu , * ) i , j , tab_sur ( k ) k = k + 1 enddo enddo close ( unit = iu ) ! statistical moments check write ( * , * ) 'statistical moments:' write ( * , * ) mom % mu , mom % si , mom % sk , mom % ku ! precision write ( * , '(a, e8.2)' ) 'maximum difference (%) ' , max ( 100 * abs (( mom % sk - SSK ) / SSK ), & ! 100 * abs (( mom % ku - SKU ) / SKU ) ) stop contains subroutine cost ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = 1. / ( 1. + abs_diff_sk_ku ( chrom = x ( 1 : 2 ))) return endsubroutine cost subroutine newton_raphson_downhill ( x , fvec , eps , ndir , rel ) implicit none integer ( kind = I4 ), intent ( in ) :: ndir real ( kind = R8 ), intent ( in ) :: eps real ( kind = R8 ), intent ( in ) :: rel real ( kind = R8 ), intent ( inout ), dimension ( 1 : 2 ) :: x real ( kind = R8 ), intent ( out ) :: fvec real ( kind = R8 ), dimension ( 1 : 2 ) :: x0 real ( kind = R8 ), dimension ( 1 : ndir ) :: ct , st , ff , x1 , x2 real ( kind = R8 ) :: f0 , fd1 , fd2 , ti , dfdx1 , dfdx2 , dx1 , dx2 , dt integer ( kind = I4 ) :: i do i = 1 , ndir ti = PI_R8 * ( - 1. + ( i - 1 ) * 2. / ndir ) ct ( i ) = cos ( ti ) st ( i ) = sin ( ti ) enddo x0 = x do f0 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) / )) fd1 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) + eps , x0 ( 2 ) / )) fd2 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) + eps / )) dfdx1 = ( fd1 - f0 ) / eps dfdx2 = ( fd2 - f0 ) / eps !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) !$OMP DO PRIVATE(i, dt, dx1, dx2) do i = 1 , ndir dt = - f0 / ( eps * ( dfdx1 * ct ( i ) + dfdx2 * st ( i )) ) dx1 = eps * ct ( i ) * dt dx2 = eps * st ( i ) * dt x1 ( i ) = x0 ( 1 ) + rel * dx1 x2 ( i ) = x0 ( 2 ) + rel * dx2 ff ( i ) = abs_diff_sk_ku ( chrom = ( / x1 ( i ), x2 ( i ) / )) enddo !$OMP END DO !$OMP END PARALLEL i = minloc ( ff , 1 ) x0 = ( / x1 ( i ), x2 ( i ) / ) if ( ff ( i ) < 1.e-8 ) exit write ( * , * ) x0 ( 1 ), x0 ( 2 ), ff ( i ) enddo x = x0 fvec = ff ( i ) return endsubroutine newton_raphson_downhill real ( kind = R8 ) function abs_diff_sk_ku ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: chrom real ( kind = R8 ) :: sk , ku call sk_ku ( xx = chrom ( 1 : 2 ), sk = sk , ku = ku ) abs_diff_sk_ku = abs ( sk - SSK ) + abs ( ku - SKU ) return endfunction abs_diff_sk_ku real ( kind = R8 ) function cost_func ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: chrom cost_func = 1. / ( 1. + abs_diff_sk_ku ( chrom ( 1 : 2 ))) return endfunction cost_func subroutine sk_ku ( xx , sk , ku ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: xx real ( kind = R8 ), intent ( out ) :: sk real ( kind = R8 ), intent ( out ) :: ku real ( kind = R8 ) :: xa , xb , mu , si , a , b , un real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: ia , ib , deb , fin , npts , long , i , k real ( kind = R8 ), dimension ( 1 : 2 ) :: x long = nn do k = 1 , 2 x ( k ) = max ( xx ( k ), 1.e-4_R8 ) enddo ia = long ib = long npts = long * long deb = 1 + ia fin = npts - ib a = x ( 1 ) b = x ( 2 ) hh = ( 2._R8 - a - b ) / ( npts - 1 ) h = ( pi_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - pi_R8 / 2 * ( 1. - a ) b2 = + pi_R8 / 2 * ( 1. - b ) alp = - ( b2 - npts * b1 ) / ( b2 - b1 ) bet = ( npts - 1 ) / ( b2 - b1 ) un = 1._R8 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * sin (( pi_R8 * xa ) / 2. )) mu = ( un / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = ( pi_R8 * ( - 2 + xa + xb )) / 2. - ( mu ** 2 * pi_R8 * ( - 2 + xa + xb )) / 2. + 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 2 * mu * Log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * Sin (( pi_R8 * xa ) / 2. )) si = ( un / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / npts si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = ( 6 * mu * pi_R8 - 2 * mu ** 3 * pi_R8 - 3 * mu * pi_R8 * xa + mu ** 3 * pi_R8 * xa - 3 * mu * pi_R8 * xb + mu ** 3 * pi_R8 * xb - 6 * mu * 1._R8 / tan (( pi_R8 * xa ) / 2. ) - 6 * mu * 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 - 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 6 * mu ** 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 2 * Log ( Sin (( pi_R8 * xb ) / 2. )) - 6 * mu ** 2 * Log ( Sin (( pi_R8 * xb ) / 2. ))) / ( 2. * si ** 3 ) sk = ( un / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo sk = sk / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = ( 6 * pi_R8 - 36 * mu ** 2 * pi_R8 + 6 * mu ** 4 * pi_R8 - 3 * pi_R8 * xa + 18 * mu ** 2 * pi_R8 * xa - 3 * mu ** 4 * pi_R8 * xa - 3 * pi_R8 * xb + 18 * mu ** 2 * pi_R8 * xb - 3 * mu ** 4 * pi_R8 * xb + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xb ) / 2. ) + 12 * mu * 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 - 12 * mu * 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 + 24 * mu * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu ** 3 * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu * Log ( Sin (( pi_R8 * xb ) / 2. )) + 24 * mu ** 3 * Log ( Sin (( pi_R8 * xb ) / 2. )) + 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 4 * Sin ( pi_R8 * xa ) + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 4 * Sin ( pi_R8 * xb )) / ( 6. * si ** 4 ) ku = ( un / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo ku = ku / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . return endsubroutine sk_ku real ( kind = R8 ) function add_tang ( n , deb , fin , alp , bet , mu , si ) implicit none real ( kind = R8 ), intent ( in ) :: alp , bet , mu , si integer ( kind = i4 ), intent ( in ) :: n , fin , deb real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_tang = ( 1. / 12 ) * ( + 9 * ( tang ( xdeb + 0.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.0_R8 , n , alp , bet , mu , si )) & + 1 * ( tang ( xdeb + 1.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 1.0_R8 , n , alp , bet , mu , si )) & - 4 * ( tang ( xdeb + 0.5_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.5_R8 , n , alp , bet , mu , si )) ) return endfunction add_tang real ( kind = R8 ) function tang ( xi , n , alp , bet , mu , si ) implicit none real ( kind = R8 ), intent ( in ) :: xi , alp , bet , mu , si integer ( kind = i4 ), intent ( in ) :: n real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet tang = ( ( tan ( tmp ) - mu ) / si ) ** n return endfunction tang subroutine calc_moments_1D ( tab , mx , nb_mom , lg ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg integer ( kind = I4 ) , intent ( in ) :: nb_mom real ( kind = R8 ) , intent ( in ), dimension ( 1 : lg ) :: tab type ( moment_stat ), intent ( out ) :: mx integer ( kind = I4 ) :: i real ( kind = R8 ) :: tmp mx % mu = 0 mx % si = 0 mx % va = 0 mx % Sk = 0 mx % Ku = 0 do i = 1 , lg mx % mu = mx % mu + tab ( i ) / lg enddo if ( nb_mom == 1 ) return do i = 1 , lg mx % va = mx % va + (( tab ( i ) - mx % mu ) ** 2 ) / lg enddo mx % si = sqrt ( mx % va ) if ( nb_mom == 2 ) return if ( mx % si < 1.e-15_R8 ) then mx % Sk = 0 mx % Ku = 0 else do i = 1 , lg tmp = ( tab ( i ) - mx % mu ) / mx % si mx % Sk = mx % Sk + ( tmp ** 3 ) / lg mx % Ku = mx % Ku + ( tmp ** 4 ) / lg enddo endif return endsubroutine calc_moments_1D subroutine profil_theo_trie_1D ( tab , lg , x , mx ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg real ( kind = R8 ) , intent ( out ), dimension ( 1 : lg ) :: tab real ( kind = R8 ) , intent ( in ), dimension ( 1 : 2 ) :: x type ( moment_stat ), intent ( out ) :: mx real ( kind = R8 ) :: b1 , b2 , alp , bet integer ( kind = I4 ) :: i b1 = - PI_R8 / 2 * ( 1. - x ( 1 )) b2 = + PI_R8 / 2 * ( 1. - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i + alp ) / bet ) enddo call calc_moments_1D ( tab , mx , nb_mom = 4 , lg = lg ) tab ( 1 : lg ) = ( tab ( 1 : lg ) - mx % mu ) / mx % si mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D subroutine melange ( tab , lg ) implicit none integer ( kind = i4 ), intent ( in ) :: lg real ( kind = r8 ) , intent ( inout ), dimension ( 1 : lg ) :: tab real ( kind = r8 ), dimension ( 1 : lg ) :: tmp integer ( kind = i4 ) :: i call random_number ( harvest = tmp ) call sort_array2 ( tab_inout = tmp ( 1 : lg ), & ! tab1 = tab ( 1 : lg ), n = lg ) ! return endsubroutine melange endprogram test_algen","tags":"","loc":"program/test_algen.html"},{"title":"test_files – TOOLIB","text":"Uses files program~~test_files~~UsesGraph program~test_files test_files module~files files program~test_files->module~files module~data_arch data_arch module~files->module~data_arch module~miscellaneous miscellaneous module~files->module~miscellaneous iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Some routines to deal with files. Example of use Calls program~~test_files~~CallsGraph program~test_files test_files proc~dir_separator dir_separator program~test_files->proc~dir_separator proc~filename filename program~test_files->proc~filename proc~list_files list_files program~test_files->proc~list_files proc~make_path make_path program~test_files->proc~make_path proc~mkdir mkdir program~test_files->proc~mkdir proc~path2vec path2vec program~test_files->proc~path2vec proc~str_remove_chars str_remove_chars program~test_files->proc~str_remove_chars proc~str_replace str_replace program~test_files->proc~str_replace proc~vec2path vec2path program~test_files->proc~vec2path proc~is_linux is_linux proc~dir_separator->proc~is_linux proc~filename->proc~dir_separator proc~get_unit get_unit proc~list_files->proc~get_unit proc~make_path->proc~dir_separator proc~make_path->proc~mkdir proc~path2vec->proc~dir_separator proc~vec2path->proc~dir_separator Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial character(len=512) :: cwd logical(kind=4) :: dir_exists integer(kind=4) :: exit_status integer(kind=4) :: i_g character(len=512), allocatable, dimension(:) :: list_f90 character(len=1) :: os_sep character(len=512) :: path character(len=:), allocatable :: slogan character(len=:), allocatable :: str character(len=512) :: str_tmp character(len=512), allocatable, dimension(:) :: vpath Source Code program test_files use files implicit none logical ( kind = 4 ) :: dir_exists integer ( kind = 4 ) :: exit_status , i_g character ( len = :), allocatable :: slogan , str character ( len = 512 ), allocatable , dimension (:) :: vpath character ( len = 512 ), allocatable , dimension (:) :: list_f90 character ( len = 512 ) :: path , cwd , str_tmp character ( len = 1 ) :: os_sep write ( * , * ) 'Give a sting from which spaces and hyphen have to be removed' read ( * , '(a)' ) str_tmp str = str_remove_chars ( string = trim ( str_tmp ), chars = '- ' ) write ( * , * ) str path = \"/my_name/is bond/james/bond/  .007\" call path2vec ( file_path = trim ( path ), vec_path = vpath ) write ( * , * ) size ( vpath ), ' folders in path' write ( * , '(*(a))' ) ( trim ( vpath ( i_g )), ' | ' , i_g = 1 , ubound ( vpath , 1 ) ) call vec2path ( file_path = str , vec_path = vpath ) write ( * , * ) 'complete path: ' , trim ( str ) write ( * , * ) 'file is: \"' , filename ( trim ( path ) ), '\"' deallocate ( str ) !=================================== write ( * , * ) '----------------------' !=================================== call getcwd ( cwd ) call make_path ( wkd = trim ( cwd ), file_path = \"out/a/b/c/d/file.txt\" , exit_status = exit_status ) !=================================== write ( * , * ) '----------------------' !=================================== call list_files ( dir = \"div\" , list = list_f90 , ext = \"f90\" ) do i_g = 1 , ubound ( list_f90 , 1 ) write ( * , * ) trim ( list_f90 ( i_g ) ) enddo !=================================== write ( * , * ) '----------------------' !=================================== slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 0 ) ! first instance only write ( * , * ) slogan slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 1 ) ! last instance only write ( * , * ) slogan slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 2 ) ! both instances write ( * , * ) slogan !=================================== write ( * , * ) '----------------------' !=================================== os_sep = dir_separator () write ( * , * ) 'The local directory separator is:' , os_sep !=================================== write ( * , * ) '----------------------' !=================================== call getcwd ( path ) write ( * , * ) 'The working directory is: ' , trim ( path ) !=================================== write ( * , * ) '----------------------' !=================================== call mkdir ( wkd = trim ( path ), directory = 'scratch' , sep = os_sep , exit_status = exit_status ) inquire ( file = 'scratch' , exist = dir_exists ) if ( dir_exists ) then write ( * , * ) 'Directory ''scratch'' successfuly created' else write ( * , * ) 'Directory ''scratch'' not created' endif !=================================== write ( * , * ) '----------------------' !=================================== call chdir ( \"scratch\" ) call getcwd ( path ) write ( * , * ) 'The new working directory is: ' , trim ( path ) !=================================== write ( * , * ) '----------------------' !=================================== endprogram test_files","tags":"","loc":"program/test_files.html"},{"title":"main – TOOLIB","text":"Uses sort_arrays data_arch miscellaneous program~~main~~UsesGraph program~main main module~data_arch data_arch program~main->module~data_arch module~miscellaneous miscellaneous program~main->module~miscellaneous module~sort_arrays sort_arrays program~main->module~sort_arrays iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~miscellaneous->module~data_arch module~sort_arrays->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Various routines to sort real/integer arrays. Example of use. Calls program~~main~~CallsGraph program~main main proc~get_unit get_unit program~main->proc~get_unit proc~init_order init_order program~main->proc~init_order proc~sort_array2 sort_array2 program~main->proc~sort_array2 proc~sort_array2->proc~init_order proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4) :: i integer(kind=I4) :: k integer(kind=I4), parameter :: n = 100 real(kind=R8) :: r integer(kind=I4) :: u10 integer(kind=I4) :: u20 integer(kind=I4), dimension(n) :: vec_int1 integer(kind=I4), dimension(n) :: vec_int2 integer(kind=I4), dimension(n) :: vec_order real(kind=R8), dimension(n) :: vec_real1 real(kind=R8), dimension(n) :: vec_real2 integer(kind=I4), dimension(n) :: vec_sol_int1 integer(kind=I4), dimension(n) :: vec_sol_int2 integer(kind=I4), dimension(n) :: vec_sol_order real(kind=R8), dimension(n) :: vec_sol_real1 real(kind=R8), dimension(n) :: vec_sol_real2 Source Code program main use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use sort_arrays , only : sort_array2 , init_order implicit none integer ( kind = I4 ), parameter :: n = 100 real ( kind = R8 ), dimension ( n ) :: vec_real1 , vec_real2 real ( kind = R8 ), dimension ( n ) :: vec_sol_real1 , vec_sol_real2 integer ( kind = I4 ), dimension ( n ) :: vec_int1 , vec_int2 , vec_order integer ( kind = I4 ), dimension ( n ) :: vec_sol_int1 , vec_sol_int2 , vec_sol_order integer ( kind = I4 ) :: i , k , u10 , u20 real ( kind = R8 ) :: r !=============== Sort an integer vector, and other vectors with the same order ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_int1 ( i ), vec_real1 ( i ), & ! vec_int2 ( i ), vec_real2 ( i ), k ! enddo close ( u10 ) ! ------------- sort with respect to the first column (integer values) call sort_array2 ( tab_inout = vec_int1 ( 1 : n ), & ! tab1 = vec_real1 ( 1 : n ), & ! tab2 = vec_int2 ( 1 : n ), & ! tab3 = vec_real2 ( 1 : n ), n = n ) ! ! ------------- get solution call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col1_int.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_sol_int1 ( i ), vec_sol_real1 ( i ), & ! vec_sol_int2 ( i ), vec_sol_real2 ( i ), k ! enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_ordered_vec_col1_int.csv' ) do i = 1 , n write ( u20 , * ) vec_int1 ( i ) - vec_sol_int1 ( i ), vec_real1 ( i ) - vec_sol_real1 ( i ), & ! vec_int2 ( i ) - vec_sol_int2 ( i ), vec_real2 ( i ) - vec_sol_real2 ( i ) enddo !----------------------------- REMARK -------------------------------------- ! As the sorted vector is integers, some values may be identical, leading to ! several possibilities for the subsequently sorted vectors. Look elements ! 9 and 10 for example. !--------------------------------------------------------------------------- close ( u20 ) !=============== Sort a real vector, and other vectors with the same order ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_int1 ( i ), vec_real1 ( i ), & ! vec_int2 ( i ), vec_real2 ( i ), k ! enddo close ( u10 ) ! ------------- sort with respect to the second column (real values) call sort_array2 ( tab_inout = vec_real1 ( 1 : n ), & ! tab1 = vec_int1 ( 1 : n ), & ! tab2 = vec_int2 ( 1 : n ), & ! tab3 = vec_real2 ( 1 : n ), n = n ) ! ! ------------- get solution call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col2_real.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_sol_int1 ( i ), vec_sol_real1 ( i ), & ! vec_sol_int2 ( i ), vec_sol_real2 ( i ), k ! enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_ordered_vec_col2_real.csv' ) do i = 1 , n write ( u20 , * ) vec_int1 ( i ) - vec_sol_int1 ( i ), vec_real1 ( i ) - vec_sol_real1 ( i ), & ! vec_int2 ( i ) - vec_sol_int2 ( i ), vec_real2 ( i ) - vec_sol_real2 ( i ) ! enddo close ( u20 ) !=============== Sort a real vector and return the order vector ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) k , vec_real1 ( i ), k , r , k enddo close ( u10 ) ! ------------- sort with respect to the second column (real values, same case as above) call init_order ( order = vec_order ( 1 : n ), n = n ) call sort_array2 ( tab_inout = vec_real1 ( 1 : n ), & ! tab0 = vec_order ( 1 : n ), n = n ) ! ! ------------- get solution of order call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col2_real.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) k , r , k , r , vec_sol_order ( i ) enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_order_vec.csv' ) do i = 1 , n write ( u20 , * ) vec_order ( i ) - vec_sol_order ( i ) enddo close ( u20 ) stop endprogram main","tags":"","loc":"program/main.html"},{"title":"test_minpack – TOOLIB","text":"Uses minpack program~~test_minpack~~UsesGraph program~test_minpack test_minpack module~minpack minpack program~test_minpack->module~minpack Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. A fortran collection of functions for minimization problems. Example of use. Calls program~~test_minpack~~CallsGraph program~test_minpack test_minpack proc~chkder_test chkder_test program~test_minpack->proc~chkder_test proc~hybrd1_test hybrd1_test program~test_minpack->proc~hybrd1_test proc~hybrj1_test hybrj1_test program~test_minpack->proc~hybrj1_test proc~lmder1_2_test lmder1_2_test program~test_minpack->proc~lmder1_2_test proc~lmder1_test lmder1_test program~test_minpack->proc~lmder1_test proc~lmdif1_2_test lmdif1_2_test program~test_minpack->proc~lmdif1_2_test proc~lmdif1_test lmdif1_test program~test_minpack->proc~lmdif1_test proc~lmstr1_2_test lmstr1_2_test program~test_minpack->proc~lmstr1_2_test proc~lmstr1_test lmstr1_test program~test_minpack->proc~lmstr1_test proc~qform_test qform_test program~test_minpack->proc~qform_test proc~timestamp timestamp program~test_minpack->proc~timestamp proc~chkder chkder proc~chkder_test->proc~chkder proc~chkder_f chkder_f proc~chkder_test->proc~chkder_f proc~r8vec_print r8vec_print proc~chkder_test->proc~r8vec_print proc~hybrd1 hybrd1 proc~hybrd1_test->proc~hybrd1 proc~hybrd1_f hybrd1_f proc~hybrd1_test->proc~hybrd1_f proc~hybrd1_test->proc~r8vec_print proc~hybrj1_test->proc~hybrd1_f proc~hybrj1 hybrj1 proc~hybrj1_test->proc~hybrj1 proc~hybrj1_test->proc~r8vec_print proc~lmder1 lmder1 proc~lmder1_2_test->proc~lmder1 proc~lmder1_2_f lmder1_2_f proc~lmder1_2_test->proc~lmder1_2_f proc~lmder1_2_test->proc~r8vec_print proc~lmder1_test->proc~lmder1 proc~lmder1_f lmder1_f proc~lmder1_test->proc~lmder1_f proc~lmder1_test->proc~r8vec_print proc~lmdif1 lmdif1 proc~lmdif1_2_test->proc~lmdif1 proc~lmdif1_2_f lmdif1_2_f proc~lmdif1_2_test->proc~lmdif1_2_f proc~lmdif1_2_test->proc~r8vec_print proc~lmdif1_test->proc~lmdif1 proc~lmdif1_f lmdif1_f proc~lmdif1_test->proc~lmdif1_f proc~lmdif1_test->proc~r8vec_print proc~lmstr1 lmstr1 proc~lmstr1_2_test->proc~lmstr1 proc~lmstr1_2_f lmstr1_2_f proc~lmstr1_2_test->proc~lmstr1_2_f proc~lmstr1_2_test->proc~r8vec_print proc~lmstr1_test->proc~lmstr1 proc~lmstr1_f lmstr1_f proc~lmstr1_test->proc~lmstr1_f proc~lmstr1_test->proc~r8vec_print proc~qform qform proc~qform_test->proc~qform proc~qrfac qrfac proc~qform_test->proc~qrfac proc~r8mat_print r8mat_print proc~qform_test->proc~r8mat_print proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~lmder lmder proc~lmder1->proc~lmder proc~lmdif lmdif proc~lmdif1->proc~lmdif proc~lmstr lmstr proc~lmstr1->proc~lmstr proc~enorm enorm proc~qrfac->proc~enorm proc~r8mat_print_some r8mat_print_some proc~r8mat_print->proc~r8mat_print_some proc~hybrd->proc~qform proc~hybrd->proc~qrfac proc~hybrd->proc~enorm proc~dogleg dogleg proc~hybrd->proc~dogleg proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~hybrj->proc~qform proc~hybrj->proc~qrfac proc~hybrj->proc~enorm proc~hybrj->proc~dogleg proc~hybrj->proc~r1mpyq proc~hybrj->proc~r1updt proc~lmder->proc~qrfac proc~lmder->proc~enorm proc~lmpar lmpar proc~lmder->proc~lmpar proc~lmdif->proc~qrfac proc~lmdif->proc~enorm proc~fdjac2 fdjac2 proc~lmdif->proc~fdjac2 proc~lmdif->proc~lmpar proc~lmstr->proc~qrfac proc~lmstr->proc~enorm proc~lmstr->proc~lmpar proc~rwupdt rwupdt proc~lmstr->proc~rwupdt proc~dogleg->proc~enorm proc~lmpar->proc~enorm proc~qrsolv qrsolv proc~lmpar->proc~qrsolv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer, parameter :: rk = kind(1.0D+00) Subroutines subroutine chkder_f (n, x, fvec, fjac, ldfjac, iflag) CHKDER_F is a function/jacobian routine for use with CHKDER_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag subroutine chkder_test () CHKDER_TEST tests CHKDER. Arguments None subroutine hybrd1_f (n, x, fvec, iflag) HYBRD1_F is a function routine for use with HYBRD1_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) integer :: iflag subroutine hybrd1_test () HYBRD1_TEST tests HYBRD1. Arguments None subroutine hybrj1_f (n, x, fvec, fjac, ldfjac, iflag) HYBRJ1_F is a function/jacobian routine for use with HYBRJ1_TEST. Arguments Type Intent Optional Attributes Name integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (n) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag subroutine hybrj1_test () HYBRJ1_TEST tests HYBRJ1. Arguments None subroutine lmder1_2_f (m, n, x, fvec, fjac, ldfjac, iflag) LMDER1_2_F is a function/jacobian routine for use with LMDER1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag subroutine lmder1_2_test () LMDER1_2_TEST tests LMDER1. Arguments None subroutine lmder1_f (m, n, x, fvec, fjac, ldfjac, iflag) LMDER1_F is a function/jacobian routine for use with LMDER1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag subroutine lmder1_test () LMDER1_TEST tests LMDER1. Arguments None subroutine lmdif1_2_f (m, n, x, fvec, iflag) LMDIF1_2_F is a function routine for use with LMDIF1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) integer :: iflag subroutine lmdif1_2_test () LMDIF1_2_TEST tests LMDIF1. Arguments None subroutine lmdif1_f (m, n, x, fvec, iflag) LMDIF1_F is a function routine for use with LMDIF1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) integer :: iflag subroutine lmdif1_test () LMDIF1_TEST tests LMDIF1. Arguments None subroutine lmstr1_2_f (m, n, x, fvec, fjrow, iflag) LMSTR1_2_F is a function/jacobian routine for use with LMSTR1_2_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjrow (n) integer :: iflag subroutine lmstr1_2_test () LMSTR1_2_TEST tests LMSTR1. Arguments None subroutine lmstr1_f (m, n, x, fvec, fjrow, iflag) LMSTR1_F is a function/jacobian routine for use with LMSTR1_TEST. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=rk) :: x (n) real(kind=rk) :: fvec (m) real(kind=rk) :: fjrow (n) integer :: iflag subroutine lmstr1_test () LMSTR1_TEST tests LMSTR1. Arguments None subroutine qform_test () QFORM_TEST tests QFORM. Arguments None Source Code program test_minpack use minpack !*****************************************************************************80 ! ! minpack_test() tests minpack(). ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    02 January 2018 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) call timestamp ( ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'minpack_test():' write ( * , '(a)' ) '  FORTRAN90 version' write ( * , '(a)' ) '  Test minpack().' call chkder_test ( ) call hybrd1_test ( ) call hybrj1_test ( ) call lmder1_test ( ) call lmder1_2_test ( ) call lmdif1_test ( ) call lmdif1_2_test ( ) call lmstr1_test ( ) call lmstr1_2_test ( ) call qform_test ( ) ! !  Terminate. ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'minpack_test():' write ( * , '(a)' ) '  Normal end of execution.' write ( * , '(a)' ) ' ' call timestamp ( ) stop 0 contains subroutine chkder_test ( ) !*****************************************************************************80 ! !! CHKDER_TEST tests CHKDER. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 5 integer , parameter :: m = n integer , parameter :: ldfjac = n real ( kind = rk ) err ( m ) real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) real ( kind = rk ) fvecp ( m ) integer i integer ido integer iflag integer mode real ( kind = rk ) x ( n ) real ( kind = rk ) xp ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CHKDER_TEST' write ( * , '(a)' ) '  CHKDER compares a user supplied jacobian' write ( * , '(a)' ) '  and a finite difference approximation to it' write ( * , '(a)' ) '  and judges whether the jacobian is correct.' do ido = 1 , 2 if ( ido == 1 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  On the first test, use a correct jacobian.' else if ( ido == 2 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Repeat the test, but use a \"bad\" jacobian' write ( * , '(a)' ) '  and see if the routine notices!' end if ! !  Set the point at which the test is to be made: ! x ( 1 : n ) = 0.5D+00 call r8vec_print ( n , x , '  Evaluation point X:' ) mode = 1 call chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) iflag = 1 call chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) call chkder_f ( n , xp , fvecp , fjac , ldfjac , iflag ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Sampled function values F(X) and F(XP)' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(i3,2g14.6)' ) i , fvec ( i ), fvecp ( i ) end do iflag = 2 call chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) ! !  Here's where we put a mistake into the jacobian, on purpose. ! if ( ido == 2 ) then fjac ( 1 , 1 ) = 1.01D+00 * fjac ( 1 , 1 ) fjac ( 2 , 3 ) = - fjac ( 2 , 3 ) end if write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Computed jacobian' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(5g14.6)' ) fjac ( i , 1 : n ) end do mode = 2 call chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  CHKDER gradient component error estimates:' write ( * , '(a)' ) '     > 0.5, the component is probably correct.' write ( * , '(a)' ) '     < 0.5, the component is probably incorrect.' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(i6,g14.6)' ) i , err ( i ) end do end do return end subroutine chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! CHKDER_F is a function/jacobian routine for use with CHKDER_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    17 May 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer i integer iflag integer j real ( kind = rk ) prod real ( kind = rk ) x ( n ) ! !  If IFLAG is 0, print out X (and anything else about this iterate). ! if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do ! !  If IFLAG is 1, we are supposed to evaluate F(X). ! else if ( iflag == 1 ) then do i = 1 , n - 1 fvec ( i ) = x ( i ) - real ( n + 1 , kind = rk ) + sum ( x ( 1 : n ) ) end do fvec ( n ) = product ( x ( 1 : n ) ) - 1.0D+00 ! !  If IFLAG is 2, we are supposed to evaluate FJAC(I,J) = d F(I)/d X(J) ! else if ( iflag == 2 ) then fjac ( 1 : n - 1 , 1 : n ) = 1.0D+00 do i = 1 , n - 1 fjac ( i , i ) = 2.0D+00 end do prod = product ( x ( 1 : n ) ) do j = 1 , n fjac ( n , j ) = prod / x ( j ) end do end if return end subroutine hybrd1_test ( ) !*****************************************************************************80 ! !! HYBRD1_TEST tests HYBRD1. ! !  Discussion: ! !    This is an example of what your main program would look !    like if you wanted to use MINPACK to solve N nonlinear equations !    in N unknowns.  In this version, we avoid computing the jacobian !    matrix, and request that MINPACK approximate it for us. ! !    The set of nonlinear equations is: ! !      x1&#94;2 - 10 * x1 + x2&#94;2 + 8 = 0 !      x1 * x2&#94;2 + x1 - 10 * x2 + 8 = 0 ! !    with solution x1 = x2 = 1 ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 2 !~   external hybrd1_f real ( kind = rk ) fvec ( n ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'HYBRD1_TEST' write ( * , '(a)' ) '  HYBRD1 solves a nonlinear system of equations.' x ( 1 : 2 ) = ( / 3.0D+00 , 0.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) call hybrd1_f ( n , x , fvec , iflag ) call r8vec_print ( n , fvec , '  Initial F(X):' ) tol = 0.00001D+00 call hybrd1 ( hybrd1_f , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  Final X:' ) call r8vec_print ( n , fvec , '  Final F(X):' ) return end subroutine hybrd1_f ( n , x , fvec , iflag ) !*****************************************************************************80 ! !! HYBRD1_F is a function routine for use with HYBRD1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    John Burkardt ! !  Input: ! !    integer N, the number of variables. ! !    real ( kind = rk ) X(N), the variable values. ! !  Output: ! !    real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    integer IFLAG, error flag. !    If IFLAG < 0, an error has occurred and the computation should stop. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer n real ( kind = rk ) fvec ( n ) integer iflag real ( kind = rk ) x ( n ) fvec ( 1 ) = x ( 1 ) * x ( 1 ) - 1 0.0D+00 * x ( 1 ) + x ( 2 ) * x ( 2 ) + 8.0D+00 fvec ( 2 ) = x ( 1 ) * x ( 2 ) * x ( 2 ) + x ( 1 ) - 1 0.0D+00 * x ( 2 ) + 8.0D+00 iflag = 1 return end subroutine hybrj1_test ( ) !*****************************************************************************80 ! !! HYBRJ1_TEST tests HYBRJ1. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 2 integer , parameter :: ldfjac = n !~   external hybrj1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'HYBRJ1_TEST' write ( * , '(a)' ) '  HYBRJ1 solves a nonlinear system of equations.' x ( 1 : 2 ) = ( / 3.0D+00 , 0.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) call hybrd1_f ( n , x , fvec , iflag ) call r8vec_print ( n , fvec , '  F(X):' ) tol = 0.00001D+00 call hybrj1 ( hybrj1_f , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( n , fvec , '  F(X):' ) return end subroutine hybrj1_f ( n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! HYBRJ1_F is a function/jacobian routine for use with HYBRJ1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer i integer iflag real ( kind = rk ) x ( n ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 ) = x ( 1 ) * x ( 1 ) - 1 0.0D+00 * x ( 1 ) + x ( 2 ) * x ( 2 ) + 8.0D+00 fvec ( 2 ) = x ( 1 ) * x ( 2 ) * x ( 2 ) + x ( 1 ) - 1 0.0D+00 * x ( 2 ) + 8.0D+00 else if ( iflag == 2 ) then fjac ( 1 , 1 ) = 2.0D+00 * x ( 1 ) - 1 0.0D+00 fjac ( 1 , 2 ) = 2.0D+00 * x ( 2 ) fjac ( 2 , 1 ) = x ( 2 ) * x ( 2 ) + 1.0D+00 fjac ( 2 , 2 ) = 2.0D+00 * x ( 1 ) * x ( 2 ) - 1 0.0D+00 end if return end subroutine lmder1_test ( ) !*****************************************************************************80 ! !! LMDER1_TEST tests LMDER1. ! !  Discussion: ! !    LMDER1 solves M nonlinear equations in N unknowns, with M >= N. ! !    LMDER1 seeks a solution X minimizing the euclidean norm of the residual. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y = a * x + b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x+b*y+c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1+b*2+c*3 + d*9  + e = 0 !      a*1+b*3+c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    31 October 2005 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 integer , parameter :: ldfjac = m !~   external lmder1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_TEST' write ( * , '(a)' ) '  LMDER1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmder1 ( lmder1_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! LMDER1_F is a function/jacobian routine for use with LMDER1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Input: ! !    integer N, the number of variables. ! !    real ( kind = rk ) X(N), the variable values. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! !  Output: ! !    real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer m integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), parameter , dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), parameter , dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) else if ( iflag == 2 ) then fjac ( 1 : m , 1 ) = xdat ( 1 : m ) fjac ( 1 : m , 2 ) = 1.0D+00 else write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop end if return end subroutine lmder1_2_test ( ) !*****************************************************************************80 ! !! LMDER1_2_TEST tests LMDER1. ! !  Discussion: ! !    LMDER1 solves M nonlinear equations in n unknowns, where M is greater !    than N.  The functional fit is nonlinear this time, of the form ! !      y=a+b*x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 integer , parameter :: ldfjac = m !~   external lmder1_2_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_2_TEST' write ( * , '(a)' ) '  LMDER1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmder1_2_f ( m , n , x , fvec , fjac , ldfjac , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmder1 ( lmder1_2_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmder1_2_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! LMDER1_2_F is a function/jacobian routine for use with LMDER1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer m integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) else if ( iflag == 2 ) then fjac ( 1 : m , 1 ) = 1.0D+00 fjac ( 1 : m , 2 ) = xdat ( 1 : m ) ** x ( 3 ) fjac ( 1 : m , 3 ) = x ( 2 ) * log ( xdat ( 1 : m ) ) * xdat ( 1 : m ) ** x ( 3 ) end if return end subroutine lmdif1_test ( ) !*****************************************************************************80 ! !! LMDIF1_TEST tests LMDIF1. ! !  Discussion: ! !    LMDIF1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  Generally, you cannot get a solution vector x which will satisfy !    all the equations.  That is, the vector equation f(x)=0 cannot !    be solved exactly.  Instead, minpack seeks a solution x so that !    the euclidean norm transpose(f(x))*f(x) is minimized.  The size !    of the euclidean norm is a measure of how good the solution is. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y=a*x+b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x+b*y+c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1+b*2+c*3 + d*9  + e = 0 !      a*1+b*3+c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 !~   external lmdif1_f real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDIF1_TEST' write ( * , '(a)' ) '  LMDIF1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmdif1_f ( m , n , x , fvec , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmdif1 ( lmdif1_f , m , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmdif1_f ( m , n , x , fvec , iflag ) !*****************************************************************************80 ! !! LMDIF1_F is a function routine for use with LMDIF1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) end if return end subroutine lmdif1_2_test ( ) !*****************************************************************************80 ! !! LMDIF1_2_TEST tests LMDIF1. ! !  Discussion: ! !    LMDIF1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  It is similar to test02, except that the functional fit is !    nonlinear this time, of the form ! !      y = a + b * x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 !~   external lmdif1_2_f real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDIF1_2_TEST' write ( * , '(a)' ) '  LMDIF1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  X:' ) iflag = 1 call lmdif1_2_f ( m , n , x , fvec , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmdif1 ( lmdif1_2_f , m , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmdif1_2_f ( m , n , x , fvec , iflag ) !*****************************************************************************80 ! !! LMDIF1_2_F is a function routine for use with LMDIF1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) end if return end subroutine lmstr1_test ( ) !*****************************************************************************80 ! !! LMSTR1_TEST tests LMSTR1. ! !  Discussion: ! !    LMSTR1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  Generally, you cannot get a solution vector x which will satisfy !    all the equations.  That is, the vector equation f(x)=0 cannot !    be solved exactly.  Instead, minpack seeks a solution x so that !    the euclidean norm transpose(f(x))*f(x) is minimized.  The size !    of the euclidean norm is a measure of how good the solution is. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y=a*x+b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x + b*y + c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1 + b*2 + c*3 + d*9  + e = 0 !      a*1 + b*3 + c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !    Thanks to Jacques Le Bourlot for pointing out that the line !      integer fjrow !    should instead read !      real ( kind = rk ) fjrow(n) !    19 August 2016 ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 integer , parameter :: ldfjac = m !~   external lmstr1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMSTR1_TEST' write ( * , '(a)' ) '  LMSTR1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmstr1_f ( m , n , x , fvec , fjrow , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmstr1 ( lmstr1_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmstr1_f ( m , n , x , fvec , fjrow , iflag ) !*****************************************************************************80 ! !! LMSTR1_F is a function/jacobian routine for use with LMSTR1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions, and the !    number of rows in the jacobian. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJROW(N), space to return one row !    of the jacobian,  if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute row (I-1) of the jacobian and return it in FJROW. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) else if ( 2 <= iflag ) then fjrow ( 1 ) = xdat ( iflag - 1 ) fjrow ( 2 ) = 1.0D+00 end if return end subroutine lmstr1_2_test ( ) !*****************************************************************************80 ! !! LMSTR1_2_TEST tests LMSTR1. ! !  Discussion: ! !    LMSTR1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  This test is similar to test02, except that the functional fit !    is nonlinear this time, of the form ! !      y = a + b * x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 integer , parameter :: ldfjac = m !~   external lmstr1_2_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMSTR1_2_TEST' write ( * , '(a)' ) '  LMSTR1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmstr1_2_f ( m , n , x , fvec , fjrow , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmstr1 ( lmstr1_2_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmstr1_2_f ( m , n , x , fvec , fjrow , iflag ) !*****************************************************************************80 ! !! LMSTR1_2_F is a function/jacobian routine for use with LMSTR1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions, and the !    number of rows in the jacobian. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJROW(N), space to return one row !    of the jacobian,  if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute row (I-1) of the jacobian and return it in FJROW. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) else if ( 2 <= iflag ) then fjrow ( 1 ) = 1.0D+00 fjrow ( 2 ) = xdat ( iflag - 1 ) ** x ( 3 ) fjrow ( 3 ) = x ( 2 ) * log ( xdat ( iflag - 1 ) ) * xdat ( iflag - 1 ) ** x ( 3 ) end if return end subroutine qform_test ( ) !*****************************************************************************80 ! !! QFORM_TEST tests QFORM. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    02 January 2018 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 5 integer , parameter :: n = 7 integer , parameter :: lda = m real ( kind = rk ) a ( lda , n ) real ( kind = rk ) a2 ( m , n ) real ( kind = rk ) acnorm ( n ) integer ipivot ( n ) integer j integer k integer lipvt logical pivot real ( kind = rk ) q ( m , m ) real ( kind = rk ) r ( m , n ) real ( kind = rk ) rdiag ( n ) write ( * , '(a)' ) '' write ( * , '(a)' ) 'QFORM_TEST:' write ( * , '(a)' ) '  QFORM constructs the Q factor explicitly' write ( * , '(a)' ) '  after the use of QRFAC.' ! !  Set the matrix A. ! call random_number ( harvest = a ( 1 : m , 1 : n ) ) call r8mat_print ( m , n , a , '  Matrix A:' ) ! !  Compute the QR factors. ! pivot = . false . lipvt = n call qrfac ( m , n , a , lda , pivot , ipivot , lipvt , rdiag , acnorm ) ! !  Extract the R factor. ! r ( 1 : m , 1 : n ) = 0.0D+00 do k = 1 , min ( m , n ) r ( k , k ) = rdiag ( k ) end do do j = 1 , n r ( 1 : min ( j - 1 , m ), j ) = a ( 1 : min ( j - 1 , m ), j ) end do call r8mat_print ( m , n , r , '  Matrix R:' ) ! !  Call QRFORM to form the Q factor. ! q ( 1 : m , 1 : m ) = 0.0D+00 q ( 1 : m , 1 : min ( m , n )) = a ( 1 : m , 1 : min ( m , n )) call qform ( m , n , q , m ) call r8mat_print ( m , m , q , '  Matrix Q:' ) ! !  Compute Q*R. ! a2 = matmul ( q , r ) ! !  Compare Q*R to A. ! call r8mat_print ( m , n , a2 , '  Matrix A2 = Q * R:' ) return end !~ subroutine r8mat_print ( m, n, a, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8MAT_PRINT prints an R8MAT. !~ ! !~ !  Discussion: !~ ! !~ !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    12 September 2004 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer M, the number of rows in A. !~ ! !~ !    Input, integer N, the number of columns in A. !~ ! !~ !    Input, real ( kind = rk ) A(M,N), the matrix. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer m !~   integer n !~   real ( kind = rk ) a(m,n) !~   character ( len = * ) title !~   call r8mat_print_some ( m, n, a, 1, 1, m, n, title ) !~   return !~ end !~ subroutine r8mat_print_some ( m, n, a, ilo, jlo, ihi, jhi, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8MAT_PRINT_SOME prints some of an R8MAT. !~ ! !~ !  Discussion: !~ ! !~ !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    10 September 2009 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer M, N, the number of rows and columns. !~ ! !~ !    Input, real ( kind = rk ) A(M,N), an M by N matrix to be printed. !~ ! !~ !    Input, integer ILO, JLO, the first row and column to print. !~ ! !~ !    Input, integer IHI, JHI, the last row and column to print. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer, parameter :: incx = 5 !~   integer m !~   integer n !~   real ( kind = rk ) a(m,n) !~   character ( len = 14 ) ctemp(incx) !~   integer i !~   integer i2hi !~   integer i2lo !~   integer ihi !~   integer ilo !~   integer inc !~   integer j !~   integer j2 !~   integer j2hi !~   integer j2lo !~   integer jhi !~   integer jlo !~   character ( len = * ) title !~   write ( *, '(a)' ) ' ' !~   write ( *, '(a)' ) trim ( title ) !~   if ( m <= 0 .or. n <= 0 ) then !~     write ( *, '(a)' ) ' ' !~     write ( *, '(a)' ) '  (None)' !~     return !~   end if !~   do j2lo = max ( jlo, 1 ), min ( jhi, n ), incx !~     j2hi = j2lo + incx - 1 !~     j2hi = min ( j2hi, n ) !~     j2hi = min ( j2hi, jhi ) !~     inc = j2hi + 1 - j2lo !~     write ( *, '(a)' ) ' ' !~     do j = j2lo, j2hi !~       j2 = j + 1 - j2lo !~       write ( ctemp(j2), '(i8,6x)' ) j !~     end do !~     write ( *, '(''  Col   '',5a14)' ) ctemp(1:inc) !~     write ( *, '(a)' ) '  Row' !~     write ( *, '(a)' ) ' ' !~     i2lo = max ( ilo, 1 ) !~     i2hi = min ( ihi, m ) !~     do i = i2lo, i2hi !~       do j2 = 1, inc !~         j = j2lo - 1 + j2 !~         if ( a(i,j) == real ( int ( a(i,j) ), kind = rk ) ) then !~           write ( ctemp(j2), '(f8.0,6x)' ) a(i,j) !~         else !~           write ( ctemp(j2), '(g14.6)' ) a(i,j) !~         end if !~       end do !~       write ( *, '(i5,a,5a14)' ) i, ':', ( ctemp(j), j = 1, inc ) !~     end do !~   end do !~   return !~ end !~ subroutine r8vec_print ( n, a, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8VEC_PRINT prints an R8VEC. !~ ! !~ !  Discussion: !~ ! !~ !    An R8VEC is a vector of R8's. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    22 August 2000 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer N, the number of components of the vector. !~ ! !~ !    Input, real ( kind = rk ) A(N), the vector to be printed. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer n !~   real ( kind = rk ) a(n) !~   integer i !~   character ( len = * ) title !~   write ( *, '(a)' ) ' ' !~   write ( *, '(a)' ) trim ( title ) !~   write ( *, '(a)' ) ' ' !~   do i = 1, n !~     write ( *, '(2x,i8,2x,g16.8)' ) i, a(i) !~   end do !~   return !~ end !~ subroutine timestamp ( ) !~ !*****************************************************************************80 !~ ! !~ !! TIMESTAMP prints the current YMDHMS date as a time stamp. !~ ! !~ !  Example: !~ ! !~ !    31 May 2001   9:45:54.872 AM !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    18 May 2013 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   character ( len = 8 ) ampm !~   integer d !~   integer h !~   integer m !~   integer mm !~   character ( len = 9 ), parameter, dimension(12) :: month = (/ & !~     'January  ', 'February ', 'March    ', 'April    ', & !~     'May      ', 'June     ', 'July     ', 'August   ', & !~     'September', 'October  ', 'November ', 'December ' /) !~   integer n !~   integer s !~   integer values(8) !~   integer y !~   call date_and_time ( values = values ) !~   y = values(1) !~   m = values(2) !~   d = values(3) !~   h = values(5) !~   n = values(6) !~   s = values(7) !~   mm = values(8) !~   if ( h < 12 ) then !~     ampm = 'AM' !~   else if ( h == 12 ) then !~     if ( n == 0 .and. s == 0 ) then !~       ampm = 'Noon' !~     else !~       ampm = 'PM' !~     end if !~   else !~     h = h - 12 !~     if ( h < 12 ) then !~       ampm = 'PM' !~     else if ( h == 12 ) then !~       if ( n == 0 .and. s == 0 ) then !~         ampm = 'Midnight' !~       else !~         ampm = 'AM' !~       end if !~     end if !~   end if !~   write ( *, '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & !~     d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm ) !~   return !~ end endprogram test_minpack","tags":"","loc":"program/test_minpack.html"},{"title":"test_solvers – TOOLIB","text":"Uses data_arch omp_lib solver gen_param miscellaneous program~~test_solvers~~UsesGraph program~test_solvers test_solvers module~data_arch data_arch program~test_solvers->module~data_arch module~gen_param gen_param program~test_solvers->module~gen_param module~miscellaneous miscellaneous program~test_solvers->module~miscellaneous module~solver solver program~test_solvers->module~solver omp_lib omp_lib program~test_solvers->omp_lib iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~gen_param->module~data_arch module~miscellaneous->module~data_arch module~solver->module~data_arch module~solver->module~gen_param hsl_ma48_double hsl_ma48_double module~solver->hsl_ma48_double iso_c_binding iso_c_binding module~solver->iso_c_binding module~solver->iso_fortran_env module~mumfpack mumfpack module~solver->module~mumfpack module~mumps_wrapper mumps_wrapper module~solver->module~mumps_wrapper module~sort_arrays sort_arrays module~solver->module~sort_arrays module~sulu_wrapper sulu_wrapper module~solver->module~sulu_wrapper module~mumfpack->iso_c_binding module~sort_arrays->module~data_arch module~sulu_wrapper->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. MSOLV example of use Note The program asks first for the matrix size: 1 for a very small matrix, and 0 for a bigger one.The systems are CC HB format systems with elemental matrices. Small system – nnz=18 The system is (example provided by MUMP): eltvar locates the elemental matrix line in the assembled matrix eltptr gives the elemental matrix first entry position in eltvar (last position being size( eltvar )+1) The rhs is (12, 7, 23, 6, 22), and the solution (1, 2, 3, 4, 5) Big (well, in fact, medium) system – nnz=2,097,152 The system results from a MUSST study case and there is of course no theoretical solution to compare with Warning Some solver implementation are C written, so the arrays may begin at 0. It explains the variable dec in prod_a_x Calls program~~test_solvers~~CallsGraph program~test_solvers test_solvers omp_get_wtime omp_get_wtime program~test_solvers->omp_get_wtime proc~convert_matrice_format convert_matrice_format program~test_solvers->proc~convert_matrice_format proc~get_unit get_unit program~test_solvers->proc~get_unit proc~modify_a_elt modify_a_elt program~test_solvers->proc~modify_a_elt proc~solve_syst solve_syst program~test_solvers->proc~solve_syst proc~verif_solution verif_solution program~test_solvers->proc~verif_solution proc~from_elemental_to_assembled from_elemental_to_assembled proc~convert_matrice_format->proc~from_elemental_to_assembled proc~analyse_solver analyse_solver proc~solve_syst->proc~analyse_solver proc~close_solver close_solver proc~solve_syst->proc~close_solver proc~factorize_solver factorize_solver proc~solve_syst->proc~factorize_solver proc~freefact_solver freefact_solver proc~solve_syst->proc~freefact_solver proc~init_solver init_solver proc~solve_syst->proc~init_solver proc~solution_solver solution_solver proc~solve_syst->proc~solution_solver proc~prod_a_x prod_a_x proc~verif_solution->proc~prod_a_x proc~prod_elemental_x prod_elemental_x proc~verif_solution->proc~prod_elemental_x dmumps dmumps proc~analyse_solver->dmumps ma48_analyse ma48_analyse proc~analyse_solver->ma48_analyse proc~prep_superlu prep_superlu proc~analyse_solver->proc~prep_superlu proc~s_umfpack_di_symbolic s_umfpack_di_symbolic proc~analyse_solver->proc~s_umfpack_di_symbolic proc~close_solver->dmumps infog infog proc~close_solver->infog ma48_finalize ma48_finalize proc~close_solver->ma48_finalize mpi_finalize mpi_finalize proc~close_solver->mpi_finalize proc~close_superlu close_superlu proc~close_solver->proc~close_superlu proc~umfpack_di_free_numeric umfpack_di_free_numeric proc~close_solver->proc~umfpack_di_free_numeric proc~umfpack_di_free_symbolic umfpack_di_free_symbolic proc~close_solver->proc~umfpack_di_free_symbolic proc~umfpack_di_report_info umfpack_di_report_info proc~close_solver->proc~umfpack_di_report_info proc~factorize_solver->dmumps ma48_factorize ma48_factorize proc~factorize_solver->ma48_factorize proc~fact_superlu fact_superlu proc~factorize_solver->proc~fact_superlu proc~s_umfpack_di_numeric s_umfpack_di_numeric proc~factorize_solver->proc~s_umfpack_di_numeric proc~factorize_solver->proc~umfpack_di_free_numeric proc~free_superlu free_superlu proc~freefact_solver->proc~free_superlu proc~freefact_solver->proc~umfpack_di_free_numeric proc~sort_array2 sort_array2 proc~from_elemental_to_assembled->proc~sort_array2 proc~init_solver->dmumps icntl icntl proc~init_solver->icntl proc~init_solver->infog ma48_initialize ma48_initialize proc~init_solver->ma48_initialize proc~init_solver->mpi_finalize mpi_init mpi_init proc~init_solver->mpi_init proc~init_superlu init_superlu proc~init_solver->proc~init_superlu proc~umfpack_di_defaults umfpack_di_defaults proc~init_solver->proc~umfpack_di_defaults proc~umfpack_di_report_control umfpack_di_report_control proc~init_solver->proc~umfpack_di_report_control proc~solution_solver->proc~solve_syst proc~solution_solver->dmumps proc~solution_solver->infog ma48_solve ma48_solve proc~solution_solver->ma48_solve proc~solution_solver->mpi_finalize proc~s_umfpack_di_solve s_umfpack_di_solve proc~solution_solver->proc~s_umfpack_di_solve proc~solv_superlu solv_superlu proc~solution_solver->proc~solv_superlu rhs rhs proc~solution_solver->rhs interface~destroy_compcol_matrix Destroy_CompCol_Matrix proc~close_superlu->interface~destroy_compcol_matrix interface~destroy_dense_matrix Destroy_Dense_Matrix proc~close_superlu->interface~destroy_dense_matrix interface~dgssvx dgssvx proc~fact_superlu->interface~dgssvx interface~statfree StatFree proc~fact_superlu->interface~statfree interface~statinit StatInit proc~fact_superlu->interface~statinit interface~statprint StatPrint proc~fact_superlu->interface~statprint interface~set_default_options set_default_options proc~init_superlu->interface~set_default_options interface~dcreate_compcol_matrix dCreate_CompCol_Matrix proc~prep_superlu->interface~dcreate_compcol_matrix interface~dcreate_dense_matrix dCreate_Dense_Matrix proc~prep_superlu->interface~dcreate_dense_matrix proc~umfpack_di_numeric umfpack_di_numeric proc~s_umfpack_di_numeric->proc~umfpack_di_numeric proc~umfpack_di_solve umfpack_di_solve proc~s_umfpack_di_solve->proc~umfpack_di_solve proc~umfpack_di_symbolic umfpack_di_symbolic proc~s_umfpack_di_symbolic->proc~umfpack_di_symbolic proc~solv_superlu->proc~prep_superlu proc~solv_superlu->interface~destroy_compcol_matrix interface~destroy_supernode_matrix Destroy_SuperNode_Matrix proc~solv_superlu->interface~destroy_supernode_matrix proc~solv_superlu->interface~dgssvx proc~solv_superlu->interface~statfree proc~solv_superlu->interface~statinit proc~solv_superlu->interface~statprint proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order interface~c_umfpack_di_defaults c_umfpack_di_defaults proc~umfpack_di_defaults->interface~c_umfpack_di_defaults interface~c_umfpack_di_free_numeric c_umfpack_di_free_numeric proc~umfpack_di_free_numeric->interface~c_umfpack_di_free_numeric interface~c_umfpack_di_free_symbolic c_umfpack_di_free_symbolic proc~umfpack_di_free_symbolic->interface~c_umfpack_di_free_symbolic interface~c_umfpack_di_report_control c_umfpack_di_report_control proc~umfpack_di_report_control->interface~c_umfpack_di_report_control interface~c_umfpack_di_report_info c_umfpack_di_report_info proc~umfpack_di_report_info->interface~c_umfpack_di_report_info proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order interface~c_umfpack_di_numeric c_umfpack_di_numeric proc~umfpack_di_numeric->interface~c_umfpack_di_numeric interface~c_umfpack_di_solve c_umfpack_di_solve proc~umfpack_di_solve->interface~c_umfpack_di_solve interface~c_umfpack_di_symbolic c_umfpack_di_symbolic proc~umfpack_di_symbolic->interface~c_umfpack_di_symbolic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), dimension(:), allocatable :: a_elt matrix non-zero entries in CC real(kind=R8), dimension(:), allocatable :: a_elt_ref initial a_elt real(kind=R8), dimension(:), allocatable :: b system right hand side integer(kind=I4), dimension(:), allocatable :: eltptr elemental matrices position in eltvar integer(kind=I4), dimension(:), allocatable :: eltvar elemental matrix global lines real(kind=R8) :: error integer(kind=I4) :: i integer(kind=I4) :: ii integer(kind=I4) :: size_a_elt type( MAT_SOLV ) :: slv_struct integer(kind=I4) :: state real(kind=R8) :: time1 real(kind=R8) :: time2 integer(kind=I4) :: uu Subroutines subroutine modify_a_elt (tab, nz) mMltiplication of the system coefficient by a random factor Arguments Type Intent Optional Attributes Name real(kind=R8), intent(inout) :: tab (1:nz) integer(kind=I4), intent(in) :: nz subroutine prod_a_x (n, nz, x, y, a_elt, irow, jptr, slvt) , assembled CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz) :: a_elt integer(kind=I4), intent(in), dimension(nz ) :: irow integer(kind=I4), intent(in), dimension(n+1) :: jptr integer(kind=I4), intent(in) :: slvt subroutine prod_elemental_x (n, nz, nelt, nvar, x, y, a_elt, eltptr, eltvar) , elemental CC format Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: n integer(kind=I4), intent(in) :: nz integer(kind=I4), intent(in) :: nelt integer(kind=I4), intent(in) :: nvar real(kind=R8), intent(in), dimension(n) :: x real(kind=R8), intent(out), dimension(n) :: y real(kind=R8), intent(in), dimension(nz     ) :: a_elt integer(kind=I4), intent(in), dimension(nelt +1) :: eltptr integer(kind=I4), intent(in), dimension(nvar   ) :: eltvar subroutine verif_solution (slv_struct, a_elt, b, error) The product of the system matrix by the solution , is\n       calculated, and compared to the right hand side .\n       The calculated error is the absolute error in %. Read more… Arguments Type Intent Optional Attributes Name type( MAT_SOLV ), intent(in) :: slv_struct real(kind=R8), intent(in), dimension(:) :: a_elt real(kind=R8), intent(in), dimension(:) :: b real(kind=R8), intent(out) :: error Source Code program test_solvers use omp_lib , only : omp_get_wtime use data_arch , only : I4 , R4 , R8 , & OPU , & ! *default output unit* IPU ! *default input unit* use miscellaneous , only : get_unit use gen_param , only : SOLV_MESS , & ! *Solver message: yes=```PRINT_MESS```, no=```NO_MESS```* NO_MESS , & ! *no output message* PRINT_MESS ! *solver infos output* use solver , only : MAT_SOLV , & ! *system data type* solve_syst , & ! *subroutine for the system resolution* MUMP , & ! *integer* UMFP , & ! *integer* SULU , & ! *integer* convert_matrice_format ! *various matrix format conversion* implicit none integer ( kind = I4 ) :: i , ii , uu , size_a_elt , state real ( kind = R8 ) :: time1 , time2 , error type ( MAT_SOLV ) :: slv_struct real ( kind = R8 ), dimension (:), allocatable :: b !! *system right hand side* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *matrix non-zero entries in CC* real ( kind = R8 ), dimension (:), allocatable :: a_elt_ref !! *initial ```a_elt```* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *elemental matrices position in ```eltvar```* integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *elemental matrix global lines* SOLV_MESS = NO_MESS !PRINT_MESS! write ( OPU , * ) 'small matrix? 0:n, 1:y' read ( IPU , * ) i ! ======================== SOLVER TYPE =========================================== do write ( OPU , * ) 'data read, choose solver n° : 0-MA48, 1-SULU, 2-MUMP (ref), 3-UMFP' read ( IPU , * ) ii slv_struct % slv_t = ii if ( ii >= 0 . and . ii <= 3 ) exit enddo ! ======================== SYST DATA READ =========================================== call get_unit ( uu ) if ( i == 0 ) then open ( unit = uu , file = \"mat/big_syst.bin\" , form = 'unformatted' , access = 'stream' ) else open ( unit = uu , file = \"mat/small_syst.bin\" , form = 'unformatted' , access = 'stream' ) endif ! ======================== SYST INFO =========================================== read ( uu ) slv_struct % nn , slv_struct % ne , slv_struct % nvar , slv_struct % nt write ( OPU , * ) '*************** INFO ********************' write ( OPU , * ) 'system size:                  ' , slv_struct % nn write ( OPU , * ) 'number of elemental matrices: ' , slv_struct % ne write ( OPU , * ) 'number of nnz entries:        ' , slv_struct % nt write ( OPU , * ) '*****************************************' allocate ( eltvar ( slv_struct % nvar ) ) allocate ( a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( a_elt_ref ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( eltptr ( slv_struct % ne + 1 ) ) allocate ( b ( slv_struct % nn ) ) allocate ( slv_struct % eltvar ( slv_struct % nvar ) ) allocate ( slv_struct % a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( slv_struct % eltptr ( slv_struct % ne + 1 ) ) call solve_syst ( mat = slv_struct , step = 'ini' ) do ii = 1 , slv_struct % nvar read ( uu ) slv_struct % eltvar ( ii ) enddo do ii = 1 , slv_struct % ne + 1 read ( uu ) slv_struct % eltptr ( ii ) enddo do ii = 1 , slv_struct % nt read ( uu ) slv_struct % a_elt ( ii ) enddo do ii = 1 , slv_struct % nn read ( uu ) slv_struct % b ( ii ) enddo close ( uu ) ! The matrices are in CC HB format. Only MUMPS accepts elemental entries, so the ! following subroutine converts elemental marices to assembled vectors. ! If MUMPS is chosen, nothing is done. call convert_matrice_format ( mat = slv_struct ) ! ======================== backup ============================================ eltvar = slv_struct % eltvar a_elt_ref = slv_struct % a_elt eltptr = slv_struct % eltptr b = slv_struct % b ! ======================== PROCESS =========================================== time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'ana' ) ; write ( OPU , * ) 'system analyzed' call solve_syst ( mat = slv_struct , step = 'fac' ) ; write ( OPU , * ) 'system factorized' call solve_syst ( mat = slv_struct , step = 'sol' ) ; write ( OPU , * ) 'system solved' call solve_syst ( mat = slv_struct , step = 'fre' ) ; write ( OPU , * ) 'system freed' time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt_ref , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) ! Here, the matrix coefficients are modified, but the sparsity is conserved. It gives a look to the ability ! of the solver to exploit the symbolic calculations performed before. do if ( slv_struct % slv_t == MUMP ) then size_a_elt = size ( slv_struct % a_elt ) else size_a_elt = slv_struct % nt endif ! the original entries are retrieved, then modified a_elt = a_elt_ref call modify_a_elt ( tab = a_elt , nz = size_a_elt ) slv_struct % a_elt = a_elt slv_struct % b = b slv_struct % x = 0._R8 time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'fac' ) call solve_syst ( mat = slv_struct , step = 'sol' ) call solve_syst ( mat = slv_struct , step = 'fre' ) time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) write ( OPU , * ) 'STOP? (y=1, n=0)' read ( IPU , * ) ii if ( ii == 1 ) exit enddo deallocate ( eltvar , a_elt , a_elt_ref , eltptr , b ) call solve_syst ( mat = slv_struct , step = 'end' ) stop contains !========================================================================================= !< @note The product \\{y\\} of the system matrix [A] by the solution \\{x\\}, is !<        calculated, and compared to the right hand side \\{b\\}. !<        The calculated error is the absolute error in %. !< @endnote !----------------------------------------------------------------------------------------- subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution !========================================================================================= subroutine modify_a_elt ( tab , nz ) !! mMltiplication of the system coefficient by a random factor implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt !========================================================================================= subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) !! [A] \\{x\\}, assembled CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x !========================================================================================= subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) !! [A] \\{x\\}, elemental CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x endprogram test_solvers","tags":"","loc":"program/test_solvers.html"},{"title":"test_bspline – TOOLIB","text":"Uses data_arch bspline program~~test_bspline~~UsesGraph program~test_bspline test_bspline module~bspline bspline program~test_bspline->module~bspline module~data_arch data_arch program~test_bspline->module~data_arch iso_fortran_env iso_fortran_env module~bspline->iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Jacob Williams SPLIN. Example of use. Calls program~~test_bspline~~CallsGraph program~test_bspline test_bspline proc~interp_surf interp_surf program~test_bspline->proc~interp_surf proc~db2ink db2ink proc~interp_surf->proc~db2ink proc~db2val db2val proc~interp_surf->proc~db2val proc~func func proc~interp_surf->proc~func proc~check_inputs check_inputs proc~db2ink->proc~check_inputs proc~dbknot dbknot proc~db2ink->proc~dbknot proc~dbtpcf dbtpcf proc~db2ink->proc~dbtpcf proc~dbvalu dbvalu proc~db2val->proc~dbvalu proc~dintrv dintrv proc~db2val->proc~dintrv proc~dbintk dbintk proc~dbtpcf->proc~dbintk proc~dbnslv dbnslv proc~dbtpcf->proc~dbnslv proc~dbvalu->proc~dintrv proc~dbintk->proc~dbnslv proc~dbnfac dbnfac proc~dbintk->proc~dbnfac proc~dbspvn dbspvn proc~dbintk->proc~dbspvn Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4) :: deg real(kind=R8) :: mad integer(kind=I4), parameter :: nnx = 700 integer(kind=I4), parameter :: nny = 1400 integer(kind=I4), parameter :: nx = 128 integer(kind=I4), parameter :: ny = 256 Functions pure elemental function func (xi, yj) Arguments Type Intent Optional Attributes Name real(kind=R8), intent(in) :: xi real(kind=R8), intent(in) :: yj Return Value real(kind=r8) Subroutines subroutine interp_surf (nx, ny, nnx, nny, deg, mad) Arguments Type Intent Optional Attributes Name integer(kind=I4), intent(in) :: nx integer(kind=I4), intent(in) :: ny integer(kind=I4), intent(in) :: nnx integer(kind=I4), intent(in) :: nny integer(kind=I4), intent(in) :: deg real(kind=R8), intent(out) :: mad Source Code program test_bspline use bspline use data_arch , only : I4 , R8 , PI_R8 implicit none integer ( kind = I4 ), parameter :: nx = 128 , ny = 256 integer ( kind = I4 ), parameter :: nnx = 700 , nny = 1400 integer ( kind = I4 ) :: deg real ( kind = R8 ) :: mad deg = 2 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 3 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 4 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 5 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad stop contains subroutine interp_surf ( nx , ny , nnx , nny , deg , mad ) implicit none integer ( kind = I4 ), intent ( in ) :: nx , ny , nnx , nny , deg real ( kind = R8 ), intent ( out ) :: mad integer ( kind = I4 ) :: i , j , inbvx , inbvy , iloy , iflag real ( kind = R8 ) :: val real ( kind = R8 ), dimension ( 1 : nx , 1 : ny ) :: coeff , tab real ( kind = R8 ), dimension ( 1 : nnx , 1 : nny ) :: tab_ref , tab_int real ( kind = R8 ), dimension ( 1 :( nx + deg )) :: tx real ( kind = R8 ), dimension ( 1 :( ny + deg )) :: ty real ( kind = R8 ), dimension ( 1 : nx ) :: x real ( kind = R8 ), dimension ( 1 : ny ) :: y real ( kind = R8 ), dimension ( 1 : nnx ) :: xx real ( kind = R8 ), dimension ( 1 : nny ) :: yy x ( 1 : nx ) = [( - 1. + ( i - 1 ) * 2. / ( nx - 1 ), i = 1 , nx )] y ( 1 : ny ) = [( - 1. + ( j - 1 ) * 2. / ( ny - 1 ), j = 1 , ny )] do j = 1 , ny do i = 1 , nx tab ( i , j ) = func ( x ( i ), y ( j ) ) enddo enddo iflag = 0 call db2ink ( x = x ( 1 : nx ), & ! Array of x abcissae. Must be strictly increasing. nx = nx , & ! Number of x abcissae y = y ( 1 : ny ), & ! Array of y abcissae. Must be strictly increasing. ny = ny , & ! Number of y abcissae fcn = tab ( 1 : nx , 1 : ny ), & ! Array of function values to interpolate. fcn(i,j) should !    contain the function value at the point (x(i),y(j)) kx = deg , & ! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) ky = deg , & ! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) tx = tx ( 1 :( nx + deg )), & ! The knots in the x direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. ty = ty ( 1 :( ny + deg )), & ! The knots in the y direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. bcoef = coeff ( 1 : nx , 1 : ny ), & ! Array of coefficients of the b-spline interpolant. iflag = iflag ) ! **on input:**  0 = knot sequence chosen by [[db2ink]]. !                1 = knot sequence chosen by user. ! **on output:** 1 = successful execution. !                2 = iflag out of range. !                3 = nx out of range. !                4 = kx out of range. !                5 = x not strictly increasing. !                6 = tx not non-decreasing. !                7 = ny out of range. !                8 = ky out of range. !                9 = y not strictly increasing. !               10 = ty not non-decreasing. if ( iflag /= 1 ) error stop 'error calling db2ink' xx ( 1 : nnx ) = [( - 1. + ( i - 1 ) * 2. / ( nnx - 1 ), i = 1 , nnx )] yy ( 1 : nny ) = [( - 1. + ( j - 1 ) * 2. / ( nny - 1 ), j = 1 , nny )] inbvx = 1 inbvy = 1 iloy = 1 do j = 1 , nny do i = 1 , nnx call db2val ( xval = xx ( i ), & ! xval     !! x coordinate of evaluation point. yval = yy ( j ), & ! yval     !! y coordinate of evaluation point. idx = 0 , & ! idx      !! x derivative of piecewise polynomial to evaluate. idy = 0 , & ! idy      !! y derivative of piecewise polynomial to evaluate. tx = tx ( 1 :( nx + deg )), & ! tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) ty = ty ( 1 :( ny + deg )), & ! ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) nx = nx , & ! nx       !! the number of interpolation points in x. (same as in last call to [[db2ink]]) ny = ny , & ! ny       !! the number of interpolation points in y. (same as in last call to [[db2ink]]) kx = deg , & ! kx       !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) ky = deg , & ! ky       !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) bcoef = coeff ( 1 : nx , 1 : ny ), & ! bcoef    !! the b-spline coefficients computed by [[db2ink]]. f = val , & ! f        !! interpolated value & iflag = iflag , & ! iflag    !! status flag: 0 : no errors, /=0 : error inbvx = inbvx , & ! inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. inbvy = inbvy , & ! inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. iloy = iloy ) ! iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. tab_int ( i , j ) = val enddo enddo do j = 1 , nny do i = 1 , nnx tab_ref ( i , j ) = func ( xx ( i ), yy ( j ) ) enddo enddo mad = maxval ( abs ( tab_ref - tab_int ) ) return endsubroutine interp_surf pure elemental real ( kind = R8 ) function func ( xi , yj ) implicit none real ( kind = R8 ), intent ( in ) :: xi , yj func = sin ( 10 * PI_R8 * xi ) * sin ( 10 * PI_R8 * yj ) return endfunction func endprogram test_bspline","tags":"","loc":"program/test_bspline.html"},{"title":"test_surfile – TOOLIB","text":"Uses data_arch surfile program~~test_surfile~~UsesGraph program~test_surfile test_surfile module~data_arch data_arch program~test_surfile->module~data_arch module~surfile surfile program~test_surfile->module~surfile iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~surfile->module~data_arch iso_c_binding iso_c_binding module~surfile->iso_c_binding module~miscellaneous miscellaneous module~surfile->module~miscellaneous module~sort_arrays sort_arrays module~surfile->module~sort_arrays module~miscellaneous->module~data_arch module~sort_arrays->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Routines to handle Digital Surf binary format (.sur). Example of use Calls program~~test_surfile~~CallsGraph program~test_surfile test_surfile proc~init_scal init_scal program~test_surfile->proc~init_scal proc~read_surf read_surf program~test_surfile->proc~read_surf proc~scal2surf scal2surf program~test_surfile->proc~scal2surf proc~trans_surf_txt trans_surf_txt program~test_surfile->proc~trans_surf_txt proc~write_surf write_surf program~test_surfile->proc~write_surf proc~empty empty proc~init_scal->proc~empty proc~get_unit get_unit proc~read_surf->proc~get_unit proc~lower lower proc~read_surf->proc~lower proc~open_surffile open_surffile proc~read_surf->proc~open_surffile proc~sort_array2 sort_array2 proc~read_surf->proc~sort_array2 proc~trans_surf_tab trans_surf_tab proc~read_surf->proc~trans_surf_tab proc~f_c_string f_c_string proc~scal2surf->proc~f_c_string proc~c_f_string c_f_string proc~trans_surf_txt->proc~c_f_string proc~trans_surf_txt->proc~empty proc~trans_surf_txt->proc~get_unit proc~write_surf->proc~scal2surf proc~build_surf build_surf proc~write_surf->proc~build_surf proc~write_surf->proc~get_unit proc~write_surf->proc~lower proc~surf2scal surf2scal proc~write_surf->proc~surf2scal proc~write_surffile write_surffile proc~write_surf->proc~write_surffile proc~unit2iuc unit2IUc proc~build_surf->proc~unit2iuc proc~c_f_string->proc~empty proc~open_surffile->proc~trans_surf_txt proc~open_surffile->proc~get_unit proc~open_surffile->proc~surf2scal proc~change_array_order change_array_order proc~sort_array2->proc~change_array_order proc~init_order init_order proc~sort_array2->proc~init_order proc~sort_array_integer_with_order sort_array_integer_with_order proc~sort_array2->proc~sort_array_integer_with_order proc~sort_array_real_with_order sort_array_real_with_order proc~sort_array2->proc~sort_array_real_with_order proc~surf2scal->proc~c_f_string proc~unit2iuf unit2IUf proc~surf2scal->proc~unit2iuf proc~trans_surf_tab->proc~unit2iuc proc~write_surffile->proc~get_unit proc~sort_array_integer_with_order->proc~sort_array_integer_with_order proc~sort_array_real_with_order->proc~sort_array_real_with_order proc~unit2iuc->proc~unit2iuf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=I4) :: i integer(kind=I4) :: j type( SCALE_SURF ) :: scal object SCALE_SURF , fortran type version type( OBJ_SURF ) :: surf object OBJ_SURF ,         c type version real(kind=R8), dimension(:,:), allocatable :: tab height array Source Code program test_surfile use data_arch use surfile implicit none real ( kind = R8 ), dimension (:,:), allocatable :: tab !! *height array* type ( SCALE_SURF ) :: scal !! *object [[SCALE_SURF]], fortran type version* type ( OBJ_SURF ) :: surf !! *object [[OBJ_SURF]],         c type version* integer ( kind = I4 ) :: i , j ! --- reads a xyz ascii file, writes the corresponding \"sur\" file and dumps the header call init_scal ( scal ) ! creates an empty surface type (fortran form) call read_surf ( nom_fic = \"sur/600x300.dat\" , & !  in; three columns in ascii format : x y f(x,y); no header; tab separation tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call write_surf ( nom_fic = \"out/600x300_dat_to_not-scaled.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call scal2surf ( scal , surf ) !        surface type transformation: fortran form to c form call trans_surf_txt ( surf = surf , & !    in; dumps the surface header ... fichier = \"out/600x300_dat_to_not-scaled.txt\" , & !    in; ... in a specified file ... xyz = . false .) !    in; ... and no f(x,y) dump. deallocate ( tab ) ! --- reads a \"sur\" file, writes its scaled form in a \"sur\" file and a xyz file call read_surf ( nom_fic = \"sur/600x300.sur\" , & !  in; Digital Surf format mu = 1._R8 , & !  in; data will be centered sq = 1._R8 , & !  in; data will be normalized (with the standard deviation) tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call write_surf ( nom_fic = \"out/600x300_resu_scaled.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call write_surf ( nom_fic = \"out/600x300_resu_scaled.dat\" , & !    in; filename of the ascii \".dat\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type deallocate ( tab ) ! --- creates a surface and writes a \".sur\" file allocate ( tab ( 600 , 300 )) do j = 1 , 300 do i = 1 , 600 tab ( i , j ) = 1.e+9 * cos ( 6 * 2 * PI_R8 * i / 600 ) * cos ( 3 * 2 * PI_R8 * j / 300 ) + 1.e+8 enddo enddo call init_scal ( scal = scal , & ! out; creates a surface type, containing ... nx = 600 , & !  in; ... the number of points along x ... ny = 300 , & !  in; ... the number of points along y ... lx = 1.0e-3_R8 , & !  in; ... the length (default unit : m) ... ly = 0.5e-3_R8 , & !  in; ... the width ... unit_z = 'Pa' ) !  in; ... and the unit along z. call write_surf ( nom_fic = \"out/cos.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call read_surf ( nom_fic = \"out/cos.sur\" , & !  in; Digital Surf format tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call scal2surf ( scal , surf ) !      surface type transformation: fortran form to c form call trans_surf_txt ( surf = surf , & ! in; dumps the surface header ... fichier = \"out/cos.txt\" , & ! in; ... in a specified file ... xyz = . false .) ! in; ... and no f(x,y) dump. deallocate ( tab ) stop endprogram test_surfile","tags":"","loc":"program/test_surfile.html"},{"title":"test_utils – TOOLIB","text":"Uses data_arch cholesky program~~test_utils~~UsesGraph program~test_utils test_utils module~cholesky cholesky program~test_utils->module~cholesky module~data_arch data_arch program~test_utils->module~data_arch module~cholesky->module~data_arch iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_utils~~CallsGraph program~test_utils test_utils proc~choldc choldc program~test_utils->proc~choldc proc~cholsl cholsl program~test_utils->proc~cholsl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8), dimension(tai, tai) :: a real(kind=R8), dimension(tai, tai) :: aa real(kind=R8), dimension(tai) :: b integer(kind=I4) :: i integer(kind=I4) :: info real(kind=R8), dimension(tai) :: p integer(kind=I4), parameter :: tai = 100 real(kind=R8), dimension(tai) :: x Source Code program test_utils use data_arch , only : I4 , R8 use cholesky , only : choldc , cholsl implicit none integer ( kind = I4 ), parameter :: tai = 100 real ( kind = R8 ), dimension ( tai , tai ) :: a , aa real ( kind = R8 ), dimension ( tai ) :: b , x , p integer ( kind = I4 ) :: i , info call random_number ( a ( 1 : tai , 1 : tai )) call random_number ( b ( 1 : tai )) a = matmul ( a , transpose ( a )) forall ( i = 1 : tai ) a ( i , i ) = 100 * abs ( a ( i , i )) aa ( 1 : tai , 1 : tai ) = a ( 1 : tai , 1 : tai ) call choldc ( a = a ( 1 : tai , 1 : tai ), & ! n = tai , & ! np = tai , & ! p = p ( 1 : tai ), & ! info = info ) ! call cholsl ( a = a ( 1 : tai , 1 : tai ), & ! n = tai , & ! np = tai , & ! p = p ( 1 : tai ), & ! b = b ( 1 : tai ), & ! x = x ( 1 : tai ), & ! info = info ) ! write ( * , * ) sum ( abs ( matmul ( aa , x ) - b ) ), info stop endprogram test_utils","tags":"","loc":"program/test_utils.html"},{"title":"test_fftw3 – TOOLIB","text":"Uses fftw3 data_arch miscellaneous program~~test_fftw3~~UsesGraph program~test_fftw3 test_fftw3 module~data_arch data_arch program~test_fftw3->module~data_arch module~fftw3 fftw3 program~test_fftw3->module~fftw3 module~miscellaneous miscellaneous program~test_fftw3->module~miscellaneous iso_fortran_env iso_fortran_env module~data_arch->iso_fortran_env module~fftw3->module~data_arch iso_c_binding iso_c_binding module~fftw3->iso_c_binding module~miscellaneous->module~data_arch Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Routines to work with FFTs. Example of use Calls program~~test_fftw3~~CallsGraph program~test_fftw3 test_fftw3 interface~fftw_plan_with_nthreads fftw_plan_with_nthreads program~test_fftw3->interface~fftw_plan_with_nthreads omp_get_max_threads omp_get_max_threads program~test_fftw3->omp_get_max_threads proc~calc_fftw3 calc_fftw3 program~test_fftw3->proc~calc_fftw3 proc~calc_fftw3_real_bwd calc_fftw3_real_bwd program~test_fftw3->proc~calc_fftw3_real_bwd proc~calc_fftw3_real_fwd calc_fftw3_real_fwd program~test_fftw3->proc~calc_fftw3_real_fwd proc~end_fftw3 end_fftw3 program~test_fftw3->proc~end_fftw3 proc~get_unit get_unit program~test_fftw3->proc~get_unit proc~init_fftw3 init_fftw3 program~test_fftw3->proc~init_fftw3 proc~init_fftw3_real init_fftw3_real program~test_fftw3->proc~init_fftw3_real proc~read_surf~2 read_surf program~test_fftw3->proc~read_surf~2 proc~save_surf save_surf program~test_fftw3->proc~save_surf proc~tab_calc_fftw3 tab_calc_fftw3 program~test_fftw3->proc~tab_calc_fftw3 proc~tab_calc_fftw3_real_bwd tab_calc_fftw3_real_bwd program~test_fftw3->proc~tab_calc_fftw3_real_bwd proc~tab_calc_fftw3_real_fwd tab_calc_fftw3_real_fwd program~test_fftw3->proc~tab_calc_fftw3_real_fwd proc~tab_end_fftw3 tab_end_fftw3 program~test_fftw3->proc~tab_end_fftw3 proc~tab_end_fftw3_real tab_end_fftw3_real program~test_fftw3->proc~tab_end_fftw3_real proc~tab_init_fftw3 tab_init_fftw3 program~test_fftw3->proc~tab_init_fftw3 proc~tab_init_fftw3_real tab_init_fftw3_real program~test_fftw3->proc~tab_init_fftw3_real proc~calc_fftw3->interface~fftw_plan_with_nthreads proc~calc_fftw3->proc~end_fftw3 proc~calc_fftw3->proc~init_fftw3 interface~fftw_execute_dft fftw_execute_dft proc~calc_fftw3->interface~fftw_execute_dft omp_get_num_procs omp_get_num_procs proc~calc_fftw3->omp_get_num_procs proc~calc_fftw3_real_bwd->interface~fftw_plan_with_nthreads proc~calc_fftw3_real_bwd->proc~end_fftw3 proc~calc_fftw3_real_bwd->proc~init_fftw3_real interface~fftw_execute_dft_c2r fftw_execute_dft_c2r proc~calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r proc~calc_fftw3_real_bwd->omp_get_num_procs proc~calc_fftw3_real_fwd->interface~fftw_plan_with_nthreads proc~calc_fftw3_real_fwd->proc~end_fftw3 proc~calc_fftw3_real_fwd->proc~init_fftw3_real interface~fftw_execute_dft_r2c fftw_execute_dft_r2c proc~calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c proc~calc_fftw3_real_fwd->omp_get_num_procs proc~desalloc_fftw3 desalloc_fftw3 proc~end_fftw3->proc~desalloc_fftw3 proc~destroy_plan_fftw3 destroy_plan_fftw3 proc~end_fftw3->proc~destroy_plan_fftw3 proc~alloc_fftw3 alloc_fftw3 proc~init_fftw3->proc~alloc_fftw3 proc~make_plan_fftw3 make_plan_fftw3 proc~init_fftw3->proc~make_plan_fftw3 proc~alloc_fftw3_real alloc_fftw3_real proc~init_fftw3_real->proc~alloc_fftw3_real proc~make_plan_fftw3_real make_plan_fftw3_real proc~init_fftw3_real->proc~make_plan_fftw3_real proc~read_surf~2->proc~get_unit proc~save_surf->proc~get_unit proc~tab_calc_fftw3->interface~fftw_execute_dft omp_get_thread_num omp_get_thread_num proc~tab_calc_fftw3->omp_get_thread_num proc~tab_calc_fftw3_real_bwd->interface~fftw_execute_dft_c2r proc~tab_calc_fftw3_real_bwd->omp_get_thread_num proc~tab_calc_fftw3_real_fwd->interface~fftw_execute_dft_r2c proc~tab_calc_fftw3_real_fwd->omp_get_thread_num proc~tab_desalloc_fftw3 tab_desalloc_fftw3 proc~tab_end_fftw3->proc~tab_desalloc_fftw3 proc~tab_destroy_plan_fftw3 tab_destroy_plan_fftw3 proc~tab_end_fftw3->proc~tab_destroy_plan_fftw3 proc~tab_end_fftw3_real->proc~tab_desalloc_fftw3 proc~tab_end_fftw3_real->proc~tab_destroy_plan_fftw3 proc~tab_alloc_fftw3 tab_alloc_fftw3 proc~tab_init_fftw3->proc~tab_alloc_fftw3 proc~tab_make_plan_fftw3 tab_make_plan_fftw3 proc~tab_init_fftw3->proc~tab_make_plan_fftw3 proc~tab_alloc_fftw3_real tab_alloc_fftw3_real proc~tab_init_fftw3_real->proc~tab_alloc_fftw3_real proc~tab_make_plan_fftw3_real tab_make_plan_fftw3_real proc~tab_init_fftw3_real->proc~tab_make_plan_fftw3_real interface~fftw_alloc_complex fftw_alloc_complex proc~alloc_fftw3->interface~fftw_alloc_complex proc~alloc_fftw3_real->interface~fftw_alloc_complex interface~fftw_alloc_real fftw_alloc_real proc~alloc_fftw3_real->interface~fftw_alloc_real interface~fftw_free fftw_free proc~desalloc_fftw3->interface~fftw_free interface~fftw_destroy_plan fftw_destroy_plan proc~destroy_plan_fftw3->interface~fftw_destroy_plan interface~fftw_plan_dft_2d fftw_plan_dft_2d proc~make_plan_fftw3->interface~fftw_plan_dft_2d interface~fftw_plan_dft_c2r_2d fftw_plan_dft_c2r_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d interface~fftw_plan_dft_r2c_2d fftw_plan_dft_r2c_2d proc~make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d proc~tab_alloc_fftw3->interface~fftw_alloc_complex proc~tab_alloc_fftw3_real->interface~fftw_alloc_complex proc~tab_alloc_fftw3_real->interface~fftw_alloc_real proc~tab_desalloc_fftw3->interface~fftw_free proc~tab_destroy_plan_fftw3->interface~fftw_destroy_plan proc~tab_make_plan_fftw3->interface~fftw_plan_dft_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_c2r_2d proc~tab_make_plan_fftw3_real->interface~fftw_plan_dft_r2c_2d Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=R8) :: error integer(kind=I4) :: i integer(kind=I4) :: k integer(kind=I4) :: nb_iter integer(kind=I4) :: ni integer(kind=I4) :: nj real(kind=R4) :: t1 real(kind=R4) :: t2 real(kind=R8), dimension(:,:), allocatable :: tab real array containing the information to process complex(kind=R8), dimension(:,:), allocatable :: tab1 input array FORWARD ,  output array BACKWARD complex(kind=R8), dimension(:,:), allocatable :: tab2 input array BACKWARD , output array FORWARD real(kind=R8), dimension(:,:), allocatable :: tabr1 real array containing the information to process real(kind=R8), dimension(:,:), allocatable :: tabr2 real array containing the information to process Subroutines subroutine read_surf (nom_fic, tab_s, nx, ny) Subroutine that opens a surface file .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(out), dimension(:,:), allocatable :: tab_s height array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y subroutine save_surf (nom_fic, tab_s, nx, ny) Subroutine that saves a surface file .dat Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: nom_fic file name real(kind=R8), intent(in), dimension(1:nx, 1:ny) :: tab_s height array integer(kind=I4), intent(in) :: nx number of pixels along x integer(kind=I4), intent(in) :: ny number of pixels along y Source Code program test_fftw3 !$ use omp_lib use data_arch , only : I4 , R8 , R4 use miscellaneous , only : get_unit use fftw3 implicit none integer ( kind = I4 ) :: i , k integer ( kind = I4 ) :: ni integer ( kind = I4 ) :: nj integer ( kind = I4 ) :: nb_iter real ( kind = R8 ) :: error real ( kind = R4 ) :: t1 , t2 real ( kind = R8 ), dimension (:,:), allocatable :: tab !! real array containing the information to process real ( kind = R8 ), dimension (:,:), allocatable :: tabr1 !! real array containing the information to process real ( kind = R8 ), dimension (:,:), allocatable :: tabr2 !! real array containing the information to process complex ( kind = R8 ), dimension (:,:), allocatable :: tab1 !! input array ```FORWARD```,  output array ```BACKWARD``` complex ( kind = R8 ), dimension (:,:), allocatable :: tab2 !! input array ```BACKWARD```, output array ```FORWARD``` ! COMPLEX -> COMPLEX -> COMPLEX !---------------------------------------------------------------------------------------------------------------- ! multithread activation !---------------------------------------------------------------------------------------------------------------- NB_THREADS_FFT = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = NB_THREADS_FFT ) ! first case: random array forward, then backward transformed ! The difference ```error``` between original and processed data is calculated ni = 4096 nj = 4096 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) call init_fftw3 ( long = ni , larg = nj ) call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( * , * ) 'C-C-C error = ' , error call end_fftw3 () deallocate ( tab , tab1 , tab2 ) ! second case: height array forward, then backward transformed ! The difference between original and processed data can be assessed with the resulting \"600x300_FB.dat\" ni = 600 nj = 300 call read_surf ( nom_fic = \"./sur/600x300.dat\" , tab_s = tab , nx = ni , ny = nj ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) ; tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call cpu_time ( t1 ) call init_fftw3 ( long = ni , larg = nj ) call calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) call end_fftw3 () call cpu_time ( t2 ) write ( * , * ) t2 - t1 tab ( 1 : ni , 1 : nj ) = real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 ) call save_surf ( nom_fic = \"./sur/600x300_FB_comp.dat\" , tab_s = tab , nx = ni , ny = nj ) deallocate ( tab , tab1 , tab2 ) !---------------------------------------------------------------------------------------------------------------- ! multithread deactivation ! ```NB_THREADS_MAX``` are simultaneously computed on random 512x512 arrays ! The difference ```error``` between original and processed data is calculated call fftw_plan_with_nthreads ( nthreads = 1 ) ni = 0512 nj = 0512 nb_iter = 100 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) call get_unit ( k ) open ( unit = k , file = \"out/error_comp.txt\" ) NB_THREADS_FFT = omp_get_max_threads () call tab_init_fftw3 ( long = ni , larg = nj , plan_flag = FFTW_MEASURE ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, NB_ITER/NB_THREADS_FFT) PRIVATE(tab, tab1, tab2) do i = 1 , nb_iter call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) + 1._R8 tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call tab_calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call tab_calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( k , * ) error enddo !$OMP END DO !$OMP END PARALLEL call tab_end_fftw3 () close ( k ) deallocate ( tab , tab1 , tab2 ) ! REAL -> COMPLEX -> REAL !---------------------------------------------------------------------------------------------------------------- ! multithread activation !---------------------------------------------------------------------------------------------------------------- NB_THREADS_FFT = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = NB_THREADS_FFT ) ! first case: random array forward, then backward transformed ! The difference ```error``` between original and processed data is calculated ni = 4096 nj = 4096 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tabr2 ( 1 : ni , 1 : nj ) ) allocate ( tab2 ( 1 : ni , 1 : nj ) ) call init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_ESTIMATE ) call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr2 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tabr2 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( * , * ) 'R-C-R: error = ' , error call end_fftw3 () deallocate ( tab , tabr1 , tabr2 , tab2 ) ! second case: height array forward, then backward transformed ! The difference between original and processed data can be assessed with the resulting \"600x300_FB.dat\" ni = 600 nj = 300 call read_surf ( nom_fic = \"./sur/600x300.dat\" , tab_s = tab , nx = ni , ny = nj ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) ; tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call cpu_time ( t1 ) call init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_ESTIMATE ) call calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr1 , long = ni , larg = nj ) call end_fftw3 () call cpu_time ( t2 ) write ( * , * ) t2 - t1 tab ( 1 : ni , 1 : nj ) = tabr1 ( 1 : ni , 1 : nj ) call save_surf ( nom_fic = \"./sur/600x300_FB_real.dat\" , tab_s = tab , nx = ni , ny = nj ) deallocate ( tab , tabr1 , tab2 ) !---------------------------------------------------------------------------------------------------------------- ! multithread deactivation ! ```NB_THREADS_MAX``` are simultaneously computed on random 512x512 arrays ! The difference ```error``` between original and processed data is calculated call fftw_plan_with_nthreads ( nthreads = 1 ) ni = 0512 nj = 0512 nb_iter = 100 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab2 ( 1 : ni , 1 : nj ) ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tabr2 ( 1 : ni , 1 : nj ) ) call get_unit ( k ) open ( unit = k , file = \"out/error_real.txt\" ) NB_THREADS_FFT = omp_get_max_threads () call tab_init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_MEASURE ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, NB_ITER/NB_THREADS_FFT) PRIVATE(tab, tabr1, tabr2, tab2) do i = 1 , nb_iter call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) + 1._R8 tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call tab_calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call tab_calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr2 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - tabr2 ( 1 : ni , 1 : nj )) / tab ( 1 : ni , 1 : nj ) ) ) write ( k , * ) error enddo !$OMP END DO !$OMP END PARALLEL call tab_end_fftw3_real () close ( k ) deallocate ( tab , tabr1 , tabr2 , tab2 ) stop contains !========================================================================================= subroutine read_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that opens a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( out ), dimension (:,:), allocatable :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: x , y allocate ( tab_s ( 1 : nx , 1 : ny ) ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) do i = 1 , nx do j = 1 , ny read ( k , * ) x , y , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine read_surf !========================================================================================= subroutine save_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that saves a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'unknown' ) do i = 1 , nx do j = 1 , ny write ( k , * ) i , j , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine save_surf endprogram test_fftw3","tags":"","loc":"program/test_fftw3.html"},{"title":"mod_miscellaneous.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_miscellaneous.f90~~EfferentGraph sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_miscellaneous.f90~~AfferentGraph sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_files.f90 mod_files.f90 sourcefile~mod_files.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_surfile.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~14 prg.f90 sourcefile~prg.f90~14->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 sourcefile~prg.f90~4 prg.f90 sourcefile~prg.f90~4->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~8 prg.f90 sourcefile~prg.f90~8->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~12 prg.f90 sourcefile~prg.f90~12->sourcefile~mod_surfile.f90 sourcefile~prg.f90~7 prg.f90 sourcefile~prg.f90~7->sourcefile~mod_files.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.1.0 !<  date: april, 6 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Various subroutines** !<  </span> module miscellaneous use data_arch , only : I4 , R8 , OPU , IPU , ERU implicit none private public :: get_unit , trans_center2corner , trans_corner2center , progress_bar_terminal contains !================================================================================================ subroutine get_unit ( iunit ) !! Provide for a free unit, from here [John Burkardt website](https://people.sc.fsu.edu/~jburkardt/f_src) implicit none integer ( kind = I4 ), intent ( out ) :: iunit !! free unit to use integer ( kind = I4 ) :: i integer ( kind = I4 ) :: ios logical ( kind = I4 ) :: lopen iunit = 0 do i = 10 , 99 if ( i /= OPU . and . i /= IPU . and . i /= ERU ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return endif endif endif enddo return endsubroutine get_unit !================================================================================================ subroutine trans_center2corner ( tab_in , tab_out , long , larg ) !! Generic subroutine for real or complex arrays that shift the center to the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* class ( * ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* class ( * ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* select type ( tab_in ) type is ( real ( kind = R8 ) ) select type ( tab_out ) type is ( real ( kind = R8 ) ) call trans_center2corner_real ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect type is ( complex ( kind = R8 ) ) select type ( tab_out ) type is ( complex ( kind = R8 ) ) call trans_center2corner_cmpl ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect endselect return endsubroutine trans_center2corner !================================================================================================ subroutine trans_corner2center ( tab_in , tab_out , long , larg ) !! Generic subroutine for real or complex arrays that shift the corners to the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* class ( * ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* class ( * ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* select type ( tab_in ) type is ( real ( kind = R8 ) ) select type ( tab_out ) type is ( real ( kind = R8 ) ) call trans_corner2center_real ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect type is ( complex ( kind = R8 ) ) select type ( tab_out ) type is ( complex ( kind = R8 ) ) call trans_corner2center_cmpl ( tab_in ( 1 : long , 1 : larg ), tab_out ( 1 : long , 1 : larg ), long = long , larg = larg ) endselect endselect return endsubroutine trans_corner2center !================================================================================================ subroutine trans_center2corner_real ( tab_in , tab_out , long , larg ) !! Subroutine to transform an array of reals so that the center is in the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j , ii , jj ii = 0 jj = 0 if ( long == 2 * ( long / 2 ) ) ii = 1 if ( larg == 2 * ( larg / 2 ) ) jj = 1 do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - ii , long ) + 1 , & ! mod ( j + larg / 2 - jj , larg ) + 1 ) enddo enddo return endsubroutine trans_center2corner_real !================================================================================================ subroutine trans_center2corner_cmpl ( tab_in , tab_out , long , larg ) !! Subroutine to transform an array of complexes so that the center is in the corners implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* complex ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* complex ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j , ii , jj ii = 0 jj = 0 if ( long == 2 * ( long / 2 ) ) ii = 1 if ( larg == 2 * ( larg / 2 ) ) jj = 1 do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - ii , long ) + 1 , & ! mod ( j + larg / 2 - jj , larg ) + 1 ) enddo enddo return endsubroutine trans_center2corner_cmpl !================================================================================================ subroutine trans_corner2center_real ( tab_in , tab_out , long , larg ) !! Function to transform an acf real array so that the acf maximum is in the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - 1 , long ) + 1 , & ! mod ( j + larg / 2 - 1 , larg ) + 1 ) enddo enddo return endsubroutine trans_corner2center_real !================================================================================================ subroutine trans_corner2center_cmpl ( tab_in , tab_out , long , larg ) !! Function to transform an acf complex array so that the acf maximum is in the center implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* complex ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *2D array to transform* complex ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *transformed 2D array* integer ( kind = I4 ) :: i , j do j = 1 , larg do i = 1 , long tab_out ( i , j ) = tab_in ( mod ( i + long / 2 - 1 , long ) + 1 , & ! mod ( j + larg / 2 - 1 , larg ) + 1 ) enddo enddo return endsubroutine trans_corner2center_cmpl !================================================================================================ subroutine progress_bar_terminal ( val , max_val , init ) !! Print a progress bar on the terminal implicit none integer ( kind = I4 ), intent ( in ) :: val !! *actual position* integer ( kind = I4 ), intent ( in ) :: max_val !! *maximum value reached* logical ( kind = I4 ), intent ( in ) :: init !! *progress bar initialization* character ( len = 102 ) :: bar integer ( kind = I4 ) :: ival if ( init ) then write ( * , * ) write ( bar , '(a)' ) '[' // repeat ( '.' , 100 ) // ']' write ( * , '(a)' , advance = 'no' ) bar return endif ival = nint ( 9 9.99 * ( real ( val , kind = R8 ) / max_val ) ) write ( bar , '(a)' ) '[' // repeat ( '*' , ival ) // repeat ( '.' , 100 - ival ) // ']' write ( * , '(a)' , advance = 'no' ) repeat ( achar ( 8 ), 102 ) // bar if ( val == max_val ) then write ( * , * ) ' ... done' write ( * , * ) endif return endsubroutine progress_bar_terminal endmodule miscellaneous","tags":"","loc":"sourcefile/mod_miscellaneous.f90.html"},{"title":"mod_minpack.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~mod_minpack.f90~~AfferentGraph sourcefile~mod_minpack.f90 mod_minpack.f90 sourcefile~prg.f90~9 prg.f90 sourcefile~prg.f90~9->sourcefile~mod_minpack.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: John Burkardt !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **A fortran collection of functions for minimization problems** !< </span> !< !< @note !< MINPACK is a FORTRAN90 library which solves systems of nonlinear equations, !< or carries out the least squares minimization of the residual of a set of linear or nonlinear equations, !< by Jorge More, Danny Sorenson, Burton Garbow, Kenneth Hillstrom. !< !< [link](https://people.math.sc.edu/Burkardt/f_src/minpack/minpack.html) !< !< @endnote !< module minpack implicit none public contains subroutine chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) !*****************************************************************************80 ! !! CHKDER checks the gradients of M functions of N variables. ! !  Discussion: ! !    CHKDER checks the gradients of M nonlinear functions in N variables, !    evaluated at a point X, for consistency with the functions themselves. ! !    The user calls CHKDER twice, first with MODE = 1 and then with MODE = 2. ! !    MODE = 1. !      On input, !        X contains the point of evaluation. !      On output, !        XP is set to a neighboring point. ! !    Now the user must evaluate the function and gradients at X, and the !    function at XP.  Then the function is called again: ! !    MODE = 2. !      On input, !        FVEC contains the function values at X, !        FJAC contains the function gradients at X. !        FVECP contains the functions evaluated at XP. !      On output, !        ERR contains measures of correctness of the respective gradients. ! !    The function does not perform reliably if cancellation or !    rounding errors cause a severe loss of significance in the !    evaluation of a function.  Therefore, none of the components !    of X should be unusually small (in particular, zero) or any !    other value which may cause loss of significance. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. ! !    Input, real ( kind = 8 ) X(N), the point at which the jacobian is to be !    evaluated. ! !    Input, real ( kind = 8 ) FVEC(M), is used only when MODE = 2. !    In that case, it should contain the function values at X. ! !    Input, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  When MODE = 2, !    FJAC(I,J) should contain the value of dF(I)/dX(J). ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Output, real ( kind = 8 ) XP(N), on output with MODE = 1, is a neighboring !    point of X, at which the function is to be evaluated. ! !    Input, real ( kind = 8 ) FVECP(M), on input with MODE = 2, is the function !    value at XP. ! !    Input, integer ( kind = 4 ) MODE, should be set to 1 on the first call, and !    2 on the second. ! !    Output, real ( kind = 8 ) ERR(M).  On output when MODE = 2, ERR contains !    measures of correctness of the respective gradients.  If there is no !    severe loss of significance, then if ERR(I): !      = 1.0D+00, the I-th gradient is correct, !      = 0.0D+00, the I-th gradient is incorrect. !      > 0.5D+00, the I-th gradient is probably correct. !      < 0.5D+00, the I-th gradient is probably incorrect. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsf real ( kind = 8 ) epslog real ( kind = 8 ) epsmch real ( kind = 8 ) err ( m ) real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) fvecp ( m ) integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) mode real ( kind = 8 ) temp real ( kind = 8 ) x ( n ) real ( kind = 8 ) xp ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( epsmch ) ! !  MODE = 1. ! if ( mode == 1 ) then do j = 1 , n temp = eps * abs ( x ( j ) ) if ( temp == 0.0D+00 ) then temp = eps end if xp ( j ) = x ( j ) + temp end do ! !  MODE = 2. ! else if ( mode == 2 ) then epsf = 10 0.0D+00 * epsmch epslog = log10 ( eps ) err = 0.0D+00 do j = 1 , n temp = abs ( x ( j ) ) if ( temp == 0.0D+00 ) then temp = 1.0D+00 end if err ( 1 : m ) = err ( 1 : m ) + temp * fjac ( 1 : m , j ) end do do i = 1 , m temp = 1.0D+00 if ( fvec ( i ) /= 0.0D+00 . and . fvecp ( i ) /= 0.0D+00 . and . & abs ( fvecp ( i ) - fvec ( i )) >= epsf * abs ( fvec ( i ) ) ) then temp = eps * abs ( ( fvecp ( i ) - fvec ( i )) / eps - err ( i ) ) & / ( abs ( fvec ( i ) ) + abs ( fvecp ( i ) ) ) end if err ( i ) = 1.0D+00 if ( epsmch < temp . and . temp < eps ) then err ( i ) = ( log10 ( temp ) - epslog ) / epslog end if if ( eps <= temp ) then err ( i ) = 0.0D+00 end if end do end if return endsubroutine chkder subroutine dogleg ( n , r , lr , diag , qtb , delta , x ) !*****************************************************************************80 ! !! DOGLEG finds the minimizing combination of Gauss-Newton and gradient steps. ! !  Discussion: ! !    Given an M by N matrix A, an N by N nonsingular diagonal !    matrix D, an M-vector B, and a positive number DELTA, the !    problem is to determine the convex combination X of the !    Gauss-Newton and scaled gradient directions that minimizes !    (A*X - B) in the least squares sense, subject to the !    restriction that the euclidean norm of D*X be at most DELTA. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization of A.  That is, if A = Q*R, where Q has !    orthogonal columns and R is an upper triangular matrix, !    then DOGLEG expects the full upper triangle of R and !    the first N components of Q'*B. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of the matrix R. ! !    Input, real ( kind = 8 ) R(LR), the upper triangular matrix R stored !    by rows. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must be !    no less than (N*(N+1))/2. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'* B. ! !    Input, real ( kind = 8 ) DELTA, is a positive upper bound on the !    euclidean norm of D*X(1:N). ! !    Output, real ( kind = 8 ) X(N), the desired convex combination of the !    Gauss-Newton direction and the scaled gradient direction. ! implicit none integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) alpha real ( kind = 8 ) bnorm real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) gnorm integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) k integer ( kind = 4 ) l real ( kind = 8 ) qnorm real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) sgnorm real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) ! !  Calculate the Gauss-Newton direction. ! jj = ( n * ( n + 1 ) ) / 2 + 1 do k = 1 , n j = n - k + 1 jj = jj - k l = jj + 1 sum2 = 0.0D+00 do i = j + 1 , n sum2 = sum2 + r ( l ) * x ( i ) l = l + 1 end do temp = r ( jj ) if ( temp == 0.0D+00 ) then l = j do i = 1 , j temp = max ( temp , abs ( r ( l )) ) l = l + n - i end do if ( temp == 0.0D+00 ) then temp = epsmch else temp = epsmch * temp end if end if x ( j ) = ( qtb ( j ) - sum2 ) / temp end do ! !  Test whether the Gauss-Newton direction is acceptable. ! wa1 ( 1 : n ) = 0.0D+00 wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) qnorm = enorm ( n , wa2 ) if ( qnorm <= delta ) then return end if ! !  The Gauss-Newton direction is not acceptable. !  Calculate the scaled gradient direction. ! l = 1 do j = 1 , n temp = qtb ( j ) do i = j , n wa1 ( i ) = wa1 ( i ) + r ( l ) * temp l = l + 1 end do wa1 ( j ) = wa1 ( j ) / diag ( j ) end do ! !  Calculate the norm of the scaled gradient. !  Test for the special case in which the scaled gradient is zero. ! gnorm = enorm ( n , wa1 ) sgnorm = 0.0D+00 alpha = delta / qnorm if ( gnorm /= 0.0D+00 ) then ! !  Calculate the point along the scaled gradient which minimizes the quadratic. ! wa1 ( 1 : n ) = ( wa1 ( 1 : n ) / gnorm ) / diag ( 1 : n ) l = 1 do j = 1 , n sum2 = 0.0D+00 do i = j , n sum2 = sum2 + r ( l ) * wa1 ( i ) l = l + 1 end do wa2 ( j ) = sum2 end do temp = enorm ( n , wa2 ) sgnorm = ( gnorm / temp ) / temp ! !  Test whether the scaled gradient direction is acceptable. ! alpha = 0.0D+00 ! !  The scaled gradient direction is not acceptable. !  Calculate the point along the dogleg at which the quadratic is minimized. ! if ( sgnorm < delta ) then bnorm = enorm ( n , qtb ) temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / delta ) temp = temp - ( delta / qnorm ) * ( sgnorm / delta ) ** 2 & + sqrt ( ( temp - ( delta / qnorm ) ) ** 2 & + ( 1.0D+00 - ( delta / qnorm ) ** 2 ) & * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) ) alpha = ( ( delta / qnorm ) * ( 1.0D+00 - ( sgnorm / delta ) ** 2 ) ) & / temp end if end if ! !  Form appropriate convex combination of the Gauss-Newton !  direction and the scaled gradient direction. ! temp = ( 1.0D+00 - alpha ) * min ( sgnorm , delta ) x ( 1 : n ) = temp * wa1 ( 1 : n ) + alpha * x ( 1 : n ) return endsubroutine dogleg function enorm ( n , x ) !*****************************************************************************80 ! !! ENORM computes the Euclidean norm of a vector. ! !  Discussion: ! !    This is an extremely simplified version of the original ENORM !    routine, which has been renamed to \"ENORM2\". ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the length of the vector. ! !    Input, real ( kind = 8 ) X(N), the vector whose norm is desired. ! !    Output, real ( kind = 8 ) ENORM, the Euclidean norm of the vector. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) x ( n ) real ( kind = 8 ) enorm enorm = sqrt ( sum ( x ( 1 : n ) ** 2 )) return endfunction enorm function enorm2 ( n , x ) !*****************************************************************************80 ! !! ENORM2 computes the Euclidean norm of a vector. ! !  Discussion: ! !    This routine was named ENORM.  It has been renamed \"ENORM2\", !    and a simplified routine has been substituted. ! !    The Euclidean norm is computed by accumulating the sum of !    squares in three different sums.  The sums of squares for the !    small and large components are scaled so that no overflows !    occur.  Non-destructive underflows are permitted.  Underflows !    and overflows do not occur in the computation of the unscaled !    sum of squares for the intermediate components. ! !    The definitions of small, intermediate and large components !    depend on two constants, RDWARF and RGIANT.  The main !    restrictions on these constants are that RDWARF&#94;2 not !    underflow and RGIANT&#94;2 not overflow. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1 !    Argonne National Laboratory, !    Argonne, Illinois. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, is the length of the vector. ! !    Input, real ( kind = 8 ) X(N), the vector whose norm is desired. ! !    Output, real ( kind = 8 ) ENORM2, the Euclidean norm of the vector. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) agiant real ( kind = 8 ) enorm2 integer ( kind = 4 ) i real ( kind = 8 ) rdwarf real ( kind = 8 ) rgiant real ( kind = 8 ) s1 real ( kind = 8 ) s2 real ( kind = 8 ) s3 real ( kind = 8 ) x ( n ) real ( kind = 8 ) xabs real ( kind = 8 ) x1max real ( kind = 8 ) x3max rdwarf = sqrt ( tiny ( rdwarf ) ) rgiant = sqrt ( huge ( rgiant ) ) s1 = 0.0D+00 s2 = 0.0D+00 s3 = 0.0D+00 x1max = 0.0D+00 x3max = 0.0D+00 agiant = rgiant / real ( n , kind = 8 ) do i = 1 , n xabs = abs ( x ( i ) ) if ( xabs <= rdwarf ) then if ( x3max < xabs ) then s3 = 1.0D+00 + s3 * ( x3max / xabs ) ** 2 x3max = xabs else if ( xabs /= 0.0D+00 ) then s3 = s3 + ( xabs / x3max ) ** 2 end if else if ( agiant <= xabs ) then if ( x1max < xabs ) then s1 = 1.0D+00 + s1 * ( x1max / xabs ) ** 2 x1max = xabs else s1 = s1 + ( xabs / x1max ) ** 2 end if else s2 = s2 + xabs ** 2 end if end do ! !  Calculation of norm. ! if ( s1 /= 0.0D+00 ) then enorm2 = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max ) else if ( s2 /= 0.0D+00 ) then if ( x3max <= s2 ) then enorm2 = sqrt ( s2 * ( 1.0D+00 + ( x3max / s2 ) * ( x3max * s3 ) ) ) else enorm2 = sqrt ( x3max * ( ( s2 / x3max ) + ( x3max * s3 ) ) ) end if else enorm2 = x3max * sqrt ( s3 ) end if return endfunction enorm2 subroutine fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn ) !*****************************************************************************80 ! !! FDJAC1 estimates an N by N jacobian matrix using forward differences. ! !  Discussion: ! !    This function computes a forward-difference approximation !    to the N by N jacobian matrix associated with a specified !    problem of N functions in N variables. If the jacobian has !    a banded form, then function evaluations are saved by only !    approximating the nonzero terms. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated. ! !    Input, real ( kind = 8 ) FVEC(N), the functions evaluated at X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the N by N approximate !    jacobian matrix. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC, which !    must not be less than N. ! !    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN. !    If FCN returns a nonzero value of IFLAG, then this routine returns !    immediately to the calling program, with the value of IFLAG. ! !    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and !    superdiagonals within the band of the jacobian matrix.  If the !    jacobian is not banded, set ML and MU to N-1. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( n ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) ml integer ( kind = 4 ) msum integer ( kind = 4 ) mu real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( max ( epsfcn , epsmch ) ) msum = ml + mu + 1 ! !  Computation of dense approximate jacobian. ! if ( n <= msum ) then do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == 0.0D+00 ) then h = eps end if iflag = 1 x ( j ) = temp + h call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) then exit end if x ( j ) = temp fjac ( 1 : n , j ) = ( wa1 ( 1 : n ) - fvec ( 1 : n ) ) / h end do else ! !  Computation of banded approximate jacobian. ! do k = 1 , msum do j = k , n , msum wa2 ( j ) = x ( j ) h = eps * abs ( wa2 ( j ) ) if ( h == 0.0D+00 ) then h = eps end if x ( j ) = wa2 ( j ) + h end do iflag = 1 call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) then exit end if do j = k , n , msum x ( j ) = wa2 ( j ) h = eps * abs ( wa2 ( j ) ) if ( h == 0.0D+00 ) then h = eps end if fjac ( 1 : n , j ) = 0.0D+00 do i = 1 , n if ( j - mu <= i . and . i <= j + ml ) then fjac ( i , j ) = ( wa1 ( i ) - fvec ( i ) ) / h end if end do end do end do end if return endsubroutine fdjac1 subroutine fdjac2 ( fcn , m , n , x , fvec , fjac , ldfjac , iflag , epsfcn ) !*****************************************************************************80 ! !! FDJAC2 estimates an M by N jacobian matrix using forward differences. ! !  Discussion: ! !    This function computes a forward-difference approximation !    to the M by N jacobian matrix associated with a specified !    problem of M functions in N variables. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input, real ( kind = 8 ) X(N), the point where the jacobian is evaluated. ! !    Input, real ( kind = 8 ) FVEC(M), the functions evaluated at X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), the M by N approximate !    jacobian matrix. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC, !    which must not be less than M. ! !    Output, integer ( kind = 4 ) IFLAG, is an error flag returned by FCN. !    If FCN returns a nonzero value of IFLAG, then this routine returns !    immediately to the calling program, with the value of IFLAG. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable !    step length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) eps real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) h integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) j real ( kind = 8 ) temp real ( kind = 8 ) wa ( m ) real ( kind = 8 ) x ( n ) epsmch = epsilon ( epsmch ) eps = sqrt ( max ( epsfcn , epsmch ) ) do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == 0.0D+00 ) then h = eps end if iflag = 1 x ( j ) = temp + h call fcn ( m , n , x , wa , iflag ) if ( iflag < 0 ) then exit end if x ( j ) = temp fjac ( 1 : m , j ) = ( wa ( 1 : m ) - fvec ( 1 : m ) ) / h end do return endsubroutine fdjac2 subroutine hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf ) !*****************************************************************************80 ! !! HYBRD seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRD finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  The user must provide a !    subroutine which calculates the functions. ! !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input, integer ( kind = 4 ) ML, MU, specify the number of subdiagonals and !    superdiagonals within the band of the jacobian matrix.  If the jacobian !    is not banded, set ML and MU to at least n - 1. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of !    iterates if it is positive.  In this case, FCN is called with IFLAG = 0 at !    the beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. !    See the description of FCN. !    Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, relative error between two consecutive iterates is at most XTOL. !    2, number of calls to FCN has reached or exceeded MAXFEV. !    3, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, iteration is not making good progress, as measured by the improvement !       from the last five jacobian evaluations. !    5, iteration is not making good progress, as measured by the improvement !       from the last ten iterations. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains !    the orthogonal matrix Q produced by the QR factorization of the final !    approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced by !    the QR factorization of the final approximate jacobian, stored rowwise. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must be no !    less than (N*(N+1))/2. ! !    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) iter integer ( kind = 4 ) iwa ( 1 ) integer ( kind = 4 ) j logical jeval integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) ml integer ( kind = 4 ) mode integer ( kind = 4 ) msum integer ( kind = 4 ) mu integer ( kind = 4 ) ncfail integer ( kind = 4 ) nslow1 integer ( kind = 4 ) nslow2 integer ( kind = 4 ) ncsuc integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( n ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then return else if ( xtol < 0.0D+00 ) then return else if ( maxfev <= 0 ) then return else if ( ml < 0 ) then return else if ( mu < 0 ) then return else if ( factor <= 0.0D+00 ) then return else if ( ldfjac < n ) then return else if ( lr < ( n * ( n + 1 ) ) / 2 ) then return end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point !  and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( n , fvec ) ! !  Determine the number of calls to FCN needed to compute the jacobian matrix. ! msum = min ( ml + mu + 1 , n ) ! !  Initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !  Beginning of the outer loop. ! 30 continue jeval = . true . ! !  Calculate the jacobian matrix. ! iflag = 2 call fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn ) nfev = nfev + msum if ( iflag < 0 ) then go to 300 end if ! !  Compute the QR factorization of the jacobian. ! pivot = . false . call qrfac ( n , n , fjac , ldfjac , pivot , iwa , 1 , wa1 , wa2 ) ! !  On the first iteration, if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q' * FVEC and store in QTF. ! qtf ( 1 : n ) = fvec ( 1 : n ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then temp = - dot_product ( qtf ( j : n ), fjac ( j : n , j ) ) / fjac ( j , j ) qtf ( j : n ) = qtf ( j : n ) + fjac ( j : n , j ) * temp end if end do ! !  Copy the triangular factor of the QR factorization into R. ! sing = . false . do j = 1 , n l = j do i = 1 , j - 1 r ( l ) = fjac ( i , j ) l = l + n - i end do r ( l ) = wa1 ( j ) if ( wa1 ( j ) == 0.0D+00 ) then sing = . true . end if end do ! !  Accumulate the orthogonal factor in FJAC. ! call qform ( n , n , fjac , ldfjac ) ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 180 continue ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( n , x , fvec , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Determine the direction P. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( n , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 endif ! !  Compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum2 = 0.0D+00 do j = i , n sum2 = sum2 + r ( l ) * wa1 ( j ) l = l + 1 end do wa3 ( i ) = qtf ( i ) + sum2 end do temp = enorm ( n , wa3 ) prered = 0.0D+00 if ( temp < fnorm ) then prered = 1.0D+00 - ( temp / fnorm ) ** 2 end if ! !  Compute the ratio of the actual to the predicted reduction. ! ratio = 0.0D+00 if ( 0.0D+00 < prered ) then ratio = actred / prered end if ! !  Update the step bound. ! if ( ratio < 0.1D+00 ) then ncsuc = 0 ncfail = ncfail + 1 delta = 0.5D+00 * delta else ncfail = 0 ncsuc = ncsuc + 1 if ( 0.5D+00 <= ratio . or . 1 < ncsuc ) then delta = max ( delta , pnorm / 0.5D+00 ) end if if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then delta = pnorm / 0.5D+00 end if end if ! !  Test for successful iteration. ! !  Successful iteration. !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : n ) = wa4 ( 1 : n ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( 0.001D+00 <= actred ) then nslow1 = 0 end if if ( jeval ) then nslow2 = nslow2 + 1 end if if ( 0.1D+00 <= actred ) then nslow2 = 0 end if ! !  Test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == 0.0D+00 ) then info = 1 end if if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 2 end if if ( 0.1D+00 * max ( 0.1D+00 * delta , pnorm ) <= epsmch * xnorm ) then info = 3 end if if ( nslow2 == 5 ) then info = 4 end if if ( nslow1 == 10 ) then info = 5 end if if ( info /= 0 ) then go to 300 end if ! !  Criterion for recalculating jacobian approximation !  by forward differences. ! if ( ncfail == 2 ) then go to 290 end if ! !  Calculate the rank one modification to the jacobian !  and update QTF if necessary. ! do j = 1 , n sum2 = dot_product ( wa4 ( 1 : n ), fjac ( 1 : n , j ) ) wa2 ( j ) = ( sum2 - wa3 ( j ) ) / pnorm wa1 ( j ) = diag ( j ) * ( ( diag ( j ) * wa1 ( j ) ) / pnorm ) if ( 0.0001D+00 <= ratio ) then qtf ( j ) = sum2 end if end do ! !  Compute the QR factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !  End of the inner loop. ! jeval = . false . go to 180 290 continue ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , iflag ) end if return endsubroutine hybrd subroutine hybrd1 ( fcn , n , x , fvec , tol , info ) !*****************************************************************************80 ! !! HYBRD1 seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRD1 finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  This is done by using the !    more general nonlinear equation solver HYBRD.  The user must provide a !    subroutine which calculates the functions.  The jacobian is then !    calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See the !    description of FCN. !    Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    2, number of calls to FCN has reached or exceeded 200*(N+1). !    3, TOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, the iteration is not making good progress. ! implicit none integer ( kind = 4 ) lwa integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) epsfcn real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( n , n ) real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) info integer ( kind = 4 ) j integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) maxfev integer ( kind = 4 ) ml integer ( kind = 4 ) mode integer ( kind = 4 ) mu integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r (( n * ( n + 1 )) / 2 ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol if ( n <= 0 ) then info = 0 return end if if ( tol < 0.0D+00 ) then info = 0 return end if xtol = tol maxfev = 200 * ( n + 1 ) ml = n - 1 mu = n - 1 epsfcn = 0.0D+00 diag ( 1 : n ) = 1.0D+00 mode = 2 factor = 10 0.0D+00 nprint = 0 info = 0 nfev = 0 fjac ( 1 : n , 1 : n ) = 0.0D+00 ldfjac = n r ( 1 :( n * ( n + 1 )) / 2 ) = 0.0D+00 lr = ( n * ( n + 1 ) ) / 2 qtf ( 1 : n ) = 0.0D+00 call hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf ) if ( info == 5 ) then info = 4 end if return endsubroutine hybrd1 subroutine hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & factor , nprint , info , nfev , njev , r , lr , qtf ) !*****************************************************************************80 ! !! HYBRJ seeks a zero of N nonlinear equations in N variables. ! !  Discussion: ! !    HYBRJ finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  The user must provide a !    subroutine which calculates the functions and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: ! !      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N matrix, containing !    the orthogonal matrix Q produced by the QR factorization !    of the final approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of the !    array FJAC.  LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. !    See the description of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, relative error between two consecutive iterates is at most XTOL. !    2, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    3, XTOL is too small.  No further improvement in !       the approximate solution X is possible. !    4, iteration is not making good progress, as measured by the !       improvement from the last five jacobian evaluations. !    5, iteration is not making good progress, as measured by the !       improvement from the last ten iterations. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN !    with IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN !    with IFLAG = 2. ! !    Output, real ( kind = 8 ) R(LR), the upper triangular matrix produced !    by the QR factorization of the final approximate jacobian, stored rowwise. ! !    Input, integer ( kind = 4 ) LR, the size of the R array, which must !    be no less than (N*(N+1))/2. ! !    Output, real ( kind = 8 ) QTF(N), contains the vector Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) lr integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) iter integer ( kind = 4 ) iwa ( 1 ) integer ( kind = 4 ) j logical jeval integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) ncfail integer ( kind = 4 ) nslow1 integer ( kind = 4 ) nslow2 integer ( kind = 4 ) ncsuc integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r ( lr ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( n ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if if ( ldfjac < n . or . & xtol < 0.0D+00 . or . & maxfev <= 0 . or . & factor <= 0.0D+00 . or . & lr < ( n * ( n + 1 ) ) / 2 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) then if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if fnorm = enorm ( n , fvec ) ! !  Initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !  Beginning of the outer loop. ! do jeval = . true . ! !  Calculate the jacobian matrix. ! iflag = 2 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Compute the QR factorization of the jacobian. ! pivot = . false . call qrfac ( n , n , fjac , ldfjac , pivot , iwa , 1 , wa1 , wa2 ) ! !  On the first iteration, if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q'*FVEC and store in QTF. ! qtf ( 1 : n ) = fvec ( 1 : n ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = 0.0D+00 do i = j , n sum2 = sum2 + fjac ( i , j ) * qtf ( i ) end do temp = - sum2 / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp end do end if end do ! !  Copy the triangular factor of the QR factorization into R. ! sing = . false . do j = 1 , n l = j do i = 1 , j - 1 r ( l ) = fjac ( i , j ) l = l + n - i end do r ( l ) = wa1 ( j ) if ( wa1 ( j ) == 0.0D+00 ) then sing = . true . end if end do ! !  Accumulate the orthogonal factor in FJAC. ! call qform ( n , n , fjac , ldfjac ) ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! do ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if end if ! !  Determine the direction P. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then info = iflag iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if fnorm1 = enorm ( n , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 end if ! !  Compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum2 = 0.0D+00 do j = i , n sum2 = sum2 + r ( l ) * wa1 ( j ) l = l + 1 end do wa3 ( i ) = qtf ( i ) + sum2 end do temp = enorm ( n , wa3 ) prered = 0.0D+00 if ( temp < fnorm ) then prered = 1.0D+00 - ( temp / fnorm ) ** 2 end if ! !  Compute the ratio of the actual to the predicted reduction. ! if ( 0.0D+00 < prered ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio < 0.1D+00 ) then ncsuc = 0 ncfail = ncfail + 1 delta = 0.5D+00 * delta else ncfail = 0 ncsuc = ncsuc + 1 if ( 0.5D+00 <= ratio . or . 1 < ncsuc ) then delta = max ( delta , pnorm / 0.5D+00 ) end if if ( abs ( ratio - 1.0D+00 ) <= 0.1D+00 ) then delta = pnorm / 0.5D+00 end if end if ! !  Test for successful iteration. ! ! !  Successful iteration. !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : n ) = wa4 ( 1 : n ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( 0.001D+00 <= actred ) then nslow1 = 0 end if if ( jeval ) then nslow2 = nslow2 + 1 end if if ( 0.1D+00 <= actred ) then nslow2 = 0 end if ! !  Test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == 0.0D+00 ) then info = 1 end if if ( info /= 0 ) then iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 2 end if if ( 0.1D+00 * max ( 0.1D+00 * delta , pnorm ) <= epsmch * xnorm ) then info = 3 end if if ( nslow2 == 5 ) then info = 4 end if if ( nslow1 == 10 ) then info = 5 end if if ( info /= 0 ) then iflag = 0 if ( 0 < nprint ) then call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end if return end if ! !  Criterion for recalculating jacobian. ! if ( ncfail == 2 ) then exit end if ! !  Calculate the rank one modification to the jacobian !  and update QTF if necessary. ! do j = 1 , n sum2 = dot_product ( wa4 ( 1 : n ), fjac ( 1 : n , j ) ) wa2 ( j ) = ( sum2 - wa3 ( j ) ) / pnorm wa1 ( j ) = diag ( j ) * ( ( diag ( j ) * wa1 ( j ) ) / pnorm ) if ( 0.0001D+00 <= ratio ) then qtf ( j ) = sum2 end if end do ! !  Compute the QR factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !  End of the inner loop. ! jeval = . false . end do ! !  End of the outer loop. ! end do endsubroutine hybrj subroutine hybrj1 ( fcn , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! HYBRJ1 seeks a zero of N equations in N variables by Powell's method. ! !  Discussion: ! !    HYBRJ1 finds a zero of a system of N nonlinear functions in N variables !    by a modification of the Powell hybrid method.  This is done by using the !    more general nonlinear equation solver HYBRJ.  The user !    must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(n) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) N, the number of functions and variables. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(N), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array which contains !    the orthogonal matrix Q produced by the QR factorization of the final !    approximate jacobian. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of  FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates that the relative error between X and the solution is at most !    TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    2, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    3, TOL is too small.  No further improvement in the approximate !       solution X is possible. !    4, iteration is not making good progress. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fvec ( n ) integer ( kind = 4 ) info integer ( kind = 4 ) j integer ( kind = 4 ) lr integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) r (( n * ( n + 1 )) / 2 ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( ldfjac < n ) then return else if ( tol < 0.0D+00 ) then return end if maxfev = 100 * ( n + 1 ) xtol = tol mode = 2 diag ( 1 : n ) = 1.0D+00 factor = 10 0.0D+00 nprint = 0 lr = ( n * ( n + 1 ) ) / 2 call hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & factor , nprint , info , nfev , njev , r , lr , qtf ) if ( info == 5 ) then info = 4 end if return endsubroutine hybrj1 subroutine lmder ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) !*****************************************************************************80 ! !! LMDER minimizes M functions in N variables by the Levenberg-Marquardt method. ! !  Discussion: ! !    LMDER minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    The user must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, is the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix of FJAC contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that !      P' * ( JAC' * JAC ) * P = R' * R, !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual !    and predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, real ( kind = 8 ) GTOL.  Termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN with IFLAG = 1 is at least MAXFEV by the end of an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of !       squares are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares !       is possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN with !    IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN with !    IFLAG = 2. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P !    such that JAC*P = Q*R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular with diagonal !    elements of nonincreasing magnitude.  Column J of P is column !    IPVT(J) of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) xnorm real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then go to 300 end if if ( m < n ) then go to 300 end if if ( ldfjac < m & . or . ftol < 0.0D+00 . or . xtol < 0.0D+00 . or . gtol < 0.0D+00 & . or . maxfev <= 0 . or . factor <= 0.0D+00 ) then go to 300 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  Calculate the jacobian matrix. ! iflag = 2 call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) then go to 300 end if ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Compute the QR factorization of the jacobian. ! pivot = . true . call qrfac ( m , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) ! !  On the first iteration and if mode is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q'*FVEC and store the first N components in QTF. ! wa4 ( 1 : m ) = fvec ( 1 : m ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( wa4 ( j : m ), fjac ( j : m , j ) ) temp = - sum2 / fjac ( j , j ) wa4 ( j : m ) = wa4 ( j : m ) + fjac ( j : m , j ) * temp end if fjac ( j , j ) = wa1 ( j ) qtf ( j ) = wa4 ( j ) end do ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( 1 : j ), fjac ( 1 : j , j ) ) / fnorm gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 300 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 200 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction p and x + p. calculate the norm of p. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! actred = - 1.0D+00 if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 end if ! !  Compute the scaled predicted reduction and !  the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! if ( prered /= 0.0D+00 ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( 0.0D+00 <= actred ) then temp = 0.5D+00 end if if ( actred < 0.0D+00 ) then temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = 2.0D+00 * pnorm par = 0.5D+00 * par end if end if ! !  Successful iteration. ! !  Update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence. ! if ( abs ( actred ) <= ftol . and . & prered <= ftol . and . & 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) then info = 3 end if if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 300 end if ! !  End of the inner loop. repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 200 end if ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , fjac , ldfjac , iflag ) end if return endsubroutine lmder subroutine lmder1 ( fcn , m , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! LMDER1 minimizes M functions in N variables by Levenberg-Marquardt method. ! !  Discussion: ! !    LMDER1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    This is done by using the more general least-squares solver LMDER. !    The user must provide a subroutine which calculates the functions !    and the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the jacobian.  FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjac, ldfjac, iflag ) !      integer ( kind = 4 ) ldfjac !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjac(ldfjac,n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If IFLAG = 2 on input, FCN should calculate the jacobian at X and !    return this matrix in FJAC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, is the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that !      P' * ( JAC' * JAC ) * P = R' * R, !    where P is a permutation matrix and JAC is the final calculated !    jacobian.  Column J of P is column IPVT(J) of the identity matrix. !    The lower trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, is the leading dimension of FJAC, !    which must be no less than M. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares is !       possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( m < n ) then return else if ( ldfjac < m ) then return else if ( tol < 0.0D+00 ) then return end if factor = 10 0.0D+00 maxfev = 100 * ( n + 1 ) ftol = tol xtol = tol gtol = 0.0D+00 mode = 1 nprint = 0 call lmder ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmder1 subroutine lmdif ( fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , & diag , mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf ) !*****************************************************************************80 ! !! LMDIF minimizes M functions in N variables by the Levenberg-Marquardt method. ! !  Discussion: ! !    LMDIF minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    The user must provide a subroutine which calculates the functions. !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual !    and predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  Therefore, XTOL !    measures the relative error desired in the approximate solution.  XTOL !    should be nonnegative. ! !    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number of !    calls to FCN is at least MAXFEV by the end of an iteration. ! !    Input, real ( kind = 8 ) EPSFCN, is used in determining a suitable step !    length for the forward-difference approximation.  This approximation !    assumes that the relative errors in the functions are of the order of !    EPSFCN.  If EPSFCN is less than the machine precision, it is assumed that !    the relative errors in the functions are of the order of the machine !    precision. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound. !    This bound is set to the product of FACTOR and the euclidean norm of !    DIAG*X if nonzero, or else to FACTOR itself.  In most cases, FACTOR should !    lie in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of squares !       are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN has reached or exceeded MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares !       is possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an M by N array.  The upper !    N by N submatrix of FJAC contains an upper triangular matrix R with !    diagonal elements of nonincreasing magnitude such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    trapezoidal part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least M. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such !    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular with diagonal !    elements of nonincreasing magnitude.  Column J of P is column IPVT(J) !    of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsfcn real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) iter integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 if ( n <= 0 ) then go to 300 else if ( m < n ) then go to 300 else if ( ldfjac < m ) then go to 300 else if ( ftol < 0.0D+00 ) then go to 300 else if ( xtol < 0.0D+00 ) then go to 300 else if ( gtol < 0.0D+00 ) then go to 300 else if ( maxfev <= 0 ) then go to 300 else if ( factor <= 0.0D+00 ) then go to 300 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 300 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) then go to 300 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  Calculate the jacobian matrix. ! iflag = 2 call fdjac2 ( fcn , m , n , x , fvec , fjac , ldfjac , iflag , epsfcn ) nfev = nfev + n if ( iflag < 0 ) then go to 300 end if ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , iflag ) end if if ( iflag < 0 ) then go to 300 end if end if ! !  Compute the QR factorization of the jacobian. ! pivot = . true . call qrfac ( m , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) ! !  On the first iteration and if MODE is 1, scale according !  to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if ! !  On the first iteration, calculate the norm of the scaled X !  and initialize the step bound DELTA. ! wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Form Q' * FVEC and store the first N components in QTF. ! wa4 ( 1 : m ) = fvec ( 1 : m ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( wa4 ( j : m ), fjac ( j : m , j ) ) temp = - sum2 / fjac ( j , j ) wa4 ( j : m ) = wa4 ( j : m ) + fjac ( j : m , j ) * temp end if fjac ( j , j ) = wa1 ( j ) qtf ( j ) = wa4 ( j ) end do ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = 0.0D+00 do i = 1 , j sum2 = sum2 + fjac ( i , j ) * ( qtf ( i ) / fnorm ) end do gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 300 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 200 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 300 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 else actred = - 1.0D+00 end if ! !  Compute the scaled predicted reduction and the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! ratio = 0.0D+00 if ( prered /= 0.0D+00 ) then ratio = actred / prered end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( actred >= 0.0D+00 ) then temp = 0.5D+00 endif if ( actred < 0.0D+00 ) then temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = 2.0D+00 * pnorm par = 0.5D+00 * par end if end if ! !  Test for successful iteration. ! ! !  Successful iteration. update X, FVEC, and their norms. ! if ( 0.0001D+00 <= ratio ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence. ! if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) info = 3 if ( info /= 0 ) then go to 300 end if ! !  Tests for termination and stringent tolerances. ! if ( maxfev <= nfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 300 end if ! !  End of the inner loop.  Repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 200 end if ! !  End of the outer loop. ! go to 30 300 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , iflag ) end if return endsubroutine lmdif subroutine lmdif1 ( fcn , m , n , x , fvec , tol , info ) !*****************************************************************************80 ! !! LMDIF1 minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMDIF1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm. !    This is done by using the more general least-squares solver LMDIF. !    The user must provide a subroutine which calculates the functions. !    The jacobian is then calculated by a forward-difference approximation. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions.  The routine should have the form: !      subroutine fcn ( m, n, x, fvec, iflag ) !      integer ( kind = 4 ) n !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) ! !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    To terminate the algorithm, FCN may set IFLAG negative on return. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Input, real ( kind = 8 ) TOL.  Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN has reached or exceeded 200*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares !       is possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) epsfcn real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( m , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) ldfjac integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol info = 0 if ( n <= 0 ) then return else if ( m < n ) then return else if ( tol < 0.0D+00 ) then return end if factor = 10 0.0D+00 maxfev = 200 * ( n + 1 ) ftol = tol xtol = tol gtol = 0.0D+00 epsfcn = 0.0D+00 mode = 1 nprint = 0 ldfjac = m call lmdif ( fcn , m , n , x , fvec , ftol , xtol , gtol , maxfev , epsfcn , & diag , mode , factor , nprint , info , nfev , fjac , ldfjac , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmdif1 subroutine lmpar ( n , r , ldr , ipvt , diag , qtb , delta , par , x , sdiag ) !*****************************************************************************80 ! !! LMPAR computes a parameter for the Levenberg-Marquardt method. ! !  Discussion: ! !    Given an M by N matrix A, an N by N nonsingular diagonal !    matrix D, an M-vector B, and a positive number DELTA, !    the problem is to determine a value for the parameter !    PAR such that if X solves the system ! !      A*X = B, !      sqrt ( PAR ) * D * X = 0, ! !    in the least squares sense, and DXNORM is the euclidean !    norm of D*X, then either PAR is zero and ! !      ( DXNORM - DELTA ) <= 0.1 * DELTA, ! !    or PAR is positive and ! !      abs ( DXNORM - DELTA) <= 0.1 * DELTA. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization, with column pivoting, of A.  That is, if !    A*P = Q*R, where P is a permutation matrix, Q has orthogonal !    columns, and R is an upper triangular matrix with diagonal !    elements of nonincreasing magnitude, then LMPAR expects !    the full upper triangle of R, the permutation matrix P, !    and the first N components of Q'*B.  On output !    LMPAR also provides an upper triangular matrix S such that ! !      P' * ( A' * A + PAR * D * D ) * P = S'* S. ! !    S is employed within LMPAR and may be of separate interest. ! !    Only a few iterations are generally needed for convergence !    of the algorithm. ! !    If, however, the limit of 10 iterations is reached, then the output !    PAR will contain the best value obtained so far. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    24 January 2014 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N),the N by N matrix.  The full !    upper triangle must contain the full upper triangle of the matrix R. !    On output the full upper triangle is unaltered, and the strict lower !    triangle contains the strict upper triangle (transposed) of the upper !    triangular matrix S. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of R.  LDR must be !    no less than N. ! !    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P !    such that A*P = Q*R.  Column J of P is column IPVT(J) of the !    identity matrix. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B. ! !    Input, real ( kind = 8 ) DELTA, an upper bound on the euclidean norm !    of D*X.  DELTA should be positive. ! !    Input/output, real ( kind = 8 ) PAR.  On input an initial estimate of the !    Levenberg-Marquardt parameter.  On output the final estimate. !    PAR should be nonnegative. ! !    Output, real ( kind = 8 ) X(N), the least squares solution of the system !    A*X = B, sqrt(PAR)*D*X = 0, for the output value of PAR. ! !    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper !    triangular matrix S. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dwarf real ( kind = 8 ) dxnorm !~   real ( kind = 8 ) enorm real ( kind = 8 ) gnorm real ( kind = 8 ) fp integer ( kind = 4 ) i integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) nsing real ( kind = 8 ) par real ( kind = 8 ) parc real ( kind = 8 ) parl real ( kind = 8 ) paru real ( kind = 8 ) qnorm real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) sdiag ( n ) real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) x ( n ) ! !  DWARF is the smallest positive magnitude. ! dwarf = tiny ( dwarf ) ! !  Compute and store in X the Gauss-Newton direction. ! !  If the jacobian is rank-deficient, obtain a least squares solution. ! nsing = n do j = 1 , n wa1 ( j ) = qtb ( j ) if ( r ( j , j ) == 0.0D+00 . and . nsing == n ) then nsing = j - 1 end if if ( nsing < n ) then wa1 ( j ) = 0.0D+00 end if end do do k = 1 , nsing j = nsing - k + 1 wa1 ( j ) = wa1 ( j ) / r ( j , j ) temp = wa1 ( j ) wa1 ( 1 : j - 1 ) = wa1 ( 1 : j - 1 ) - r ( 1 : j - 1 , j ) * temp end do do j = 1 , n l = ipvt ( j ) x ( l ) = wa1 ( j ) end do ! !  Initialize the iteration counter. !  Evaluate the function at the origin, and test !  for acceptance of the Gauss-Newton direction. ! iter = 0 wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) dxnorm = enorm ( n , wa2 ) fp = dxnorm - delta if ( fp <= 0.1D+00 * delta ) then if ( iter == 0 ) then par = 0.0D+00 end if return end if ! !  If the jacobian is not rank deficient, the Newton !  step provides a lower bound, PARL, for the zero of !  the function. ! !  Otherwise set this bound to zero. ! parl = 0.0D+00 if ( n <= nsing ) then do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do do j = 1 , n sum2 = dot_product ( wa1 ( 1 : j - 1 ), r ( 1 : j - 1 , j ) ) wa1 ( j ) = ( wa1 ( j ) - sum2 ) / r ( j , j ) end do temp = enorm ( n , wa1 ) parl = ( ( fp / delta ) / temp ) / temp end if ! !  Calculate an upper bound, PARU, for the zero of the function. ! do j = 1 , n sum2 = dot_product ( qtb ( 1 : j ), r ( 1 : j , j ) ) l = ipvt ( j ) wa1 ( j ) = sum2 / diag ( l ) end do gnorm = enorm ( n , wa1 ) paru = gnorm / delta if ( paru == 0.0D+00 ) then paru = dwarf / min ( delta , 0.1D+00 ) end if ! !  If the input PAR lies outside of the interval (PARL, PARU), !  set PAR to the closer endpoint. ! par = max ( par , parl ) par = min ( par , paru ) if ( par == 0.0D+00 ) then par = gnorm / dxnorm end if ! !  Beginning of an iteration. ! do iter = iter + 1 ! !  Evaluate the function at the current value of PAR. ! if ( par == 0.0D+00 ) then par = max ( dwarf , 0.001D+00 * paru ) end if wa1 ( 1 : n ) = sqrt ( par ) * diag ( 1 : n ) call qrsolv ( n , r , ldr , ipvt , wa1 , qtb , x , sdiag ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) dxnorm = enorm ( n , wa2 ) temp = fp fp = dxnorm - delta ! !  If the function is small enough, accept the current value of PAR. ! if ( abs ( fp ) <= 0.1D+00 * delta ) then exit end if ! !  Test for the exceptional cases where PARL !  is zero or the number of iterations has reached 10. ! if ( parl == 0.0D+00 . and . fp <= temp . and . temp < 0.0D+00 ) then exit else if ( iter == 10 ) then exit end if ! !  Compute the Newton correction. ! do j = 1 , n l = ipvt ( j ) wa1 ( j ) = diag ( l ) * ( wa2 ( l ) / dxnorm ) end do do j = 1 , n wa1 ( j ) = wa1 ( j ) / sdiag ( j ) temp = wa1 ( j ) wa1 ( j + 1 : n ) = wa1 ( j + 1 : n ) - r ( j + 1 : n , j ) * temp end do temp = enorm ( n , wa1 ) parc = ( ( fp / delta ) / temp ) / temp ! !  Depending on the sign of the function, update PARL or PARU. ! if ( 0.0D+00 < fp ) then parl = max ( parl , par ) else if ( fp < 0.0D+00 ) then paru = min ( paru , par ) end if ! !  Compute an improved estimate for PAR. ! par = max ( parl , par + parc ) ! !  End of an iteration. ! end do ! !  Termination. ! if ( iter == 0 ) then par = 0.0D+00 end if return endsubroutine lmpar subroutine lmstr ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) !*****************************************************************************80 ! !! LMSTR minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMSTR minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm !    which uses minimal storage. ! !    The user must provide a subroutine which calculates the functions and !    the rows of the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the rows of the jacobian. !    FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjrow, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjrow(n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of !    the jacobian at X, and return this vector in FJROW. !    To terminate the algorithm, set the output value of IFLAG negative. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper !    triangle of FJAC contains an upper triangular matrix R such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated jacobian. !    Column J of P is column IPVT(J) of the identity matrix.  The lower !    triangular part of FJAC contains information generated during !    the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) FTOL.  Termination occurs when both the actual and !    predicted relative reductions in the sum of squares are at most FTOL. !    Therefore, FTOL measures the relative error desired in the sum of !    squares.  FTOL should be nonnegative. ! !    Input, real ( kind = 8 ) XTOL.  Termination occurs when the relative error !    between two consecutive iterates is at most XTOL.  XTOL should be !    nonnegative. ! !    Input, real ( kind = 8 ) GTOL. termination occurs when the cosine of the !    angle between FVEC and any column of the jacobian is at most GTOL in !    absolute value.  Therefore, GTOL measures the orthogonality desired !    between the function vector and the columns of the jacobian.  GTOL should !    be nonnegative. ! !    Input, integer ( kind = 4 ) MAXFEV.  Termination occurs when the number !    of calls to FCN with IFLAG = 1 is at least MAXFEV by the end of !    an iteration. ! !    Input/output, real ( kind = 8 ) DIAG(N).  If MODE = 1, then DIAG is set !    internally.  If MODE = 2, then DIAG must contain positive entries that !    serve as multiplicative scale factors for the variables. ! !    Input, integer ( kind = 4 ) MODE, scaling option. !    1, variables will be scaled internally. !    2, scaling is specified by the input DIAG vector. ! !    Input, real ( kind = 8 ) FACTOR, determines the initial step bound.  This !    bound is set to the product of FACTOR and the euclidean norm of DIAG*X if !    nonzero, or else to FACTOR itself.  In most cases, FACTOR should lie !    in the interval (0.1, 100) with 100 the recommended value. ! !    Input, integer ( kind = 4 ) NPRINT, enables controlled printing of iterates !    if it is positive.  In this case, FCN is called with IFLAG = 0 at the !    beginning of the first iteration and every NPRINT iterations thereafter !    and immediately prior to return, with X and FVEC available !    for printing.  If NPRINT is not positive, no special calls !    of FCN with IFLAG = 0 are made. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See the !    description of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, both actual and predicted relative reductions in the sum of squares !       are at most FTOL. !    2, relative error between two consecutive iterates is at most XTOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, the cosine of the angle between FVEC and any column of the jacobian !       is at most GTOL in absolute value. !    5, number of calls to FCN with IFLAG = 1 has reached MAXFEV. !    6, FTOL is too small.  No further reduction in the sum of squares is !       possible. !    7, XTOL is too small.  No further improvement in the approximate !       solution X is possible. !    8, GTOL is too small.  FVEC is orthogonal to the columns of the !       jacobian to machine precision. ! !    Output, integer ( kind = 4 ) NFEV, the number of calls to FCN !    with IFLAG = 1. ! !    Output, integer ( kind = 4 ) NJEV, the number of calls to FCN !    with IFLAG = 2. ! !    Output, integer ( kind = 4 ) IPVT(N), defines a permutation matrix P such !    that JAC * P = Q * R, where JAC is the final calculated jacobian, Q is !    orthogonal (not stored), and R is upper triangular. !    Column J of P is column IPVT(J) of the identity matrix. ! !    Output, real ( kind = 8 ) QTF(N), contains the first N elements of Q'*FVEC. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) actred real ( kind = 8 ) delta real ( kind = 8 ) diag ( n ) real ( kind = 8 ) dirder !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) fnorm real ( kind = 8 ) fnorm1 real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gnorm real ( kind = 8 ) gtol integer ( kind = 4 ) i integer ( kind = 4 ) iflag integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) iter integer ( kind = 4 ) j integer ( kind = 4 ) l integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) par logical pivot real ( kind = 8 ) pnorm real ( kind = 8 ) prered real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) ratio logical sing real ( kind = 8 ) sum2 real ( kind = 8 ) temp real ( kind = 8 ) temp1 real ( kind = 8 ) temp2 real ( kind = 8 ) wa1 ( n ) real ( kind = 8 ) wa2 ( n ) real ( kind = 8 ) wa3 ( n ) real ( kind = 8 ) wa4 ( m ) real ( kind = 8 ) x ( n ) real ( kind = 8 ) xnorm real ( kind = 8 ) xtol epsmch = epsilon ( epsmch ) info = 0 iflag = 0 nfev = 0 njev = 0 ! !  Check the input parameters for errors. ! if ( n <= 0 ) then go to 340 else if ( m < n ) then go to 340 else if ( ldfjac < n ) then go to 340 else if ( ftol < 0.0D+00 ) then go to 340 else if ( xtol < 0.0D+00 ) then go to 340 else if ( gtol < 0.0D+00 ) then go to 340 else if ( maxfev <= 0 ) then go to 340 else if ( factor <= 0.0D+00 ) then go to 340 end if if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= 0.0D+00 ) then go to 340 end if end do end if ! !  Evaluate the function at the starting point and calculate its norm. ! iflag = 1 call fcn ( m , n , x , fvec , wa3 , iflag ) nfev = 1 if ( iflag < 0 ) then go to 340 end if fnorm = enorm ( m , fvec ) ! !  Initialize Levenberg-Marquardt parameter and iteration counter. ! par = 0.0D+00 iter = 1 ! !  Beginning of the outer loop. ! 30 continue ! !  If requested, call FCN to enable printing of iterates. ! if ( 0 < nprint ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) then call fcn ( m , n , x , fvec , wa3 , iflag ) end if if ( iflag < 0 ) then go to 340 end if end if ! !  Compute the QR factorization of the jacobian matrix calculated one row !  at a time, while simultaneously forming Q'* FVEC and storing !  the first N components in QTF. ! qtf ( 1 : n ) = 0.0D+00 fjac ( 1 : n , 1 : n ) = 0.0D+00 iflag = 2 do i = 1 , m call fcn ( m , n , x , fvec , wa3 , iflag ) if ( iflag < 0 ) then go to 340 end if temp = fvec ( i ) call rwupdt ( n , fjac , ldfjac , wa3 , qtf , temp , wa1 , wa2 ) iflag = iflag + 1 end do njev = njev + 1 ! !  If the jacobian is rank deficient, call QRFAC to !  reorder its columns and update the components of QTF. ! sing = . false . do j = 1 , n if ( fjac ( j , j ) == 0.0D+00 ) then sing = . true . end if ipvt ( j ) = j wa2 ( j ) = enorm ( j , fjac ( 1 , j ) ) end do if ( sing ) then pivot = . true . call qrfac ( n , n , fjac , ldfjac , pivot , ipvt , n , wa1 , wa2 ) do j = 1 , n if ( fjac ( j , j ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( j : n ), fjac ( j : n , j ) ) temp = - sum2 / fjac ( j , j ) qtf ( j : n ) = qtf ( j : n ) + fjac ( j : n , j ) * temp end if fjac ( j , j ) = wa1 ( j ) end do end if ! !  On the first iteration !    if mode is 1, !      scale according to the norms of the columns of the initial jacobian. !    calculate the norm of the scaled X, !    initialize the step bound delta. ! if ( iter == 1 ) then if ( mode /= 2 ) then diag ( 1 : n ) = wa2 ( 1 : n ) do j = 1 , n if ( wa2 ( j ) == 0.0D+00 ) then diag ( j ) = 1.0D+00 end if end do end if wa3 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == 0.0D+00 ) then delta = factor end if end if ! !  Compute the norm of the scaled gradient. ! gnorm = 0.0D+00 if ( fnorm /= 0.0D+00 ) then do j = 1 , n l = ipvt ( j ) if ( wa2 ( l ) /= 0.0D+00 ) then sum2 = dot_product ( qtf ( 1 : j ), fjac ( 1 : j , j ) ) / fnorm gnorm = max ( gnorm , abs ( sum2 / wa2 ( l ) ) ) end if end do end if ! !  Test for convergence of the gradient norm. ! if ( gnorm <= gtol ) then info = 4 go to 340 end if ! !  Rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j ) ) end do end if ! !  Beginning of the inner loop. ! 240 continue ! !  Determine the Levenberg-Marquardt parameter. ! call lmpar ( n , fjac , ldfjac , ipvt , diag , qtf , delta , par , wa1 , wa2 ) ! !  Store the direction P and X + P. !  Calculate the norm of P. ! wa1 ( 1 : n ) = - wa1 ( 1 : n ) wa2 ( 1 : n ) = x ( 1 : n ) + wa1 ( 1 : n ) wa3 ( 1 : n ) = diag ( 1 : n ) * wa1 ( 1 : n ) pnorm = enorm ( n , wa3 ) ! !  On the first iteration, adjust the initial step bound. ! if ( iter == 1 ) then delta = min ( delta , pnorm ) end if ! !  Evaluate the function at X + P and calculate its norm. ! iflag = 1 call fcn ( m , n , wa2 , wa4 , wa3 , iflag ) nfev = nfev + 1 if ( iflag < 0 ) then go to 340 end if fnorm1 = enorm ( m , wa4 ) ! !  Compute the scaled actual reduction. ! if ( 0.1D+00 * fnorm1 < fnorm ) then actred = 1.0D+00 - ( fnorm1 / fnorm ) ** 2 else actred = - 1.0D+00 end if ! !  Compute the scaled predicted reduction and !  the scaled directional derivative. ! do j = 1 , n wa3 ( j ) = 0.0D+00 l = ipvt ( j ) temp = wa1 ( l ) wa3 ( 1 : j ) = wa3 ( 1 : j ) + fjac ( 1 : j , j ) * temp end do temp1 = enorm ( n , wa3 ) / fnorm temp2 = ( sqrt ( par ) * pnorm ) / fnorm prered = temp1 ** 2 + temp2 ** 2 / 0.5D+00 dirder = - ( temp1 ** 2 + temp2 ** 2 ) ! !  Compute the ratio of the actual to the predicted reduction. ! if ( prered /= 0.0D+00 ) then ratio = actred / prered else ratio = 0.0D+00 end if ! !  Update the step bound. ! if ( ratio <= 0.25D+00 ) then if ( actred >= 0.0D+00 ) then temp = 0.5D+00 else temp = 0.5D+00 * dirder / ( dirder + 0.5D+00 * actred ) end if if ( 0.1D+00 * fnorm1 >= fnorm . or . temp < 0.1D+00 ) then temp = 0.1D+00 end if delta = temp * min ( delta , pnorm / 0.1D+00 ) par = par / temp else if ( par == 0.0D+00 . or . ratio >= 0.75D+00 ) then delta = pnorm / 0.5D+00 par = 0.5D+00 * par end if end if ! !  Test for successful iteration. ! if ( ratio >= 0.0001D+00 ) then x ( 1 : n ) = wa2 ( 1 : n ) wa2 ( 1 : n ) = diag ( 1 : n ) * x ( 1 : n ) fvec ( 1 : m ) = wa4 ( 1 : m ) xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 end if ! !  Tests for convergence, termination and stringent tolerances. ! if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 1 end if if ( delta <= xtol * xnorm ) then info = 2 end if if ( abs ( actred ) <= ftol . and . prered <= ftol & . and . 0.5D+00 * ratio <= 1.0D+00 . and . info == 2 ) then info = 3 end if if ( info /= 0 ) then go to 340 end if if ( nfev >= maxfev ) then info = 5 end if if ( abs ( actred ) <= epsmch . and . prered <= epsmch & . and . 0.5D+00 * ratio <= 1.0D+00 ) then info = 6 end if if ( delta <= epsmch * xnorm ) then info = 7 end if if ( gnorm <= epsmch ) then info = 8 end if if ( info /= 0 ) then go to 340 end if ! !  End of the inner loop.  Repeat if iteration unsuccessful. ! if ( ratio < 0.0001D+00 ) then go to 240 end if ! !  End of the outer loop. ! go to 30 340 continue ! !  Termination, either normal or user imposed. ! if ( iflag < 0 ) then info = iflag end if iflag = 0 if ( 0 < nprint ) then call fcn ( m , n , x , fvec , wa3 , iflag ) end if return endsubroutine lmstr subroutine lmstr1 ( fcn , m , n , x , fvec , fjac , ldfjac , tol , info ) !*****************************************************************************80 ! !! LMSTR1 minimizes M functions in N variables using Levenberg-Marquardt method. ! !  Discussion: ! !    LMSTR1 minimizes the sum of the squares of M nonlinear functions in !    N variables by a modification of the Levenberg-Marquardt algorithm !    which uses minimal storage. ! !    This is done by using the more general least-squares solver !    LMSTR.  The user must provide a subroutine which calculates !    the functions and the rows of the jacobian. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, external FCN, the name of the user-supplied subroutine which !    calculates the functions and the rows of the jacobian. !    FCN should have the form: !      subroutine fcn ( m, n, x, fvec, fjrow, iflag ) !      integer ( kind = 4 ) m !      integer ( kind = 4 ) n !      real ( kind = 8 ) fjrow(n) !      real ( kind = 8 ) fvec(m) !      integer ( kind = 4 ) iflag !      real ( kind = 8 ) x(n) !    If IFLAG = 0 on input, then FCN is only being called to allow the user !    to print out the current iterate. !    If IFLAG = 1 on input, FCN should calculate the functions at X and !    return this vector in FVEC. !    If the input value of IFLAG is I > 1, calculate the (I-1)-st row of !    the jacobian at X, and return this vector in FJROW. !    To terminate the algorithm, set the output value of IFLAG negative. ! !    Input, integer ( kind = 4 ) M, the number of functions. ! !    Input, integer ( kind = 4 ) N, the number of variables. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) X(N).  On input, X must contain an initial !    estimate of the solution vector.  On output X contains the final !    estimate of the solution vector. ! !    Output, real ( kind = 8 ) FVEC(M), the functions evaluated at the output X. ! !    Output, real ( kind = 8 ) FJAC(LDFJAC,N), an N by N array.  The upper !    triangle contains an upper triangular matrix R such that ! !      P' * ( JAC' * JAC ) * P = R' * R, ! !    where P is a permutation matrix and JAC is the final calculated !    jacobian.  Column J of P is column IPVT(J) of the identity matrix. !    The lower triangular part of FJAC contains information generated !    during the computation of R. ! !    Input, integer ( kind = 4 ) LDFJAC, the leading dimension of FJAC. !    LDFJAC must be at least N. ! !    Input, real ( kind = 8 ) TOL. Termination occurs when the algorithm !    estimates either that the relative error in the sum of squares is at !    most TOL or that the relative error between X and the solution is at !    most TOL.  TOL should be nonnegative. ! !    Output, integer ( kind = 4 ) INFO, error flag.  If the user has terminated !    execution, INFO is set to the (negative) value of IFLAG. See description !    of FCN.  Otherwise, INFO is set as follows: !    0, improper input parameters. !    1, algorithm estimates that the relative error in the sum of squares !       is at most TOL. !    2, algorithm estimates that the relative error between X and the !       solution is at most TOL. !    3, conditions for INFO = 1 and INFO = 2 both hold. !    4, FVEC is orthogonal to the columns of the jacobian to machine precision. !    5, number of calls to FCN with IFLAG = 1 has reached 100*(N+1). !    6, TOL is too small.  No further reduction in the sum of squares !       is possible. !    7, TOL is too small.  No further improvement in the approximate !       solution X is possible. ! implicit none integer ( kind = 4 ) ldfjac integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) diag ( n ) real ( kind = 8 ) factor external fcn real ( kind = 8 ) fjac ( ldfjac , n ) real ( kind = 8 ) ftol real ( kind = 8 ) fvec ( m ) real ( kind = 8 ) gtol integer ( kind = 4 ) info integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) maxfev integer ( kind = 4 ) mode integer ( kind = 4 ) nfev integer ( kind = 4 ) njev integer ( kind = 4 ) nprint real ( kind = 8 ) qtf ( n ) real ( kind = 8 ) tol real ( kind = 8 ) x ( n ) real ( kind = 8 ) xtol if ( n <= 0 ) then info = 0 return end if if ( m < n ) then info = 0 return end if if ( ldfjac < n ) then info = 0 return end if if ( tol < 0.0D+00 ) then info = 0 return end if fvec ( 1 : n ) = 0.0D+00 fjac ( 1 : ldfjac , 1 : n ) = 0.0D+00 ftol = tol xtol = tol gtol = 0.0D+00 maxfev = 100 * ( n + 1 ) diag ( 1 : n ) = 0.0D+00 mode = 1 factor = 10 0.0D+00 nprint = 0 info = 0 nfev = 0 njev = 0 ipvt ( 1 : n ) = 0 qtf ( 1 : n ) = 0.0D+00 call lmstr ( fcn , m , n , x , fvec , fjac , ldfjac , ftol , xtol , gtol , maxfev , & diag , mode , factor , nprint , info , nfev , njev , ipvt , qtf ) if ( info == 8 ) then info = 4 end if return endsubroutine lmstr1 subroutine qform ( m , n , q , ldq ) !*****************************************************************************80 ! !! QFORM produces the explicit QR factorization of a matrix. ! !  Discussion: ! !    The QR factorization of a matrix is usually accumulated in implicit !    form, that is, as a series of orthogonal transformations of the !    original matrix.  This routine carries out those transformations, !    to explicitly exhibit the factorization constructed by QRFAC. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, is a positive integer input variable set !    to the number of rows of A and the order of Q. ! !    Input, integer ( kind = 4 ) N, is a positive integer input variable set !    to the number of columns of A. ! !    Input/output, real ( kind = 8 ) Q(LDQ,M).  Q is an M by M array. !    On input the full lower trapezoid in the first min(M,N) columns of Q !    contains the factored form. !    On output, Q has been accumulated into a square matrix. ! !    Input, integer ( kind = 4 ) LDQ, is a positive integer input variable !    not less than M which specifies the leading dimension of the array Q. ! implicit none integer ( kind = 4 ) ldq integer ( kind = 4 ) m integer ( kind = 4 ) n integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) minmn real ( kind = 8 ) q ( ldq , m ) real ( kind = 8 ) temp real ( kind = 8 ) wa ( m ) minmn = min ( m , n ) do j = 2 , minmn q ( 1 : j - 1 , j ) = 0.0D+00 end do ! !  Initialize remaining columns to those of the identity matrix. ! q ( 1 : m , n + 1 : m ) = 0.0D+00 do j = n + 1 , m q ( j , j ) = 1.0D+00 end do ! !  Accumulate Q from its factored form. ! do l = 1 , minmn k = minmn - l + 1 wa ( k : m ) = q ( k : m , k ) q ( k : m , k ) = 0.0D+00 q ( k , k ) = 1.0D+00 if ( wa ( k ) /= 0.0D+00 ) then do j = k , m temp = dot_product ( wa ( k : m ), q ( k : m , j ) ) / wa ( k ) q ( k : m , j ) = q ( k : m , j ) - temp * wa ( k : m ) end do end if end do return endsubroutine qform subroutine qrfac ( m , n , a , lda , pivot , ipvt , lipvt , rdiag , acnorm ) !*****************************************************************************80 ! !! QRFAC computes a QR factorization using Householder transformations. ! !  Discussion: ! !    This function uses Householder transformations with optional column !    pivoting to compute a QR factorization of the !    M by N matrix A.  That is, QRFAC determines an orthogonal !    matrix Q, a permutation matrix P, and an upper trapezoidal !    matrix R with diagonal elements of nonincreasing magnitude, !    such that A*P = Q*R. ! !    The Householder transformation for column K, K = 1,2,...,min(M,N), !    is of the form ! !      I - ( 1 / U(K) ) * U * U' ! !    where U has zeros in the first K-1 positions. ! !    The form of this transformation and the method of pivoting first !    appeared in the corresponding LINPACK routine. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of A. ! !    Input, integer ( kind = 4 ) N, the number of columns of A. ! !    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array. !    On input, A contains the matrix for which the QR factorization is to !    be computed.  On output, the strict upper trapezoidal part of A contains !    the strict upper trapezoidal part of R, and the lower trapezoidal !    part of A contains a factored form of Q, the non-trivial elements of !    the U vectors described above. ! !    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must !    be no less than M. ! !    Input, logical PIVOT, is TRUE if column pivoting is to be carried out. ! !    Output, integer ( kind = 4 ) IPVT(LIPVT), defines the permutation matrix P !    such that A*P = Q*R.  Column J of P is column IPVT(J) of the identity !    matrix.  If PIVOT is false, IPVT is not referenced. ! !    Input, integer ( kind = 4 ) LIPVT, the dimension of IPVT, which should !    be N if pivoting is used. ! !    Output, real ( kind = 8 ) RDIAG(N), contains the diagonal elements of R. ! !    Output, real ( kind = 8 ) ACNORM(N), the norms of the corresponding !    columns of the input matrix A.  If this information is not needed, !    then ACNORM can coincide with RDIAG. ! implicit none integer ( kind = 4 ) lda integer ( kind = 4 ) lipvt integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( lda , n ) real ( kind = 8 ) acnorm ( n ) real ( kind = 8 ) ajnorm !~   real ( kind = 8 ) enorm real ( kind = 8 ) epsmch integer ( kind = 4 ) i integer ( kind = 4 ) i4_temp integer ( kind = 4 ) ipvt ( lipvt ) integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) kmax integer ( kind = 4 ) minmn logical pivot real ( kind = 8 ) r8_temp ( m ) real ( kind = 8 ) rdiag ( n ) real ( kind = 8 ) temp real ( kind = 8 ) wa ( n ) epsmch = epsilon ( epsmch ) ! !  Compute the initial column norms and initialize several arrays. ! do j = 1 , n acnorm ( j ) = enorm ( m , a ( 1 : m , j ) ) end do rdiag ( 1 : n ) = acnorm ( 1 : n ) wa ( 1 : n ) = acnorm ( 1 : n ) if ( pivot ) then do j = 1 , n ipvt ( j ) = j end do end if ! !  Reduce A to R with Householder transformations. ! minmn = min ( m , n ) do j = 1 , minmn ! !  Bring the column of largest norm into the pivot position. ! if ( pivot ) then kmax = j do k = j , n if ( rdiag ( kmax ) < rdiag ( k ) ) then kmax = k end if end do if ( kmax /= j ) then r8_temp ( 1 : m ) = a ( 1 : m , j ) a ( 1 : m , j ) = a ( 1 : m , kmax ) a ( 1 : m , kmax ) = r8_temp ( 1 : m ) rdiag ( kmax ) = rdiag ( j ) wa ( kmax ) = wa ( j ) i4_temp = ipvt ( j ) ipvt ( j ) = ipvt ( kmax ) ipvt ( kmax ) = i4_temp end if end if ! !  Compute the Householder transformation to reduce the !  J-th column of A to a multiple of the J-th unit vector. ! ajnorm = enorm ( m - j + 1 , a ( j , j ) ) if ( ajnorm /= 0.0D+00 ) then if ( a ( j , j ) < 0.0D+00 ) then ajnorm = - ajnorm end if a ( j : m , j ) = a ( j : m , j ) / ajnorm a ( j , j ) = a ( j , j ) + 1.0D+00 ! !  Apply the transformation to the remaining columns and update the norms. ! do k = j + 1 , n temp = dot_product ( a ( j : m , j ), a ( j : m , k ) ) / a ( j , j ) a ( j : m , k ) = a ( j : m , k ) - temp * a ( j : m , j ) if ( pivot . and . rdiag ( k ) /= 0.0D+00 ) then temp = a ( j , k ) / rdiag ( k ) rdiag ( k ) = rdiag ( k ) * sqrt ( max ( 0.0D+00 , 1.0D+00 - temp ** 2 ) ) if ( 0.05D+00 * ( rdiag ( k ) / wa ( k ) ) ** 2 <= epsmch ) then rdiag ( k ) = enorm ( m - j , a ( j + 1 , k ) ) wa ( k ) = rdiag ( k ) end if end if end do end if rdiag ( j ) = - ajnorm end do return endsubroutine qrfac subroutine qrsolv ( n , r , ldr , ipvt , diag , qtb , x , sdiag ) !*****************************************************************************80 ! !! QRSOLV solves a rectangular linear system A*x=b in the least squares sense. ! !  Discussion: ! !    Given an M by N matrix A, an N by N diagonal matrix D, !    and an M-vector B, the problem is to determine an X which !    solves the system ! !      A*X = B !      D*X = 0 ! !    in the least squares sense. ! !    This function completes the solution of the problem !    if it is provided with the necessary information from the !    QR factorization, with column pivoting, of A.  That is, if !    Q*P = Q*R, where P is a permutation matrix, Q has orthogonal !    columns, and R is an upper triangular matrix with diagonal !    elements of nonincreasing magnitude, then QRSOLV expects !    the full upper triangle of R, the permutation matrix p, !    and the first N components of Q'*B. ! !    The system is then equivalent to ! !      R*Z = Q'*B !      P'*D*P*Z = 0 ! !    where X = P*Z.  If this system does not have full rank, !    then a least squares solution is obtained.  On output QRSOLV !    also provides an upper triangular matrix S such that ! !      P'*(A'*A + D*D)*P = S'*S. ! !    S is computed within QRSOLV and may be of separate interest. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N), the N by N matrix. !    On input the full upper triangle must contain the full upper triangle !    of the matrix R.  On output the full upper triangle is unaltered, and !    the strict lower triangle contains the strict upper triangle !    (transposed) of the upper triangular matrix S. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of R, which must be !    at least N. ! !    Input, integer ( kind = 4 ) IPVT(N), defines the permutation matrix P such !    that A*P = Q*R.  Column J of P is column IPVT(J) of the identity matrix. ! !    Input, real ( kind = 8 ) DIAG(N), the diagonal elements of the matrix D. ! !    Input, real ( kind = 8 ) QTB(N), the first N elements of the vector Q'*B. ! !    Output, real ( kind = 8 ) X(N), the least squares solution. ! !    Output, real ( kind = 8 ) SDIAG(N), the diagonal elements of the upper !    triangular matrix S. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) c real ( kind = 8 ) cotan real ( kind = 8 ) diag ( n ) integer ( kind = 4 ) i integer ( kind = 4 ) ipvt ( n ) integer ( kind = 4 ) j integer ( kind = 4 ) k integer ( kind = 4 ) l integer ( kind = 4 ) nsing real ( kind = 8 ) qtb ( n ) real ( kind = 8 ) qtbpj real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) s real ( kind = 8 ) sdiag ( n ) real ( kind = 8 ) sum2 real ( kind = 8 ) t real ( kind = 8 ) temp real ( kind = 8 ) wa ( n ) real ( kind = 8 ) x ( n ) ! !  Copy R and Q'*B to preserve input and initialize S. ! !  In particular, save the diagonal elements of R in X. ! do j = 1 , n r ( j : n , j ) = r ( j , j : n ) x ( j ) = r ( j , j ) end do wa ( 1 : n ) = qtb ( 1 : n ) ! !  Eliminate the diagonal matrix D using a Givens rotation. ! do j = 1 , n ! !  Prepare the row of D to be eliminated, locating the !  diagonal element using P from the QR factorization. ! l = ipvt ( j ) if ( diag ( l ) /= 0.0D+00 ) then sdiag ( j : n ) = 0.0D+00 sdiag ( j ) = diag ( l ) ! !  The transformations to eliminate the row of D !  modify only a single element of Q'*B !  beyond the first N, which is initially zero. ! qtbpj = 0.0D+00 do k = j , n ! !  Determine a Givens rotation which eliminates the !  appropriate element in the current row of D. ! if ( sdiag ( k ) /= 0.0D+00 ) then if ( abs ( r ( k , k ) ) < abs ( sdiag ( k ) ) ) then cotan = r ( k , k ) / sdiag ( k ) s = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) c = s * cotan else t = sdiag ( k ) / r ( k , k ) c = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * t ** 2 ) s = c * t end if ! !  Compute the modified diagonal element of R and !  the modified element of (Q'*B,0). ! r ( k , k ) = c * r ( k , k ) + s * sdiag ( k ) temp = c * wa ( k ) + s * qtbpj qtbpj = - s * wa ( k ) + c * qtbpj wa ( k ) = temp ! !  Accumulate the tranformation in the row of S. ! do i = k + 1 , n temp = c * r ( i , k ) + s * sdiag ( i ) sdiag ( i ) = - s * r ( i , k ) + c * sdiag ( i ) r ( i , k ) = temp end do end if end do end if ! !  Store the diagonal element of S and restore !  the corresponding diagonal element of R. ! sdiag ( j ) = r ( j , j ) r ( j , j ) = x ( j ) end do ! !  Solve the triangular system for Z.  If the system is !  singular, then obtain a least squares solution. ! nsing = n do j = 1 , n if ( sdiag ( j ) == 0.0D+00 . and . nsing == n ) then nsing = j - 1 end if if ( nsing < n ) then wa ( j ) = 0.0D+00 end if end do do j = nsing , 1 , - 1 sum2 = dot_product ( wa ( j + 1 : nsing ), r ( j + 1 : nsing , j ) ) wa ( j ) = ( wa ( j ) - sum2 ) / sdiag ( j ) end do ! !  Permute the components of Z back to components of X. ! do j = 1 , n l = ipvt ( j ) x ( l ) = wa ( j ) end do return endsubroutine qrsolv subroutine r1mpyq ( m , n , a , lda , v , w ) !*****************************************************************************80 ! !! R1MPYQ computes A*Q, where Q is the product of Householder transformations. ! !  Discussion: ! !    Given an M by N matrix A, this function computes A*Q where !    Q is the product of 2*(N - 1) transformations ! !      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1) ! !    and GV(I), GW(I) are Givens rotations in the (I,N) plane which !    eliminate elements in the I-th and N-th planes, respectively. !    Q itself is not given, rather the information to recover the !    GV, GW rotations is supplied. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of A. ! !    Input, integer ( kind = 4 ) N, the number of columns of A. ! !    Input/output, real ( kind = 8 ) A(LDA,N), the M by N array. !    On input, the matrix A to be postmultiplied by the orthogonal matrix Q. !    On output, the value of A*Q. ! !    Input, integer ( kind = 4 ) LDA, the leading dimension of A, which must not !    be less than M. ! !    Input, real ( kind = 8 ) V(N), W(N), contain the information necessary !    to recover the Givens rotations GV and GW. ! implicit none integer ( kind = 4 ) lda integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( lda , n ) real ( kind = 8 ) c integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) s real ( kind = 8 ) temp real ( kind = 8 ) v ( n ) real ( kind = 8 ) w ( n ) ! !  Apply the first set of Givens rotations to A. ! do j = n - 1 , 1 , - 1 if ( 1.0D+00 < abs ( v ( j ) ) ) then c = 1.0D+00 / v ( j ) s = sqrt ( 1.0D+00 - c ** 2 ) else s = v ( j ) c = sqrt ( 1.0D+00 - s ** 2 ) end if do i = 1 , m temp = c * a ( i , j ) - s * a ( i , n ) a ( i , n ) = s * a ( i , j ) + c * a ( i , n ) a ( i , j ) = temp end do end do ! !  Apply the second set of Givens rotations to A. ! do j = 1 , n - 1 if ( abs ( w ( j ) ) > 1.0D+00 ) then c = 1.0D+00 / w ( j ) s = sqrt ( 1.0D+00 - c ** 2 ) else s = w ( j ) c = sqrt ( 1.0D+00 - s ** 2 ) end if do i = 1 , m temp = c * a ( i , j ) + s * a ( i , n ) a ( i , n ) = - s * a ( i , j ) + c * a ( i , n ) a ( i , j ) = temp end do end do return endsubroutine r1mpyq subroutine r1updt ( m , n , s , ls , u , v , w , sing ) !*****************************************************************************80 ! !! R1UPDT re-triangularizes a matrix after a rank one update. ! !  Discussion: ! !    Given an M by N lower trapezoidal matrix S, an M-vector U, and an !    N-vector V, the problem is to determine an orthogonal matrix Q such that ! !      (S + U * V' ) * Q ! !    is again lower trapezoidal. ! !    This function determines Q as the product of 2 * (N - 1) !    transformations ! !      GV(N-1)*...*GV(1)*GW(1)*...*GW(N-1) ! !    where GV(I), GW(I) are Givens rotations in the (I,N) plane !    which eliminate elements in the I-th and N-th planes, !    respectively.  Q itself is not accumulated, rather the !    information to recover the GV and GW rotations is returned. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows of S. ! !    Input, integer ( kind = 4 ) N, the number of columns of S. !    N must not exceed M. ! !    Input/output, real ( kind = 8 ) S(LS).  On input, the lower trapezoidal !    matrix S stored by columns.  On output S contains the lower trapezoidal !    matrix produced as described above. ! !    Input, integer ( kind = 4 ) LS, the length of the S array.  LS must be at !    least (N*(2*M-N+1))/2. ! !    Input, real ( kind = 8 ) U(M), the U vector. ! !    Input/output, real ( kind = 8 ) V(N).  On input, V must contain the !    vector V.  On output V contains the information necessary to recover the !    Givens rotations GV described above. ! !    Output, real ( kind = 8 ) W(M), contains information necessary to !    recover the Givens rotations GW described above. ! !    Output, logical SING, is set to TRUE if any of the diagonal elements !    of the output S are zero.  Otherwise SING is set FALSE. ! implicit none integer ( kind = 4 ) ls integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) cos real ( kind = 8 ) cotan real ( kind = 8 ) giant integer ( kind = 4 ) i integer ( kind = 4 ) j integer ( kind = 4 ) jj integer ( kind = 4 ) l real ( kind = 8 ) s ( ls ) real ( kind = 8 ) sin logical sing real ( kind = 8 ) tan real ( kind = 8 ) tau real ( kind = 8 ) temp real ( kind = 8 ) u ( m ) real ( kind = 8 ) v ( n ) real ( kind = 8 ) w ( m ) ! !  GIANT is the largest magnitude. ! giant = huge ( giant ) ! !  Initialize the diagonal element pointer. ! jj = ( n * ( 2 * m - n + 1 ) ) / 2 - ( m - n ) ! !  Move the nontrivial part of the last column of S into W. ! l = jj do i = n , m w ( i ) = s ( l ) l = l + 1 end do ! !  Rotate the vector V into a multiple of the N-th unit vector !  in such a way that a spike is introduced into W. ! do j = n - 1 , 1 , - 1 jj = jj - ( m - j + 1 ) w ( j ) = 0.0D+00 if ( v ( j ) /= 0.0D+00 ) then ! !  Determine a Givens rotation which eliminates the !  J-th element of V. ! if ( abs ( v ( n ) ) < abs ( v ( j ) ) ) then cotan = v ( n ) / v ( j ) sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) cos = sin * cotan tau = 1.0D+00 if ( abs ( cos ) * giant > 1.0D+00 ) then tau = 1.0D+00 / cos end if else tan = v ( j ) / v ( n ) cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) sin = cos * tan tau = sin end if ! !  Apply the transformation to V and store the information !  necessary to recover the Givens rotation. ! v ( n ) = sin * v ( j ) + cos * v ( n ) v ( j ) = tau ! !  Apply the transformation to S and extend the spike in W. ! l = jj do i = j , m temp = cos * s ( l ) - sin * w ( i ) w ( i ) = sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do end if end do ! !  Add the spike from the rank 1 update to W. ! w ( 1 : m ) = w ( 1 : m ) + v ( n ) * u ( 1 : m ) ! !  Eliminate the spike. ! sing = . false . do j = 1 , n - 1 if ( w ( j ) /= 0.0D+00 ) then ! !  Determine a Givens rotation which eliminates the !  J-th element of the spike. ! if ( abs ( s ( jj ) ) < abs ( w ( j ) ) ) then cotan = s ( jj ) / w ( j ) sin = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) cos = sin * cotan if ( 1.0D+00 < abs ( cos ) * giant ) then tau = 1.0D+00 / cos else tau = 1.0D+00 end if else tan = w ( j ) / s ( jj ) cos = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) sin = cos * tan tau = sin end if ! !  Apply the transformation to S and reduce the spike in W. ! l = jj do i = j , m temp = cos * s ( l ) + sin * w ( i ) w ( i ) = - sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 end do ! !  Store the information necessary to recover the Givens rotation. ! w ( j ) = tau end if ! !  Test for zero diagonal elements in the output S. ! if ( s ( jj ) == 0.0D+00 ) then sing = . true . end if jj = jj + ( m - j + 1 ) end do ! !  Move W back into the last column of the output S. ! l = jj do i = n , m s ( l ) = w ( i ) l = l + 1 end do if ( s ( jj ) == 0.0D+00 ) then sing = . true . end if return endsubroutine r1updt function r8_uniform_01 ( seed ) !*****************************************************************************80 ! !! R8_UNIFORM_01 returns a unit pseudorandom R8. ! !  Discussion: ! !    An R8 is a real ( kind = 8 ) value. ! !    For now, the input quantity SEED is an integer variable. ! !    This routine implements the recursion ! !      seed = 16807 * seed mod ( 2&#94;31 - 1 ) !      r8_uniform_01 = seed / ( 2&#94;31 - 1 ) ! !    The integer arithmetic never requires more than 32 bits, !    including a sign bit. ! !    If the initial seed is 12345, then the first three computations are ! !      Input     Output      R8_UNIFORM_01 !      SEED      SEED ! !         12345   207482415  0.096616 !     207482415  1790989824  0.833995 !    1790989824  2035175616  0.947702 ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    05 July 2006 ! !  Author: ! !    John Burkardt ! !  Reference: ! !    Paul Bratley, Bennett Fox, Linus Schrage, !    A Guide to Simulation, !    Springer Verlag, pages 201-202, 1983. ! !    Pierre L'Ecuyer, !    Random Number Generation, !    in Handbook of Simulation, !    edited by Jerry Banks, !    Wiley Interscience, page 95, 1998. ! !    Bennett Fox, !    Algorithm 647: !    Implementation and Relative Efficiency of Quasirandom !    Sequence Generators, !    ACM Transactions on Mathematical Software, !    Volume 12, Number 4, pages 362-376, 1986. ! !    Peter Lewis, Allen Goodman, James Miller !    A Pseudo-Random Number Generator for the System/360, !    IBM Systems Journal, !    Volume 8, pages 136-143, 1969. ! !  Parameters: ! !    Input/output, integer ( kind = 4 ) SEED, the \"seed\" value, which should !    NOT be 0. On output, SEED has been updated. ! !    Output, real ( kind = 8 ) R8_UNIFORM_01, a new pseudorandom variate, !    strictly between 0 and 1. ! implicit none integer ( kind = 4 ), parameter :: i4_huge = 2147483647 integer ( kind = 4 ) k real ( kind = 8 ) r8_uniform_01 integer ( kind = 4 ) seed if ( seed == 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'R8_UNIFORM_01 - Fatal error!' write ( * , '(a)' ) '  Input value of SEED = 0.' stop 1 end if k = seed / 127773 seed = 16807 * ( seed - k * 127773 ) - k * 2836 if ( seed < 0 ) then seed = seed + i4_huge end if r8_uniform_01 = real ( seed , kind = 8 ) * 4.656612875D-10 return endfunction r8_uniform_01 subroutine r8mat_print ( m , n , a , title ) !*****************************************************************************80 ! !! R8MAT_PRINT prints an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    12 September 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, the number of rows in A. ! !    Input, integer ( kind = 4 ) N, the number of columns in A. ! !    Input, real ( kind = 8 ) A(M,N), the matrix. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = * ) title call r8mat_print_some ( m , n , a , 1 , 1 , m , n , title ) return endsubroutine r8mat_print subroutine r8mat_print_some ( m , n , a , ilo , jlo , ihi , jhi , title ) !*****************************************************************************80 ! !! R8MAT_PRINT_SOME prints some of an R8MAT. ! !  Discussion: ! !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    10 September 2009 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) M, N, the number of rows and columns. ! !    Input, real ( kind = 8 ) A(M,N), an M by N matrix to be printed. ! !    Input, integer ( kind = 4 ) ILO, JLO, the first row and column to print. ! !    Input, integer ( kind = 4 ) IHI, JHI, the last row and column to print. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ), parameter :: incx = 5 integer ( kind = 4 ) m integer ( kind = 4 ) n real ( kind = 8 ) a ( m , n ) character ( len = 14 ) ctemp ( incx ) integer ( kind = 4 ) i integer ( kind = 4 ) i2hi integer ( kind = 4 ) i2lo integer ( kind = 4 ) ihi integer ( kind = 4 ) ilo integer ( kind = 4 ) inc integer ( kind = 4 ) j integer ( kind = 4 ) j2 integer ( kind = 4 ) j2hi integer ( kind = 4 ) j2lo integer ( kind = 4 ) jhi integer ( kind = 4 ) jlo character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) if ( m <= 0 . or . n <= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  (None)' return end if do j2lo = max ( jlo , 1 ), min ( jhi , n ), incx j2hi = j2lo + incx - 1 j2hi = min ( j2hi , n ) j2hi = min ( j2hi , jhi ) inc = j2hi + 1 - j2lo write ( * , '(a)' ) ' ' do j = j2lo , j2hi j2 = j + 1 - j2lo write ( ctemp ( j2 ), '(i8,6x)' ) j end do write ( * , '(''  Col   '',5a14)' ) ctemp ( 1 : inc ) write ( * , '(a)' ) '  Row' write ( * , '(a)' ) ' ' i2lo = max ( ilo , 1 ) i2hi = min ( ihi , m ) do i = i2lo , i2hi do j2 = 1 , inc j = j2lo - 1 + j2 if ( a ( i , j ) == real ( int ( a ( i , j ) ), kind = 8 ) ) then write ( ctemp ( j2 ), '(f8.0,6x)' ) a ( i , j ) else write ( ctemp ( j2 ), '(g14.6)' ) a ( i , j ) end if end do write ( * , '(i5,a,5a14)' ) i , ':' , ( ctemp ( j ), j = 1 , inc ) end do end do return endsubroutine r8mat_print_some subroutine r8vec_print ( n , a , title ) !*****************************************************************************80 ! !! R8VEC_PRINT prints an R8VEC. ! !  Discussion: ! !    An R8VEC is a vector of R8's. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    22 August 2000 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the number of components of the vector. ! !    Input, real ( kind = 8 ) A(N), the vector to be printed. ! !    Input, character ( len = * ) TITLE, a title. ! implicit none integer ( kind = 4 ) n real ( kind = 8 ) a ( n ) integer ( kind = 4 ) i character ( len = * ) title write ( * , '(a)' ) ' ' write ( * , '(a)' ) trim ( title ) write ( * , '(a)' ) ' ' do i = 1 , n write ( * , '(2x,i8,2x,g16.8)' ) i , a ( i ) end do return endsubroutine r8vec_print subroutine rwupdt ( n , r , ldr , w , b , alpha , c , s ) !*****************************************************************************80 ! !! RWUPDT computes the decomposition of triangular matrix augmented by one row. ! !  Discussion: ! !    Given an N by N upper triangular matrix R, this function !    computes the QR decomposition of the matrix formed when a row !    is added to R.  If the row is specified by the vector W, then !    RWUPDT determines an orthogonal matrix Q such that when the !    N+1 by N matrix composed of R augmented by W is premultiplied !    by Q', the resulting matrix is upper trapezoidal. !    The matrix Q' is the product of N transformations ! !      G(N)*G(N-1)* ... *G(1) ! !    where G(I) is a Givens rotation in the (I,N+1) plane which eliminates !    elements in the (N+1)-st plane.  RWUPDT also computes the product !    Q'*C where C is the (N+1)-vector (B,ALPHA). ! !    Q itself is not accumulated, rather the information to recover the G !    rotations is supplied. ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    06 April 2010 ! !  Author: ! !    Original FORTRAN77 version by Jorge More, Burton Garbow, Kenneth Hillstrom. !    FORTRAN90 version by John Burkardt. ! !  Reference: ! !    Jorge More, Burton Garbow, Kenneth Hillstrom, !    User Guide for MINPACK-1, !    Technical Report ANL-80-74, !    Argonne National Laboratory, 1980. ! !  Parameters: ! !    Input, integer ( kind = 4 ) N, the order of R. ! !    Input/output, real ( kind = 8 ) R(LDR,N).  On input the upper triangular !    part of R must contain the matrix to be updated.  On output R contains the !    updated triangular matrix. ! !    Input, integer ( kind = 4 ) LDR, the leading dimension of the array R. !    LDR must not be less than N. ! !    Input, real ( kind = 8 ) W(N), the row vector to be added to R. ! !    Input/output, real ( kind = 8 ) B(N).  On input, the first N elements !    of the vector C.  On output the first N elements of the vector Q'*C. ! !    Input/output, real ( kind = 8 ) ALPHA.  On input, the (N+1)-st element !    of the vector C.  On output the (N+1)-st element of the vector Q'*C. ! !    Output, real ( kind = 8 ) C(N), S(N), the cosines and sines of the !    transforming Givens rotations. ! implicit none integer ( kind = 4 ) ldr integer ( kind = 4 ) n real ( kind = 8 ) alpha real ( kind = 8 ) b ( n ) real ( kind = 8 ) c ( n ) real ( kind = 8 ) cotan integer ( kind = 4 ) i integer ( kind = 4 ) j real ( kind = 8 ) r ( ldr , n ) real ( kind = 8 ) rowj real ( kind = 8 ) s ( n ) real ( kind = 8 ) tan real ( kind = 8 ) temp real ( kind = 8 ) w ( n ) do j = 1 , n rowj = w ( j ) ! !  Apply the previous transformations to R(I,J), I=1,2,...,J-1, and to W(J). ! do i = 1 , j - 1 temp = c ( i ) * r ( i , j ) + s ( i ) * rowj rowj = - s ( i ) * r ( i , j ) + c ( i ) * rowj r ( i , j ) = temp end do ! !  Determine a Givens rotation which eliminates W(J). ! c ( j ) = 1.0D+00 s ( j ) = 0.0D+00 if ( rowj /= 0.0D+00 ) then if ( abs ( r ( j , j ) ) < abs ( rowj ) ) then cotan = r ( j , j ) / rowj s ( j ) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * cotan ** 2 ) c ( j ) = s ( j ) * cotan else tan = rowj / r ( j , j ) c ( j ) = 0.5D+00 / sqrt ( 0.25D+00 + 0.25D+00 * tan ** 2 ) s ( j ) = c ( j ) * tan end if ! !  Apply the current transformation to R(J,J), B(J), and ALPHA. ! r ( j , j ) = c ( j ) * r ( j , j ) + s ( j ) * rowj temp = c ( j ) * b ( j ) + s ( j ) * alpha alpha = - s ( j ) * b ( j ) + c ( j ) * alpha b ( j ) = temp end if end do return endsubroutine rwupdt subroutine timestamp ( ) !*****************************************************************************80 ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! !  Example: ! !    31 May 2001   9:45:54.872 AM ! !  Licensing: ! !    This code may freely be copied, modified, and used for any purpose. ! !  Modified: ! !    18 May 2013 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none character ( len = 8 ) ampm integer ( kind = 4 ) d integer ( kind = 4 ) h integer ( kind = 4 ) m integer ( kind = 4 ) mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer ( kind = 4 ) n integer ( kind = 4 ) s integer ( kind = 4 ) values ( 8 ) integer ( kind = 4 ) y call date_and_time ( values = values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & d , trim ( month ( m ) ), y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return endsubroutine timestamp endmodule minpack","tags":"","loc":"sourcefile/mod_minpack.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~~EfferentGraph sourcefile~prg.f90 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~prg.f90->sourcefile~mod_least_squares.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !< version: 1.0 !< date: 15 mai 2012 !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **Least squares, linear and non linear. Example of use.** !< </span> program test_least use data_arch , only : I4 , R8 , PI_R8 use least_squares , only : moindres_carres , moindres_carres_lineaire implicit none integer ( kind = I4 ) :: n1 , n2 , info real ( kind = R8 ), dimension (:), allocatable :: hij , beta real ( kind = R8 ), dimension (:,:), allocatable :: vec_xy , Jf n1 = 128 n2 = 128 allocate ( hij ( 1 : n1 * n2 ) ) allocate ( vec_xy ( 1 : n1 * n2 , 1 : 2 ) ) allocate ( beta ( 1 : 3 ) ) call calc_imp_acf ( long = n1 , & ! larg = n2 , & ! tau1 = 0.3_R8 , & ! tau2 = 0.1_R8 , & ! alpha = - 0.2_R8 , & ! ang = PI_R8 / 6. , & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! vec_acf = hij ( 1 : n1 * n2 ) ) ! beta ( 1 : 3 ) = [ 0.1 , 0.1 , 0.1 ] call moindres_carres ( nb_var = 3 , & ! nb_pts = n1 * n2 , & ! hij = hij ( 1 : n1 * n2 ), & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! beta = beta ( 1 : 3 ), & ! f = f , & ! df = df , & ! typ = 'no_type' , & ! eps = 0.001_R8 , & ! relax = 0.5_R8 , & ! nb_var_der = 3 , & ! info = info ) ! write ( * , * ) 'Non linear approach to a non linear problem. Solution is 0.3 0.1 +/-0.5' write ( * , * ) beta ( 1 ), beta ( 2 ), sin ( mod ( beta ( 3 ), 2 * PI_R8 )) !======================================================= allocate ( Jf ( 1 : n1 * n2 , 1 : 3 ) ) beta ( 1 : 3 ) = [ 0.1 , 0.1 , 0.1 ] call calc_Jf ( long = n1 , & ! larg = n2 , & ! nb_var = 3 , & ! vec_xy = vec_xy ( 1 : n1 * n2 , 1 : 2 ), & ! var = beta ( 1 : 3 ), & ! Jf = Jf ( 1 : n1 * n2 , 1 : 3 ) ) ! call moindres_carres_lineaire ( nb_var = 3 , & ! nb_pts = n1 * n2 , & ! hij = hij ( 1 : n1 * n2 ), & ! beta = beta ( 1 : 3 ), & ! Jf = Jf ( 1 : n1 * n2 , 1 : 3 ) ) ! write ( * , * ) 'Linear approach to a non linear problem. Solution is 0.3 0.1 +/-0.5' write ( * , * ) beta ( 1 ), beta ( 2 ), sin ( mod ( beta ( 3 ), 2 * PI_R8 )) !======================================================= deallocate ( hij , vec_xy , beta , Jf ) contains real ( kind = R8 ) function f ( xi , yi , var , nb_var , typ ) !! Kind of particular 2D autocorrelation function use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters* real ( kind = R8 ), intent ( in ) :: xi !! *x coordinates* real ( kind = R8 ), intent ( in ) :: yi !! *y coordinates* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameter vector* character ( len =* ), intent ( in ) :: typ !! *not used here* f = autocov_impo ( xi = xi , xj = yi , tau1 = var ( 1 ), tau2 = var ( 2 ), alpha =- 0.2_R8 , ang = var ( 3 )) return endfunction f real ( kind = R8 ) function df ( xi , yi , var , nb_var , ivar , typ ) !! Kind of particular 2D autocorrelation function. Numerical derivatives. use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters* integer ( kind = I4 ), intent ( in ) :: ivar !! *ith parameter* real ( kind = R8 ), intent ( in ) :: xi !! *x coordinates* real ( kind = R8 ), intent ( in ) :: yi !! *y coordinates* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameter vector* character ( len =* ), intent ( in ) :: typ !! *not used here* real ( kind = R8 ) :: v1 , v2 , v3 , dv1 , dv2 , dv3 v1 = var ( 1 ) ; dv1 = 0.001 !v1 / 100 v2 = var ( 2 ) ; dv2 = 0.001 !v2 / 100 v3 = var ( 3 ) ; dv3 = 0.100 !v3 / 100 select case ( ivar ) case ( 1 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 + 0.5 * dv1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 - 0.5 * dv1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 ) ) / dv1 ! case ( 2 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 + 0.5 * dv2 , alpha =- 0.2_R8 , ang = v3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 - 0.5 * dv2 , alpha =- 0.2_R8 , ang = v3 ) ) / dv2 ! case ( 3 ) df = ( autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 + 0.5 * dv3 ) - & ! autocov_impo ( xi = xi , xj = yi , tau1 = v1 , tau2 = v2 , alpha =- 0.2_R8 , ang = v3 - 0.5 * dv3 ) ) / dv3 ! endselect return endfunction df subroutine calc_Jf ( long , larg , nb_var , vec_xy , var , Jf ) !! Determine the Jacobian matrix of f implicit none integer ( kind = I4 ), intent ( in ) :: long !! *number of points along x* integer ( kind = I4 ), intent ( in ) :: larg !! *number of points along y* integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* real ( kind = R8 ), intent ( in ), dimension ( 1 : long * larg , 1 : 2 ) :: vec_xy !! *x and y coordinates of evaluation points* real ( kind = R8 ), intent ( out ), dimension ( 1 : long * larg , 1 : nb_var ) :: Jf !! *Jacobian matrix* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var !! *parameters vector* integer ( kind = I4 ) :: i , j , k , ivar k = 0 do j = 1 , larg do i = 1 , long k = k + 1 do ivar = 1 , nb_var Jf ( k , ivar ) = df ( xi = vec_xy ( k , 1 ), & ! yi = vec_xy ( k , 2 ), & ! var = var ( 1 : 3 ), & ! nb_var = 3 , & ! ivar = ivar , & ! typ = \"no_type\" ) ! enddo enddo enddo return endsubroutine calc_Jf real ( kind = R8 ) function autocov_impo ( xi , xj , tau1 , tau2 , alpha , ang ) !================================================================================================ !<@note Function that returns  \\exp \\left(\\alpha \\sqrt{\\left(\\frac{x}{\\tau_1}\\right)&#94;2+ !<                                                        \\left(\\frac{y}{\\tau_2}\\right)&#94;2} !<                                      \\right)  !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none real ( kind = R8 ), intent ( in ) :: tau1 !! *correlation length along x* real ( kind = R8 ), intent ( in ) :: tau2 !! *correlation length along y* real ( kind = R8 ), intent ( in ) :: alpha !! *log(z)* where *z* is often 0.2 real ( kind = R8 ), intent ( in ) :: xi !! *x coordinate* real ( kind = R8 ), intent ( in ) :: xj !! *y coordinate* real ( kind = R8 ), intent ( in ) :: ang !! *angle* (rad) real ( kind = R8 ) :: x , y x = + cos ( ang ) * xi + sin ( ang ) * xj y = - sin ( ang ) * xi + cos ( ang ) * xj autocov_impo = exp ( alpha * sqrt ( ( x / tau1 ) ** 2 + ( y / tau2 ) ** 2 ) ) return endfunction autocov_impo subroutine calc_imp_acf ( long , larg , tau1 , tau2 , alpha , ang , vec_acf , vec_xy ) !================================================================================================ !<@note Function that returns the theoretical autocorrelation function in an array.<br/> !< The autocorrelation function is supposed to be obtained from a real surface which must be periodic !< or nearly periodic (because of the use of FFTs). !< In addition, the surface is supposed to be 0 mean and normalized (\\sigma = 1 ), !< therefore *acf* is zero-mean and normalized so that its max value is 1.<br/> !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: long !! *surface acf width* integer ( kind = I4 ), intent ( in ) :: larg !! *surface acf height* real ( kind = R8 ), intent ( in ) :: tau1 !! *first correlation length* real ( kind = R8 ), intent ( in ) :: tau2 !! *surface second correlation length* real ( kind = R8 ), intent ( in ) :: alpha !! *parameter that controls the expondential decrease* real ( kind = R8 ), intent ( in ) :: ang !! *acf ellipsis angle* real ( kind = R8 ), dimension ( 1 : long * larg ), intent ( out ) :: vec_acf !! *resulting acf* real ( kind = R8 ), dimension ( 1 : long * larg , 1 : 2 ), intent ( out ) :: vec_xy !! *points coordinates* integer ( kind = I4 ) :: i , j , k , long2 , larg2 real ( kind = R8 ) :: xi , xj , r long2 = long / 2 + 1 larg2 = larg / 2 + 1 k = 0 do j = 1 , larg do i = 1 , long k = k + 1 xi = real ( i - long2 , kind = R8 ) / long xj = real ( j - larg2 , kind = R8 ) / larg vec_xy ( k , 1 ) = xi vec_xy ( k , 2 ) = xj call random_number ( r ) r = 1. + 0.05 * ( 2 * ( 0.5 - r )) vec_acf ( k ) = r * autocov_impo ( xi = xi , & ! IN xj = xj , & ! IN tau1 = tau1 , & ! IN tau2 = tau2 , & ! IN alpha = alpha , & ! IN ang = ang ) ! IN enddo enddo return endsubroutine calc_imp_acf endprogram test_least","tags":"","loc":"sourcefile/prg.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~2~~EfferentGraph sourcefile~prg.f90~2 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~2->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~2->sourcefile~mod_miscellaneous.f90 sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_least_squares.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_tchebychev use data_arch , only : I4 , R8 , HIG_R8 use miscellaneous , only : get_unit use tchebychev , only : least_squares_tcheby , tcheby , coeff_tcheby_vers_monome implicit none integer ( kind = I4 ) :: i , iu , nbvar integer ( kind = I4 ), parameter :: n1 = 1024 , n2 = 512 , i1 = 9 , i2 = 11 real ( kind = R8 ), allocatable , dimension (:,:) :: tab_height , tab_result real ( kind = R8 ), allocatable , dimension (:) :: tab_coef1 , tab_coef2 character ( len = 128 ) :: str nbvar = ( i1 + 1 ) * ( i2 + 1 ) allocate ( tab_height ( 1 : n1 , 1 : n2 ) ) ; tab_height ( 1 : n1 , 1 : n2 ) = HIG_R8 allocate ( tab_result ( 1 : n1 , 1 : n2 ) ) ; tab_result ( 1 : n1 , 1 : n2 ) = HIG_R8 allocate ( tab_coef1 ( 1 : nbvar ) ) ; tab_coef1 ( 1 : nbvar ) = HIG_R8 allocate ( tab_coef2 ( 1 : nbvar ) ) ; tab_coef2 ( 1 : nbvar ) = HIG_R8 call genere_surf_poly ( long1 = n1 , & ! long2 = n2 , & ! deg1 = i1 , & ! deg2 = i2 , & ! tab_out = tab_height ( 1 : n1 , 1 : n2 ), & ! tab_coef = tab_coef1 ( 1 : nbvar ) ) ! call least_squares_tcheby ( tab_in = tab_height ( 1 : n1 , 1 : n2 ), & ! tab_out = tab_result ( 1 : n1 , 1 : n2 ), & ! long1 = n1 , & ! long2 = n2 , & ! nvarx = i1 , & ! nvary = i2 , & ! verif = . true ., & ! multi_thread = . true .) ! write ( * , * ) write ( * , * ) 'If the surface is well approximated, the differences are very small.' write ( * , * ) 'Indeed, the approximated surface is a polynomial of the same degree along x, y as the approximating one.' write ( * , * ) 'Result :' , sum ( abs ( tab_result - tab_height ) ) write ( * , * ) write ( * , * ) 'If the translation from Tchebychev to ordinary polynomial is well carried out,' write ( * , * ) 'there should be no big difference between the two surfaces.' call get_unit ( iu ) open ( iu , file = 'verif_tcheby_vers_monome.txt' ) write ( str , '(a,i3.3,a)' ) '(' , nbvar , 'E18.8,a)' read ( iu , trim ( str )) ( tab_coef2 ( i ), i = 1 , nbvar ) close ( iu ) call convert_to_poly ( long1 = n1 , & ! long2 = n2 , & ! deg1 = i1 , & ! deg2 = i2 , & ! tab_coef = tab_coef2 ( 1 : nbvar ), & ! tab_out = tab_height ( 1 : n1 , 1 : n2 ) ) ! write ( * , * ) 'Max. abs. diff. :' , maxval ( abs (( tab_result - tab_height ) / ( 1._R8 + tab_height ) ) ) write ( * , * ) write ( * , * ) 'Given the fact that the reference surface is made of the product of two polynomials,' write ( * , * ) 'the coefficients found must be the same as the imposed ones.' write ( * , * ) 'Max. abs. diff. :' , maxval ( abs (( tab_coef1 - tab_coef2 ) / tab_coef1 ) ) deallocate ( tab_height , tab_result , tab_coef1 , tab_coef2 ) contains !================================================================================================== subroutine convert_to_poly ( long1 , long2 , deg1 , deg2 , tab_coef , tab_out ) !! Génération d'une surface polynômiale pour vérification des procédures d'approximation implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , k1 , k2 , k1k2 tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine convert_to_poly subroutine genere_surf_poly ( long1 , long2 , deg1 , deg2 , tab_out , tab_coef ) !! génère une surface implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: deg1 !! *degré selon x* integer ( kind = I4 ), intent ( in ) :: deg2 !! *degré selon y* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* real ( kind = R8 ), intent ( out ), dimension ( 1 :( deg1 + 1 ) * ( deg2 + 1 )) :: tab_coef !! *tableau des coefficients* real ( kind = R8 ) :: xi , xj integer ( kind = I4 ) :: i , j , ij , k1 , k2 , k1k2 real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai real ( kind = R8 ), dimension ( 0 : deg2 ) :: aj real ( kind = R8 ), dimension ( 0 : deg1 ) :: ai_m real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_t real ( kind = R8 ), dimension ( 1 : long1 ) :: val_xi_m call random_number ( ai ( 0 : deg1 ) ) call random_number ( aj ( 0 : deg2 ) ) ai = + 9 * ai - 4._R8 aj = - 5 * aj + 8._R8 ! =========================== SIMPLE CHECK ===================================================== ! A combination of Tchebychev polynomials must ! yield the same results as a classical polynomial !-------------------------------------------- val_xi_t = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_t ( i ) = val_xi_t ( i ) + ai ( k1 ) * tcheby ( n = k1 , x = xi ) enddo enddo !-------------------------------------------- ! Towards equivalent classical polynomial call coeff_tcheby_vers_monome ( coeff_t = ai ( 0 : deg1 ), coeff_m = ai_m ( 0 : deg1 ), deg = deg1 ) val_xi_m = 0._R8 do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) do k1 = 0 , deg1 val_xi_m ( i ) = val_xi_m ( i ) + ai_m ( k1 ) * ( xi ** k1 ) enddo enddo !-------------------------------------------- write ( * , * ) 'Equivalence of Tchebychev and classical polynomials' write ( * , * ) 'Difference must be negligible' write ( * , * ) ' Diff = ' , maxval ( abs ( val_xi_m - val_xi_t ) ) !-------------------------------------------- ! =========================== END SIMPLE CHECK ================================================== tab_coef = 0._R8 ij = 0 do j = 0 , deg2 do i = 0 , deg1 ij = ij + 1 tab_coef ( ij ) = ai ( i ) * aj ( j ) enddo enddo tab_out = 0._R8 do j = 1 , long2 xj = - 1. + ( j - 1 ) * 2. / ( long2 - 1 ) do i = 1 , long1 xi = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) k1k2 = 0 do k2 = 0 , deg2 do k1 = 0 , deg1 k1k2 = k1k2 + 1 tab_out ( i , j ) = tab_out ( i , j ) + tab_coef ( k1k2 ) * ( xi ** k1 ) * ( xj ** k2 ) enddo enddo enddo enddo return endsubroutine genere_surf_poly endprogram test_tchebychev","tags":"","loc":"sourcefile/prg.f90~2.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~3~~EfferentGraph sourcefile~prg.f90~3 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~3->sourcefile~mod_data_arch.f90 sourcefile~mod_intpl.f90 mod_intpl.f90 sourcefile~prg.f90~3->sourcefile~mod_intpl.f90 sourcefile~mod_intpl.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !< version: 1.0 !< date: 15 mai 2012 !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **Interpolation/weighting functions. Example of use.** !< </span> program test_intpl use data_arch , only : I4 , R8 , PI_R8 use intpl implicit none integer ( kind = I4 ), parameter :: n1 = 1024 , n2 = 2 * n1 write ( * , * ) ' ORDER 1' ; call test_interp_pond ( ordre = 1 ) write ( * , * ) ' ORDER 3' ; call test_interp_pond ( ordre = 3 ) write ( * , * ) ' ORDER 5' ; call test_interp_pond ( ordre = 5 ) write ( * , * ) ' ORDER 7' ; call test_interp_pond ( ordre = 7 ) stop contains subroutine test_interp_pond ( ordre ) !! Test interpolation/weighting function for a particular order implicit none integer ( kind = I4 ), intent ( in ) :: ordre !! order integer ( kind = I4 ) :: i , ii , j , jj , istat1 , istat2 real ( kind = R8 ), allocatable , dimension (:) :: tableau1D , tab_f1D , tab_g1D , erreur1D real ( kind = R8 ), allocatable , dimension (:,:) :: tableau2D , tab_f2D , tab_g2D , erreur2D type ( tborne ) :: bfin , bgro allocate ( tableau1D ( 0 : n2 ), tab_f1D ( 0 : n2 ), & ! tab_g1D ( 0 : n1 ), erreur1D ( 0 : n2 ), & ! stat = istat1 ) ! allocate ( tableau2D ( 0 : n2 , 0 : n2 ), tab_f2D ( 0 : n2 , 0 : n2 ), & ! tab_g2D ( 0 : n1 , 0 : n1 ), erreur2D ( 0 : n2 , 0 : n2 ), & ! stat = istat2 ) ! if ( istat1 + istat2 /= 0 ) stop '\"test_interp_pond\" problem of allocation' !............................................................. do ii = 0 , n1 i = 2 * ii tableau1D ( ii ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call interp1D ( tabgros = tableau1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( def_tab1D ( i ) - tab_f1D ( i ) ) / & ! ( def_tab1D ( i ) + tab_f1D ( i ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'interp 1D - max err, mean err: :         ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau do ii = 0 , n1 erreur1D ( ii ) = 200 * abs ( ( def_tab1D ( 2 * ii ) - tab_g1D ( ii ) ) / & ! ( def_tab1D ( 2 * ii ) + tab_g1D ( ii ) ) ) ! comparaison théorique/interpolé enddo write ( * , * ) 'weight 1D - max err, mean err:           ' , maxval ( erreur1D ( 0 : n1 ) ), sum ( erreur1D ( 0 : n1 ) ) / ( n1 + 1 ) !-!<............................................................. do i = 0 , n2 tableau1D ( i ) = def_tab1D ( i ) ! initialisation à une fonction ressemblant à UN noyau élastique enddo call restrict1D ( tabfin = tableau1D ( 0 : n2 ), & ! lb_fin = 0 , & ! tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! restriction de ce tableau call interp1D ( tabgros = tab_g1D ( 0 : n1 ), & ! lb_gros = 0 , & ! tabfin = tab_f1D ( 0 : n2 ), & ! lb_fin = 0 , & ! ub_gros = n1 , & ! ordre = ordre ) ! interpolation de ce tableau do i = 0 , n2 erreur1D ( i ) = 200 * abs ( ( tableau1D ( i ) - tab_f1D ( i ) ) / & ! ( tableau1D ( i ) + tab_f1D ( i ) ) ) ! comparaison avant/après enddo write ( * , * ) 'weight + interp 1D - max err, mean err:  ' , maxval ( erreur1D ( 0 : n2 ) ), sum ( erreur1D ( 0 : n2 ) ) / ( n2 + 1 ) !............................................................. ! Idem 2D !............................................................. do jj = 0 , n1 do ii = 0 , n1 i = 2 * ii j = 2 * jj tableau2D ( ii , jj ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call interp2D ( tabgro = tableau2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( def_tab2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( def_tab2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'interp 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! do jj = 0 , n1 do ii = 0 , n1 erreur2D ( ii , jj ) = 200 * abs ( ( def_tab2D ( 2 * ii , 2 * jj ) - tab_g2D ( ii , jj ) ) / & ! ( def_tab2D ( 2 * ii , 2 * jj ) + tab_g2D ( ii , jj ) ) ) ! enddo enddo write ( * , * ) 'weight 2D - max err, mean err:           ' , maxval ( erreur2D ( 0 : n1 , 0 : n1 ) ), sum ( erreur2D ( 0 : n1 , 0 : n1 ) ) / ( n1 + 1 ) ** 2 !............................................................. do j = 0 , n2 do i = 0 , n2 tableau2D ( i , j ) = def_tab2D ( i , j ) enddo enddo bfin = tborne ( lb1 = 0 , ub1 = n2 , lb2 = 0 , ub2 = n2 ) bgro = tborne ( lb1 = 0 , ub1 = n1 , lb2 = 0 , ub2 = n1 ) call restrict2D ( tabfin = tableau2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! tabgros = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgros = bgro , & ! ordre = ordre ) ! call interp2D ( tabgro = tab_g2D ( 0 : n1 , 0 : n1 ), & ! bgro = bgro , & ! tabfin = tab_f2D ( 0 : n2 , 0 : n2 ), & ! bfin = bfin , & ! ordre = ordre ) ! do j = 0 , n2 do i = 0 , n2 erreur2D ( i , j ) = 200 * abs ( ( tableau2D ( i , j ) - tab_f2D ( i , j ) ) / & ! ( tableau2D ( i , j ) + tab_f2D ( i , j ) ) ) ! enddo enddo write ( * , * ) 'weight + interp 2D - max err, mean err:  ' , maxval ( erreur2D ( 0 : n2 , 0 : n2 ) ), sum ( erreur2D ( 0 : n2 , 0 : n2 ) ) / ( n2 + 1 ) ** 2 deallocate ( tableau1D , tab_f1D , tab_g1D , erreur1D ) deallocate ( tableau2D , tab_f2D , tab_g2D , erreur2D ) return endsubroutine test_interp_pond real ( kind = R8 ) function def_tab1D ( i ) implicit none integer ( kind = I4 ), intent ( in ) :: i !~       def_tab1D = 1._R8 / ( 1._R8 + (i/64._R8)**2._R8 ) def_tab1D = sin ( 2 * i * PI_R8 / n1 ) + 1.1_R8 return endfunction def_tab1D real ( kind = R8 ) function def_tab2D ( i , j ) implicit none integer ( kind = I4 ), intent ( in ) :: i , j !~       def_tab2D = 1._R8 / (1._R8 + ( (i-j)/64._R8 )**2._R8 ) def_tab2D = sin ( 2 * i * PI_R8 / n1 ) * cos ( 2 * j * PI_R8 / n1 ) + 1.1_R8 return endfunction def_tab2D endprogram test_intpl","tags":"","loc":"sourcefile/prg.f90~3.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~4~~EfferentGraph sourcefile~prg.f90~4 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~4->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~4->sourcefile~mod_miscellaneous.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: march, 07 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Various subroutines. Example of use.** !<  </span> program test_data_arch use data_arch use miscellaneous , only : get_unit , trans_center2corner , trans_corner2center , progress_bar_terminal implicit none integer ( kind = I4 ) :: uu , i , j integer ( kind = I4 ), parameter :: nx = 11 , ny = 11 character ( len = 3 ) :: snx real ( kind = R8 ), dimension ( nx , ny ) :: array_in , array_out call get_unit ( uu ) open ( unit = uu , file = 'out/GLOB_VAR_VALUES.txt' ) write ( uu , '(I9,T40,a)' ) I4 , 'I4' write ( uu , '(I9,T40,a)' ) I8 , 'I8' write ( uu , '(I9,T40,a)' ) R4 , 'R4' write ( uu , '(I9,T40,a)' ) R8 , 'R8' write ( uu , '(I12,T40,a)' ) HIG_I4 , 'HIG_I4' write ( uu , '(I9,T40,a)' ) OPU , 'OPU' write ( uu , '(I9,T40,a)' ) IPU , 'IPU' write ( uu , '(I9,T40,a)' ) ERU , 'ERU' write ( uu , '(E20.12,T40,a)' ) UN , 'UN' write ( uu , '(E20.12,T40,a)' ) PI_R4 , 'PI_R4' write ( uu , '(E20.12,T40,a)' ) PI_R8 , 'PI_R8' write ( uu , '(E20.12,T40,a)' ) EPS_R4 , 'EPS_R4' write ( uu , '(E20.12,T40,a)' ) EPS_R8 , 'EPS_R8' write ( uu , '(E20.12,T40,a)' ) HIG_R8 , 'HIG_R8' write ( uu , '(E20.12,T40,a)' ) HIG_E8 , 'HIG_E8' write ( uu , '(E20.12,T40,a)' ) EPS_E8 , 'EPS_E8' write ( uu , '(I9,T40,a)' ) EXPO_MAX , 'EXPO_MAX' close ( uu ) write ( snx , '(I3.3)' ) nx write ( * , * ) '============== INITIAL ARRAY ==================' array_in = reshape ( [ ( 0. , i = 1 , nx * ny ) ], [ nx , ny ] ) array_in ( nx / 2 : nx / 2 + 2 , ny / 2 : ny / 2 + 2 ) = 1. do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_in ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============ CENTER => CORNER =================' call trans_center2corner ( tab_in = array_in , tab_out = array_out , long = nx , larg = ny ) do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_out ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============== INITIAL ARRAY ==================' array_in = array_out do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_in ( i , j )), j = 1 , ny ) enddo write ( * , * ) '============ CORNER => CENTER =================' call trans_corner2center ( tab_in = array_in , tab_out = array_out , long = nx , larg = ny ) do i = 1 , nx write ( * , '(' // snx // '10I1)' ) ( int ( array_out ( i , j )), j = 1 , ny ) enddo call progress_bar_terminal ( val = 0 , max_val = 100 , init = . true .) do i = 10 , 100 , 10 call sleep ( 1 ) call progress_bar_terminal ( val = i , max_val = 100 , init = . false .) enddo stop endprogram test_data_arch","tags":"","loc":"sourcefile/prg.f90~4.html"},{"title":"mod_pikaia_oop.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_pikaia_oop.f90~~EfferentGraph sourcefile~mod_pikaia_oop.f90 mod_pikaia_oop.f90 sourcefile~mod_mt19937-64.f90 mod_mt19937-64.f90 sourcefile~mod_pikaia_oop.f90->sourcefile~mod_mt19937-64.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_pikaia_oop.f90~~AfferentGraph sourcefile~mod_pikaia_oop.f90 mod_pikaia_oop.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_pikaia_oop.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !***************************************************************************************** !> !  PIKAIA is a general purpose unconstrained optimization !  method based on a genetic algorithm. !  This is an object-oriented version of the algorithm for Fortran 2003/2008. ! !# See also !  * [Original description page](http://www.hao.ucar.edu/modeling/pikaia/pikaia.php) !  * [Original sourcecode](http://download.hao.ucar.edu/archive/pikaia/) ! !# License ! !    Copyright (c) 2015-2020, Jacob Williams !    http://github.com/jacobwilliams/pikaia ! !    All rights reserved. ! !    Redistribution and use in source and binary forms, with or without !    modification, are permitted provided that the following conditions are met: !    * Redistributions of source code must retain the above copyright notice, this !      list of conditions and the following disclaimer. !    * Redistributions in binary form must reproduce the above copyright notice, !      this list of conditions and the following disclaimer in the documentation !      and/or other materials provided with the distribution. !    * Neither the name of pikaia nor the names of its !      contributors may be used to endorse or promote products derived from !      this software without specific prior written permission. ! !    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" !    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE !    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !    DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE !    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL !    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR !    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER !    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, !    OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE !    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. ! !    ------------------------------------------------------------------------------ ! !    The original version of the PIKAIA software is public domain software !    and is available electronically from the High Altitude Observatory. !    http://www.hao.ucar.edu/modeling/pikaia/pikaia.php ! ! !# History !  * Jacob Williams : 3/8/2015 : Significant refactoring of original PIKAIA code. !    Converted to free-form source, double precision real variables, added various !    new features, and an object-oriented interface. module pikaia_oop use , intrinsic :: iso_fortran_env use mt19937_64 !$  use omp_lib implicit none private integer , parameter :: wp = real64 !! Default real kind [8 bytes]. !********************************************************* type , public :: pikaia_class !! Main class for using the Pikaia algorithm. !! INIT and SOLVE are the only public methods. private integer :: n = 0 !number of solution variables real ( wp ), dimension (:), allocatable :: xl !! lower bounds of `x` real ( wp ), dimension (:), allocatable :: xu !! upper bound of `x` real ( wp ), dimension (:), allocatable :: del !other solution inputs (with default values): integer :: np = 100 integer :: ngen = 500 integer :: nd = 5 real ( wp ) :: pcross = 0.85_wp integer :: imut = 2 real ( wp ) :: pmuti = 0.005_wp !! initial value of `pmut` real ( wp ) :: pmutmn = 0.0005_wp real ( wp ) :: pmutmx = 0.25_wp real ( wp ) :: fdif = 1.0_wp integer :: irep = 1 integer :: ielite = 1 integer :: ivrb = 0 real ( wp ) :: convergence_tol = 0.0001_wp integer :: convergence_window = 20 integer :: iseed = 999 real ( wp ) :: initial_guess_frac = 0.1_wp !used internally: real ( wp ) :: pmut = - huge ( 1.0_wp ) real ( wp ) :: bestft = huge ( 1.0_wp ) real ( wp ) :: pmutpv = huge ( 1.0_wp ) type ( mt19937 ) :: rand !! random number generator !user-supplied procedures: procedure ( pikaia_func ), pointer :: user_f => null () !! fitness function procedure ( iter_func ), pointer :: iter_f => null () !! reporting function (best member of population) contains !public routines: procedure , non_overridable , public :: init => set_inputs procedure , non_overridable , public :: solve => solve_with_pikaia !private routines: procedure , non_overridable :: ff => func_wrapper !! internal pikaia function (x:[0,1]) procedure , non_overridable :: newpop procedure , non_overridable :: stdrep procedure , non_overridable :: genrep procedure , non_overridable :: adjmut procedure , non_overridable :: cross procedure , non_overridable :: encode procedure , non_overridable :: mutate procedure , non_overridable :: decode procedure , non_overridable :: select_parents procedure , non_overridable :: report procedure , non_overridable :: rnkpop procedure , non_overridable :: pikaia procedure , non_overridable :: rninit procedure , non_overridable :: urand end type pikaia_class !********************************************************* abstract interface subroutine pikaia_func ( me , x , f ) !! The interface for the function that pikaia will be maximizing. import :: wp , pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me !! pikaia class real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( out ) :: f !! fitness value end subroutine pikaia_func subroutine iter_func ( me , iter , x , f ) !! The interface for the function that user can specify !! to report each iteration when pikaia is running. !! The best (fittest) population member is passed to !! this routine in each generation. import :: wp , pikaia_class implicit none class ( pikaia_class ), intent ( inout ) :: me !! pikaia class integer , intent ( in ) :: iter !! iteration number real ( wp ), dimension (:), intent ( in ) :: x !! optimization variable vector real ( wp ), intent ( in ) :: f !! fitness value end subroutine iter_func end interface contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Constructor for the [[pikaia_class]]. !  The routine must be called before the solve routine can be used. ! !  The following inputs are required: n, f, xl, xu. !  For the others, if they are not present, then !  the default values are used ! !@note Based on setctl in the original code. subroutine set_inputs ( me ,& n , xl , xu , f , status ,& iter_f ,& np , ngen , nd , pcross , pmutmn , pmutmx , pmut , imut ,& fdif , irep , ielite , ivrb ,& convergence_tol , convergence_window , initial_guess_frac ,& iseed ) implicit none class ( pikaia_class ), intent ( out ) :: me !! pikaia class integer , intent ( in ) :: n !! the parameter space dimension, i.e., the number !! of adjustable parameters (size of the x vector). real ( wp ), dimension ( n ), intent ( in ) :: xl !! vector of lower bounds for x real ( wp ), dimension ( n ), intent ( in ) :: xu !! vector of upper bounds for x procedure ( pikaia_func ) :: f !! user-supplied scalar function of n variables, !! which must have the [[pikaia_func]] procedure interface. !! By convention, f should return higher values for more optimal !! parameter values (i.e., individuals which are more \"fit\"). !! For example, in fitting a function through data points, f !! could return the inverse of chi**2. integer , intent ( out ) :: status !! status output flag (0 if there were no errors) procedure ( iter_func ), optional :: iter_f !! user-supplied subroutine that will report the !! best solution for each generation. !! It must have the [[iter_func]] procedure interface.  If not present, !! then it is not used.  (note: this is independent of ivrb). integer , intent ( in ), optional :: np !! number of individuals in a population (default is 100) integer , intent ( in ), optional :: ngen !! maximum number of iterations integer , intent ( in ), optional :: nd !! number of significant digits (i.e., number of !! genes) retained in chromosomal encoding (default is 6). real ( wp ), intent ( in ), optional :: pcross !! crossover probability; must be  <= 1.0 (default !! is 0.85). If crossover takes place, either one !! or two splicing points are used, with equal !! probabilities real ( wp ), intent ( in ), optional :: pmutmn !! minimum mutation rate; must be >= 0.0 (default is 0.0005) real ( wp ), intent ( in ), optional :: pmutmx !! maximum mutation rate; must be <= 1.0 (default is 0.25) real ( wp ), intent ( in ), optional :: pmut !! initial mutation rate; should be small (default !! is 0.005) (Note: the mutation rate is the probability !! that any one gene locus will mutate in !! any one generation.) integer , intent ( in ), optional :: imut !! mutation mode; 1/2/3/4/5 (default is 2). !!  1=one-point mutation, fixed rate. !!  2=one-point, adjustable rate based on fitness. !!  3=one-point, adjustable rate based on distance. !!  4=one-point+creep, fixed rate. !!  5=one-point+creep, adjustable rate based on fitness. !!  6=one-point+creep, adjustable rate based on distance. real ( wp ), intent ( in ), optional :: fdif !! relative fitness differential; range from 0 !! (none) to 1 (maximum).  (default is 1.0) integer , intent ( in ), optional :: irep !! reproduction plan; 1/2/3=Full generational !! replacement/Steady-state-replace-random/Steady- !! state-replace-worst (default is 3) integer , intent ( in ), optional :: ielite !! elitism flag; 0/1=off/on (default is 0) !! (Applies only to reproduction plans 1 and 2) integer , intent ( in ), optional :: ivrb !! printed output 0/1/2=None/Minimal/Verbose !! (default is 0) real ( wp ), intent ( in ), optional :: convergence_tol !! convergence tolerance; must be > 0.0 (default is 0.0001) integer , intent ( in ), optional :: convergence_window !! convergence window; must be >= 0 !! This is the number of consecutive solutions !! within the tolerance for convergence to !! be declared (default is 20) real ( wp ), intent ( in ), optional :: initial_guess_frac !! fraction of the initial population !! to set equal to the initial guess.  Range from 0 !! (none) to 1.0 (all). (default is 0.1 or 10%). integer , intent ( in ), optional :: iseed !! random seed value; must be > 0 (default is 999) me % n = n if ( allocated ( me % xl )) deallocate ( me % xl ) allocate ( me % xl ( n )) me % xl = xl if ( allocated ( me % xu )) deallocate ( me % xu ) allocate ( me % xu ( n )) me % xu = xu if ( allocated ( me % del )) deallocate ( me % del ) allocate ( me % del ( n )) me % del = me % xu - me % xl me % user_f => f if ( present ( iter_f )) me % iter_f => iter_f if ( present ( np )) me % np = np if ( present ( ngen )) me % ngen = ngen if ( present ( nd )) me % nd = nd if ( present ( pcross )) me % pcross = pcross if ( present ( imut )) me % imut = imut if ( present ( pmut )) me % pmuti = pmut !initial value if ( present ( pmutmn )) me % pmutmn = pmutmn if ( present ( pmutmx )) me % pmutmx = pmutmx if ( present ( fdif )) me % fdif = fdif if ( present ( irep )) me % irep = irep if ( present ( ielite )) me % ielite = ielite if ( present ( ivrb )) me % ivrb = ivrb if ( present ( convergence_tol )) me % convergence_tol = convergence_tol if ( present ( convergence_window )) me % convergence_window = convergence_window if ( present ( initial_guess_frac )) me % initial_guess_frac = initial_guess_frac if ( present ( iseed )) me % iseed = iseed !check for errors: !initialize error flag: status = 0 !Print a header if ( me % ivrb > 0 ) then write ( output_unit , '(A)' ) '------------------------------------------------------------' write ( output_unit , '(A)' ) '              PIKAIA Genetic Algorithm Report               ' write ( output_unit , '(A)' ) '------------------------------------------------------------' write ( output_unit , '(A,I4)' ) ' Number of Generations evolving: ' , me % ngen write ( output_unit , '(A,I4)' ) '     Individuals per generation: ' , me % np write ( output_unit , '(A,I4)' ) '  Number of Chromosome segments: ' , me % n write ( output_unit , '(A,I4)' ) '  Length of Chromosome segments: ' , me % nd write ( output_unit , '(A,E11.4)' ) '          Crossover probability: ' , me % pcross write ( output_unit , '(A,E11.4)' ) '          Initial mutation rate: ' , me % pmuti write ( output_unit , '(A,E11.4)' ) '          Minimum mutation rate: ' , me % pmutmn write ( output_unit , '(A,E11.4)' ) '          Maximum mutation rate: ' , me % pmutmx write ( output_unit , '(A,E11.4)' ) '  Relative fitness differential: ' , me % fdif write ( output_unit , '(A,E11.4)' ) '         Initial guess fraction: ' , me % initial_guess_frac write ( output_unit , '(A,E11.4)' ) '          Convergence tolerance: ' , me % convergence_tol write ( output_unit , '(A,I4)' ) '             Convergence window: ' , me % convergence_window select case ( me % imut ) case ( 1 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Constant Rate' case ( 2 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Variable Rate (F)' case ( 3 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform, Variable Rate (D)' case ( 4 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Constant Rate' case ( 5 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Variable Rate (F)' case ( 6 ); write ( output_unit , '(A)' ) '                  Mutation Mode: Uniform+Creep, Variable Rate (D)' end select select case ( me % irep ) case ( 1 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Full generational replacement' case ( 2 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Steady-state-replace-random' case ( 3 ); write ( output_unit , '(A)' ) '              Reproduction Plan: Steady-state-replace-worst' end select write ( output_unit , '(A)' ) '------------------------------------------------------------' end if !Check some control values if ( me % imut /= 1 . and . me % imut /= 2 . and . me % imut /= 3 . and . & me % imut /= 4 . and . me % imut /= 5 . and . me % imut /= 6 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Mutation Mode.' status = 5 end if if ( me % fdif > 1.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Relative fitness differential.' status = 9 end if if ( me % irep /= 1 . and . me % irep /= 2 . and . me % irep /= 3 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Reproduction plan.' status = 10 end if if ( me % pcross > 1.0_wp . or . me % pcross < 0.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Crossover probability.' status = 4 end if if ( me % ielite /= 0 . and . me % ielite /= 1 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Elitism flag.' status = 11 end if if ( me % convergence_tol <= 0.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Convergence tolerance.' status = 101 end if if ( me % convergence_window <= 0 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Convergence window.' status = 102 end if if ( me % iseed <= 0 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for iseed.' status = 103 end if if ( me % nd > 9 . or . me % nd < 1 ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Chromosome length.' status = 104 end if if ( mod ( me % np , 2 ) > 0 ) then write ( output_unit , '(A)' ) ' ERROR: population size must be an even number.' status = 105 end if if ( me % initial_guess_frac < 0.0_wp . or . me % initial_guess_frac > 1.0_wp ) then write ( output_unit , '(A)' ) ' ERROR: illegal value for Initial guess fraction.' status = 106 end if if ( me % irep == 1 . and . me % imut == 1 . and . me % pmuti > 0.5_wp . and . me % ielite == 0 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously high value for Initial mutation rate; ' // & '(Should enforce elitism with ielite=1.)' end if if ( me % irep == 1 . and . me % imut == 2 . and . me % pmutmx > 0.5_wp . and . me % ielite == 0 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously high value for Maximum mutation rate; ' // & '(Should enforce elitism with ielite=1.)' end if if ( me % fdif < 0.33_wp . and . me % irep /= 3 ) then write ( output_unit , '(A)' ) & ' WARNING: dangerously low value of Relative fitness differential.' end if end subroutine set_inputs !***************************************************************************************** !***************************************************************************************** !> !  Optimization (maximization) of user-supplied \"fitness\" function !  over n-dimensional parameter space x using a basic genetic !  algorithm method. ! !  Genetic algorithms are heuristic search techniques that !  incorporate in a computational setting, the biological notion !  of evolution by means of natural selection.  This subroutine !  implements the three basic operations of selection, crossover, !  and mutation, operating on \"genotypes\" encoded as strings. ! !  Version 1.2 differs from version 1.0 (December 1995) in that !  it includes (1) two-point crossover, (2) creep mutation, and !  (3) dynamical adjustment of the mutation rate based on metric !  distance in parameter space. ! !# Authors !   * Paul Charbonneau & Barry Knapp !     (High Altitude Observatory, National Center for Atmospheric Research) !     Version 1.2 [ 2002 April 3 ] !   * Jacob Williams : 3/8/3015 : Refactoring and some new features. ! !# References !   * Charbonneau, Paul. \"An introduction to genetic algorithms for !     numerical optimization\", NCAR Technical Note TN-450+IA !     (April 2002) !   * Charbonneau, Paul. \"Release Notes for PIKAIA 1.2\", !     NCAR Technical Note TN-451+STR (April 2002) !   * Charbonneau, Paul, and Knapp, Barry. \"A User's Guide !     to PIKAIA 1.0\" NCAR Technical Note TN-418+IA !     (December 1995) !   * Goldberg, David E.  Genetic Algorithms in Search, Optimization, !     & Machine Learning.  Addison-Wesley, 1989. !   * Davis, Lawrence, ed.  Handbook of Genetic Algorithms. !     Van Nostrand Reinhold, 1991. subroutine pikaia ( me , x , f , status , omp ) implicit none !subroutine arguments: class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x !! Input - initial guess for solution vector. !! Output - the \"fittest\" (optimal) solution found, !! i.e., the solution which maximizes the fitness function. real ( wp ), intent ( out ) :: f !! the (scalar) value of the fitness function at x integer , intent ( out ) :: status !! an indicator of the success or failure !! of the call to pikaia (0=success; non-zero=failure) logical , intent ( in ), optional :: omp !! if OpenMP is being used !Local variables integer :: k , ip , ig , ip1 , ip2 , new , newtot , istart , i_window , j real ( wp ) :: current_best_f , last_best_f , fguess logical :: convergence logical :: use_openmp !! if OpenMP is being used real ( wp ), dimension ( me % n , 2 , me % np / 2 ) :: ph real ( wp ), dimension ( me % n , me % np ) :: oldph real ( wp ), dimension ( me % n , me % np ) :: newph integer , dimension ( me % n * me % nd ) :: gn1 integer , dimension ( me % n * me % nd ) :: gn2 integer , dimension ( me % np ) :: ifit integer , dimension ( me % np ) :: jfit real ( wp ), dimension ( me % np ) :: fitns real ( wp ), dimension ( me % n ) :: xguess real ( wp ), dimension ( 2 , me % np / 2 ) :: fits real ( wp ), parameter :: big = huge ( 1.0_wp ) !! a large number !initialize: call me % rninit () me % bestft = - big me % pmutpv = - big me % pmut = me % pmuti !set initial mutation rate (it can change) i_window = 0 last_best_f = - big convergence = . false . status = 0 ! if OpenMP is being used: !$  use_openmp = .true. if ( present ( omp ) ) use_openmp = omp !Handle the initial guess: if ( me % initial_guess_frac == 0.0_wp ) then !initial guess not used (totally random population) istart = 1 !index to start random population members else !use the initial guess: xguess = x do k = 1 , me % n !make sure they are all within the [0,1] bounds xguess ( k ) = max ( 0.0_wp , min ( 1.0_wp , xguess ( k )) ) end do call me % ff ( xguess , fguess ) !how many elements in the population to set to xguess?: ! [at least 1, at most n] istart = max ( 1 , min ( me % np , int ( me % np * me % initial_guess_frac ))) do k = 1 , istart oldph (:, k ) = xguess fitns ( k ) = fguess end do istart = istart + 1 !index to start random population members end if !Compute initial (random but bounded) phenotypes do ip = istart , me % np do k = 1 , me % n oldph ( k , ip ) = me % urand () !from [0,1] end do end do !$omp parallel do private(ip) do ip = istart , me % np call me % ff ( oldph (:, ip ), fitns ( ip )) end do !$omp end parallel do !Rank initial population by fitness order call me % rnkpop ( fitns , ifit , jfit ) !Main Generation Loop ! This is modified from the original for parallelization. ! Note that, now, in a generation, the population is not changed until ! all the new members are computed. So only the current members are used ! in this process. do ig = 1 , me % ngen !Main Population Loop newtot = 0 do ip = 1 , me % np / 2 !1. pick two parents call me % select_parents ( jfit , ip1 , ip2 ) !2. encode parent phenotypes call me % encode ( oldph (:, ip1 ), gn1 ) call me % encode ( oldph (:, ip2 ), gn2 ) !3. breed call me % cross ( gn1 , gn2 ) call me % mutate ( gn1 ) call me % mutate ( gn2 ) !4. decode offspring genotypes call me % decode ( gn1 , ph (:, 1 , ip )) call me % decode ( gn2 , ph (:, 2 , ip )) !5. insert into population if ( me % irep == 1 ) then call me % genrep ( ip , ph (:,:, ip ), newph ) else if (. not . use_openmp ) then ! compute all the fitnesses in the parallel do j = 1 , 2 ! compute offspring fitness (with caller's fitness function) call me % ff ( ph (:, j , ip ), fits ( j , ip )) end do call me % stdrep ( ph (:,:, ip ), fits (:, ip ), oldph , fitns , ifit , jfit , new ) newtot = newtot + new end if end if end do if ( use_openmp ) then !5. insert into population if not already done if ( me % irep /= 1 ) then ! compute all the fitnesses in the parallel !$omp parallel do private(ip) do ip = 1 , me % np / 2 !$omp parallel do private(j) do j = 1 , 2 ! compute offspring fitness (with caller's fitness function) call me % ff ( ph (:, j , ip ), fits ( j , ip )) end do !$omp end parallel do end do !$omp end parallel do newtot = 0 do ip = 1 , me % np / 2 call me % stdrep ( ph (:,:, ip ), fits (:, ip ), oldph , fitns , ifit , jfit , new ) newtot = newtot + new end do end if end if !End of Main Population Loop !if running full generational replacement: swap populations if ( me % irep == 1 ) call me % newpop ( oldph , newph , ifit , jfit , fitns , newtot ) !adjust mutation rate? if ( any ( me % imut == [ 2 , 3 , 5 , 6 ])) call adjmut ( me , oldph , fitns , ifit ) !report this iteration: if ( me % ivrb > 0 ) call me % report ( oldph , fitns , ifit , ig , newtot ) !report (unscaled) x: if ( associated ( me % iter_f )) & call me % iter_f ( ig , me % xl + me % del * oldph ( 1 : me % n , ifit ( me % np )), fitns ( ifit ( me % np ))) !JW additions: add a convergence criteria ! [stop if the last convergence_window iterations are all within the convergence_tol] current_best_f = fitns ( ifit ( me % np )) !current iteration best fitness if ( abs ( current_best_f - last_best_f ) <= me % convergence_tol ) then !this solution is within the tol from the previous one i_window = i_window + 1 !number of solutions within the convergence tolerance else i_window = 0 !a significantly better solution was found, reset window end if if ( i_window >= me % convergence_window ) then convergence = . true . exit !exit main loop -> convergence end if last_best_f = current_best_f !to compare with next iteration end do !End of Main Generation Loop !JW additions: if ( me % ivrb > 0 ) then if ( convergence ) then write ( output_unit , '(A)' ) 'Solution Converged' else write ( output_unit , '(A)' ) 'Iteration Limit Reached' end if end if !Return best phenotype and its fitness x = oldph ( 1 : me % n , ifit ( me % np )) f = fitns ( ifit ( me % np )) end subroutine pikaia !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Main pikaia wrapper used by the class. subroutine solve_with_pikaia ( me , x , f , status , omp ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), intent ( out ) :: f integer , intent ( out ) :: status logical , intent ( in ), optional :: omp !! if OpenMP is being used if ( associated ( me % user_f )) then !scale input initial guess to be [0,1]: x = ( x - me % xl ) / me % del !call the main routine, using the wrapper function: call me % pikaia ( x , f , status , omp ) !unscale output to be [xl,xu]: x = me % xl + me % del * x else write ( output_unit , '(A)' ) 'Error: pikaia class not initialized.' status = - 1 end if end subroutine solve_with_pikaia !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Wrapper for the user's function that is used by the main pikaia routine !  The x input to this function comes from pikaia, and will be between [0,1]. subroutine func_wrapper ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me ! pikaia class real ( wp ), dimension (:), intent ( in ) :: x ! optimization variable vector [0,1] real ( wp ), intent ( out ) :: f ! fitness value real ( wp ), dimension ( me % n ) :: xp !unscaled x vector: [xu,xl] !map each x variable from [0,1] to [xl,xu]: xp = me % xl + me % del * x !call the user's function with xp: call me % user_f ( xp , f ) end subroutine func_wrapper !***************************************************************************************** !***************************************************************************************** !> author: B. G. Knapp !  date: 86/12/23 ! !  Return integer array p which indexes array a in increasing order. !  Array a is not disturbed.  The Quicksort algorithm is used. ! !# Reference !   * N. Wirth, \"Algorithms and Data Structures\", Prentice-Hall, 1986 subroutine rqsort ( n , a , p ) implicit none integer , intent ( in ) :: n real ( wp ), dimension ( n ), intent ( in ) :: a integer , dimension ( n ), intent ( out ) :: p !Constants integer , parameter :: LGN = 32 !! log base 2 of maximum n integer , parameter :: Q = 11 !! smallest subfile to use quicksort on !Local: integer , dimension ( LGN ) :: stackl , stackr real ( wp ) :: x integer :: s , t , l , m , r , i , j !Initialize the stack stackl ( 1 ) = 1 stackr ( 1 ) = n l = stackl ( 1 ) r = stackr ( 1 ) s = 1 !Initialize the pointer array p = [( i , i = 1 , n )] do while ( s > 0 ) s = s - 1 if (( r - l ) < Q ) then !Use straight insertion insertion : do i = l + 1 , r t = p ( i ) x = a ( t ) do j = i - 1 , l , - 1 if ( a ( p ( j )) <= x ) then p ( j + 1 ) = t cycle insertion end if p ( j + 1 ) = p ( j ) end do j = l - 1 p ( j + 1 ) = t end do insertion else !Use quicksort, with pivot as median of a(l), a(m), a(r) m = ( l + r ) / 2 t = p ( m ) if ( a ( t ) < a ( p ( l ))) then p ( m ) = p ( l ) p ( l ) = t t = p ( m ) end if if ( a ( t ) > a ( p ( r ))) then p ( m ) = p ( r ) p ( r ) = t t = p ( m ) if ( a ( t ) < a ( p ( l ))) then p ( m ) = p ( l ) p ( l ) = t t = p ( m ) end if end if !Partition x = a ( t ) i = l + 1 j = r - 1 do while ( i <= j ) do while ( a ( p ( i )) < x ) i = i + 1 end do do while ( x < a ( p ( j ))) j = j - 1 end do if ( i <= j ) then t = p ( i ) p ( i ) = p ( j ) p ( j ) = t i = i + 1 j = j - 1 end if end do !Stack the larger subfile s = s + 1 if (( j - l ) > ( r - i )) then stackl ( s ) = l stackr ( s ) = j l = i else stackl ( s ) = i stackr ( s ) = r r = j end if s = s + 1 ! since it will be decremented next cycle cycle end if if ( s > 0 ) then l = stackl ( s ) r = stackr ( s ) end if end do end subroutine rqsort !***************************************************************************************** !***************************************************************************************** !> !  Return the next pseudo-random deviate from a sequence which is !  uniformly distributed in the interval [0,1] function urand ( me ) result ( r ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ) :: r r = me % rand % genrand64_real1 () end function urand !***************************************************************************************** !***************************************************************************************** !> !  Initialize the random number generator with the input seed value. subroutine rninit ( me ) implicit none class ( pikaia_class ), intent ( inout ) :: me call me % rand % initialize ( me % iseed ) end subroutine rninit !***************************************************************************************** !***************************************************************************************** !> !  Write generation report to standard output subroutine report ( me , oldph , fitns , ifit , ig , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , me % np ), intent ( in ) :: oldph real ( wp ), dimension ( me % np ), intent ( in ) :: fitns integer , dimension ( me % np ), intent ( in ) :: ifit integer , intent ( in ) :: ig integer , intent ( in ) :: nnew integer :: ndpwr , k logical :: rpt rpt = . false . if ( me % pmut /= me % pmutpv ) then me % pmutpv = me % pmut rpt = . true . end if if ( fitns ( ifit ( me % np )) /= me % bestft ) then me % bestft = fitns ( ifit ( me % np )) rpt = . true . end if if ( rpt . or . me % ivrb >= 2 ) then !Power of 10 to make integer genotypes for display ndpwr = 10 ** me % nd write ( output_unit , '(/I6,I6,F10.6,4F10.6)' ) & ig , nnew , me % pmut , fitns ( ifit ( me % np )),& fitns ( ifit ( me % np - 1 )), fitns ( ifit ( me % np / 2 )) do k = 1 , me % n write ( output_unit , '(22X,3I10)' ) & nint ( ndpwr * oldph ( k , ifit ( me % np ))),& nint ( ndpwr * oldph ( k , ifit ( me % np - 1 ))),& nint ( ndpwr * oldph ( k , ifit ( me % np / 2 ))) end do end if end subroutine report !***************************************************************************************** !***************************************************************************************** !> !  Encode phenotype parameters into integer genotype !  ph(k) are x,y coordinates [ 0 < x,y < 1 ] subroutine encode ( me , ph , gn ) implicit none class ( pikaia_class ), intent ( in ) :: me real ( wp ), dimension ( me % n ), intent ( in ) :: ph integer , dimension ( me % n * me % nd ), intent ( out ) :: gn integer :: ip , i , j , ii real ( wp ) :: z z = 1 0.0_wp ** me % nd ii = 0 do i = 1 , me % n ip = int ( ph ( i ) * z ) do j = me % nd , 1 , - 1 gn ( ii + j ) = mod ( ip , 10 ) ip = ip / 10 end do ii = ii + me % nd end do end subroutine encode !***************************************************************************************** !***************************************************************************************** !> !  decode genotype into phenotype parameters !  ph(k) are x,y coordinates [ 0 < x,y < 1 ] subroutine decode ( me , gn , ph ) implicit none class ( pikaia_class ), intent ( in ) :: me integer , dimension ( me % n * me % nd ), intent ( in ) :: gn real ( wp ), dimension ( me % n ), intent ( out ) :: ph integer :: ip , i , j , ii real ( wp ) :: z z = 1 0.0_wp ** ( - me % nd ) ii = 0 do i = 1 , me % n ip = 0 do j = 1 , me % nd ip = 10 * ip + gn ( ii + j ) end do ph ( i ) = ip * z ii = ii + me % nd end do end subroutine decode !***************************************************************************************** !***************************************************************************************** !> !  breeds two parent chromosomes into two offspring chromosomes. !  breeding occurs through crossover. If the crossover probability !  test yields true (crossover taking place), either one-point or !  two-point crossover is used, with equal probabilities. ! !@note Compatibility with version 1.0: To enforce 100% use of one-point !      crossover, un-comment appropriate line in source code below subroutine cross ( me , gn1 , gn2 ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn1 integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn2 integer :: i , ispl , ispl2 , itmp , t !Use crossover probability to decide whether a crossover occurs if ( me % urand () < me % pcross ) then !Compute first crossover point ispl = int ( me % urand () * me % n * me % nd ) + 1 !Now choose between one-point and two-point crossover if ( me % urand () < 0.5_wp ) then ispl2 = me % n * me % nd else ispl2 = int ( me % urand () * me % n * me % nd ) + 1 !Un-comment following line to enforce one-point crossover !ispl2=me%n*me%nd if ( ispl2 < ispl ) then itmp = ispl2 ispl2 = ispl ispl = itmp end if end if !Swap genes from ispl to ispl2 do i = ispl , ispl2 t = gn2 ( i ) gn2 ( i ) = gn1 ( i ) gn1 ( i ) = t end do end if end subroutine cross !***************************************************************************************** !***************************************************************************************** !> !  Introduces random mutation in a genotype. !  Mutations occur at rate pmut at all gene loci. ! !# Input !   * imut=1    Uniform mutation, constant rate !   * imut=2    Uniform mutation, variable rate based on fitness !   * imut=3    Uniform mutation, variable rate based on distance !   * imut=4    Uniform or creep mutation, constant rate !   * imut=5    Uniform or creep mutation, variable rate based on fitness !   * imut=6    Uniform or creep mutation, variable rate based on distance subroutine mutate ( me , gn ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % n * me % nd ), intent ( inout ) :: gn integer :: i , j , k , l , ist , inc , loc logical :: fix !Decide which type of mutation is to occur if ( me % imut >= 4 . and . me % urand () <= 0.5_wp ) then !CREEP MUTATION OPERATOR !Subject each locus to random +/- 1 increment at the rate pmut do i = 1 , me % n do j = 1 , me % nd if ( me % urand () < me % pmut ) then !Construct integer loc = ( i - 1 ) * me % nd + j inc = nint ( me % urand () ) * 2 - 1 ist = ( i - 1 ) * me % nd + 1 gn ( loc ) = gn ( loc ) + inc !This is where we carry over the one (up to two digits) !first take care of decrement below 0 case if ( inc < 0 . and . gn ( loc ) < 0 ) then if ( j == 1 ) then gn ( loc ) = 0 else fix = . true . do k = loc , ist + 1 , - 1 gn ( k ) = 9 gn ( k - 1 ) = gn ( k - 1 ) - 1 if ( gn ( k - 1 ) >= 0 ) then fix = . false . exit end if end do if ( fix ) then !we popped under 0.00000 lower bound; fix it up if ( gn ( ist ) < 0 ) then do l = ist , loc gn ( l ) = 0 end do end if end if end if end if if ( inc > 0 . and . gn ( loc ) > 9 ) then if ( j == 1 ) then gn ( loc ) = 9 else fix = . true . do k = loc , ist + 1 , - 1 gn ( k ) = 0 gn ( k - 1 ) = gn ( k - 1 ) + 1 if ( gn ( k - 1 ) <= 9 ) then fix = . false . exit end if end do if ( fix ) then !we popped over 9.99999 upper bound; fix it up if ( gn ( ist ) > 9 ) then do l = ist , loc gn ( l ) = 9 end do end if end if end if end if end if end do end do else !UNIFORM MUTATION OPERATOR !Subject each locus to random mutation at the rate pmut do i = 1 , me % n * me % nd if ( me % urand () < me % pmut ) then gn ( i ) = int ( me % urand () * 1 0.0_wp ) end if end do end if end subroutine mutate !***************************************************************************************** !***************************************************************************************** !> !  Dynamical adjustment of mutation rate: ! !   * imut=2 or imut=5 : adjustment based on fitness differential !     between best and median individuals !   * imut=3 or imut=6 : adjustment based on metric distance !     between best and median individuals subroutine adjmut ( me , oldph , fitns , ifit ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % np ), intent ( in ) :: ifit real ( wp ), dimension ( me % n , me % np ), intent ( in ) :: oldph real ( wp ), dimension ( me % np ), intent ( in ) :: fitns integer :: i real ( wp ) :: rdif real ( wp ), parameter :: rdiflo = 0.05_wp real ( wp ), parameter :: rdifhi = 0.25_wp real ( wp ), parameter :: delta = 1.5_wp if ( me % imut == 2 . or . me % imut == 5 ) then !Adjustment based on fitness differential rdif = abs ( fitns ( ifit ( me % np )) - & fitns ( ifit ( me % np / 2 ))) / ( fitns ( ifit ( me % np )) + & fitns ( ifit ( me % np / 2 ))) else if ( me % imut == 3 . or . me % imut == 6 ) then !Adjustment based on normalized metric distance rdif = 0.0_wp do i = 1 , me % n rdif = rdif + ( oldph ( i , ifit ( me % np )) - oldph ( i , ifit ( me % np / 2 )) ) ** 2 end do rdif = sqrt ( rdif ) / real ( me % n , wp ) end if if ( rdif <= rdiflo ) then me % pmut = min ( me % pmutmx , me % pmut * delta ) else if ( rdif >= rdifhi ) then me % pmut = max ( me % pmutmn , me % pmut / delta ) end if end subroutine adjmut !***************************************************************************************** !***************************************************************************************** !> !  Selects two parents from the population, using roulette wheel !  algorithm with the relative fitnesses of the phenotypes as !  the \"hit\" probabilities. ! !# Reference !  * Davis 1991, chap. 1. ! !# History !  * Jacob Williams : 3/10/2015 : rewrote this routine to return both parents, !    and also protect against the loop exiting without selecting a parent. subroutine select_parents ( me , jfit , imom , idad ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , dimension ( me % np ), intent ( in ) :: jfit integer , intent ( out ) :: imom integer , intent ( out ) :: idad integer :: np1 , i , j real ( wp ) :: dice , rtfit integer , dimension ( 2 ) :: parents !initialize: np1 = me % np + 1 parents = - 99 !get two (unequal) parents: do j = 1 , 2 main : do dice = me % urand () * me % np * np1 rtfit = 0.0_wp do i = 1 , me % np rtfit = rtfit + np1 + me % fdif * ( np1 - 2 * jfit ( i )) if ( rtfit >= dice ) then parents ( j ) = i if ( parents ( 1 ) /= parents ( 2 )) exit main end if end do end do main end do imom = parents ( 1 ) idad = parents ( 2 ) end subroutine select_parents !***************************************************************************************** !***************************************************************************************** !> !  Ranks initial population. !  Calls external sort routine to produce key index and rank order !  of input array arrin (which is not altered). subroutine rnkpop ( me , arrin , indx , rank ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % np ), intent ( in ) :: arrin integer , dimension ( me % np ), intent ( out ) :: indx integer , dimension ( me % np ), intent ( out ) :: rank integer :: i !Compute the key index call rqsort ( me % np , arrin , indx ) !and the rank order do i = 1 , me % np rank ( indx ( i )) = me % np - i + 1 end do end subroutine rnkpop !***************************************************************************************** !***************************************************************************************** !> !  Full generational replacement: accumulate offspring into new !  population array subroutine genrep ( me , ip , ph , newph ) implicit none class ( pikaia_class ), intent ( inout ) :: me integer , intent ( in ) :: ip real ( wp ), dimension ( me % n , 2 ), intent ( in ) :: ph real ( wp ), dimension ( me % n , me % np ), intent ( out ) :: newph integer :: i1 , i2 , k !Insert one offspring pair into new population i1 = 2 * ip - 1 i2 = i1 + 1 do k = 1 , me % n newph ( k , i1 ) = ph ( k , 1 ) newph ( k , i2 ) = ph ( k , 2 ) end do end subroutine genrep !***************************************************************************************** !***************************************************************************************** !> !  Steady-state reproduction: insert offspring pair into population !  only if they are fit enough (replace-random if irep=2 or !  replace-worst if irep=3). subroutine stdrep ( me , ph , fits , oldph , fitns , ifit , jfit , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , 2 ), intent ( in ) :: ph real ( wp ), dimension ( 2 ), intent ( in ) :: fits real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: oldph real ( wp ), dimension ( me % np ), intent ( inout ) :: fitns integer , dimension ( me % np ), intent ( inout ) :: ifit integer , dimension ( me % np ), intent ( inout ) :: jfit integer , intent ( out ) :: nnew integer :: i , j , k , i1 , if1 real ( wp ) :: fit nnew = 0 main_loop : do j = 1 , 2 !1. get offspring fitness fit = fits ( j ) !2. if fit enough, insert in population do i = me % np , 1 , - 1 if ( fit > fitns ( ifit ( i ))) then !make sure the phenotype is not already in the population if ( i < me % np ) then if ( all ( oldph ( 1 : me % n , ifit ( i + 1 )) == ph ( 1 : me % n , j ))) cycle main_loop end if !offspring is fit enough for insertion, and is unique !(i) insert phenotype at appropriate place in population if ( me % irep == 3 ) then i1 = 1 else if ( me % ielite == 0 . or . i == me % np ) then i1 = int ( me % urand () * me % np ) + 1 else i1 = int ( me % urand () * ( me % np - 1 )) + 1 end if if1 = ifit ( i1 ) fitns ( if1 ) = fit do k = 1 , me % n oldph ( k , if1 ) = ph ( k , j ) end do !(ii) shift and update ranking arrays if ( i < i1 ) then !shift up jfit ( if1 ) = me % np - i do k = i1 - 1 , i + 1 , - 1 jfit ( ifit ( k )) = jfit ( ifit ( k )) - 1 ifit ( k + 1 ) = ifit ( k ) end do ifit ( i + 1 ) = if1 else !shift down jfit ( if1 ) = me % np - i + 1 do k = i1 + 1 , i jfit ( ifit ( k )) = jfit ( ifit ( k )) + 1 ifit ( k - 1 ) = ifit ( k ) end do ifit ( i ) = if1 end if nnew = nnew + 1 cycle main_loop end if end do end do main_loop end subroutine stdrep !***************************************************************************************** !***************************************************************************************** !> !  Replaces old population by new; recomputes fitnesses & ranks ! !# History !  * Jacob Williams : 3/9/2015 : avoid unnecessary function evaluation if `ielite/=1`. subroutine newpop ( me , oldph , newph , ifit , jfit , fitns , nnew ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: oldph real ( wp ), dimension ( me % n , me % np ), intent ( inout ) :: newph integer , dimension ( me % np ), intent ( out ) :: ifit integer , dimension ( me % np ), intent ( out ) :: jfit real ( wp ), dimension ( me % np ), intent ( out ) :: fitns integer , intent ( out ) :: nnew integer :: i real ( wp ) :: f nnew = me % np if ( me % ielite == 1 ) then !if using elitism, introduce in new population fittest of old !population (if greater than fitness of the individual it is !to replace) call me % ff ( newph (:, 1 ), f ) if ( f < fitns ( ifit ( me % np ))) then newph (:, 1 ) = oldph (:, ifit ( me % np )) nnew = nnew - 1 end if end if !replace population oldph = newph !get fitness using caller's fitness function !$omp parallel do private(i) do i = 1 , me % np call me % ff ( oldph (:, i ), fitns ( i )) end do !$omp end parallel do !compute new population fitness rank order call me % rnkpop ( fitns , ifit , jfit ) end subroutine newpop !***************************************************************************************** !***************************************************************************************** end module pikaia_oop !*****************************************************************************************","tags":"","loc":"sourcefile/mod_pikaia_oop.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~5~~EfferentGraph sourcefile~prg.f90~5 prg.f90 sourcefile~mod_gnufor.f90 mod_gnufor.f90 sourcefile~prg.f90~5->sourcefile~mod_gnufor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: John Burkardt !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **A fortran api to GNUPLOT. Example of use.** !< </span> !< program test_gnufor use gnufor implicit none call test01 () call test02 () call test03 () call test04 () call test05 () call test06 () stop endprogram test_gnufor","tags":"","loc":"sourcefile/prg.f90~5.html"},{"title":"mod_gen_par.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_gen_par.f90~~EfferentGraph sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_gen_par.f90~~AfferentGraph sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_gen_par.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Noël Brunetière<br/>&emsp;Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **Very general parameters** !  </span> module gen_param use data_arch , only : I4 , R8 implicit none ! codes for message integer ( kind = I4 ), parameter :: NO_MESS = 0 !! *code for no message on screen during problem solving* integer ( kind = I4 ), parameter :: PRINT_MESS = 1 !! *code for printing message during problem solving* integer ( kind = I4 ) :: SOLV_MESS = NO_MESS !! *Solver output detail control* integer ( kind = I4 ) :: VERBOSE !! *Output detail control* character ( len = 128 ) :: OUTPUT_FILE !! *When needed, output file* endmodule gen_param","tags":"","loc":"sourcefile/mod_gen_par.f90.html"},{"title":"mod_fftw3.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_fftw3.f90~~EfferentGraph sourcefile~mod_fftw3.f90 mod_fftw3.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_fftw3.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_fftw3.f90~~AfferentGraph sourcefile~mod_fftw3.f90 mod_fftw3.f90 sourcefile~prg.f90~14 prg.f90 sourcefile~prg.f90~14->sourcefile~mod_fftw3.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: april, 9 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **A fortran api to FFTW3** !< </span> !< !< + FFT distributed on **multiple threads** !< + **multiple FFT** simultaneously computed. !< module fftw3 use , intrinsic :: iso_c_binding use data_arch , only : I4 , R8 , PI_R8 , UN !$ use omp_lib implicit none private integer ( kind = I4 ) :: NB_THREADS_FFT = 4 integer ( kind = I4 ), parameter :: FORWARD = + 1 !! *just as suggested, it means  forward transformation required* integer ( kind = I4 ), parameter :: BACKWARD = - 1 !! *just as suggested, it means backward transformation required* integer ( kind = I4 ), dimension ( 2 ) :: FFT_DIM = [ 0 , 0 ] !! *Sizes currently allocated* real ( kind = R8 ), parameter :: PAD_FFT = 1.50_R8 !! *dimension multiplier for 0-padding* logical ( kind = I4 ) :: MULTI_FFTW_ALLOCATED = . false . !! *the fftw arrays are allocated and the plans are defined* logical ( kind = I4 ) :: SINGL_FFTW_ALLOCATED = . false . !! *the fftw arrays are allocated and the plans are defined* !------------------      classical way of using FFT   ----------------------------------------------------------------------------------------- !------------------ 1 FFT computed on several threads ----------------------------------------------------------------------------------------- complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: cmp_f_i !! *memory address of the input  array for a ```FORWARD``` transformation* complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: cmp_f_o !! *memory address of the output array for a ```FORWARD``` transformation* complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: cmp_b_i !! *memory address of the input  array for a ```BACKWARD``` transformation* complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: cmp_b_o !! *memory address of the output array for a ```BACKWARD``` transformation* real ( C_DOUBLE ), dimension (:,:), pointer :: rea_f_i !! *memory address of the input  array for a ```FORWARD``` transformation* real ( C_DOUBLE ), dimension (:,:), pointer :: rea_b_o !! *memory address of the output array for a ```BACKWARD``` transformation* type ( C_PTR ) :: p_f_i !! *memory address for a plan ```FORWARD``` in  input* type ( C_PTR ) :: p_f_o !! *memory address for a plan ```FORWARD``` in output* type ( C_PTR ) :: p_b_i !! *memory address for a plan ```BACKWARD``` in  input* type ( C_PTR ) :: p_b_o !! *memory address for a plan ```BACKWARD``` in output* type ( C_PTR ) :: plan_f !! *plan  ```FORWARD```* type ( C_PTR ) :: plan_b !! *plan ```BACKWARD```* !------------------      parallel FFTs   ----------------------------------------------------------------------------------------------------- !------------------ several FFT treated on 1 thread each ------------------------------------------------------------------------------------- !< @note !<   Because FFTW3 is built so that it works on the same memory zone, for concurrent executions, !<   a zone per thread is created. !< @endnote type tab_fftw complex ( C_DOUBLE_COMPLEX ), dimension (:,:), pointer :: tab endtype tab_fftw !< @note !<   Because FFTW3 is built so that it works on the same memory zone, for concurrent executions, !<   a zone per thread is created. !< @endnote type tab_fftw_real real ( C_DOUBLE ), dimension (:,:), pointer :: tab endtype tab_fftw_real type ( tab_fftw ), dimension (:), allocatable :: tab_cmp_f_i !! *array of memory addresses of the  input arrays for a ```FORWARD``` transformation* type ( tab_fftw ), dimension (:), allocatable :: tab_cmp_f_o !! *array of memory addresses of the output arrays for a ```FORWARD``` transformation* type ( tab_fftw ), dimension (:), allocatable :: tab_cmp_b_i !! *array of memory addresses of the  input arrays for a ```BACKWARD``` transformation* type ( tab_fftw ), dimension (:), allocatable :: tab_cmp_b_o !! *array of memory addresses of the output arrays for a ```BACKWARD``` transformation* type ( tab_fftw_real ), dimension (:), allocatable :: tab_rea_f_i !! *array of memory addresses of the  input arrays for a ```FORWARD``` transformation* type ( tab_fftw_real ), dimension (:), allocatable :: tab_rea_f_o !! *array of memory addresses of the output arrays for a ```FORWARD``` transformation* type ( tab_fftw_real ), dimension (:), allocatable :: tab_rea_b_i !! *array of memory addresses of the  input arrays for a ```BACKWARD``` transformation* type ( tab_fftw_real ), dimension (:), allocatable :: tab_rea_b_o !! *array of memory addresses of the output arrays for a ```BACKWARD``` transformation* type ( C_PTR ), dimension (:), allocatable :: tab_p_f_i !! *array of memory addresses for a plan ```FORWARD``` in  input* type ( C_PTR ), dimension (:), allocatable :: tab_p_f_o !! *array of memory addresses for a plan ```FORWARD``` in output* type ( C_PTR ), dimension (:), allocatable :: tab_p_b_i !! *array of memory addresses for a plan ```BACKWARD``` in  input* type ( C_PTR ), dimension (:), allocatable :: tab_p_b_o !! *array of memory addresses for a plan ```BACKWARD``` in output* type ( C_PTR ), dimension (:), allocatable :: tab_plan_f !! *plan  ```FORWARD```* type ( C_PTR ), dimension (:), allocatable :: tab_plan_b !! *plan ```BACKWARD```* include \"fftw3.f03\" public :: tab_init_fftw3 , tab_calc_fftw3 , tab_end_fftw3 , fftw_plan_with_nthreads , FORWARD , BACKWARD , & ! tab_init_fftw3_real , tab_calc_fftw3_real_bwd , tab_calc_fftw3_real_fwd , tab_end_fftw3_real , & ! init_fftw3 , calc_fftw3 , end_fftw3 , & ! init_fftw3_real , calc_fftw3_real_fwd , calc_fftw3_real_bwd , & ! MULTI_FFTW_ALLOCATED , SINGL_FFTW_ALLOCATED , NB_THREADS_FFT , FFT_DIM , & ! apod , PAD_FFT , extend , FFTW_ESTIMATE , FFTW_MEASURE , FFTW_EXHAUSTIVE ! contains !========================================================================================= subroutine init_fftw3 ( long , larg ) !! Subroutine to initialize the FFTW3 process *1 FFT distributed on several threads*. !! Complex case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* call alloc_fftw3 ( long , larg ) call make_plan_fftw3 ( long , larg ) SINGL_FFTW_ALLOCATED = . true . FFT_DIM ( 1 : 2 ) = [ long , larg ] return endsubroutine init_fftw3 !========================================================================================= subroutine init_fftw3_real ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *1 FFT distributed on several threads* !! Real case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* call alloc_fftw3_real ( long , larg ) call make_plan_fftw3_real ( long , larg , plan_flag ) SINGL_FFTW_ALLOCATED = . true . FFT_DIM ( 1 : 2 ) = [ long , larg ] return endsubroutine init_fftw3_real !========================================================================================= subroutine tab_init_fftw3 ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *several FFT on single thread each* !! Complex case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* allocate ( tab_cmp_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_f ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_b ( 0 : NB_THREADS_FFT - 1 ) ) call tab_alloc_fftw3 ( long , larg ) call tab_make_plan_fftw3 ( long , larg , plan_flag ) MULTI_FFTW_ALLOCATED = . true . return endsubroutine tab_init_fftw3 !========================================================================================= subroutine tab_init_fftw3_real ( long , larg , plan_flag ) !! Subroutine to initialize the FFTW3 process *several FFT on single thread each* !! Real case. implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* allocate ( tab_rea_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_cmp_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_rea_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_f_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_i ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_p_b_o ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_f ( 0 : NB_THREADS_FFT - 1 ) ) allocate ( tab_plan_b ( 0 : NB_THREADS_FFT - 1 ) ) call tab_alloc_fftw3_real ( long , larg ) call tab_make_plan_fftw3_real ( long , larg , plan_flag ) MULTI_FFTW_ALLOCATED = . true . return endsubroutine tab_init_fftw3_real !========================================================================================= !< @note !<   Subroutine that transforms forward or backward a double complex array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *1 FFT distributed on several threads* !< @endnote !----------------------------------------------------------------------------------------- subroutine calc_fftw3 ( sens , tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: sens !! *```=FORWARD``` or ```=BACKWARD```* integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3 ( long = long , larg = larg ) endif select case ( sens ) case ( FORWARD ) cmp_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( plan_f , cmp_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) case ( BACKWARD ) cmp_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( plan_b , cmp_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) endselect return endsubroutine calc_fftw3 !========================================================================================= !< @note !<   Subroutine that transforms forward a double real array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *1 FFT distributed on several threads* !< @endnote !----------------------------------------------------------------------------------------- subroutine calc_fftw3_real_fwd ( tab_in , tab_ou , long , larg , planner_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ), intent ( in ), optional :: planner_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: plan_flag if ( . not . present ( planner_flag ) ) then plan_flag = FFTW_ESTIMATE else plan_flag = planner_flag endif if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3_real ( long = long , larg = larg , plan_flag = plan_flag ) endif rea_f_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_r2c ( plan_f , rea_f_i ( 1 : long , 1 : larg ), cmp_f_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = cmp_f_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine calc_fftw3_real_fwd !========================================================================================= !< @note !<   Subroutine that transforms backward a double real array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *1 FFT distributed on several threads* !< @endnote !----------------------------------------------------------------------------------------- subroutine calc_fftw3_real_bwd ( tab_in , tab_ou , long , larg , planner_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ), intent ( in ), optional :: planner_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: plan_flag if ( . not . present ( planner_flag ) ) then plan_flag = FFTW_ESTIMATE else plan_flag = planner_flag endif if ( any ( FFT_DIM ( 1 : 2 ) /= [ long , larg ] ) ) then if ( sum ( FFT_DIM ( 1 : 2 )) /= 0 ) call end_fftw3 () call fftw_plan_with_nthreads ( nthreads = omp_get_num_procs ()) call init_fftw3_real ( long = long , larg = larg , plan_flag = plan_flag ) endif cmp_b_i ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_c2r ( plan_b , cmp_b_i ( 1 : long , 1 : larg ), rea_b_o ( 1 : long , 1 : larg )) tab_ou ( 1 : long , 1 : larg ) = rea_b_o ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine calc_fftw3_real_bwd !========================================================================================= !< @note !<   Subroutine that transforms forward or bacward a double complex array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *several FFT on single thread each* !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_calc_fftw3 ( sens , tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: sens !! *```=FORWARD``` or ```=BACKWARD```* integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () select case ( sens ) case ( FORWARD ) tab_cmp_f_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( tab_plan_f ( ithread ), tab_cmp_f_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) case ( BACKWARD ) tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft ( tab_plan_b ( ithread ), tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_b_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_b_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) endselect return endsubroutine tab_calc_fftw3 !========================================================================================= !< @note !<   Subroutine that transforms forward a real array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *several FFT on single thread each* !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_calc_fftw3_real_fwd ( tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () tab_rea_f_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_r2c ( tab_plan_f ( ithread ), tab_rea_f_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_cmp_f_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine tab_calc_fftw3_real_fwd !========================================================================================= !< @note !<   Subroutine that transforms backward a real array. For speed reasons !<   FFTW will always work on the same memory area, until the plans are destroyed of course. !<    *several FFT on single thread each* !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_calc_fftw3_real_bwd ( tab_in , tab_ou , long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* complex ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( in ) :: tab_in !! *array to transform* real ( kind = R8 ), dimension ( 1 : long , 1 : larg ), intent ( out ) :: tab_ou !! *transformed array* integer ( kind = I4 ) :: ithread ithread = omp_get_thread_num () tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) call fftw_execute_dft_c2r ( tab_plan_b ( ithread ), tab_cmp_b_i ( ithread )% tab ( 1 : long , 1 : larg ), & ! tab_rea_b_o ( ithread )% tab ( 1 : long , 1 : larg )) ! tab_ou ( 1 : long , 1 : larg ) = tab_rea_b_o ( ithread )% tab ( 1 : long , 1 : larg ) / sqrt ( real ( long * larg , kind = r8 )) return endsubroutine tab_calc_fftw3_real_bwd !========================================================================================= subroutine end_fftw3 () !! FFTW3 is no more useful from here. *1 FFT distributed on several threads* implicit none if ( SINGL_FFTW_ALLOCATED ) then call destroy_plan_fftw3 () call desalloc_fftw3 () endif SINGL_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine end_fftw3 !========================================================================================= subroutine tab_end_fftw3 () !! FFTW3 is no more useful from here. *several FFT on single thread each* implicit none if ( MULTI_FFTW_ALLOCATED ) then call tab_destroy_plan_fftw3 () call tab_desalloc_fftw3 () deallocate ( tab_p_f_i , tab_p_f_o , tab_p_b_i , tab_p_b_o ) deallocate ( tab_cmp_f_i , tab_cmp_f_o , tab_cmp_b_i , tab_cmp_b_o ) deallocate ( tab_plan_f , tab_plan_b ) endif MULTI_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine tab_end_fftw3 !========================================================================================= subroutine tab_end_fftw3_real () !! FFTW3 is no more useful from here. *several FFT on single thread each* implicit none call tab_destroy_plan_fftw3 () call tab_desalloc_fftw3 () deallocate ( tab_p_f_i , tab_p_f_o , tab_p_b_i , tab_p_b_o ) deallocate ( tab_rea_f_i , tab_cmp_f_o , tab_cmp_b_i , tab_rea_b_o ) deallocate ( tab_plan_f , tab_plan_b ) MULTI_FFTW_ALLOCATED = . false . FFT_DIM ( 1 : 2 ) = [ 0 , 0 ] return endsubroutine tab_end_fftw3_real !========================================================================================= !< @note !<   Allocation of the memory needed by the transformations, forward and backward. !<    *1 FFT distributed on several threads* !< !<   The space remains allocated as long as transformations are needed. !< @endnote !----------------------------------------------------------------------------------------- subroutine alloc_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward p_f_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_f_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_f_i , cmp_f_i , ( / long , larg / )) call c_f_pointer ( p_f_o , cmp_f_o , ( / long , larg / )) ! backward p_b_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_b_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_b_i , cmp_b_i , ( / long , larg / )) call c_f_pointer ( p_b_o , cmp_b_o , ( / long , larg / )) return endsubroutine alloc_fftw3 !========================================================================================= !< @note !<   Allocation of the memory needed by the transformations, forward and backward, for the !<   real case. *1 FFT distributed on several threads* !< !<   The space remains allocated as long as transformations are needed. !< @endnote !----------------------------------------------------------------------------------------- subroutine alloc_fftw3_real ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward p_f_i = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) p_f_o = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_f_i , rea_f_i , ( / long , larg / )) call c_f_pointer ( p_f_o , cmp_f_o , ( / long , larg / )) ! backward p_b_i = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) p_b_o = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( p_b_i , cmp_b_i , ( / long , larg / )) call c_f_pointer ( p_b_o , rea_b_o , ( / long , larg / )) return endsubroutine alloc_fftw3_real !========================================================================================= !< @note !<   Allocation of the memory needed by the transformations, forward and backward. !<    *several FFT on single thread each* !< !<   The space remains allocated as long as transformations are needed. !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_alloc_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ) :: ithread ! forward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_f_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_f_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_f_i ( ithread ), tab_cmp_f_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_f_o ( ithread ), tab_cmp_f_o ( ithread )% tab , ( / long , larg / )) enddo ! backward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_b_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_b_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_b_i ( ithread ), tab_cmp_b_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_b_o ( ithread ), tab_cmp_b_o ( ithread )% tab , ( / long , larg / )) enddo return endsubroutine tab_alloc_fftw3 !========================================================================================= !< @note !<   Allocation of the memory needed by the transformations, forward and backward, for the !<   real case. *several FFT on single thread each* !< !<   The space remains allocated as long as transformations are needed. !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_alloc_fftw3_real ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ) :: ithread ! forward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_f_i ( ithread ) = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) tab_p_f_o ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_f_i ( ithread ), tab_rea_f_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_f_o ( ithread ), tab_cmp_f_o ( ithread )% tab , ( / long , larg / )) enddo ! backward do ithread = 0 , NB_THREADS_FFT - 1 tab_p_b_i ( ithread ) = fftw_alloc_complex ( int ( long * larg , C_SIZE_T )) tab_p_b_o ( ithread ) = fftw_alloc_real ( int ( long * larg , C_SIZE_T )) call c_f_pointer ( tab_p_b_i ( ithread ), tab_cmp_b_i ( ithread )% tab , ( / long , larg / )) call c_f_pointer ( tab_p_b_o ( ithread ), tab_rea_b_o ( ithread )% tab , ( / long , larg / )) enddo return endsubroutine tab_alloc_fftw3_real !========================================================================================= !< @note !<   When no more transformation is needed, the memory is released. !<    *1 FFT distributed on several threads* !< @endnote !----------------------------------------------------------------------------------------- subroutine desalloc_fftw3 () implicit none ! forward call fftw_free ( p_f_i ) ; p_f_i = C_NULL_PTR call fftw_free ( p_f_o ) ; p_f_o = C_NULL_PTR ! backward call fftw_free ( p_b_i ) ; p_b_i = C_NULL_PTR call fftw_free ( p_b_o ) ; p_b_o = C_NULL_PTR return endsubroutine desalloc_fftw3 !========================================================================================= !< @note !<   When no more transformation is needed, the memory is released. !<     *several FFT on single thread each* !< @endnote !----------------------------------------------------------------------------------------- subroutine tab_desalloc_fftw3 () implicit none integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward call fftw_free ( tab_p_f_i ( ithread )) ; tab_p_f_i ( ithread ) = C_NULL_PTR call fftw_free ( tab_p_f_o ( ithread )) ; tab_p_f_o ( ithread ) = C_NULL_PTR ! backward call fftw_free ( tab_p_b_i ( ithread )) ; tab_p_b_i ( ithread ) = C_NULL_PTR call fftw_free ( tab_p_b_o ( ithread )) ; tab_p_b_o ( ithread ) = C_NULL_PTR enddo return endsubroutine tab_desalloc_fftw3 !========================================================================================= !< @note !<   Creates forward and backward plans. *1 FFT distributed on several threads* !< !<   Until no more transformation is needed, the plans remain as they are. !< @endnote !< !< @warning !<    In C, the order line/column is reversed, so the 2nd dimension ```larg``` of the array !<    is first provided in ```fftw_plan_dft_2d``` !< !<    [calling from fortran](http://www.fftw.org/doc/Calling-FFTW-from-Modern-Fortran.html#Calling-FFTW-from-Modern-Fortran) !< @endwarning !----------------------------------------------------------------------------------------- subroutine make_plan_fftw3 ( long , larg ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* ! forward plan_f = fftw_plan_dft_2d ( larg , long , cmp_f_i , cmp_f_o , FFTW_FORWARD , flags = FFTW_ESTIMATE ) ! backward plan_b = fftw_plan_dft_2d ( larg , long , cmp_b_i , cmp_b_o , FFTW_BACKWARD , flags = FFTW_ESTIMATE ) return endsubroutine make_plan_fftw3 !========================================================================================= !< @note !<   Creates forward and backward plans. *1 FFT distributed on several threads* !< !<   Until no more transformation is needed, the plans remain as they are. !< @endnote !< !< @warning !<    In C, the order line/column is reversed, so the 2nd dimension ```larg``` of the array !<    is first provided in ```fftw_plan_dft_2d``` !< !<    [calling from fortran](http://www.fftw.org/doc/Calling-FFTW-from-Modern-Fortran.html#Calling-FFTW-from-Modern-Fortran) !< @endwarning !----------------------------------------------------------------------------------------- subroutine make_plan_fftw3_real ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* ! forward plan_f = fftw_plan_dft_r2c_2d ( n0 = larg , n1 = long , in = rea_f_i , out = cmp_f_o , flags = plan_flag ) ! backward plan_b = fftw_plan_dft_c2r_2d ( n0 = larg , n1 = long , in = cmp_b_i , out = rea_b_o , flags = plan_flag ) return endsubroutine make_plan_fftw3_real !========================================================================================= !< @note !<   Creates forward and backward plans. *several FFT on single thread each* !< !<   Until no more transformation is needed, the plans remain as they are. !< @endnote !< !< @warning !<    In C, the order line/column is reversed, so the 2nd dimension ```larg``` of the array !<    is first provided in ```fftw_plan_dft_2d``` !< !<    [calling from fortran](http://www.fftw.org/doc/Calling-FFTW-from-Modern-Fortran.html#Calling-FFTW-from-Modern-Fortran) !< @endwarning !----------------------------------------------------------------------------------------- subroutine tab_make_plan_fftw3 ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward tab_plan_f ( ithread ) = fftw_plan_dft_2d ( larg , long , tab_cmp_f_i ( ithread )% tab , & ! tab_cmp_f_o ( ithread )% tab , & ! FORWARD , plan_flag ) ! ! backward tab_plan_b ( ithread ) = fftw_plan_dft_2d ( larg , long , tab_cmp_b_i ( ithread )% tab , & ! tab_cmp_b_o ( ithread )% tab , & ! BACKWARD , plan_flag ) ! enddo return endsubroutine tab_make_plan_fftw3 !========================================================================================= !< @note !<   Creates forward and backward plans. *several FFT on single thread each* !< !<   Until no more transformation is needed, the plans remain as they are. !< @endnote !< !< @warning !<    In C, the order line/column is reversed, so the 2nd dimension ```larg``` of the array !<    is first provided in ```fftw_plan_dft_2d``` !< !<    [calling from fortran](http://www.fftw.org/doc/Calling-FFTW-from-Modern-Fortran.html#Calling-FFTW-from-Modern-Fortran) !< @endwarning !----------------------------------------------------------------------------------------- subroutine tab_make_plan_fftw3_real ( long , larg , plan_flag ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *first  2D array dimension* integer ( kind = I4 ), intent ( in ) :: larg !! *second 2D array dimension* integer ( kind = I4 ), intent ( in ) :: plan_flag !! *planning option, [[fftw3(module):FFTW_ESTIMATE]] for example* integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward tab_plan_f ( ithread ) = fftw_plan_dft_r2c_2d ( larg , long , tab_rea_f_i ( ithread )% tab , & ! tab_cmp_f_o ( ithread )% tab , & ! plan_flag ) ! ! backward tab_plan_b ( ithread ) = fftw_plan_dft_c2r_2d ( larg , long , tab_cmp_b_i ( ithread )% tab , & ! tab_rea_b_o ( ithread )% tab , & ! plan_flag ) ! enddo return endsubroutine tab_make_plan_fftw3_real !========================================================================================= subroutine destroy_plan_fftw3 () !! Plans are no more needed as no additional transformation will occur. *1 FFT distributed on several threads* implicit none ! forward call fftw_destroy_plan ( plan_f ) ! backward call fftw_destroy_plan ( plan_b ) return endsubroutine destroy_plan_fftw3 !========================================================================================= subroutine tab_destroy_plan_fftw3 () !! Plans are no more needed as no additional transformation will occur. *several FFT on single thread each* implicit none integer ( kind = I4 ) :: ithread do ithread = 0 , NB_THREADS_FFT - 1 ! forward call fftw_destroy_plan ( tab_plan_f ( ithread )) ! backward call fftw_destroy_plan ( tab_plan_b ( ithread )) enddo return endsubroutine tab_destroy_plan_fftw3 !========================================================================================= !< @note Function that extends an array for FFT processing. !< !< + nx2 = 2 * ( nint(PAD_FFT_FILTER * nx)/2 ) !< + ny2 = 2 * ( nint(PAD_FFT_FILTER * ny)/2 ) !< !<  @endnote !---------------------------------------------------------------------------------------- subroutine extend ( tab_in , tab_out , nx , ny , nx2 , ny2 , ext , type_apo ) implicit none integer ( kind = I4 ), intent ( in ) :: nx !! *2D input array length* integer ( kind = I4 ), intent ( in ) :: ny !! *2D input array width* integer ( kind = I4 ), intent ( in ) :: nx2 !! *2D output array length* integer ( kind = I4 ), intent ( in ) :: ny2 !! *2D output array width* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx2 , 1 : ny2 ) :: tab_out !! *apodized array* character ( len =* ), intent ( in ) :: ext !! *extension* character ( len =* ), intent ( in ), optional :: type_apo !! *apodization type* integer ( kind = I4 ) :: i , j , ibx , iby , iex , iey real ( kind = R8 ), dimension (:,:), allocatable :: tab_tmp ibx = ceiling ( ( nx2 - nx ) / 2. ) ; iex = ibx + nx - 1 iby = ceiling ( ( ny2 - ny ) / 2. ) ; iey = iby + ny - 1 allocate ( tab_tmp ( 1 : nx2 , 1 : ny2 ) ) tab_tmp ( 1 : nx2 , 1 : ny2 ) = 0 tab_tmp ( ibx : iex , iby : iey ) = tab_in ( 1 : nx , 1 : ny ) select case ( ext ) case ( 'symmetry' ) do i = 1 , ibx - 1 tab_tmp ( ibx - i , iby : iey ) = tab_tmp ( ibx + i , iby : iey ) enddo do i = iex + 1 , nx2 tab_tmp ( i , iby : iey ) = tab_tmp ( iex - ( i - iex ), iby : iey ) enddo do j = 1 , iby - 1 tab_tmp ( 1 : nx2 , iby - j ) = tab_tmp ( 1 : nx2 , iby + j ) enddo do j = iey + 1 , ny2 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iey - ( j - iey )) enddo case ( 'constant' ) do i = 1 , ibx - 1 tab_tmp ( i , iby : iey ) = tab_tmp ( ibx , iby : iey ) enddo do i = iex + 1 , nx2 tab_tmp ( i , iby : iey ) = tab_tmp ( iex , iby : iey ) enddo do j = 1 , iby - 1 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iby ) enddo do j = iey + 1 , ny2 tab_tmp ( 1 : nx2 , j ) = tab_tmp ( 1 : nx2 , iey ) enddo case ( 'zero' ) endselect if ( present ( type_apo ) ) then call apod ( tab_in = tab_tmp ( 1 : nx2 , 1 : ny2 ), & ! tab_out = tab_out ( 1 : nx2 , 1 : ny2 ), & ! long = nx2 , & ! larg = ny2 , & ! type_apo = type_apo ) ! else tab_out ( 1 : nx2 , 1 : ny2 ) = tab_tmp ( 1 : nx2 , 1 : ny2 ) endif deallocate ( tab_tmp ) return endsubroutine extend !========================================================================================= !< @note Function that returns an apodized array. !< !<   To prevent gaps from appearing after FFT (because of non periodic waves), the surface must !<   be transformed, but not too much ... !< !<  @endnote !----------------------------------------------------------------------------------------- subroutine apod ( tab_in , tab_out , long , larg , type_apo , param ) implicit none integer ( kind = I4 ), intent ( in ) :: long !! *2D array length* integer ( kind = I4 ), intent ( in ) :: larg !! *2D array width* character ( len =* ), intent ( in ) :: type_apo !! *apodization type* real ( kind = R8 ), intent ( in ), dimension ( 1 : long , 1 : larg ) :: tab_in !! *input array* real ( kind = R8 ), intent ( out ), dimension ( 1 : long , 1 : larg ) :: tab_out !! *apodized array* real ( kind = R8 ), intent ( in ), optional :: param !! *apodized array* real ( kind = R8 ) :: a0 , a1 , a2 , ro , u , v , fct , pun , mun , eps , mi , mj , li , lj , ri , rj , fcti integer ( kind = I4 ) :: i , j , dis , ii , jj , lo2 , la2 select case ( type_apo ( 1 : 6 ) ) case ( 'blackm' ) a0 = 2 1. / 5 0. a1 = 0 1. / 0 2. a2 = 0 2. / 2 5. ri = real ( long ) ; rj = real ( larg ) mi = ( ri + UN ) / 2 ; mj = ( rj + UN ) / 2 li = ( ri - UN ) / 2 ; lj = ( rj - UN ) / 2 do i = 1 , long u = ( i - mi ) / li do j = 1 , larg v = ( j - mj ) / lj fct = ( a0 + a1 * cos ( PI_R8 * u ) + a2 * cos ( 2 * PI_R8 * u ) ) * & ! ( a0 + a1 * cos ( PI_R8 * v ) + a2 * cos ( 2 * PI_R8 * v ) ) ! tab_out ( i , j ) = tab_in ( i , j ) * fct enddo enddo case ( 'tuckey' ) !http://en.wikipedia.org/wiki/Window_function#Tukey_window mun = - UN pun = + UN eps = 0.25_R8 if ( present ( param ) ) eps = param dis = nint ( eps * long / 2 ) tab_out ( 1 : long , 1 : larg ) = UN do i = 0 , dis ro = 2. * i / ( eps * ( long - 1 ) ) - UN tab_out ( i + 1 , 1 : larg ) = 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo do i = long - 1 - dis , long - 1 ro = 2. * i / ( eps * ( long - 1 ) ) + UN - 2. / eps tab_out ( i + 1 , 1 : larg ) = 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo dis = nint ( eps * larg / 2 ) do j = 0 , dis ro = 2. * j / ( eps * ( larg - 1 ) ) - UN tab_out ( 1 : long , j + 1 ) = tab_out ( 1 : long , j + 1 ) * 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo do j = larg - 1 - dis , larg - 1 ro = 2. * j / ( eps * ( larg - 1 ) ) + UN - 2. / eps tab_out ( 1 : long , j + 1 ) = tab_out ( 1 : long , j + 1 ) * 0.5_R8 * ( UN + cos ( PI_R8 * ro ) ) enddo tab_out ( 1 : long , 1 : larg ) = tab_out ( 1 : long , 1 : larg ) * tab_in ( 1 : long , 1 : larg ) case ( 'hann__' ) do i = 1 , long fcti = 0.5 * ( 1.0 - cos ( 2.0 * PI_R8 * ( i - 1 ) / ( long - 1 ))) do j = 1 , larg fct = fcti * 0.5 * ( 1.0 - cos ( 2.0 * PI_R8 * ( j - 1 ) / ( larg - 1 ))) tab_out ( i , j ) = tab_in ( i , j ) * fct enddo enddo case ( 'welch_' ) ri = long / 2.000001_R8 rj = larg / 2.000001_R8 lo2 = ceiling ( ri ) la2 = ceiling ( rj ) do ii = lo2 - long , lo2 - 1 u = ( ii / ri ) ** 2 i = max ( ii + lo2 , 1 ) do jj = la2 - larg , la2 - 1 v = ( jj / rj ) ** 2 j = max ( jj + la2 , 1 ) if ( u + v > UN ) then tab_out ( i , j ) = 0 cycle endif tab_out ( i , j ) = tab_in ( i , j ) * ( 1._R8 - ( u + v ) ) enddo enddo case ( 'no_apo' ) tab_out ( 1 : long , 1 : larg ) = tab_in ( 1 : long , 1 : larg ) case default stop 'apod, apodization type bad choice' endselect return endsubroutine apod !~    subroutine sample_grid(w, h, wf, hf, tab_in, tab_ou) !~    implicit none !~    integer(kind=I4), intent(in) :: w   !! *input surface width* !~    integer(kind=I4), intent(in) :: h   !! *input surface height* !~    integer(kind=I4), intent(in) :: wf  !! *output surface width* !~    integer(kind=I4), intent(in) :: hf  !! *output surface height* !~    real   (kind=R8), dimension(1:wf, 1:hf), intent( in) :: tab_in  !! *input surface* !~    real   (kind=R8), dimension(1:w , 1:hf), intent(out) :: tab_ou  !! *output surface* !~       integer(kind=I4) :: iw, ih, iwf, ihf !~       real   (kind=R8) :: dw, udw, dh, udh, h1, h2, h3, h4, hh !~       do iw = 1, w !~          iwf = floor( real( wf * (iw-1), kind = R8) / w ) + 1 !~          dw  =        real( wf * (iw-1), kind = R8) / w   + 1 - iwf !~          udw = 1._R8 - dw !~          do ih = 1, h !~             ihf = floor( real( hf * (ih-1), kind = R8) / h ) + 1 !~             dh  =        real( hf * (ih-1), kind = R8) / h   + 1 - ihf !~             udh = 1._R8 - dh !~             h1 = tab_in(iwf    , ihf    ) !~             h2 = tab_in(iwf + 1, ihf    ) !~             h3 = tab_in(iwf + 1, ihf + 1) !~             h4 = tab_in(iwf    , ihf + 1) !~             hh = h1 * udw * udh + &  ! !~                  h2 *  dw * udh + &  ! !~                  h3 *  dw *  dh + &  ! !~                  h4 * udw *  dh !~             tab_ou(iw, ih) = hh !~          enddo !~       enddo !~    return !~    endsubroutine sample_grid endmodule fftw3","tags":"","loc":"sourcefile/mod_fftw3.f90.html"},{"title":"mod_intpl.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_intpl.f90~~EfferentGraph sourcefile~mod_intpl.f90 mod_intpl.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_intpl.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_intpl.f90~~AfferentGraph sourcefile~mod_intpl.f90 mod_intpl.f90 sourcefile~prg.f90~3 prg.f90 sourcefile~prg.f90~3->sourcefile~mod_intpl.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !< version: 1.0 !< date: 15 mai 2012 !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **Interpolation/weighting functions** !< </span> module intpl use data_arch , only : I4 , R8 implicit none private ! coefficient d'interpolation des ordres 1, 3, 5, 7 obtenus par les polynômes de Lagrange ! \"c\" pour coefficient, \"i\" interpolation, \"1\" \"3\" \"5\" \"7\" pour l'ordre real ( kind = R8 ), parameter :: ci1_00 = + 1.0_R8 / 2.0_R8 real ( kind = R8 ), parameter :: ci1_01 = + 1.0_R8 / 2.0_R8 real ( kind = R8 ), parameter :: ci3_00 = - 1.0_R8 / 1 6.0_R8 real ( kind = R8 ), parameter :: ci3_01 = + 9.0_R8 / 1 6.0_R8 real ( kind = R8 ), parameter :: ci3_02 = + 9.0_R8 / 1 6.0_R8 real ( kind = R8 ), parameter :: ci3_03 = - 1.0_R8 / 1 6.0_R8 real ( kind = R8 ), parameter :: ci5_00 = + 3.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci5_01 = - 2 5.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci5_02 = + 15 0.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci5_03 = + 15 0.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci5_04 = - 2 5.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci5_05 = + 3.0_R8 / 25 6.0_R8 real ( kind = R8 ), parameter :: ci7_00 = - 5.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_01 = + 4 9.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_02 = - 24 5.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_03 = + 122 5.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_04 = + 122 5.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_05 = - 24 5.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_06 = + 4 9.0_R8 / 204 8.0_R8 real ( kind = R8 ), parameter :: ci7_07 = - 5.0_R8 / 204 8.0_R8 ! coefficient de pondération des ordres 0, 1, 3, 5, 7 obtenus par les polynômes de Lagrange ! -> transposée des coeff précédents, divisée par 2 real ( kind = R8 ), parameter :: cp0_00 = + 1.0_R8 real ( kind = R8 ), parameter :: cp1_00 = + 1.0_R8 / 4.0_R8 real ( kind = R8 ), parameter :: cp1_01 = + 2.0_R8 / 4.0_R8 real ( kind = R8 ), parameter :: cp1_02 = + 1.0_R8 / 4.0_R8 real ( kind = R8 ), parameter :: cp3_00 = - 1.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_01 = + 0.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_02 = + 9.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_03 = + 1 6.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_04 = + 9.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_05 = + 0.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp3_06 = - 1.0_R8 / 3 2.0_R8 real ( kind = R8 ), parameter :: cp5_00 = + 3.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_01 = + 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_02 = - 2 5.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_03 = + 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_04 = + 15 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_05 = + 25 6.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_06 = + 15 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_07 = + 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_08 = - 2 5.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_09 = + 0.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp5_10 = + 3.0_R8 / 51 2.0_R8 real ( kind = R8 ), parameter :: cp7_00 = - 5.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_01 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_02 = + 4 9.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_03 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_04 = - 24 5.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_05 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_06 = + 122 5.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_07 = + 204 8.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_08 = + 122 5.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_09 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_10 = - 24 5.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_11 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_12 = + 4 9.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_13 = + 0.0_R8 / 409 6.0_R8 real ( kind = R8 ), parameter :: cp7_14 = - 5.0_R8 / 409 6.0_R8 type tborne integer ( kind = I4 ) :: lb1 !! lower bound 1 integer ( kind = I4 ) :: ub1 !! upper bound 1 integer ( kind = I4 ) :: lb2 !! lower bound 2 integer ( kind = I4 ) :: ub2 !! upper bound 2 endtype tborne public :: interp1D , restrict1D , interp2D , restrict2D , tborne contains function interp ( tab , lb , ind , ordre ) !! Interpolate evenly spaced points implicit none real ( kind = R8 ) :: interp !! *valeur particulière interpolée* integer ( kind = I4 ), intent ( in ) :: lb !! *borne inférieure* integer ( kind = 4 ), intent ( in ) :: ind !! *position de l'élément \"milieu\"* integer ( kind = 4 ), intent ( in ) :: ordre !! *ordre de l'interp 1, 3, 5 ou 7* real ( kind = R8 ), intent ( in ), dimension ( lb :) :: tab !! *tableau 1D à interpoler* select case ( ordre ) case ( 1 ) interp = ci1_00 * tab ( ind ) + & ! ci1_01 * tab ( ind + 1 ) ! case ( 3 ) interp = ci3_00 * tab ( ind - 1 ) + & ! ci3_01 * tab ( ind ) + & ! ci3_02 * tab ( ind + 1 ) + & ! ci3_03 * tab ( ind + 2 ) ! case ( 5 ) interp = ci5_00 * tab ( ind - 2 ) + & ! ci5_01 * tab ( ind - 1 ) + & ! ci5_02 * tab ( ind ) + & ! ci5_03 * tab ( ind + 1 ) + & ! ci5_04 * tab ( ind + 2 ) + & ! ci5_05 * tab ( ind + 3 ) ! case ( 7 ) interp = ci7_00 * tab ( ind - 3 ) + & ! ci7_01 * tab ( ind - 2 ) + & ! ci7_02 * tab ( ind - 1 ) + & ! ci7_03 * tab ( ind ) + & ! ci7_04 * tab ( ind + 1 ) + & ! ci7_05 * tab ( ind + 2 ) + & ! ci7_06 * tab ( ind + 3 ) + & ! ci7_07 * tab ( ind + 4 ) ! case default stop 'Bad choice in function \"interp\"' endselect return endfunction interp subroutine interp1D ( tabgros , lb_gros , tabfin , lb_fin , ub_gros , ordre ) !! Interpolate evenly spaced points, taking into account the borders implicit none integer ( kind = I4 ), intent ( in ) :: lb_gros !! *indice inférieur* integer ( kind = I4 ), intent ( in ) :: lb_fin !! *indice inférieur de tab_fin* integer ( kind = I4 ), intent ( in ) :: ub_gros !! *taille de tabgros* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( lb_gros :) :: tabgros !! *tableau grossier à interpoler* real ( kind = R8 ), intent ( out ), dimension ( lb_fin :) :: tabfin !! *tableau résultant, 2 fois plus fin* integer ( kind = I4 ) :: l_inf , l_sup , i , ii real ( kind = R8 ) :: tmp0 , dtmp real ( kind = R8 ), dimension ( - ordre / 2 : ordre ) :: tab_inf real ( kind = R8 ), dimension ( ub_gros - ordre : ub_gros + ordre / 2 ) :: tab_sup ! bornes pour déterminer les limites d'utilisation de la fonction interp l_inf = ordre / 2 l_sup = ub_gros - l_inf ! extension du tableau par prolongement de la dérivée tab_inf ( 0 : ordre ) = tabgros ( 0 : ordre ) tmp0 = tab_inf ( 0 ) dtmp = tab_inf ( 0 ) - tab_inf ( 1 ) do i = 1 , l_inf tab_inf ( - i ) = tmp0 + i * dtmp enddo do ii = 0 , l_inf i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tab_inf , & ! lb = - ordre / 2 , & ! ind = ii , & ! ordre = ordre ) ! enddo ! utilisation d'interp dans les limites normales do ii = l_inf + 1 , l_sup - 1 i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tabgros , & ! lb = lb_gros , & ! ind = ii , & ! ordre = ordre ) ! enddo ! extension du tableau par prolongement de la dérivée tab_sup ( ub_gros - ordre : ub_gros ) = tabgros ( ub_gros - ordre : ub_gros ) tmp0 = tab_sup ( ub_gros ) dtmp = tab_sup ( ub_gros ) - tab_sup ( ub_gros - 1 ) do i = 1 , l_inf tab_sup ( i + ub_gros ) = tmp0 + i * dtmp enddo do ii = l_sup , ub_gros - 1 i = 2 * ii tabfin ( i ) = tabgros ( ii ) tabfin ( i + 1 ) = interp ( tab = tab_sup , & ! lb = ub_gros - ordre , & ! ind = ii , & ! ordre = ordre ) ! enddo tabfin ( 2 * ub_gros ) = tabgros ( ub_gros ) return endsubroutine interp1D subroutine interp2D ( tabgro , bgro , tabfin , bfin , ordre ) !! Interpolate 2D evenly spaced points, taking into account the borders implicit none type ( tborne ), intent ( in ) :: bfin , bgro !! *indices des tableaux* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( bgro % lb1 : bgro % ub1 , bgro % lb2 : bgro % ub2 ) :: tabgro !! *tableau grossier départ* real ( kind = R8 ), intent ( out ), dimension ( bfin % lb1 : bfin % ub1 , bfin % lb2 : bfin % ub2 ) :: tabfin !! *tableau résultant fin* integer ( kind = I4 ) :: ii , j real ( kind = R8 ), dimension ( bgro % lb1 : bgro % ub1 , bfin % lb2 : 2 * bgro % ub2 ) :: tab_tmp do ii = bgro % lb1 , bgro % ub1 call interp1D ( tabgros = tabgro ( ii ,:), & ! lb_gros = bgro % lb2 , & ! tabfin = tab_tmp ( ii ,:), & ! lb_fin = bfin % lb2 , & ! ub_gros = bgro % ub2 , & ! ordre = ordre ) ! enddo do j = bfin % lb2 , 2 * bgro % ub2 call interp1D ( tabgros = tab_tmp (:, j ), & ! lb_gros = bgro % lb1 , & ! tabfin = tabfin (:, j ), & ! lb_fin = bfin % lb1 , & ! ub_gros = bgro % ub1 , & ! ordre = ordre ) ! enddo return endsubroutine interp2D function restrict ( tab , lb , ind , ordre ) !! Restrict evenly spaced points implicit none real ( kind = R8 ) :: restrict !! *valeur particulière pondérée* integer ( kind = 4 ), intent ( in ) :: lb !! *borne inférieure* integer ( kind = 4 ), intent ( in ) :: ind !! *position de l'élément \"milieu\"* integer ( kind = 4 ), intent ( in ) :: ordre !! *ordre de la restriction 1, 3, 5 ou 7* real ( kind = R8 ), intent ( in ), dimension ( lb :) :: tab !! *tableau 1D à réduire* select case ( ordre ) case ( 0 ) restrict = cp0_00 * tab ( ind ) case ( 1 ) restrict = cp1_00 * tab ( ind - 1 ) + & ! cp1_01 * tab ( ind ) + & ! cp1_02 * tab ( ind + 1 ) ! case ( 3 ) restrict = cp3_00 * tab ( ind - 3 ) + & ! cp3_01 * tab ( ind - 2 ) + & ! cp3_02 * tab ( ind - 1 ) + & ! cp3_03 * tab ( ind ) + & ! cp3_04 * tab ( ind + 1 ) + & ! cp3_05 * tab ( ind + 2 ) + & ! cp3_06 * tab ( ind + 3 ) ! case ( 5 ) restrict = cp5_00 * tab ( ind - 5 ) + & ! cp5_01 * tab ( ind - 4 ) + & ! cp5_02 * tab ( ind - 3 ) + & ! cp5_03 * tab ( ind - 2 ) + & ! cp5_04 * tab ( ind - 1 ) + & ! cp5_05 * tab ( ind ) + & ! cp5_06 * tab ( ind + 1 ) + & ! cp5_07 * tab ( ind + 2 ) + & ! cp5_08 * tab ( ind + 3 ) + & ! cp5_09 * tab ( ind + 4 ) + & ! cp5_10 * tab ( ind + 5 ) ! case ( 7 ) restrict = cp7_00 * tab ( ind - 7 ) + & ! cp7_01 * tab ( ind - 6 ) + & ! cp7_02 * tab ( ind - 5 ) + & ! cp7_03 * tab ( ind - 4 ) + & ! cp7_04 * tab ( ind - 3 ) + & ! cp7_05 * tab ( ind - 2 ) + & ! cp7_06 * tab ( ind - 1 ) + & ! cp7_07 * tab ( ind ) + & ! cp7_08 * tab ( ind + 1 ) + & ! cp7_09 * tab ( ind + 2 ) + & ! cp7_10 * tab ( ind + 3 ) + & ! cp7_11 * tab ( ind + 4 ) + & ! cp7_12 * tab ( ind + 5 ) + & ! cp7_13 * tab ( ind + 6 ) + & ! cp7_14 * tab ( ind + 7 ) ! case default stop 'Bad choice in function \"restrict\"' endselect return endfunction restrict subroutine restrict1D ( tabfin , lb_fin , tabgros , lb_gros , ub_gros , ordre ) !! Restrict evenly spaced points, taking into account the borders implicit none integer ( kind = I4 ), intent ( in ) :: lb_fin !! *indice inférieur de tab_fin* integer ( kind = I4 ), intent ( in ) :: lb_gros !! *indice inférieur* integer ( kind = I4 ), intent ( in ) :: ub_gros !! *taille de tabgros* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de la restriction* real ( kind = R8 ), intent ( in ), dimension ( lb_fin :) :: tabfin !! *tableau de départ* real ( kind = R8 ), intent ( out ), dimension ( lb_gros :) :: tabgros !! *tableau grossier résultant* integer ( kind = I4 ) :: l_inf , l_sup , i , ii real ( kind = R8 ) :: tmp0 , dtmp real ( kind = R8 ), dimension ( - ordre : 2 * ordre ) :: tab_inf real ( kind = R8 ), dimension ( 2 * ub_gros - 2 * ordre : 2 * ub_gros + ordre ) :: tab_sup ! bornes pour déterminer les limites d'utilisation de la fonction restrict l_inf = ordre / 2 l_sup = ub_gros - l_inf ! extension du tableau par prolongement de la dérivée tab_inf ( 0 : 2 * ordre ) = tabfin ( 0 : 2 * ordre ) tmp0 = tab_inf ( 0 ) dtmp = tab_inf ( 0 ) - tab_inf ( 1 ) do i = 1 , ordre tab_inf ( - i ) = tmp0 + i * dtmp enddo do ii = 0 , l_inf i = 2 * ii tabgros ( ii ) = restrict ( tab = tab_inf , & ! lb = - ordre , & ! ind = i , & ! ordre = ordre ) ! enddo ! utilisation d'interp dans les limites normales do ii = l_inf + 1 , l_sup - 1 i = 2 * ii tabgros ( ii ) = restrict ( tab = tabfin , & ! lb = lb_fin , & ! ind = i , & ! ordre = ordre ) ! enddo ! extension du tableau par prolongement de la dérivée tab_sup ( 2 * ub_gros - 2 * ordre : 2 * ub_gros ) = tabfin ( 2 * ub_gros - 2 * ordre : 2 * ub_gros ) tmp0 = tab_sup ( 2 * ub_gros ) dtmp = tab_sup ( 2 * ub_gros ) - tab_sup ( 2 * ub_gros - 1 ) do i = 1 , ordre tab_sup ( 2 * ub_gros + i ) = tmp0 + i * dtmp enddo do ii = l_sup , ub_gros i = 2 * ii tabgros ( ii ) = restrict ( tab = tab_sup , & ! lb = 2 * ub_gros - 2 * ordre , & ! ind = i , & ! ordre = ordre ) ! enddo return endsubroutine restrict1D subroutine restrict2D ( tabfin , bfin , tabgros , bgros , ordre ) !! Interpolate 2D evenly spaced points, taking into account the borders implicit none type ( tborne ), intent ( in ) :: bfin , bgros !! *indices des tableaux* integer ( kind = I4 ), intent ( in ) :: ordre !! *ordre de l'interpolation* real ( kind = R8 ), intent ( in ), dimension ( bfin % lb1 : bfin % ub1 , bfin % lb2 : bfin % ub2 ) :: tabfin !! *tableau de départ fin* real ( kind = R8 ), intent ( out ), dimension ( bgros % lb1 : bgros % ub1 , bgros % lb2 : bgros % ub2 ) :: tabgros !! *tableau grossier résultant* integer ( kind = I4 ) :: ii , j real ( kind = R8 ), dimension ( bgros % lb1 : bgros % ub1 , bfin % lb2 : 2 * bgros % ub2 ) :: tab_tmp do j = bfin % lb2 , 2 * bgros % ub2 call restrict1D ( tabfin = tabfin (:, j ), & ! lb_fin = bfin % lb1 , & ! tabgros = tab_tmp (:, j ), & ! lb_gros = bgros % lb1 , & ! ub_gros = bgros % ub1 , & ! ordre = ordre ) ! enddo do ii = bgros % lb1 , bgros % ub1 call restrict1D ( tabfin = tab_tmp ( ii ,:), & ! lb_fin = bfin % lb2 , & ! tabgros = tabgros ( ii ,:), & ! lb_gros = bgros % lb2 , & ! ub_gros = bgros % ub2 , & ! ordre = ordre ) ! enddo return endsubroutine restrict2D subroutine genere_coeff_lagrange () !! subroutine generating coefficients for kth-order interpolation implicit none integer ( kind = I4 ) :: i , j , k , n , c real ( kind = R8 ) :: coeff do write ( * , * ) 'n' ; read ( * , * ) n ; if ( n == 0 ) exit write ( * , * ) 'k' ; read ( * , * ) k write ( * , * ) 'c' ; read ( * , * ) c do i = 0 , n coeff = 1.0d0 do j = 0 , n if ( j == i ) cycle coeff = coeff * ( 0.5_R8 * ( 2 * k - 2 * j + 1 ) ) / ( i - j ) enddo write ( * , * ) coeff * c enddo enddo return endsubroutine genere_coeff_lagrange endmodule intpl","tags":"","loc":"sourcefile/mod_intpl.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~6~~EfferentGraph sourcefile~prg.f90~6 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~6->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~6->sourcefile~mod_miscellaneous.f90 sourcefile~mod_pikaia_oop.f90 mod_pikaia_oop.f90 sourcefile~prg.f90~6->sourcefile~mod_pikaia_oop.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~prg.f90~6->sourcefile~mod_sort_arrays.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_mt19937-64.f90 mod_mt19937-64.f90 sourcefile~mod_pikaia_oop.f90->sourcefile~mod_mt19937-64.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: november, 01 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **PIKAIA oop example of use** !<  </span> !< !< @note !<  The example chosen is the generation of a surface with given statistical moments. !<  The implementation is part of the analytical developments presented in:<br/> !<  A. Francisco and N. Brunetière, \"A hybrid method for fast and efficient rough surface generation\", !<  Proc IMechE Part J:J Engineering Tribology, 2016, Vol. 230(7) 747–768, DOI: 10.1177/1350650115612116 !< !<  The surface heights are generated thanks the *tangent* function. This function is indeed very near the common material !<  curves. Thus, providing the right lower and upper bounds makes it possible to match the desired statistical moments. !< @endnote !< !< @note !<  The main difficulty to cope with is the high non linearity and the convergence only possible near the solution. !<  Classical optimization methods fail in reaching the true solution: the lower and upper limits ```x(1:2```.<br/> !<  The **PIKAIA** program, which implements a genetic algorithm, is utilized to found a \"good\" solution, then a !<  very classical optimization routine is used to find the nearly exact solution. !< @endnote !< !< @warning !<  **PIKAIA** cost function must be chosen so as to be maximized.<br/> !<  For clarity reasons, the optimization function must be minimized because it is the deviation to the solution. !<  @warning !< !< @note !<  First each thread runs the **PIKAIA** program to find a rather good starting point ```x```. The parameters !<  (as defined by ```CTRL```) are the same. The only difference is the starting population. Thus, several concurrent !<  populations evolve during ```CTRL(02)``` generations.<br/> !<  Then, the optimization subroutine starts from the best population. !< @endnote !< !< @note !<  ```make all ```    <br/> !<  ```./prg```        <br/> !<  The surface is in ascii mode in the \"/out\" directory !< @endnote program test_algen use omp_lib use sort_arrays , only : sort_array2 use data_arch , only : I4 , R8 , PI_R8 use miscellaneous , only : get_unit use pikaia_oop , only : pikaia_class implicit none integer ( kind = I4 ), parameter :: nn = 512 !! *Surface side dimension* real ( kind = R8 ), parameter :: SSK = - 0 1.0_R8 !! *Imposed surface height skewness* real ( kind = R8 ), parameter :: SKU = + 2 0.0_R8 !! *Imposed surface height kurtosis* integer ( kind = I4 ) :: status !! **PIKAIA** *status* integer ( kind = I4 ) :: i , j , k !! *loop indices* integer ( kind = I4 ) :: iu !! *i/o unit* integer ( kind = I4 ) :: nb_th !! *nb threads* real ( kind = R8 ), dimension ( 1 : 2 ) :: xx !! *chromosom for* **PIKAIA** real ( kind = R8 ), dimension ( 1 : 2 ) :: xl , xu !! *lower and upper bonds of xx* real ( kind = R8 ) :: f_xx !! *cost function or optimization function at* ```xx``` real ( kind = R8 ) :: tab_sur ( 1 : nn * nn ) !! *output surface heights* type moment_stat !! <span style=\"color:green\">Statistical moment type</span> real ( kind = R8 ) :: mu !! *mean* real ( kind = R8 ) :: va !! *variance* real ( kind = R8 ) :: si !! *standard deviation* real ( kind = R8 ) :: sk !! *skewness* real ( kind = R8 ) :: ku !! *kurtosis* endtype moment_stat type ( moment_stat ) :: mom !! *a statistical moment variable* type ( pikaia_class ) :: p !! **PIKAIA** *class instanciation* real ( kind = R8 ) :: f !! *best cost* real ( kind = R8 ) :: tstart , tend !! *time variables* !$ real(kind=R8)    :: ostart,oend    !! *openmp time variables* !$ integer(kind=I4) :: tid            !! *active thread* nb_th = 1 ! get the number of available threads !$OMP PARALLEL PRIVATE(nb_th, TID) !$ !$ tid = omp_get_thread_num() !$ !$ if (tid == 0) then !$    nb_th = omp_get_num_threads() !$    write(*,'(A)') '--------------' !$    write(*,'(A,1X,I5)') 'number of OMP threads: ', nb_th !$    write(*,'(A)') '--------------' !$ endif !$OMP END PARALLEL xx ( 1 : 2 ) = 0.0_R8 xl ( 1 : 2 ) = 0.0_R8 xu ( 1 : 2 ) = 1.0_R8 !initialize the class: call p % init ( n = 2 , & ! IN           ; the parameter space dimension, i.e., the number of adjustable parameters (size of the x vector). xl = xl , & ! IN, DIM(n)   ;  vector of lower bounds for x xu = xu , & ! IN, DIM(n)   ;  vector of upper bounds for x f = cost , & !              ; user-supplied scalar function of n variables, which must have the pikaia_func procedure interface. status = status , & ! OUT          ; status output flag (0 if there were no errors) !iter_f = report_iteration,    &  !     OPT      ; user-supplied subroutine that will report the best solution for each generation. It must have the iter_func procedure interface. np = 100 , & ! IN, OPT      ; number of individuals in a population (default is 100) ngen = 1000 , & ! IN, OPT      ; maximum number of iterations nd = 9 , & ! IN           ; number of significant digits (i.e., number of genes) retained in chromosomal encoding pcross = 0.85_R8 , & ! IN, OPT      ; crossover probability; must be <= 1.0 (default is 0.85). If crossover takes place, either one or two splicing points are used, with equal probabilities pmutmn = 0.0005_R8 , & ! IN, OPT      ; minimum mutation rate; must be >= 0.0 (default is 0.0005) pmutmx = 0.25_R8 , & ! IN, OPT      ; maximum mutation rate; must be <= 1.0 (default is 0.25) pmut = 0.005_R8 , & ! IN, OPT      ; initial mutation rate; should be small (default is 0.005) (Note: the mutation rate is the probability that any one gene locus will mutate in any one generation.) imut = 2 , & ! IN, OPT      ; mutation mode; 1/2/3/4/5 (default is 2). !              1=one-point mutation, fixed rate. !              2=one-point, adjustable rate based on fitness. !              3=one-point, adjustable rate based on distance. !              4=one-point+creep, fixed rate. !              5=one-point+creep, adjustable rate based on fitness. !              6=one-point+creep, adjustable rate based on distance. fdif = 1._R8 , & ! IN, OPT      ; relative fitness differential; range from 0 (none) to 1 (maximum). (default is 1.0) irep = 3 , & ! IN, OPT      ; reproduction plan; 1/2/3=Full generational replacement/Steady-state-replace-random/Steady- state-replace-worst (default is 3) ielite = 0 , & ! IN, OPT      ; elitism flag; 0/1=off/on (default is 0) (Applies only to reproduction plans 1 and 2) ivrb = 0 , & ! IN, OPT      ; printed output 0/1/2=None/Minimal/Verbose convergence_tol = 1.0e-6_R8 , & ! IN, OPT      ; convergence tolerance; must be > 0.0 (default is 0.0001) convergence_window = 200 , & ! IN, OPT      ; convergence window; must be >= 0 This is the number of consecutive solutions within the tolerance for convergence to be declared (default is 20) initial_guess_frac = 0.1_R8 , & ! IN, OPT      ; raction of the initial population to set equal to the initial guess. Range from 0 (none) to 1.0 (all). (default is 0.1 or 10%). iseed = 999 ) ! IN, OPT      ; random seed value; must be > 0 (default is 999) !Now call pikaia: call cpu_time ( tstart ) !$ ostart = omp_get_wtime() call p % solve ( x = xx ( 1 : 2 ), & ! INOUT, DIM(*) ; f = f , & !   OUT         ; status = status ) !,   &  !   OUT         ; !~                     omp = .false. )    ! IN, OPTIONAL !$ oend = omp_get_wtime() call cpu_time ( tend ) write ( * , * ) 'Total time spent: ' , tend - tstart write ( * , * ) 'Real time spent:  ' , oend - ostart write ( * , * ) 'Absolute diff after GA: ' , abs_diff_sk_ku ( chrom = xx ( 1 : 2 )) ! optimization function ran with this \"good\" solution call newton_raphson_downhill ( x = xx ( 1 : 2 ), & ! starting/ending point fvec = f_xx , & ! best deviation to the wanted solution eps = 1.e-6_R8 , & ! dx ndir = 32 * nb_th , & ! number of directions to explore rel = 0.9_R8 ) ! relaxation parameter write ( * , * ) 'Absolute diff after refinement: ' , abs_diff_sk_ku ( chrom = xx ( 1 : 2 )) write ( * , * ) 'A (nn x nn) SSK, SKU random surface will be now generated' ! generation of nn*nn heights with the tangent function with xx(1:2) as bound parameters. ! mu = 0. ! va = si = 1. ! sk = SSK ! ku = SKU call profil_theo_trie_1D ( tab = tab_sur ( 1 : nn * nn ), & ! resulting vector of heights lg = nn * nn , & ! vector length x = xx ( 1 : 2 ), & ! best variable couple mx = mom ) ! resulting moment ! height shuffle call melange ( tab = tab_sur ( 1 : nn * nn ), & ! lg = nn * nn ) ! ! random surface output in ascii format call get_unit ( iunit = iu ) open ( unit = iu , file = 'out/surf.dat' ) k = 1 do i = 1 , nn do j = 1 , nn write ( iu , * ) i , j , tab_sur ( k ) k = k + 1 enddo enddo close ( unit = iu ) ! statistical moments check write ( * , * ) 'statistical moments:' write ( * , * ) mom % mu , mom % si , mom % sk , mom % ku ! precision write ( * , '(a, e8.2)' ) 'maximum difference (%) ' , max ( 100 * abs (( mom % sk - SSK ) / SSK ), & ! 100 * abs (( mom % ku - SKU ) / SKU ) ) stop contains subroutine cost ( me , x , f ) implicit none class ( pikaia_class ), intent ( inout ) :: me real ( kind = R8 ) , intent ( in ), dimension (:) :: x real ( kind = R8 ) , intent ( out ) :: f f = 1. / ( 1. + abs_diff_sk_ku ( chrom = x ( 1 : 2 ))) return endsubroutine cost subroutine newton_raphson_downhill ( x , fvec , eps , ndir , rel ) implicit none integer ( kind = I4 ), intent ( in ) :: ndir real ( kind = R8 ), intent ( in ) :: eps real ( kind = R8 ), intent ( in ) :: rel real ( kind = R8 ), intent ( inout ), dimension ( 1 : 2 ) :: x real ( kind = R8 ), intent ( out ) :: fvec real ( kind = R8 ), dimension ( 1 : 2 ) :: x0 real ( kind = R8 ), dimension ( 1 : ndir ) :: ct , st , ff , x1 , x2 real ( kind = R8 ) :: f0 , fd1 , fd2 , ti , dfdx1 , dfdx2 , dx1 , dx2 , dt integer ( kind = I4 ) :: i do i = 1 , ndir ti = PI_R8 * ( - 1. + ( i - 1 ) * 2. / ndir ) ct ( i ) = cos ( ti ) st ( i ) = sin ( ti ) enddo x0 = x do f0 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) / )) fd1 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) + eps , x0 ( 2 ) / )) fd2 = abs_diff_sk_ku ( chrom = ( / x0 ( 1 ) , x0 ( 2 ) + eps / )) dfdx1 = ( fd1 - f0 ) / eps dfdx2 = ( fd2 - f0 ) / eps !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_th) !$OMP DO PRIVATE(i, dt, dx1, dx2) do i = 1 , ndir dt = - f0 / ( eps * ( dfdx1 * ct ( i ) + dfdx2 * st ( i )) ) dx1 = eps * ct ( i ) * dt dx2 = eps * st ( i ) * dt x1 ( i ) = x0 ( 1 ) + rel * dx1 x2 ( i ) = x0 ( 2 ) + rel * dx2 ff ( i ) = abs_diff_sk_ku ( chrom = ( / x1 ( i ), x2 ( i ) / )) enddo !$OMP END DO !$OMP END PARALLEL i = minloc ( ff , 1 ) x0 = ( / x1 ( i ), x2 ( i ) / ) if ( ff ( i ) < 1.e-8 ) exit write ( * , * ) x0 ( 1 ), x0 ( 2 ), ff ( i ) enddo x = x0 fvec = ff ( i ) return endsubroutine newton_raphson_downhill real ( kind = R8 ) function abs_diff_sk_ku ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: chrom real ( kind = R8 ) :: sk , ku call sk_ku ( xx = chrom ( 1 : 2 ), sk = sk , ku = ku ) abs_diff_sk_ku = abs ( sk - SSK ) + abs ( ku - SKU ) return endfunction abs_diff_sk_ku real ( kind = R8 ) function cost_func ( chrom ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: chrom cost_func = 1. / ( 1. + abs_diff_sk_ku ( chrom ( 1 : 2 ))) return endfunction cost_func subroutine sk_ku ( xx , sk , ku ) implicit none real ( kind = R8 ), intent ( in ), dimension ( 1 : 2 ) :: xx real ( kind = R8 ), intent ( out ) :: sk real ( kind = R8 ), intent ( out ) :: ku real ( kind = R8 ) :: xa , xb , mu , si , a , b , un real ( kind = R8 ) :: h , hh , b1 , b2 , alp , bet integer ( kind = I4 ) :: ia , ib , deb , fin , npts , long , i , k real ( kind = R8 ), dimension ( 1 : 2 ) :: x long = nn do k = 1 , 2 x ( k ) = max ( xx ( k ), 1.e-4_R8 ) enddo ia = long ib = long npts = long * long deb = 1 + ia fin = npts - ib a = x ( 1 ) b = x ( 2 ) hh = ( 2._R8 - a - b ) / ( npts - 1 ) h = ( pi_R8 / 2 ) * hh xa = a + ia * hh xb = b + ib * hh b1 = - pi_R8 / 2 * ( 1. - a ) b2 = + pi_R8 / 2 * ( 1. - b ) alp = - ( b2 - npts * b1 ) / ( b2 - b1 ) bet = ( npts - 1 ) / ( b2 - b1 ) un = 1._R8 !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . mu = log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * sin (( pi_R8 * xa ) / 2. )) mu = ( un / h ) * mu + add_tang ( 1 , deb , fin , alp , bet , mu = 0._R8 , si = 1._R8 ) do i = 1 , ia - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 mu = mu + tang ( i * un , 1 , alp , bet , mu = 0._R8 , si = 1._R8 ) enddo mu = mu / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . si = ( pi_R8 * ( - 2 + xa + xb )) / 2. - ( mu ** 2 * pi_R8 * ( - 2 + xa + xb )) / 2. + 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 2 * mu * Log ( 1._R8 / sin (( pi_R8 * xb ) / 2. ) * Sin (( pi_R8 * xa ) / 2. )) si = ( un / h ) * si + add_tang ( 2 , deb , fin , alp , bet , mu , si = 1._R8 ) do i = 1 , ia - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo do i = npts , npts - ( ib - 2 ), - 1 si = si + tang ( i * un , 2 , alp , bet , mu , si = 1._R8 ) enddo si = si / npts si = sqrt ( si ) !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . sk = ( 6 * mu * pi_R8 - 2 * mu ** 3 * pi_R8 - 3 * mu * pi_R8 * xa + mu ** 3 * pi_R8 * xa - 3 * mu * pi_R8 * xb + mu ** 3 * pi_R8 * xb - 6 * mu * 1._R8 / tan (( pi_R8 * xa ) / 2. ) - 6 * mu * 1._R8 / tan (( pi_R8 * xb ) / 2. ) - 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 - 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 6 * mu ** 2 * Log ( Sin (( pi_R8 * xa ) / 2. )) + 2 * Log ( Sin (( pi_R8 * xb ) / 2. )) - 6 * mu ** 2 * Log ( Sin (( pi_R8 * xb ) / 2. ))) / ( 2. * si ** 3 ) sk = ( un / h ) * sk + add_tang ( 3 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 sk = sk + tang ( i * un , 3 , alp , bet , mu , si ) enddo sk = sk / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . ku = ( 6 * pi_R8 - 36 * mu ** 2 * pi_R8 + 6 * mu ** 4 * pi_R8 - 3 * pi_R8 * xa + 18 * mu ** 2 * pi_R8 * xa - 3 * mu ** 4 * pi_R8 * xa - 3 * pi_R8 * xb + 18 * mu ** 2 * pi_R8 * xb - 3 * mu ** 4 * pi_R8 * xb + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xa ) / 2. ) + 4 * ( - 2 + 9 * mu ** 2 ) * 1._R8 / tan (( pi_R8 * xb ) / 2. ) + 12 * mu * 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 2 - 12 * mu * 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 2 + 24 * mu * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu ** 3 * Log ( Sin (( pi_R8 * xa ) / 2. )) - 24 * mu * Log ( Sin (( pi_R8 * xb ) / 2. )) + 24 * mu ** 3 * Log ( Sin (( pi_R8 * xb ) / 2. )) + 1._R8 / sin (( pi_R8 * xa ) / 2. ) ** 4 * Sin ( pi_R8 * xa ) + 1._R8 / sin (( pi_R8 * xb ) / 2. ) ** 4 * Sin ( pi_R8 * xb )) / ( 6. * si ** 4 ) ku = ( un / h ) * ku + add_tang ( 4 , deb , fin , alp , bet , mu , si ) do i = 1 , ia - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo do i = npts , npts - ( ib - 2 ), - 1 ku = ku + tang ( i * un , 4 , alp , bet , mu , si ) enddo ku = ku / npts !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . return endsubroutine sk_ku real ( kind = R8 ) function add_tang ( n , deb , fin , alp , bet , mu , si ) implicit none real ( kind = R8 ), intent ( in ) :: alp , bet , mu , si integer ( kind = i4 ), intent ( in ) :: n , fin , deb real ( kind = R8 ) :: xdeb , xfin xdeb = deb xfin = fin add_tang = ( 1. / 12 ) * ( + 9 * ( tang ( xdeb + 0.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.0_R8 , n , alp , bet , mu , si )) & + 1 * ( tang ( xdeb + 1.0_R8 , n , alp , bet , mu , si ) + tang ( xfin - 1.0_R8 , n , alp , bet , mu , si )) & - 4 * ( tang ( xdeb + 0.5_R8 , n , alp , bet , mu , si ) + tang ( xfin - 0.5_R8 , n , alp , bet , mu , si )) ) return endfunction add_tang real ( kind = R8 ) function tang ( xi , n , alp , bet , mu , si ) implicit none real ( kind = R8 ), intent ( in ) :: xi , alp , bet , mu , si integer ( kind = i4 ), intent ( in ) :: n real ( kind = R8 ) :: tmp tmp = ( xi + alp ) / bet tang = ( ( tan ( tmp ) - mu ) / si ) ** n return endfunction tang subroutine calc_moments_1D ( tab , mx , nb_mom , lg ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg integer ( kind = I4 ) , intent ( in ) :: nb_mom real ( kind = R8 ) , intent ( in ), dimension ( 1 : lg ) :: tab type ( moment_stat ), intent ( out ) :: mx integer ( kind = I4 ) :: i real ( kind = R8 ) :: tmp mx % mu = 0 mx % si = 0 mx % va = 0 mx % Sk = 0 mx % Ku = 0 do i = 1 , lg mx % mu = mx % mu + tab ( i ) / lg enddo if ( nb_mom == 1 ) return do i = 1 , lg mx % va = mx % va + (( tab ( i ) - mx % mu ) ** 2 ) / lg enddo mx % si = sqrt ( mx % va ) if ( nb_mom == 2 ) return if ( mx % si < 1.e-15_R8 ) then mx % Sk = 0 mx % Ku = 0 else do i = 1 , lg tmp = ( tab ( i ) - mx % mu ) / mx % si mx % Sk = mx % Sk + ( tmp ** 3 ) / lg mx % Ku = mx % Ku + ( tmp ** 4 ) / lg enddo endif return endsubroutine calc_moments_1D subroutine profil_theo_trie_1D ( tab , lg , x , mx ) implicit none integer ( kind = I4 ) , intent ( in ) :: lg real ( kind = R8 ) , intent ( out ), dimension ( 1 : lg ) :: tab real ( kind = R8 ) , intent ( in ), dimension ( 1 : 2 ) :: x type ( moment_stat ), intent ( out ) :: mx real ( kind = R8 ) :: b1 , b2 , alp , bet integer ( kind = I4 ) :: i b1 = - PI_R8 / 2 * ( 1. - x ( 1 )) b2 = + PI_R8 / 2 * ( 1. - x ( 2 )) alp = - ( b2 - lg * b1 ) / ( b2 - b1 ) bet = ( lg - 1 ) / ( b2 - b1 ) do i = 1 , lg tab ( i ) = tan ( ( i + alp ) / bet ) enddo call calc_moments_1D ( tab , mx , nb_mom = 4 , lg = lg ) tab ( 1 : lg ) = ( tab ( 1 : lg ) - mx % mu ) / mx % si mx % mu = 0._R8 mx % si = 1._R8 return endsubroutine profil_theo_trie_1D subroutine melange ( tab , lg ) implicit none integer ( kind = i4 ), intent ( in ) :: lg real ( kind = r8 ) , intent ( inout ), dimension ( 1 : lg ) :: tab real ( kind = r8 ), dimension ( 1 : lg ) :: tmp integer ( kind = i4 ) :: i call random_number ( harvest = tmp ) call sort_array2 ( tab_inout = tmp ( 1 : lg ), & ! tab1 = tab ( 1 : lg ), n = lg ) ! return endsubroutine melange endprogram test_algen","tags":"","loc":"sourcefile/prg.f90~6.html"},{"title":"umfpack.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~umfpack.f90~~AfferentGraph sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< @note !< UMFPACK Fortran interface via the mUMFPACK module !< Version 1.0 (Apr 23, 2014) for UMFPACK version 5.6.2 !< Compile with any Fortran compiler with support of iso_c_binding module !< and link with the UMFPACK C library: !< e.g., gfortran umfpack.f90 my_code.f90 -lumfpack !< @endnote module mumfpack use iso_c_binding implicit none ! private size constants integer , parameter , private :: i4 = 4 , & ! size of default integer i8 = 8 , & ! size of long integer ip = c_intptr_t , & ! size of pointers used in basic Fortran wrappers r4 = 4 , & ! size of single precision real/complex r8 = 8 ! size of double precision real/complex ! default pointers to UMFPACK Symbolic and Numeric objects type ( c_ptr ), private :: iSymbolic = c_null_ptr , iNumeric = c_null_ptr ! ====================================================================== ! UMFPACK constants ! ====================================================================== ! size of Info and Control arrays integer , parameter :: UMFPACK_INFO = 90 , & UMFPACK_CONTROL = 20 ! Version, copyright, and license character ( 30 ), parameter :: UMFPACK_VERSION = \"UMFPACK V5.6.2 (Apr 25, 2013)\" character ( 79 ), parameter :: UMFPACK_COPYRIGHT = \"UMFPACK:  Copyright (c) 2005-2012 by Timothy A. Davis.  All Rights Reserved.\" character ( 12 ), parameter :: UMFPACK_DATE = \"Apr 25, 2013\" integer , parameter :: UMFPACK_MAIN_VERSION = 5 , & UMFPACK_SUB_VERSION = 6 , & UMFPACK_SUBSUB_VERSION = 2 ! UMFPACK_VER_CODE(main,sub) ((main) * 1000 + (sub)) ! UMFPACK_VER UMFPACK_VER_CODE(UMFPACK_MAIN_VERSION,UMFPACK_SUB_VERSION) ! contents of Info enum , bind ( c ) enumerator :: & ! returned by all routines that use Info: UMFPACK_STATUS = 0 , & ! /* UMFPACK_OK, or other result */ UMFPACK_NROW = 1 , & ! /* n_row input value */ UMFPACK_NCOL = 16 , & ! /* n_col input value */ UMFPACK_NZ = 2 , & ! /* # of entries in A */ ! computed in UMFPACK_*symbolic and UMFPACK_numeric: UMFPACK_SIZE_OF_UNIT = 3 , & ! /* sizeof (Unit) */ ! computed in UMFPACK_*symbolic: UMFPACK_SIZE_OF_INT = 4 , & ! /* sizeof (int) */ UMFPACK_SIZE_OF_LONG = 5 , & ! /* sizeof (SuiteSparse_long) */ UMFPACK_SIZE_OF_POINTER = 6 , & ! /* sizeof (void *) */ UMFPACK_SIZE_OF_ENTRY = 7 , & ! /* sizeof (Entry), real or complex */ UMFPACK_NDENSE_ROW = 8 , & ! /* number of dense rows */ UMFPACK_NEMPTY_ROW = 9 , & ! /* number of empty rows */ UMFPACK_NDENSE_COL = 10 , & ! /* number of dense rows */ UMFPACK_NEMPTY_COL = 11 , & ! /* number of empty rows */ UMFPACK_SYMBOLIC_DEFRAG = 12 , & ! /* # of memory compactions */ UMFPACK_SYMBOLIC_PEAK_MEMORY = 13 , & ! /* memory used by symbolic analysis */ UMFPACK_SYMBOLIC_SIZE = 14 , & ! /* size of Symbolic object, in Units */ UMFPACK_SYMBOLIC_TIME = 15 , & ! /* time (sec.) for symbolic analysis */ UMFPACK_SYMBOLIC_WALLTIME = 17 , & ! /* wall clock time for sym. analysis */ UMFPACK_STRATEGY_USED = 18 , & ! /* strategy used: sym, unsym */ UMFPACK_ORDERING_USED = 19 , & ! /* ordering used: colamd, amd, given */ UMFPACK_QFIXED = 31 , & ! /* whether Q is fixed or refined */ UMFPACK_DIAG_PREFERRED = 32 , & ! /* whether diagonal pivoting attempted*/ UMFPACK_PATTERN_SYMMETRY = 33 , & ! /* symmetry of pattern of S */ UMFPACK_NZ_A_PLUS_AT = 34 , & ! /* nnz (S+S'), excl. diagonal */ UMFPACK_NZDIAG = 35 , & ! /* nnz (diag (S)) */ ! AMD statistics, computed in UMFPACK_*symbolic: UMFPACK_SYMMETRIC_LUNZ = 36 , & ! /* nz in L+U, if AMD ordering used */ UMFPACK_SYMMETRIC_FLOPS = 37 , & ! /* flops for LU, if AMD ordering used */ UMFPACK_SYMMETRIC_NDENSE = 38 , & ! /* # of \"dense\" rows/cols in S+S' */ UMFPACK_SYMMETRIC_DMAX = 39 , & ! /* max nz in cols of L, for AMD */ ! 51:55 unused ! statistics for singleton pruning UMFPACK_COL_SINGLETONS = 56 , & ! /* # of column singletons */ UMFPACK_ROW_SINGLETONS = 57 , & ! /* # of row singletons */ UMFPACK_N2 = 58 , & ! /* size of S */ UMFPACK_S_SYMMETRIC = 59 , & ! /* 1 if S square and symmetricly perm.*/ ! estimates computed in UMFPACK_*symbolic: UMFPACK_NUMERIC_SIZE_ESTIMATE = 20 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY_ESTIMATE = 21 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS_ESTIMATE = 22 , & ! /* flop count */ UMFPACK_LNZ_ESTIMATE = 23 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ_ESTIMATE = 24 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT_ESTIMATE = 25 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK_ESTIMATE = 26 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL_ESTIMATE = 27 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE_ESTIMATE = 28 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS_ESTIMATE = 29 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS_ESTIMATE = 30 , & ! /* max # columns in any front */ ! exact values, (estimates shown above) computed in UMFPACK_numeric: UMFPACK_NUMERIC_SIZE = 40 , & ! /* final size of Numeric->Memory */ UMFPACK_PEAK_MEMORY = 41 , & ! /* for symbolic & numeric */ UMFPACK_FLOPS = 42 , & ! /* flop count */ UMFPACK_LNZ = 43 , & ! /* nz in L, incl. diagonal */ UMFPACK_UNZ = 44 , & ! /* nz in U, incl. diagonal */ UMFPACK_VARIABLE_INIT = 45 , & ! /* initial size of Numeric->Memory*/ UMFPACK_VARIABLE_PEAK = 46 , & ! /* peak size of Numeric->Memory */ UMFPACK_VARIABLE_FINAL = 47 , & ! /* final size of Numeric->Memory */ UMFPACK_MAX_FRONT_SIZE = 48 , & ! /* max frontal matrix size */ UMFPACK_MAX_FRONT_NROWS = 49 , & ! /* max # rows in any front */ UMFPACK_MAX_FRONT_NCOLS = 50 , & ! /* max # columns in any front */ ! computed in UMFPACK_numeric: UMFPACK_NUMERIC_DEFRAG = 60 , & ! /* # of garbage collections */ UMFPACK_NUMERIC_REALLOC = 61 , & ! /* # of memory reallocations */ UMFPACK_NUMERIC_COSTLY_REALLOC = 62 , & ! /* # of costlly memory realloc's */ UMFPACK_COMPRESSED_PATTERN = 63 , & ! /* # of integers in LU pattern */ UMFPACK_LU_ENTRIES = 64 , & ! /* # of reals in LU factors */ UMFPACK_NUMERIC_TIME = 65 , & ! /* numeric factorization time */ UMFPACK_UDIAG_NZ = 66 , & ! /* nz on diagonal of U */ UMFPACK_RCOND = 67 , & ! /* est. reciprocal condition # */ UMFPACK_WAS_SCALED = 68 , & ! /* none, max row, or sum row */ UMFPACK_RSMIN = 69 , & ! /* min (max row) or min (sum row) */ UMFPACK_RSMAX = 70 , & ! /* max (max row) or max (sum row) */ UMFPACK_UMIN = 71 , & ! /* min abs diagonal entry of U */ UMFPACK_UMAX = 72 , & ! /* max abs diagonal entry of U */ UMFPACK_ALLOC_INIT_USED = 73 , & ! /* alloc_init parameter used */ UMFPACK_FORCED_UPDATES = 74 , & ! /* # of forced updates */ UMFPACK_NUMERIC_WALLTIME = 75 , & ! /* numeric wall clock time */ UMFPACK_NOFF_DIAG = 76 , & ! /* number of off-diagonal pivots */ UMFPACK_ALL_LNZ = 77 , & ! /* nz in L, if no dropped entries */ UMFPACK_ALL_UNZ = 78 , & ! /* nz in U, if no dropped entries */ UMFPACK_NZDROPPED = 79 , & ! /* # of dropped small entries */ ! computed in UMFPACK_solve: UMFPACK_IR_TAKEN = 80 , & ! /* # of iterative refinement steps taken */ UMFPACK_IR_ATTEMPTED = 81 , & ! /* # of iter. refinement steps attempted */ UMFPACK_OMEGA1 = 82 , & ! /* omega1, sparse backward error estimate */ UMFPACK_OMEGA2 = 83 , & ! /* omega2, sparse backward error estimate */ UMFPACK_SOLVE_FLOPS = 84 , & ! /* flop count for solve */ UMFPACK_SOLVE_TIME = 85 , & ! /* solve time (seconds) */ UMFPACK_SOLVE_WALLTIME = 86 ! /* solve time (wall clock, seconds) */ ! Info(87,88,89) unused ! Unused parts of Info may be used in future versions of UMFPACK. end enum ! contents of Control enum , bind ( c ) enumerator :: & ! used in all UMFPACK_report_* routines: UMFPACK_PRL = 0 , & ! /* print level */ ! used in UMFPACK_*symbolic only: UMFPACK_DENSE_ROW = 1 , & ! /* dense row parameter */ UMFPACK_DENSE_COL = 2 , & ! /* dense col parameter */ UMFPACK_BLOCK_SIZE = 4 , & ! /* BLAS-3 block size */ UMFPACK_STRATEGY = 5 , & ! /* auto, symmetric, or unsym. */ UMFPACK_ORDERING = 10 , & ! /* ordering method to use */ UMFPACK_FIXQ = 13 , & ! /* -1: no fixQ, 0: default, 1: fixQ */ UMFPACK_AMD_DENSE = 14 , & ! /* for AMD ordering */ UMFPACK_AGGRESSIVE = 19 , & ! /* whether or not to use aggressive */ UMFPACK_SINGLETONS = 11 , & ! /* singleton filter on if true */ ! used in UMFPACK_*numeric only: UMFPACK_PIVOT_TOLERANCE = 3 , & ! /* threshold partial pivoting setting */ UMFPACK_ALLOC_INIT = 6 , & ! /* initial allocation ratio */ UMFPACK_SYM_PIVOT_TOLERANCE = 15 , & ! /* threshold, only for diag. entries */ UMFPACK_SCALE = 16 , & ! /* what row scaling to do */ UMFPACK_FRONT_ALLOC_INIT = 17 , & ! /* frontal matrix allocation ratio */ UMFPACK_DROPTOL = 18 , & ! /* drop tolerance for entries in L,U */ ! used in UMFPACK_*solve only: UMFPACK_IRSTEP = 7 , & ! /* max # of iterative refinements */ ! compile-time settings - Control(8:11) cannot be changed at run time: UMFPACK_COMPILED_WITH_BLAS = 8 ! /* uses the BLAS */ end enum ! /* 9,12: unused */ ! Control(UMFPACK_STRATEGY) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_STRATEGY_AUTO = 0 , & ! /* use sym. or unsym. strategy */ UMFPACK_STRATEGY_UNSYMMETRIC , & ! /* COLAMD(A), coletree postorder, not prefer diag*/ UMFPACK_STRATEGY_OBSOLETE , & ! /* 2-by-2 is no longer available */ UMFPACK_STRATEGY_SYMMETRIC ! /* AMD(A+A'), no coletree postorder, prefer diagonal */ end enum ! Control(UMFPACK_SCALE) is one of the following: enum , bind ( c ) ; enumerator :: & UMFPACK_SCALE_NONE = 0 , & ! /* no scaling */ UMFPACK_SCALE_SUM , & ! /* default: divide each row by sum (abs (row))*/ UMFPACK_SCALE_MAX ! /* divide each row by max (abs (row)) */ end enum ! Control(UMFPACK_ORDERING) and Info(UMFPACK_ORDERING_USED) are one of: enum , bind ( c ) ; enumerator :: & UMFPACK_ORDERING_CHOLMOD = 0 , & ! /* use CHOLMOD (AMD/COLAMD then METIS)*/ UMFPACK_ORDERING_AMD , & ! /* use AMD/COLAMD */ UMFPACK_ORDERING_GIVEN , & ! /* user-provided Qinit */ UMFPACK_ORDERING_METIS , & ! /* use METIS */ UMFPACK_ORDERING_BEST , & ! /* try many orderings, pick best */ UMFPACK_ORDERING_NONE , & ! /* natural ordering */ UMFPACK_ORDERING_USER ! /* user-provided function */ ! /* AMD/COLAMD means: use AMD for symmetric strategy, COLAMD for unsymmetric */ end enum ! status codes enum , bind ( c ) ; enumerator :: & UMFPACK_OK = 0 , & ! /* status > 0 means a warning, but the method was successful anyway. */ ! /* A Symbolic or Numeric object was still created. */ UMFPACK_WARNING_singular_matrix = 1 , & ! /* The following warnings were added in umfpack_*_get_determinant */ UMFPACK_WARNING_determinant_underflow = 2 , & UMFPACK_WARNING_determinant_overflow = 3 , & ! /* status < 0 means an error, and the method was not successful. */ ! /* No Symbolic of Numeric object was created. */ UMFPACK_ERROR_out_of_memory =- 1 , & UMFPACK_ERROR_invalid_Numeric_object =- 3 , & UMFPACK_ERROR_invalid_Symbolic_object =- 4 , & UMFPACK_ERROR_argument_missing =- 5 , & UMFPACK_ERROR_n_nonpositive =- 6 , & UMFPACK_ERROR_invalid_matrix =- 8 , & UMFPACK_ERROR_different_pattern =- 11 , & UMFPACK_ERROR_invalid_system =- 13 , & UMFPACK_ERROR_invalid_permutation =- 15 , & UMFPACK_ERROR_internal_error =- 911 , & ! /* yes, call me if you get this! */ UMFPACK_ERROR_file_IO =- 17 , & UMFPACK_ERROR_ordering_failed =- 18 end enum ! solve codes ! /* Solve the system ( )x=b, where ( ) is defined below.  \"t\" refers to the */ ! /* linear algebraic transpose (complex conjugate if A is complex), or the (') */ ! /* operator in MATLAB.  \"at\" refers to the array transpose, or the (.') */ ! /* operator in MATLAB. */ enum , bind ( c ) ; enumerator :: & UMFPACK_A = 0 , & ! /* Ax=b    */ UMFPACK_At = 1 , & ! /* A'x=b   */ UMFPACK_Aat = 2 , & ! /* A.'x=b  */ UMFPACK_Pt_L = 3 , & ! /* P'Lx=b  */ UMFPACK_L = 4 , & ! /* Lx=b    */ UMFPACK_Lt_P = 5 , & ! /* L'Px=b  */ UMFPACK_Lat_P = 6 , & ! /* L.'Px=b */ UMFPACK_Lt = 7 , & ! /* L'x=b   */ UMFPACK_Lat = 8 , & ! /* L.'x=b  */ UMFPACK_U_Qt = 9 , & ! /* UQ'x=b  */ UMFPACK_U = 10 , & ! /* Ux=b    */ UMFPACK_Q_Ut = 11 , & ! /* QU'x=b  */ UMFPACK_Q_Uat = 12 , & ! /* QU.'x=b */ UMFPACK_Ut = 13 , & ! /* U'x=b   */ UMFPACK_Uat = 14 ! /* U.'x=b  */ end enum ! ====================================================================== ! Full UMFPACK interface: interfaces to C functions ! ====================================================================== interface ! int umfpack_di_symbolic(int n_row,int n_col,const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void **Symbolic,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) bind ( c , name = 'umfpack_di_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) bind ( c , name = 'umfpack_zi_symbolic' ) import c_int , c_ptr integer ( c_int ), value :: n_row , n_col type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ) :: Symbolic type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_numeric(const int Ap [ ],const int Ai [ ],const double Ax [ ], ! void *Symbolic,void **Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_numeric' ) import c_int , c_ptr type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value , intent ( in ) :: Symbolic type ( c_ptr ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! int umfpack_di_solve(int sys,const int Ap [ ],const int Ai [ ],const double Ax [ ],double X [ ],const double B [ ], ! void *Numeric,const double Control [UMFPACK_CONTROL],double Info [UMFPACK_INFO]) ; integer ( c_int ) function c_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) bind ( c , name = 'umfpack_di_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function integer ( c_int ) function c_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) bind ( c , name = 'umfpack_zi_solve' ) import c_int , c_ptr integer ( c_int ), value :: sys type ( c_ptr ), value , intent ( in ) :: Ap , Ai type ( c_ptr ), value , intent ( in ) :: Ax , Az type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric type ( c_ptr ), value :: Control , Info end function ! void umfpack_di_free_symbolic(void **Symbolic) ; subroutine c_umfpack_di_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_di_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine subroutine c_umfpack_zi_free_symbolic ( Symbolic ) bind ( c , name = 'umfpack_zi_free_symbolic' ) import c_ptr type ( c_ptr ) :: Symbolic end subroutine ! void umfpack_di_free_numeric(void **Numeric) ; subroutine c_umfpack_di_free_numeric ( Numeric ) bind ( c , name = 'umfpack_di_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine subroutine c_umfpack_zi_free_numeric ( Numeric ) bind ( c , name = 'umfpack_zi_free_numeric' ) import c_ptr type ( c_ptr ) :: Numeric end subroutine ! void umfpack_di_defaults(double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_defaults ( Control ) bind ( c , name = 'umfpack_di_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_defaults ( Control ) bind ( c , name = 'umfpack_zi_defaults' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! int umfpack_di_scale(double X [ ],const double B [ ],void *Numeric) ; integer ( c_int ) function c_umfpack_di_scale ( X , B , Numeric ) bind ( c , name = 'umfpack_di_scale' ) import c_int , c_ptr type ( c_ptr ), value :: X type ( c_ptr ), value , intent ( in ) :: B type ( c_ptr ), value , intent ( in ) :: Numeric end function integer ( c_int ) function c_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) bind ( c , name = 'umfpack_zi_scale' ) import c_int , c_ptr type ( c_ptr ), value :: Xx , Xz type ( c_ptr ), value , intent ( in ) :: Bx , Bz type ( c_ptr ), value , intent ( in ) :: Numeric end function ! int umfpack_di_save_numeric(void *Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_save_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_save_symbolic(void *Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_save_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_save_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ), value :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_numeric(void **Numeric,char *filename) ; integer ( c_int ) function c_umfpack_di_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_di_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_numeric ( Numeric , filename ) bind ( c , name = 'umfpack_zi_load_numeric' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Numeric character ( 1 , c_char ) :: filename ( * ) end function ! int umfpack_di_load_symbolic(void **Symbolic,char *filename) ; integer ( c_int ) function c_umfpack_di_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_di_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function integer ( c_int ) function c_umfpack_zi_load_symbolic ( Symbolic , filename ) bind ( c , name = 'umfpack_zi_load_symbolic' ) import c_int , c_ptr , c_char type ( c_ptr ) :: Symbolic character ( 1 , c_char ) :: filename ( * ) end function ! void umfpack_di_report_status(const double Control [UMFPACK_CONTROL],int status) ; subroutine c_umfpack_di_report_status ( Control , status ) bind ( c , name = 'umfpack_di_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine subroutine c_umfpack_zi_report_status ( Control , status ) bind ( c , name = 'umfpack_zi_report_status' ) import c_ptr , c_int type ( c_ptr ), value :: Control integer ( c_int ), value :: status end subroutine ! void umfpack_di_report_control(const double Control [UMFPACK_CONTROL]) ; subroutine c_umfpack_di_report_control ( Control ) bind ( c , name = 'umfpack_di_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine subroutine c_umfpack_zi_report_control ( Control ) bind ( c , name = 'umfpack_zi_report_control' ) import c_ptr type ( c_ptr ), value :: Control end subroutine ! void umfpack_di_report_info(const double Control [UMFPACK_CONTROL],const double Info [UMFPACK_INFO]) ; subroutine c_umfpack_di_report_info ( Control , Info ) bind ( c , name = 'umfpack_di_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine subroutine c_umfpack_zi_report_info ( Control , Info ) bind ( c , name = 'umfpack_zi_report_info' ) import c_ptr type ( c_ptr ), value :: Control , Info end subroutine ! int umfpack_di_report_numeric(void *Numeric,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_di_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function integer ( c_int ) function c_umfpack_zi_report_numeric ( Numeric , Control ) bind ( c , name = 'umfpack_zi_report_numeric' ) import c_int , c_ptr type ( c_ptr ), value :: Numeric , Control end function ! int umfpack_di_report_symbolic(void *Symbolic,const double Control [UMFPACK_CONTROL]) ; integer ( c_int ) function c_umfpack_di_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_di_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function integer ( c_int ) function c_umfpack_zi_report_symbolic ( Symbolic , Control ) bind ( c , name = 'umfpack_zi_report_symbolic' ) import c_int , c_ptr type ( c_ptr ), value :: Symbolic , Control end function end interface ! ====================================================================== ! Full UMFPACK interface: overloaded names ! ====================================================================== interface umfpack_zi_symbolic module procedure umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_zi_symbolic module procedure s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_symbolic module procedure umfpack_di_symbolic , umfpack_zi_symbolic , umfpack_ci_symbolic end interface interface s_umfpack_symbolic module procedure s_umfpack_di_symbolic , s_umfpack_zi_symbolic , s_umfpack_ci_symbolic end interface interface umfpack_zi_numeric module procedure umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_zi_numeric module procedure s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_numeric module procedure umfpack_di_numeric , umfpack_zi_numeric , umfpack_ci_numeric end interface interface s_umfpack_numeric module procedure s_umfpack_di_numeric , s_umfpack_zi_numeric , s_umfpack_ci_numeric end interface interface umfpack_zi_solve module procedure umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_zi_solve module procedure s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface umfpack_solve module procedure umfpack_di_solve , umfpack_zi_solve , umfpack_ci_solve end interface interface s_umfpack_solve module procedure s_umfpack_di_solve , s_umfpack_zi_solve , s_umfpack_ci_solve end interface interface s_umfpack_free_symbolic module procedure umfpack_free_symbolic end interface interface s_umfpack_di_free_symbolic module procedure umfpack_di_free_symbolic end interface interface s_umfpack_zi_free_symbolic module procedure umfpack_zi_free_symbolic end interface interface s_umfpack_free_numeric module procedure umfpack_free_numeric end interface interface s_umfpack_di_free_numeric module procedure umfpack_di_free_numeric end interface interface s_umfpack_zi_free_numeric module procedure umfpack_zi_free_numeric end interface interface s_umfpack_defaults module procedure umfpack_defaults end interface interface s_umfpack_di_defaults module procedure umfpack_di_defaults end interface interface s_umfpack_zi_defaults module procedure umfpack_zi_defaults end interface ! a conflict with the constant UMFPACK_SCALE interface umfpack_zi_scale module procedure umfpack_zi_scale , umfpack_ci_scale end interface interface umfpack_scale_function module procedure umfpack_di_scale , umfpack_zi_scale , umfpack_ci_scale end interface interface s_umfpack_zi_scale module procedure s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_scale module procedure s_umfpack_di_scale , s_umfpack_zi_scale , s_umfpack_ci_scale end interface interface s_umfpack_report_control module procedure umfpack_report_control end interface interface s_umfpack_di_report_control module procedure umfpack_di_report_control end interface interface s_umfpack_zi_report_control module procedure umfpack_zi_report_control end interface interface s_umfpack_report_info module procedure umfpack_report_info end interface interface s_umfpack_di_report_info module procedure umfpack_di_report_info end interface interface s_umfpack_zi_report_info module procedure umfpack_zi_report_info end interface ! ====================================================================== ! Basic UMFPACK interface: overloaded names ! ====================================================================== interface umf4csym module procedure umf4csym , umf4csym_ip end interface interface umf4zsym module procedure umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4sym module procedure umf4sym , umf4sym_ip , umf4zsym , umf4zsym_ip , umf4csym , umf4csym_ip end interface interface umf4cnum module procedure umf4cnum , umf4cnum_ip end interface interface umf4znum module procedure umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4num module procedure umf4num , umf4num_ip , umf4znum , umf4znum_ip , umf4cnum , umf4cnum_ip end interface interface umf4csolr module procedure umf4csolr , umf4csolr_ip end interface interface umf4zsolr module procedure umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4solr module procedure umf4solr , umf4solr_ip , umf4zsolr , umf4zsolr_ip , umf4csolr , umf4csolr_ip end interface interface umf4csol module procedure umf4csol , umf4csol_ip end interface interface umf4zsol module procedure umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4sol module procedure umf4sol , umf4sol_ip , umf4zsol , umf4zsol_ip , umf4csol , umf4csol_ip end interface interface umf4cscal module procedure umf4cscal , umf4cscal_ip end interface interface umf4zscal module procedure umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4scal module procedure umf4scal , umf4scal_ip , umf4zscal , umf4zscal_ip , umf4cscal , umf4cscal_ip end interface interface umf4cfnum module procedure umf4cfnum , umf4cfnum_ip end interface interface umf4zfnum module procedure umf4zfnum , umf4zfnum_ip end interface interface umf4fnum module procedure umf4fnum , umf4fnum_ip end interface interface umf4cfsym module procedure umf4cfsym , umf4cfsym_ip end interface interface umf4zfsym module procedure umf4zfsym , umf4zfsym_ip end interface interface umf4fsym module procedure umf4fsym , umf4fsym_ip end interface interface umf4csnum module procedure umf4csnum , umf4csnum_ip end interface interface umf4zsnum module procedure umf4zsnum , umf4zsnum_ip end interface interface umf4snum module procedure umf4snum , umf4snum_ip end interface interface umf4cssym module procedure umf4cssym , umf4cssym_ip end interface interface umf4zssym module procedure umf4zssym , umf4zssym_ip end interface interface umf4ssym module procedure umf4ssym , umf4ssym_ip end interface interface umf4clnum module procedure umf4clnum , umf4clnum_ip end interface interface umf4zlnum module procedure umf4zlnum , umf4zlnum_ip end interface interface umf4lnum module procedure umf4lnum , umf4lnum_ip end interface interface umf4clsym module procedure umf4clsym , umf4clsym_ip end interface interface umf4zlsym module procedure umf4zlsym , umf4zlsym_ip end interface interface umf4lsym module procedure umf4lsym , umf4lsym_ip end interface ! ====================================================================== ! Defined operator .umfpack. ! ====================================================================== type tCSC_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSC_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSC_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tCSR_di integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) end type type tCSR_zi integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) real ( r8 ), allocatable :: Ax (:) real ( r8 ), allocatable :: Az (:) end type type tCSR_ci integer , allocatable :: Ap (:) integer , allocatable :: Ai (:) complex ( r8 ), allocatable :: Ax (:) end type type tVec_zi real ( r8 ), allocatable :: x (:) real ( r8 ), allocatable :: z (:) end type type pCSC_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSC_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSC_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pCSR_di integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) end type type pCSR_zi integer , pointer :: Ap (:) integer , pointer :: Ai (:) real ( r8 ), pointer :: Ax (:) real ( r8 ), pointer :: Az (:) end type type pCSR_ci integer , pointer :: Ap (:) integer , pointer :: Ai (:) complex ( r8 ), pointer :: Ax (:) end type type pVec_zi real ( r8 ), pointer :: x (:) real ( r8 ), pointer :: z (:) end type ! overloaded structure constructors (not implemented in g95) ! interface pCSC_di ! module procedure make_CSC_di ! end interface ! interface pCSC_zi ! module procedure make_CSC_zi ! end interface ! interface pCSC_ci ! module procedure make_CSC_ci ! end interface interface pCSC module procedure make_CSC_di , make_CSC_zi , make_CSC_ci end interface interface pCSR module procedure make_CSR_di , make_CSR_zi , make_CSR_ci end interface ! interface pVec_zi ! module procedure make_Vec_zi ! end interface interface pVec module procedure make_Vec_zi end interface interface operator (. umfpack .) module procedure umfpack_di_operator_CSC , umfpack_zi_operator_CSC , umfpack_ci_operator_CSC , & umfpack_di_operator_CSR , umfpack_zi_operator_CSR , umfpack_ci_operator_CSR , & umfpack_di_operator_pCSC , umfpack_zi_operator_pCSC , umfpack_ci_operator_pCSC , & umfpack_di_operator_pCSR , umfpack_zi_operator_pCSR , umfpack_ci_operator_pCSR end interface contains ! ====================================================================== ! Full UMFPACK interface: Fortran wrappers ! ====================================================================== integer function umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_symbolic = c_umfpack_di_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target , intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( in ) :: Az ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_symbolic ( n_row , n_col , Ap , Ai , Ax , Az , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: n_row , n_col integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_n_row , c_n_col type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info c_n_row = n_row c_n_col = n_col c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_symbolic = c_umfpack_zi_symbolic ( c_n_row , c_n_col , c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Control , c_Info ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end function subroutine s_umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info , status ) integer , intent ( in ) :: n_row , n_col integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional :: Symbolic real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_symbolic ( n_row , n_col , Ap , Ai , Ax , Symbolic , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_numeric = c_umfpack_di_numeric ( c_Ap , c_Ai , c_Ax , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_loc ( Az ) if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , target , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info c_Ap = c_loc ( Ap ) c_Ai = c_loc ( Ai ) c_Ax = c_loc ( Ax ) c_Az = c_null_ptr if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_numeric = c_umfpack_zi_numeric ( c_Ap , c_Ai , c_Ax , c_Az , c_Symbolic , c_Numeric , c_Control , c_Info ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end function subroutine s_umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info , status ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ), optional , intent ( in ) :: Symbolic type ( c_ptr ), optional :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_di_solve = c_umfpack_di_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_X , c_B , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_di_solve ( sys , Ap , Ai , Ax , X , B , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), target , optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif if ( present ( Az )) then ; c_Az = c_loc ( Az ) ; else ; c_Az = c_null_ptr ; endif c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_zi_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), optional , intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_zi_solve ( sys , Ap , Ai , Ax , Az , Xx , Xz , Bx , Bz , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) integer , optional , intent ( in ) :: sys integer , target , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), target , optional , intent ( in ) :: Ax ( * ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer :: c_sys type ( c_ptr ) :: c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info if ( present ( sys )) then ; c_sys = sys ; else ; c_sys = UMFPACK_A ; endif if ( present ( Ap )) then ; c_Ap = c_loc ( Ap ) ; else ; c_Ap = c_null_ptr ; endif if ( present ( Ai )) then ; c_Ai = c_loc ( Ai ) ; else ; c_Ai = c_null_ptr ; endif if ( present ( Ax )) then ; c_Ax = c_loc ( Ax ) ; else ; c_Ax = c_null_ptr ; endif c_Az = c_null_ptr c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif if ( present ( Info )) then ; c_Info = c_loc ( Info ) ; else ; c_Info = c_null_ptr ; endif umfpack_ci_solve = c_umfpack_zi_solve ( c_sys , c_Ap , c_Ai , c_Ax , c_Az , c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric , c_Control , c_Info ) end function subroutine s_umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info , status ) integer , optional , intent ( in ) :: sys integer , optional , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), optional , intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) integer , optional :: status integer :: c_status c_status = umfpack_ci_solve ( sys , Ap , Ai , Ax , Xx , Bx , Numeric , Control , Info ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_di_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_zi_free_symbolic ( Symbolic ) type ( c_ptr ), optional :: Symbolic type ( c_ptr ) :: c_Symbolic if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif call c_umfpack_zi_free_symbolic ( c_Symbolic ) if ( present ( Symbolic )) then ; Symbolic = c_Symbolic ; else ; iSymbolic = c_Symbolic ; endif end subroutine subroutine umfpack_free_symbolic ( Symbolic , version ) type ( c_ptr ), optional :: Symbolic character ( * ), optional :: version type ( c_ptr ) :: c_Symbolic character ( 2 ) :: c_version if ( present ( Symbolic )) then ; c_Symbolic = Symbolic ; else ; c_Symbolic = iSymbolic ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case ( \"ci\" ) ; call umfpack_zi_free_symbolic ( c_Symbolic ) case default ; call umfpack_di_free_symbolic ( c_Symbolic ) end select end subroutine subroutine umfpack_di_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_di_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_zi_free_numeric ( Numeric ) type ( c_ptr ), optional :: Numeric type ( c_ptr ) :: c_Numeric if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif call c_umfpack_zi_free_numeric ( c_Numeric ) if ( present ( Numeric )) then ; Numeric = c_Numeric ; else ; iNumeric = c_Numeric ; endif end subroutine subroutine umfpack_free_numeric ( Numeric , version ) type ( c_ptr ), optional :: Numeric character ( * ), optional :: version type ( c_ptr ) :: c_Numeric character ( 2 ) :: c_version if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case ( \"ci\" ) ; call umfpack_zi_free_numeric ( c_Numeric ) case default ; call umfpack_di_free_numeric ( c_Numeric ) end select end subroutine integer function umfpack_di_scale ( X , B , Numeric ) real ( r8 ), target :: X ( * ) real ( r8 ), target , intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_X , c_B , c_Numeric c_X = c_loc ( X ) c_B = c_loc ( B ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_di_scale = c_umfpack_di_scale ( c_X , c_B , c_Numeric ) end function subroutine s_umfpack_di_scale ( X , B , Numeric , status ) real ( r8 ), intent ( out ) :: X ( * ) real ( r8 ), intent ( in ) :: B ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_di_scale ( X , B , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) real ( r8 ), target :: Xx ( * ), Xz ( * ) real ( r8 ), target , intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_loc ( Xz ) c_Bx = c_loc ( Bx ) c_Bz = c_loc ( Bz ) if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_zi_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric , status ) real ( r8 ), intent ( out ) :: Xx ( * ), Xz ( * ) real ( r8 ), intent ( in ) :: Bx ( * ), Bz ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_zi_scale ( Xx , Xz , Bx , Bz , Numeric ) if ( present ( status )) status = c_status end subroutine integer function umfpack_ci_scale ( Xx , Bx , Numeric ) complex ( r8 ), target :: Xx ( * ) complex ( r8 ), target , intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric type ( c_ptr ) :: c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric c_Xx = c_loc ( Xx ) c_Xz = c_null_ptr c_Bx = c_loc ( Bx ) c_Bz = c_null_ptr if ( present ( Numeric )) then ; c_Numeric = Numeric ; else ; c_Numeric = iNumeric ; endif umfpack_ci_scale = c_umfpack_zi_scale ( c_Xx , c_Xz , c_Bx , c_Bz , c_Numeric ) end function subroutine s_umfpack_ci_scale ( Xx , Bx , Numeric , status ) complex ( r8 ), intent ( out ) :: Xx ( * ) complex ( r8 ), intent ( in ) :: Bx ( * ) type ( c_ptr ), optional , intent ( in ) :: Numeric integer , optional :: status integer :: c_status c_status = umfpack_ci_scale ( Xx , Bx , Numeric ) if ( present ( status )) status = c_status end subroutine subroutine umfpack_di_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_di_defaults ( c_Control ) end subroutine subroutine umfpack_zi_defaults ( Control ) real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif call c_umfpack_zi_defaults ( c_Control ) end subroutine subroutine umfpack_defaults ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_defaults ( Control ) case ( \"ci\" ) ; call umfpack_zi_defaults ( Control ) case default ; call umfpack_di_defaults ( Control ) end select end subroutine subroutine umfpack_di_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_control ( Control ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Control logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_control ( c_Control ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_control ( Control , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_control ( Control ) case ( \"ci\" ) ; call umfpack_zi_report_control ( Control ) case default ; call umfpack_di_report_control ( Control ) end select end subroutine subroutine umfpack_di_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_di_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_zi_report_info ( Control , Info ) use iso_fortran_env , only : output_unit real ( r8 ), target , optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ), target :: Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Control , c_Info logical :: isOpened if ( present ( Control )) then ; c_Control = c_loc ( Control ) ; else ; c_Control = c_null_ptr ; endif c_Info = c_loc ( Info ) inquire ( output_unit , opened = isOpened ) if ( isOpened ) flush ( output_unit ) call c_umfpack_zi_report_info ( c_Control , c_Info ) if ( isOpened ) flush ( output_unit ) end subroutine subroutine umfpack_report_info ( Control , Info , version ) real ( r8 ), optional :: Control ( 0 : UMFPACK_CONTROL - 1 ) real ( r8 ) :: Info ( 0 : UMFPACK_INFO - 1 ) character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; call umfpack_zi_report_info ( Control , Info ) case ( \"ci\" ) ; call umfpack_zi_report_info ( Control , Info ) case default ; call umfpack_di_report_info ( Control , Info ) end select end subroutine integer function umfpack_di_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_save_numeric = c_umfpack_di_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_save_numeric = c_umfpack_zi_save_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_save_numeric = umfpack_zi_save_numeric ( Numeric , filename ) case default ; umfpack_save_numeric = umfpack_di_save_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_save_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_save_symbolic = c_umfpack_di_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_save_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_save_symbolic = c_umfpack_zi_save_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_save_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_save_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_save_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_save_symbolic = umfpack_zi_save_symbolic ( Symbolic , filename ) case default ; umfpack_save_symbolic = umfpack_di_save_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_save_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_save_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_di_load_numeric = c_umfpack_di_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_numeric ( Numeric , filename ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename umfpack_zi_load_numeric = c_umfpack_zi_load_numeric ( Numeric , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_numeric ( Numeric , filename , status ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_numeric ( Numeric , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_numeric ( Numeric , filename , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case ( \"ci\" ) ; umfpack_load_numeric = umfpack_zi_load_numeric ( Numeric , filename ) case default ; umfpack_load_numeric = umfpack_di_load_numeric ( Numeric , filename ) end select end function subroutine s_umfpack_load_numeric ( Numeric , filename , status , version ) type ( c_ptr ), intent ( in ) :: Numeric character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_numeric ( Numeric , filename , version ) if ( present ( status )) status = c_status end subroutine integer function umfpack_di_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_di_load_symbolic = c_umfpack_di_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_di_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_di_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_zi_load_symbolic ( Symbolic , filename ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename umfpack_zi_load_symbolic = c_umfpack_zi_load_symbolic ( Symbolic , trim ( filename ) // c_null_char ) end function subroutine s_umfpack_zi_load_symbolic ( Symbolic , filename , status ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status integer :: c_status c_status = umfpack_zi_load_symbolic ( Symbolic , filename ) if ( present ( status )) status = c_status end subroutine integer function umfpack_load_symbolic ( Symbolic , filename , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename character ( * ), optional :: version character ( 2 ) :: c_version if ( present ( version )) then ; c_version = version ; else ; c_version = \"di\" ; endif select case ( c_version ) case ( \"zi\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case ( \"ci\" ) ; umfpack_load_symbolic = umfpack_zi_load_symbolic ( Symbolic , filename ) case default ; umfpack_load_symbolic = umfpack_di_load_symbolic ( Symbolic , filename ) end select end function subroutine s_umfpack_load_symbolic ( Symbolic , filename , status , version ) type ( c_ptr ), intent ( in ) :: Symbolic character ( * ), intent ( in ) :: filename integer , optional :: status character ( * ), optional :: version integer :: c_status c_status = umfpack_load_symbolic ( Symbolic , filename , version ) if ( present ( status )) status = c_status end subroutine ! ====================================================================== ! Basic UMFPACK interface: Fortran wrappers ! ====================================================================== subroutine umf4def ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control ) end subroutine subroutine umf4zdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4cdef ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_defaults ( Control , \"zi\" ) end subroutine subroutine umf4pcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control ) end subroutine subroutine umf4zpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4cpcon ( Control ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ) call umfpack_report_control ( Control , \"zi\" ) end subroutine subroutine umf4sym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4zsym ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) end subroutine subroutine umf4csym ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) end subroutine subroutine umf4sym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zsym_ip ( m , n , Ap , Ai , Ax , Az , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , Az , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4csym_ip ( m , n , Ap , Ai , Ax , Symbolic , Control , Info ) integer , intent ( in ) :: m , n integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic c_Symbolic = c_null_ptr call s_umfpack_symbolic ( m , n , Ap , Ai , Ax , c_Symbolic , Control , Info ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4num ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4znum ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4cnum ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) type ( c_ptr ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_numeric ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) end subroutine subroutine umf4num_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4znum_ip ( Ap , Ai , Ax , Az , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , Az , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cnum_ip ( Ap , Ai , Ax , Symbolic , Numeric , Control , Info ) integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) integer ( ip ) :: Symbolic , Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Symbolic , c_Numeric c_Symbolic = transfer ( Symbolic , c_Symbolic ) c_Numeric = c_null_ptr call s_umfpack_numeric ( Ap , Ai , Ax , c_Symbolic , c_Numeric , Control , Info ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4solr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4zsolr ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) end subroutine subroutine umf4csolr ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) end subroutine subroutine umf4solr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4zsolr_ip ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) real ( r8 ), intent ( in ) :: Ax ( * ), Az ( * ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , Az , x , xz , b , bz , c_Numeric , Control , Info ) end subroutine subroutine umf4csolr_ip ( sys , Ap , Ai , Ax , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys integer , intent ( in ) :: Ap ( * ), Ai ( * ) complex ( r8 ), intent ( in ) :: Ax ( * ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call s_umfpack_solve ( sys , Ap , Ai , Ax , x , b , c_Numeric , Control , Info ) end subroutine subroutine umf4sol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,Numeric,c_Control,Info) call s_umfpack_solve ( sys , xx = x , bx = b , Numeric = Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4sol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_solve ( sys , x = x , b = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4zsol_ip ( sys , x , xz , b , bz , Numeric , Control , Info ) integer , intent ( in ) :: sys real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,xz,b,bz,c_Numeric,c_Control,Info) call s_umfpack_zi_solve ( sys , xx = x , xz = xz , bx = b , bz = bz , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4csol_ip ( sys , x , b , Numeric , Control , Info ) integer , intent ( in ) :: sys complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) real ( r8 ) :: c_Control ( 0 : UMFPACK_CONTROL - 1 ) type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) c_Control = Control c_Control ( UMFPACK_IRSTEP ) = 0. ! call umfpack_solve(sys,x,b,c_Numeric,c_Control,Info) call s_umfpack_ci_solve ( sys , xx = x , bx = b , Numeric = c_Numeric , Control = c_Control , Info = Info ) end subroutine subroutine umf4scal ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4zscal ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , xz , b , bz , Numeric ) end subroutine subroutine umf4cscal ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) type ( c_ptr ) :: Numeric integer , intent ( out ) :: status status = umfpack_scale_function ( x , b , Numeric ) end subroutine subroutine umf4scal_ip ( x , b , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ) real ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4zscal_ip ( x , xz , b , bz , Numeric , status ) real ( r8 ), intent ( out ) :: x ( * ), xz ( * ) real ( r8 ), intent ( in ) :: b ( * ), bz ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , xz , b , bz , c_Numeric ) end subroutine subroutine umf4cscal_ip ( x , b , Numeric , status ) complex ( r8 ), intent ( out ) :: x ( * ) complex ( r8 ), intent ( in ) :: b ( * ) integer ( ip ) :: Numeric integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_scale_function ( x , b , c_Numeric ) end subroutine subroutine umf4pinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info ) end subroutine subroutine umf4zpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"zi\" ) end subroutine subroutine umf4cpinf ( Control , Info ) real ( r8 ) :: Control ( 0 : UMFPACK_CONTROL - 1 ), Info ( 0 : UMFPACK_INFO - 1 ) call umfpack_report_info ( Control , Info , \"ci\" ) end subroutine subroutine umf4fnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric ) end subroutine subroutine umf4zfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"zi\" ) end subroutine subroutine umf4cfnum ( Numeric ) type ( c_ptr ) :: Numeric call umfpack_free_numeric ( Numeric , \"ci\" ) end subroutine subroutine umf4fnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4cfnum_ip ( Numeric ) integer ( ip ) :: Numeric type ( c_ptr ) :: c_Numeric c_Numeric = transfer ( Numeric , c_Numeric ) call umfpack_free_numeric ( c_Numeric , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4fsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic ) end subroutine subroutine umf4zfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"zi\" ) end subroutine subroutine umf4cfsym ( Symbolic ) type ( c_ptr ) :: Symbolic call umfpack_free_symbolic ( Symbolic , \"ci\" ) end subroutine subroutine umf4fsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4cfsym_ip ( Symbolic ) integer ( ip ) :: Symbolic type ( c_ptr ) :: c_Symbolic c_Symbolic = transfer ( Symbolic , c_Symbolic ) call umfpack_free_symbolic ( c_Symbolic , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4snum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename ) end subroutine subroutine umf4zsnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_save_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4snum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename ) end subroutine subroutine umf4zsnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"zi\" ) end subroutine subroutine umf4csnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = transfer ( Numeric , c_Numeric ) status = umfpack_save_numeric ( c_Numeric , filename , \"ci\" ) end subroutine subroutine umf4ssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_save_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4ssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename ) end subroutine subroutine umf4zssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"zi\" ) end subroutine subroutine umf4cssym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = transfer ( Symbolic , c_Symbolic ) status = umfpack_save_symbolic ( c_Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename ) end subroutine subroutine umf4zlnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"zi\" ) end subroutine subroutine umf4clnum ( Numeric , filenum , status ) type ( c_ptr ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" status = umfpack_load_numeric ( Numeric , filename , \"ci\" ) end subroutine subroutine umf4lnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4zlnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"zi\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4clnum_ip ( Numeric , filenum , status ) integer ( ip ) :: Numeric integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Numeric character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"n\" , filenum , \".umf\" c_Numeric = c_null_ptr status = umfpack_load_numeric ( c_Numeric , filename , \"ci\" ) Numeric = transfer ( c_Numeric , Numeric ) end subroutine subroutine umf4lsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename ) end subroutine subroutine umf4zlsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"zi\" ) end subroutine subroutine umf4clsym ( Symbolic , filenum , status ) type ( c_ptr ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" status = umfpack_load_symbolic ( Symbolic , filename , \"ci\" ) end subroutine subroutine umf4lsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4zlsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"zi\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine subroutine umf4clsym_ip ( Symbolic , filenum , status ) integer ( ip ) :: Symbolic integer , intent ( in ) :: filenum integer , intent ( out ) :: status type ( c_ptr ) :: c_Symbolic character ( 20 ) :: filename write ( filename , '(a,i0,a)' ) \"s\" , filenum , \".umf\" c_Symbolic = c_null_ptr status = umfpack_load_symbolic ( c_Symbolic , filename , \"ci\" ) Symbolic = transfer ( c_Symbolic , Symbolic ) end subroutine ! ====================================================================== ! Defined operator .umfpack.: associated procedures ! ====================================================================== function umfpack_di_operator_CSC ( A , B ) result ( X ) type ( tCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSC ( A , B ) result ( X ) type ( tCSC_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSC ( A , B ) result ( X ) type ( tCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_CSR ( A , B ) result ( X ) type ( tCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B ( * ) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_CSR ( A , B ) result ( X ) type ( tCSR_zi ), intent ( in ) :: A type ( tVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_CSR ( A , B ) result ( X ) type ( tCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSC ( A , B ) result ( X ) type ( pCSC_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSC ( A , B ) result ( X ) type ( pCSC_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSC ( A , B ) result ( X ) type ( pCSC_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_A n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_di_operator_pCSR ( A , B ) result ( X ) type ( pCSR_di ), intent ( in ) :: A real ( c_double ), intent ( in ) :: B (:) real ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_di_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_di_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_di_free_symbolic ( Symbolic ) call s_umfpack_di_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_di_free_numeric ( Numeric ) end function function umfpack_zi_operator_pCSR ( A , B ) result ( X ) type ( pCSR_zi ), intent ( in ) :: A type ( pVec_zi ), intent ( in ) :: B type ( tVec_zi ) :: X type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr allocate ( X % x ( n ), X % z ( n )) call s_umfpack_zi_symbolic ( n , n , A % Ap , A % Ai , A % Ax , A % Az , Symbolic ) call s_umfpack_zi_numeric ( A % Ap , A % Ai , A % Ax , A % Az , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_zi_solve ( sys , A % Ap , A % Ai , A % Ax , A % Az , X % x , X % z , B % x , B % z , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function function umfpack_ci_operator_pCSR ( A , B ) result ( X ) type ( pCSR_ci ), intent ( in ) :: A complex ( c_double ), intent ( in ) :: B ( * ) complex ( c_double ) :: X ( size ( A % Ap ) - 1 ) type ( c_ptr ) :: Symbolic , Numeric integer :: n integer , parameter :: sys = UMFPACK_Aat n = size ( A % Ap ) - 1 Symbolic = c_null_ptr Numeric = c_null_ptr call s_umfpack_ci_symbolic ( n , n , A % Ap , A % Ai , A % Ax , Symbolic ) call s_umfpack_ci_numeric ( A % Ap , A % Ai , A % Ax , Symbolic , Numeric ) call umfpack_zi_free_symbolic ( Symbolic ) call s_umfpack_ci_solve ( sys , A % Ap , A % Ai , A % Ax , X , B , Numeric ) call umfpack_zi_free_numeric ( Numeric ) end function type ( pCSC_di ) function make_CSC_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSC_zi ) function make_CSC_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSC_ci ) function make_CSC_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_di ) function make_CSR_di ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pCSR_zi ) function make_CSR_zi ( Ap , Ai , Ax , Az ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) real ( r8 ), target , intent ( in ) :: Ax (:), Az (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax result % Az => Az end function type ( pCSR_ci ) function make_CSR_ci ( Ap , Ai , Ax ) result ( result ) integer , target , intent ( in ) :: Ap (:), Ai (:) complex ( r8 ), target , intent ( in ) :: Ax (:) result % Ap => Ap result % Ai => Ai result % Ax => Ax end function type ( pVec_zi ) function make_Vec_zi ( bx , bz ) result ( result ) real ( r8 ), target , intent ( in ) :: bx (:), bz (:) result % x => bx result % z => bz end function ! ====================================================================== endmodule mumfpack ! ======================================================================","tags":"","loc":"sourcefile/umfpack.f90.html"},{"title":"mod_surfile.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_surfile.f90~~EfferentGraph sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_surfile.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_surfile.f90~~AfferentGraph sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~prg.f90~12 prg.f90 sourcefile~prg.f90~12->sourcefile~mod_surfile.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: November, 17 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Routines to handle Digital Surf binary format (.sur)** !<  </span> module surfile use , intrinsic :: ISO_C_BINDING , only : C_CHAR , C_NULL_CHAR , C_FLOAT , C_INT , C_SHORT use data_arch use miscellaneous , only : get_unit use sort_arrays , only : sort_array2 implicit none private !< <span style=\"color:green\">Fortran typed surface object: header, dimensions, mean and std</span> !< @note !< Fortran surface object, adapted from 'surffile.c', 'gwyddion' software, Copyright (C) 2005 David Necas, Petr Klapetek. !< @endnote !< !< @warning !< Must be 512 bytes long before length definition !< @endwarning type SCALE_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( len = 12 ) :: signature character ( len = 16 ) :: xlength_unit character ( len = 16 ) :: ylength_unit character ( len = 16 ) :: zlength_unit character ( len = 16 ) :: xaxis character ( len = 16 ) :: yaxis character ( len = 16 ) :: zaxis character ( len = 16 ) :: dx_unit character ( len = 16 ) :: dy_unit character ( len = 16 ) :: dz_unit character ( len = 30 ) :: object_name character ( len = 30 ) :: operator_name character ( len = 128 ) :: client_zone character ( len = 8 ) :: reserved character ( len = 34 ) :: reservedzone character ( len = 12 ) :: obsolete character ( len = 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = R4 ) :: dx real ( kind = R4 ) :: dy real ( kind = R4 ) :: dz real ( kind = R4 ) :: xunit_ratio real ( kind = R4 ) :: yunit_ratio real ( kind = R4 ) :: zunit_ratio real ( kind = R4 ) :: XOffset real ( kind = R4 ) :: YOffset real ( kind = R4 ) :: ZOffset real ( kind = R4 ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = I4 ) :: zmin integer ( kind = I4 ) :: zmax integer ( kind = I4 ) :: xres integer ( kind = I4 ) :: yres integer ( kind = I4 ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = 2 ) :: format ! 0 integer ( kind = 2 ) :: version ! 1 integer ( kind = 2 ) :: material_code ! 1 integer ( kind = 2 ) :: type ! 2 integer ( kind = 2 ) :: range ! 0 integer ( kind = 2 ) :: special_points ! 0 integer ( kind = 2 ) :: absolute ! 1 integer ( kind = 2 ) :: pointsize ! 32 integer ( kind = 2 ) :: imprint ! 0 integer ( kind = 2 ) :: inversion ! 0 integer ( kind = 2 ) :: leveling ! 0 integer ( kind = 2 ) :: seconds ! 0 integer ( kind = 2 ) :: minutes ! 0 integer ( kind = 2 ) :: hours ! 0 integer ( kind = 2 ) :: day ! 0 integer ( kind = 2 ) :: month ! 0 integer ( kind = 2 ) :: year ! 0 integer ( kind = 2 ) :: dayof ! 0 integer ( kind = 2 ) :: comment_size ! 0 integer ( kind = 2 ) :: private_size ! 0 integer ( kind = 2 ) :: nobjects ! 1 integer ( kind = 2 ) :: acquisition ! 0 !------------- 512 bytes above real ( kind = R8 ) :: lx !! *surface length* real ( kind = R8 ) :: ly !! *surface width* real ( kind = R8 ) :: lz !! *surface height (max -min)* real ( kind = R8 ) :: mu !! *surface mean height* real ( kind = R8 ) :: si !! *surface mean height* endtype SCALE_SURF !< <span style=\"color:green\">C like surface object: header and heights</span> !< @note !< Fortran surface object, adapted from 'surffile.c', 'gwyddion' software, Copyright (C) 2005 David Necas, Petr Klapetek. !< @endnote !< type OBJ_SURF ! bytes below: 8+10+2*12+9*16+2*30+34+128 = 408 character ( kind = C_CHAR ), dimension ( 12 ) :: signature character ( kind = C_CHAR ), dimension ( 16 ) :: xlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: ylength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: zlength_unit character ( kind = C_CHAR ), dimension ( 16 ) :: xaxis character ( kind = C_CHAR ), dimension ( 16 ) :: yaxis character ( kind = C_CHAR ), dimension ( 16 ) :: zaxis character ( kind = C_CHAR ), dimension ( 16 ) :: dx_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dy_unit character ( kind = C_CHAR ), dimension ( 16 ) :: dz_unit character ( kind = C_CHAR ), dimension ( 30 ) :: object_name character ( kind = C_CHAR ), dimension ( 30 ) :: operator_name character ( kind = C_CHAR ), dimension ( 128 ) :: client_zone character ( kind = C_CHAR ), dimension ( 8 ) :: reserved character ( kind = C_CHAR ), dimension ( 34 ) :: reservedzone character ( kind = C_CHAR ), dimension ( 12 ) :: obsolete character ( kind = C_CHAR ), dimension ( 10 ) :: obsolete2 ! bytes below: 10*4 = 40 real ( kind = C_FLOAT ) :: dx real ( kind = C_FLOAT ) :: dy real ( kind = C_FLOAT ) :: dz real ( kind = C_FLOAT ) :: xunit_ratio real ( kind = C_FLOAT ) :: yunit_ratio real ( kind = C_FLOAT ) :: zunit_ratio real ( kind = C_FLOAT ) :: XOffset real ( kind = C_FLOAT ) :: YOffset real ( kind = C_FLOAT ) :: ZOffset real ( kind = C_FLOAT ) :: measurement_duration ! bytes below: 5*4 = 20 integer ( kind = C_INT ) :: zmin integer ( kind = C_INT ) :: zmax integer ( kind = C_INT ) :: xres integer ( kind = C_INT ) :: yres integer ( kind = C_INT ) :: nofpoints ! bytes below: 22*2 = 44 integer ( kind = C_SHORT ) :: format integer ( kind = C_SHORT ) :: version integer ( kind = C_SHORT ) :: material_code integer ( kind = C_SHORT ) :: type integer ( kind = C_SHORT ) :: range integer ( kind = C_SHORT ) :: special_points integer ( kind = C_SHORT ) :: absolute integer ( kind = C_SHORT ) :: pointsize integer ( kind = C_SHORT ) :: imprint integer ( kind = C_SHORT ) :: inversion integer ( kind = C_SHORT ) :: leveling integer ( kind = C_SHORT ) :: seconds integer ( kind = C_SHORT ) :: minutes integer ( kind = C_SHORT ) :: hours integer ( kind = C_SHORT ) :: day integer ( kind = C_SHORT ) :: month integer ( kind = C_SHORT ) :: year integer ( kind = C_SHORT ) :: dayof integer ( kind = C_SHORT ) :: comment_size integer ( kind = C_SHORT ) :: private_size integer ( kind = C_SHORT ) :: nobjects integer ( kind = C_SHORT ) :: acquisition integer ( kind = C_INT ), allocatable :: val (:) !! *heights* endtype OBJ_SURF integer ( kind = 4 ), parameter :: SURF_DAT = 1 !! *'.dat' format, txt* integer ( kind = 4 ), parameter :: SURF_SUR = 2 !! *'.sur' format, binary* public :: read_surf , write_surf , init_scal , unit2IUc , unit2IUf , & ! trans_surf_txt , scal2surf , surf2scal , empty , SCALE_SURF , OBJ_SURF ! contains subroutine scal2surf ( scal , surf ) !! Transform a [[SCALE_SURF]] object into a [[OBJ_SURF]] object implicit none type ( SCALE_SURF ), intent ( in ) :: scal !! *object [[SCALE_SURF]]* type ( OBJ_SURF ), intent ( out ) :: surf !! *object [[OBJ_SURF]]* call f_c_string ( fs = trim ( scal % signature ), & ! cs = surf % signature ) ! call f_c_string ( fs = trim ( scal % xlength_unit ), & ! cs = surf % xlength_unit ) ! call f_c_string ( fs = trim ( scal % ylength_unit ), & ! cs = surf % ylength_unit ) ! call f_c_string ( fs = trim ( scal % zlength_unit ), & ! cs = surf % zlength_unit ) ! call f_c_string ( fs = trim ( scal % xaxis ), & ! cs = surf % xaxis ) ! call f_c_string ( fs = trim ( scal % yaxis ), & ! cs = surf % yaxis ) ! call f_c_string ( fs = trim ( scal % zaxis ), & ! cs = surf % zaxis ) ! call f_c_string ( fs = trim ( scal % dx_unit ), & ! cs = surf % dx_unit ) ! call f_c_string ( fs = trim ( scal % dy_unit ), & ! cs = surf % dy_unit ) ! call f_c_string ( fs = trim ( scal % dz_unit ), & ! cs = surf % dz_unit ) ! call f_c_string ( fs = trim ( scal % object_name ), & ! cs = surf % object_name ) ! call f_c_string ( fs = trim ( scal % operator_name ), & ! cs = surf % operator_name ) ! call f_c_string ( fs = trim ( scal % client_zone ), & ! cs = surf % client_zone ) ! call f_c_string ( fs = trim ( scal % reserved ), & ! cs = surf % reserved ) ! call f_c_string ( fs = trim ( scal % reservedzone ), & ! cs = surf % reservedzone ) ! call f_c_string ( fs = trim ( scal % obsolete ), & ! cs = surf % obsolete ) ! call f_c_string ( fs = trim ( scal % obsolete2 ), & ! cs = surf % obsolete2 ) ! surf % dx = scal % dx surf % dy = scal % dy surf % dz = scal % dz surf % xunit_ratio = scal % xunit_ratio surf % yunit_ratio = scal % yunit_ratio surf % zunit_ratio = scal % zunit_ratio surf % XOffset = scal % XOffset surf % YOffset = scal % YOffset surf % ZOffset = scal % ZOffset surf % measurement_duration = scal % measurement_duration surf % zmin = scal % zmin surf % zmax = scal % zmax surf % xres = scal % xres surf % yres = scal % yres surf % nofpoints = scal % nofpoints surf % format = scal % format surf % version = scal % version surf % material_code = scal % material_code surf % type = scal % type surf % range = scal % range surf % special_points = scal % special_points surf % absolute = scal % absolute surf % pointsize = scal % pointsize surf % imprint = scal % imprint surf % inversion = scal % inversion surf % leveling = scal % leveling surf % seconds = scal % seconds surf % minutes = scal % minutes surf % hours = scal % hours surf % day = scal % day surf % month = scal % month surf % year = scal % year surf % dayof = scal % dayof surf % comment_size = scal % comment_size surf % private_size = scal % private_size surf % nobjects = scal % nobjects surf % acquisition = scal % acquisition return endsubroutine scal2surf subroutine surf2scal ( surf , scal ) !! Transform a [[OBJ_SURF]] object into a [[SCALE_SURF]] object implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ) :: i call c_f_string ( cs = surf % signature , & ! fs = scal % signature , & ! lngth_s = i ) ! call c_f_string ( cs = surf % xlength_unit , & ! fs = scal % xlength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % ylength_unit , & ! fs = scal % ylength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % zlength_unit , & ! fs = scal % zlength_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % xaxis , & ! fs = scal % xaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % yaxis , & ! fs = scal % yaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % zaxis , & ! fs = scal % zaxis , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dx_unit , & ! fs = scal % dx_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dy_unit , & ! fs = scal % dy_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % dz_unit , & ! fs = scal % dz_unit , & ! lngth_s = i ) ! call c_f_string ( cs = surf % object_name , & ! fs = scal % object_name , & ! lngth_s = i ) ! call c_f_string ( cs = surf % operator_name , & ! fs = scal % operator_name , & ! lngth_s = i ) ! call c_f_string ( cs = surf % client_zone , & ! fs = scal % client_zone , & ! lngth_s = i ) ! call c_f_string ( cs = surf % reserved , & ! fs = scal % reserved , & ! lngth_s = i ) ! call c_f_string ( cs = surf % reservedzone , & ! fs = scal % reservedzone , & ! lngth_s = i ) ! call c_f_string ( cs = surf % obsolete , & ! fs = scal % obsolete , & ! lngth_s = i ) ! call c_f_string ( cs = surf % obsolete2 , & ! fs = scal % obsolete2 , & ! lngth_s = i ) ! scal % dx = surf % dx scal % dy = surf % dy scal % dz = surf % dz scal % xunit_ratio = surf % xunit_ratio scal % yunit_ratio = surf % yunit_ratio scal % zunit_ratio = surf % zunit_ratio scal % XOffset = surf % XOffset scal % YOffset = surf % YOffset scal % ZOffset = surf % ZOffset scal % measurement_duration = surf % measurement_duration scal % zmin = surf % zmin scal % zmax = surf % zmax scal % xres = surf % xres scal % yres = surf % yres scal % nofpoints = surf % nofpoints scal % format = surf % format scal % version = surf % version scal % material_code = surf % material_code scal % type = surf % type scal % range = surf % range scal % special_points = surf % special_points scal % absolute = surf % absolute scal % pointsize = surf % pointsize scal % imprint = surf % imprint scal % inversion = surf % inversion scal % leveling = surf % leveling scal % seconds = surf % seconds scal % minutes = surf % minutes scal % hours = surf % hours scal % day = surf % day scal % month = surf % month scal % year = surf % year scal % dayof = surf % dayof scal % comment_size = surf % comment_size scal % private_size = surf % private_size scal % nobjects = surf % nobjects scal % acquisition = surf % acquisition scal % lx = scal % dx * scal % xres * unit2IUf ( scal % dx_unit ) scal % ly = scal % dy * scal % yres * unit2IUf ( scal % dy_unit ) return endsubroutine surf2scal subroutine empty ( charinout ) !! Just empties a string implicit none character ( len =* ), intent ( inout ) :: charinout charinout = repeat ( ' ' , len ( charinout )) return endsubroutine empty !========================================================================================= !< @note !<   Converts a C string to a Fortran string !< !<   From a memory viewpoint, a C string is like a character vector ending with a ```C_NULL_CHAR``` !<   so, as long as it is not found, the characters are copied one by one in a fortran string !< @endnote !----------------------------------------------------------------------------------------- subroutine c_f_string ( cs , fs , lngth_s ) implicit none character ( kind = C_CHAR ), dimension (:), intent ( in ) :: cs !! *C string* character ( len =* ), intent ( out ) :: fs !! *Fortran string* integer ( kind = I4 ), intent ( out ) :: lngth_s !! *resulting Fortran string length* integer ( kind = I4 ) :: i , ucs ucs = size ( cs ) ! vector length lngth_s = ucs ! resulting string default length i = 1 do if ( i > ucs ) exit if ( cs ( i ) == C_NULL_CHAR ) then ! fin de chaîne c rencontrée ; s'il n'y a pas de null_char lngth_s = i - 1 ! c'est qu'on utilise tout le vecteur exit endif i = i + 1 enddo call empty ( fs ) do i = 1 , lngth_s ! the C string is translated into fortran fs ( i : i ) = cs ( i ) enddo return endsubroutine c_f_string !========================================================================================= !< @note !<   Converts a Fortran string to a C string !< !<   A From a memory viewpoint, a C string is like a character vector ending with a ```C_NULL_CHAR```, !<   so the characters are copied one by one in a ```C_CHAR``` vector that ends with a ```C_NULL_CHAR``` !< @endnote !----------------------------------------------------------------------------------------- subroutine f_c_string ( fs , cs ) implicit none character ( len =* ), intent ( in ) :: fs !! *fortran string* character ( kind = C_CHAR ), dimension (:), intent ( out ) :: cs !! *resulting C string* integer ( kind = I4 ) :: i , ufs ufs = len_trim ( fs ) ! longueur de la chaîne fortran sans les null, les blancs, ... if ( ufs == 0 ) then ! si la chaîne est vide cs ( 1 ) = C_NULL_CHAR else do i = 1 , ufs cs ( i ) = fs ( i : i ) enddo if ( ufs < size ( cs )) cs ( ufs + 1 ) = C_NULL_CHAR ! si la fin du vecteur n'est pas atteinte endif return endsubroutine f_c_string subroutine init_scal ( scal , nx , ny , lx , ly , unit_z ) !! [[OBJ_SURF]] initialization, every unit is m implicit none type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* integer ( kind = I4 ), optional , intent ( in ) :: nx integer ( kind = I4 ), optional , intent ( in ) :: ny real ( kind = R8 ), optional , intent ( in ) :: lx real ( kind = R8 ), optional , intent ( in ) :: ly character ( * ), optional , intent ( in ) :: unit_z integer ( kind = I4 ), dimension ( 1 : 8 ) :: time_val character ( len = 256 ) :: string call date_and_time ( values = time_val ) scal % format = 0 scal % nobjects = 1 scal % version = 1 scal % type = 2 scal % material_code = 1 scal % acquisition = 0 scal % range = 0 scal % special_points = 0 scal % absolute = 1 scal % pointsize = 32 scal % zmin = 0 scal % zmax = 0 scal % xres = 0 scal % yres = 0 scal % nofpoints = 0 scal % xunit_ratio = 1. scal % yunit_ratio = 1. scal % zunit_ratio = 1. scal % imprint = 0 scal % inversion = 0 scal % leveling = 0 scal % seconds = time_val ( 7 ) scal % minutes = time_val ( 6 ) scal % hours = time_val ( 5 ) scal % day = time_val ( 3 ) scal % month = time_val ( 2 ) scal % year = time_val ( 1 ) scal % dayof = 0 scal % measurement_duration = 0.0 scal % comment_size = 0 scal % private_size = 0 scal % XOffset = 0. scal % YOffset = 0. scal % ZOffset = 0. call empty ( scal % reserved ) call empty ( scal % obsolete2 ) call empty ( scal % obsolete ) call empty ( scal % reservedzone ) call empty ( scal % client_zone ) call empty ( scal % object_name ) call empty ( scal % signature ) call empty ( scal % operator_name ) scal % object_name = 'HOME MADE' scal % signature = 'DIGITAL SURF' scal % operator_name = 'MOD_SURFILE' call empty ( scal % xaxis ) call empty ( scal % yaxis ) call empty ( scal % zaxis ) scal % xaxis = \"X\" scal % yaxis = \"Y\" scal % zaxis = \"Z\" call empty ( scal % xlength_unit ) call empty ( scal % ylength_unit ) call empty ( scal % zlength_unit ) call empty ( scal % dx_unit ) call empty ( scal % dy_unit ) call empty ( scal % dz_unit ) scal % xlength_unit = \"m\" ; scal % dx_unit = trim ( scal % xlength_unit ) ; scal % dx = 1.0 scal % ylength_unit = \"m\" ; scal % dy_unit = trim ( scal % ylength_unit ) ; scal % dy = 1.0 scal % zlength_unit = \"m\" ; scal % dz_unit = trim ( scal % zlength_unit ) ; scal % dz = 1.0 scal % mu = 0 scal % si = 0 if ( present ( nx )) scal % xres = nx if ( present ( ny )) scal % yres = ny if ( present ( lx )) scal % lx = lx if ( present ( ly )) scal % ly = ly if ( present ( nx ). and . present ( lx )) scal % dx = lx / nx if ( present ( ny ). and . present ( ly )) scal % dy = ly / ny if ( present ( unit_z )) then ; scal % zlength_unit = trim ( unit_z ) scal % dz_unit = trim ( unit_z ) ; endif return endsubroutine init_scal !========================================================================================= !< @note !<   Writes an [[OBJ_SURF]] object in a text file !< !<   The object components are first written in a fortran string, then it is written into !<   the file with a comment !< @endnote !----------------------------------------------------------------------------------------- subroutine trans_surf_txt ( surf , fichier , xyz ) implicit none type ( OBJ_SURF ), intent ( in ) :: surf !! *object [[OBJ_SURF]]* character ( len =* ), intent ( in ) :: fichier !! *text file to write* logical ( kind = I4 ), intent ( in ) :: xyz !! *whether to also write the heights (maybe huge)* integer ( kind = I4 ) :: i , k , s character ( len = 512 ) :: string , cc call get_unit ( k ) open ( k , file = trim ( fichier )) call c_f_string ( cs = surf % signature , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"signature              \" ; call empty ( cc ) write ( cc , * ) surf % format ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"format                 \" ; call empty ( cc ) write ( cc , * ) surf % nobjects ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nobjects               \" ; call empty ( cc ) write ( cc , * ) surf % version ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"version                \" ; call empty ( cc ) write ( cc , * ) surf % type ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"type                   \" ; call empty ( cc ) call c_f_string ( cs = surf % object_name , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"object_name            \" ; call empty ( cc ) call c_f_string ( cs = surf % operator_name , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"operator_name          \" ; call empty ( cc ) write ( cc , * ) surf % material_code ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"material_code          \" ; call empty ( cc ) write ( cc , * ) surf % acquisition ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"acquisition            \" ; call empty ( cc ) write ( cc , * ) surf % range ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"range                  \" ; call empty ( cc ) write ( cc , * ) surf % special_points ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"special_points         \" ; call empty ( cc ) write ( cc , * ) surf % absolute ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"absolute               \" ; call empty ( cc ) call c_f_string ( cs = surf % reserved , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reserved               \" ; call empty ( cc ) write ( cc , * ) surf % pointsize ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"pointsize              \" ; call empty ( cc ) write ( cc , * ) surf % zmin ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmin                   \" ; call empty ( cc ) write ( cc , * ) surf % zmax ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zmax                   \" ; call empty ( cc ) write ( cc , * ) surf % xres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xres                   \" ; call empty ( cc ) write ( cc , * ) surf % yres ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yres                   \" ; call empty ( cc ) write ( cc , * ) surf % nofpoints ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"nofpoints              \" ; call empty ( cc ) write ( cc , * ) surf % dx ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx                     \" ; call empty ( cc ) write ( cc , * ) surf % dy ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy                     \" ; call empty ( cc ) write ( cc , * ) surf % dz ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz                     \" ; call empty ( cc ) call c_f_string ( cs = surf % xaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % yaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % zaxis , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zaxis                  \" ; call empty ( cc ) call c_f_string ( cs = surf % dx_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dx_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dy_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dy_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % dz_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dz_unit                \" ; call empty ( cc ) call c_f_string ( cs = surf % xlength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xlength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % ylength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ylength_unit           \" ; call empty ( cc ) call c_f_string ( cs = surf % zlength_unit , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zlength_unit           \" ; call empty ( cc ) write ( cc , * ) surf % xunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"xunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % yunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"yunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % zunit_ratio ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"zunit_ratio            \" ; call empty ( cc ) write ( cc , * ) surf % imprint ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"imprint                \" ; call empty ( cc ) write ( cc , * ) surf % inversion ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"inversion              \" ; call empty ( cc ) write ( cc , * ) surf % leveling ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"leveling               \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete               \" ; call empty ( cc ) write ( cc , * ) surf % seconds ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"seconds                \" ; call empty ( cc ) write ( cc , * ) surf % minutes ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"minutes                \" ; call empty ( cc ) write ( cc , * ) surf % hours ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"hours                  \" ; call empty ( cc ) write ( cc , * ) surf % day ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"day                    \" ; call empty ( cc ) write ( cc , * ) surf % month ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"month                  \" ; call empty ( cc ) write ( cc , * ) surf % year ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"year                   \" ; call empty ( cc ) write ( cc , * ) surf % dayof ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"dayof                  \" ; call empty ( cc ) write ( cc , * ) surf % measurement_duration ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"measurement_duration   \" ; call empty ( cc ) call c_f_string ( cs = surf % obsolete2 , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"obsolete2              \" ; call empty ( cc ) write ( cc , * ) surf % comment_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"comment_size           \" ; call empty ( cc ) write ( cc , * ) surf % private_size ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"private_size           \" ; call empty ( cc ) call c_f_string ( cs = surf % client_zone , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"client_zone            \" ; call empty ( cc ) write ( cc , * ) surf % XOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"XOffset                \" ; call empty ( cc ) write ( cc , * ) surf % YOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"YOffset                \" ; call empty ( cc ) write ( cc , * ) surf % ZOffset ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"ZOffset                \" ; call empty ( cc ) call c_f_string ( cs = surf % reservedzone , fs = string , lngth_s = s ) write ( cc , * ) '\"' , trim ( string ( 1 : s )), '\"' ; write ( k , '(1x,a,T130,a)' ) adjustl ( trim ( cc )), \"reservedzone           \" ; call empty ( cc ) if ( xyz ) then do i = 0 , surf % nofpoints - 1 write ( k , * ) mod ( i , surf % xres ) * surf % dx , ( i / surf % xres ) * surf % dy , surf % val ( i + 1 ) * surf % dz enddo endif close ( k ) return endsubroutine trans_surf_txt !========================================================================================= !< @note !<   Subroutine that opens a ```.sur``` file and transfers it contents into an object [[OBJ_SURF]] !< @endnote !< !< @warning !<    By default here, the heights are not written with ```dump=.true.``` !< @endwarning !----------------------------------------------------------------------------------------- subroutine open_surffile ( fichier , surf , scal , dump ) implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be read* type ( OBJ_SURF ), intent ( out ) :: surf !! *object that will contain the file infos and heights* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* logical ( kind = I4 ), optional , intent ( in ) :: dump !! *whether to transform the data in a text file* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: scal_x , scal_y , scal_z character ( kind = C_CHAR ) :: charact call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"read\" , & ! position = \"rewind\" , & ! convert = 'little_endian' ,& ! status = 'old' ) read ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone do i = 1 , surf % comment_size read ( k ) charact enddo allocate ( surf % val ( 1 : surf % nofpoints ) ) do i = 1 , surf % nofpoints read ( k ) surf % val ( i ) enddo close ( k ) call surf2scal ( surf , scal ) if ( present ( dump ). and . dump ) call trans_surf_txt ( surf , trim ( fichier ) // '.txt' , xyz = . false .) return endsubroutine open_surffile function lower ( s1 ) result ( s2 ) !! Converts uppercase to lowercase, adapted from [here](http://fortranwiki.org/fortran/show/String_Functions) character ( * ), intent ( in ) :: s1 !! *string to transform to lower case* character ( len ( s1 )) :: s2 !! *result: same string but each character is lower case* character ( len = 1 ) :: ch integer ( kind = I4 ), parameter :: duc = ichar ( 'A' ) - ichar ( 'a' ) integer ( kind = I4 ) :: i do i = 1 , len ( s1 ) ch = s1 ( i : i ) if ( ch >= 'A' . and . ch <= 'Z' ) ch = char ( ichar ( ch ) - duc ) s2 ( i : i ) = ch enddo return endfunction lower function unit2IUc ( string ) result ( met ) !! Convert a C type unit string into value (m) implicit none real ( kind = R8 ) :: met character ( kind = C_CHAR ), dimension (:), intent ( in ) :: string character ( len = 2 ) :: chaine chaine = string ( 1 ) // string ( 2 ) met = unit2IUf ( chaine ) return endfunction unit2IUc function unit2IUf ( string ) result ( met ) !! Convert a unit string into value (m) implicit none real ( kind = R8 ) :: met character ( * ), intent ( in ) :: string select case ( string ) case ( 'm' ) met = 1.e+00_R8 case ( 'cm' ) met = 1.e-02_R8 case ( 'mm' ) met = 1.e-03_R8 case ( 'µm' ) met = 1.e-06_R8 case ( 'µ' ) met = 1.e-06_R8 case ( 'nm' ) met = 1.e-09_R8 case ( 'pm' ) met = 1.e-12_R8 case ( 'Pa' ) met = 1.e+00_R8 case ( 'MP' ) met = 1.e+06_R8 case ( 'GP' ) met = 1.e+09_R8 case default if ( string ( 1 : 1 ) == '%' ) then met = 1.e-02_R8 else met = 1 endif endselect return endfunction unit2IUf subroutine trans_surf_tab ( surf , tab ) !! Write the heights of an [[OBJ_SURF]] object into a 2D array implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` that contains the heights* real ( kind = R8 ), dimension (:, :), allocatable , intent ( out ) :: tab !! *height array* integer ( kind = I4 ) :: long , larg , i , j , k real ( kind = R8 ) :: unit_z long = surf % xres larg = surf % yres allocate ( tab ( 1 : long , 1 : larg ) ) unit_z = unit2IUc ( surf % dz_unit ) do j = 1 , larg do i = 1 , long k = ( j - 1 ) * long + i tab ( i , j ) = ( surf % val ( k ) * surf % dz + surf % Zoffset ) * unit_z enddo enddo deallocate ( surf % val ) return endsubroutine trans_surf_tab !========================================================================================= !< @note !<   Subroutine that opens a surface file ```.sur``` or ```.dat``` !< !<   The heights are centred, scaled then put into a vector. !< @endnote !< !< @warning !<    If the scale factor ```sq``` is negative, the heights are not scaled when reading ```.sur``` !< @endwarning !< !< @warning !<    By default, the ```.sur``` header is dumped !< @endwarning !----------------------------------------------------------------------------------------- subroutine read_surf ( nom_fic , mu , sq , tab_s , scal ) implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* real ( kind = R8 ), intent ( in ), optional :: mu !! *desired mean* real ( kind = R8 ), intent ( in ), optional :: sq !! *desired height standard deviation* type ( SCALE_SURF ), intent ( out ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension (:,:), allocatable , intent ( out ) :: tab_s !! *height array* integer ( kind = I4 ) :: style , i , ii , j , jj , k , nb , eof , tmp , nx , ny real ( kind = R8 ) :: sqs , mean , dz , lx , ly , lz type ( OBJ_SURF ) :: surf character ( len = 3 ) :: ext real ( kind = R8 ), dimension (:), allocatable :: x , y , z i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call open_surffile ( fichier = trim ( nom_fic ), surf = surf , scal = scal , dump = . false .) call trans_surf_tab ( surf = surf , tab = tab_s ) case ( SURF_DAT ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) nb = 0 do read ( k , * , iostat = eof ) if ( eof /= 0 ) exit nb = nb + 1 enddo rewind ( k ) allocate ( x ( 1 : nb ) ) allocate ( y ( 1 : nb ) ) allocate ( z ( 1 : nb ) ) do i = 1 , nb read ( k , * ) x ( i ), y ( i ), z ( i ) enddo close ( k ) ! the triplet x, y, z is sorted according x !----------------------------------------------------------- call sort_array2 ( tab_inout = x ( 1 : nb ), & ! tab1 = y ( 1 : nb ), & ! tab2 = z ( 1 : nb ), n = nb ) ! i = 1 do if ( abs ( x ( i ) - x ( 1 )) > 100 * EPS_R8 ) exit i = i + 1 enddo scal % dx = abs ( x ( i ) - x ( 1 )) j = 1 do if ( abs ( x ( j + 1 ) - x ( j )) > 1.0e-10 ) exit j = j + 1 enddo ny = j ! number of same abscissae for a given column if ( mod ( nb , ny ) /= 0 ) STOP 'READ_SURF, non rectangular mesh' nx = nb / ny scal % xres = nx scal % yres = ny do i = 1 , nx ii = ( i - 1 ) * ny + 1 jj = ii + ny - 1 call sort_array2 ( tab_inout = y ( ii : jj ), & ! tab1 = z ( ii : jj ), n = jj - ii + 1 ) ! enddo j = 1 do if ( abs ( y ( j ) - y ( 1 )) > 100 * EPS_R8 ) exit j = j + 1 enddo scal % dy = abs ( y ( j ) - y ( 1 )) allocate ( tab_s ( 1 : nx , 1 : ny ) ) k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 tab_s ( i , j ) = z ( k ) enddo enddo lx = maxval ( x ) - minval ( x ) ly = maxval ( y ) - minval ( y ) lz = maxval ( tab_s ) - minval ( tab_s ) scal % dz = lz / ( nx * ny ) scal % xlength_unit = 'm ' ; scal % dx_unit = 'm ' scal % ylength_unit = 'm ' ; scal % dy_unit = 'm ' scal % zlength_unit = 'm ' ; scal % dz_unit = 'm ' !call sort_real(g=1, d=nx*ny, rtabref=z(1:nx*ny)) !scal%dz = 1.e+10 !do i = 2, nx*ny !   dz = z(i) -z(i-1) !   if (abs(dz) < 100*EPS_R8) cycle !   scal%dz = min(scal%dz, dz) !enddo !scal%dz = dz deallocate ( x , y , z ) endselect nx = scal % xres ny = scal % yres scal % mu = sum ( tab_s ( 1 : nx , 1 : ny ) ) / ( nx * ny ) scal % si = ( sum ( ( tab_s ( 1 : nx , 1 : ny ) - scal % mu ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) ! centering ? if ( present ( mu ) ) then tab_s ( 1 : nx , 1 : ny ) = ( tab_s ( 1 : nx , 1 : ny ) - scal % mu ) + mu endif ! scaling ? if ( present ( sq ) ) then mean = sum ( tab_s ( 1 : nx , 1 : ny ) ) / ( nx * ny ) sqs = ( sum ( ( tab_s ( 1 : nx , 1 : ny ) - mean ) ** 2 ) / ( nx * ny )) ** ( 0.5_R8 ) tab_s ( 1 : nx , 1 : ny ) = sq * ( tab_s ( 1 : nx , 1 : ny ) - mean ) / sqs + mean endif return endsubroutine read_surf subroutine build_surf ( surf , tab ) !! Creates an object [[OBJ_SURF]] from an array implicit none type ( OBJ_SURF ), intent ( inout ) :: surf !! *resulting object ```OBJ_SURF```* real ( kind = R8 ), dimension ( 1 : surf % xres , 1 : surf % yres ), intent ( in ) :: tab integer ( kind = I4 ) :: i , j , k , nx , ny real ( kind = R8 ) :: max_n , min_t , max_t , mil_t , amp_t , unit_x , unit_y , unit_z nx = surf % xres ny = surf % yres surf % nofpoints = nx * ny unit_x = unit2IUc ( surf % dx_unit ) unit_y = unit2IUc ( surf % dy_unit ) unit_z = unit2IUc ( surf % dz_unit ) if ( allocated ( surf % val )) deallocate ( surf % val ) allocate ( surf % val ( 1 : surf % nofpoints )) min_t = minval ( tab ( 1 : nx , 1 : ny ) ) / unit_z max_t = maxval ( tab ( 1 : nx , 1 : ny ) ) / unit_z mil_t = 0.5_R8 * ( min_t + max_t ) ! middle of the range amp_t = max_t - min_t ! range amplitude surf % ZOffset = mil_t max_n = 0.5 * huge ( 1 ) ! the heights are integers, allowed to span ! half the positive integer range. surf % dz = amp_t / max_n ! subsequent dz k = 0 do j = 1 , ny do i = 1 , nx k = k + 1 surf % val ( k ) = nint ( ( tab ( i , j ) / unit_z - surf % ZOffset ) / surf % dz ) ! enddo enddo surf % zmin = minval ( surf % val ) surf % zmax = maxval ( surf % val ) return endsubroutine build_surf subroutine write_surffile ( fichier , surf ) !! Write an object [[OBJ_SURF]] in a file implicit none character ( len =* ), intent ( in ) :: fichier !! *file to be written* type ( OBJ_SURF ), intent ( inout ) :: surf !! *object ```OBJ_SURF``` to write* integer ( kind = I4 ) :: i , k call get_unit ( k ) open ( k , file = trim ( fichier ), & ! form = 'unformatted' , & ! access = \"stream\" , & ! beware the \"frecord-marker\" in other modes action = \"write\" , & ! position = \"rewind\" , & ! status = \"replace\" , & ! convert = 'little_endian' ) write ( k ) surf % signature , surf % format , surf % nobjects , surf % version , surf % type , surf % object_name , & surf % operator_name , surf % material_code , surf % acquisition , surf % range , surf % special_points , & surf % absolute , surf % reserved , surf % pointsize , surf % zmin , surf % zmax , surf % xres , surf % yres , & surf % nofpoints , surf % dx , surf % dy , surf % dz , surf % xaxis , surf % yaxis , surf % zaxis , surf % dx_unit , & surf % dy_unit , surf % dz_unit , surf % xlength_unit , surf % ylength_unit , surf % zlength_unit , & surf % xunit_ratio , surf % yunit_ratio , surf % zunit_ratio , surf % imprint , surf % inversion , surf % leveling , & surf % obsolete , surf % seconds , surf % minutes , surf % hours , surf % day , surf % month , surf % year , surf % dayof , & surf % measurement_duration , surf % obsolete2 , surf % comment_size , surf % private_size , surf % client_zone , & surf % XOffset , surf % YOffset , surf % ZOffset , surf % reservedzone , & ( surf % val ( i ), i = 1 , surf % nofpoints ) close ( k ) return endsubroutine write_surffile subroutine write_surf ( nom_fic , tab_s , scal ) !! Writes a height array into a surface file ```.sur``` or ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* type ( SCALE_SURF ), intent ( inout ) :: scal !! *object [[SCALE_SURF]]* real ( kind = R8 ), dimension ( 1 : scal % xres , 1 : scal % yres ), intent ( in ) :: tab_s character ( len = 3 ) :: ext integer ( kind = I4 ) :: style , i , j , k type ( OBJ_SURF ) :: surf_s real ( kind = R8 ) :: dx , dy i = len_trim ( nom_fic ) ext = lower ( nom_fic ( i - 2 : i ) ) if ( ext == 'dat' ) style = SURF_DAT if ( ext == 'sur' ) style = SURF_SUR select case ( style ) case ( SURF_SUR ) call scal2surf ( scal , surf_s ) call build_surf ( surf = surf_s , tab = tab_s ( 1 : scal % xres , 1 : scal % yres )) surf_s % comment_size = 0 ! to increase compatibility with mountains surf_s % material_code = 1 ! to increase compatibility with mountains surf_s % type = 2 ! to increase compatibility with mountains surf_s % range = 0 ! to increase compatibility with mountains surf_s % imprint = 0 ! to increase compatibility with mountains call write_surffile ( fichier = trim ( nom_fic ), surf = surf_s ) call surf2scal ( surf_s , scal ) case ( SURF_DAT ) dx = scal % dx dy = scal % dy call get_unit ( k ) open ( k , file = trim ( nom_fic )) do i = 1 , scal % xres do j = 1 , scal % yres write ( k , * ) ( i - 1 ) * dx , ( j - 1 ) * dy , tab_s ( i , j ) enddo enddo close ( k ) endselect return endsubroutine write_surf endmodule surfile !============ EN TETE TYPIQUE !~  \"DIGITAL SURF\" !~  0 !~  1 !~  1 !~  2 !~  \"* 16-774-lm1-pnm bouches *\" !~  \"\" !~  0 !~  0 !~  0 !~  0 !~  1 !~  \"\" !~  32 !~  -19122091 !~  4341882 !~  512 !~  512 !~  262144 !~  3.55476077E-04 !~  3.54291551E-04 !~  3.25564076E-10 !~  \"X\" !~  \"Y\" !~  \"Z\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  \"mm\" !~  1.00000000 !~  1.00000000 !~  1.00000000 !~  0 !~  0 !~  0 !~  \"\" !~  0 !~  0 !~  0 !~  0 !~  0 !~  0 !~  0 !~  0.00000000 !~  \"\" !~  0 !~  0 !~  \"\" !~   0.00000000 !~   0.00000000 !~  -0.00000000 !~  \"\" !~","tags":"","loc":"sourcefile/mod_surfile.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~7~~EfferentGraph sourcefile~prg.f90~7 prg.f90 sourcefile~mod_files.f90 mod_files.f90 sourcefile~prg.f90~7->sourcefile~mod_files.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_files.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: february, 27 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Some routines to deal with files. Example of use** !<  </span> !< program test_files use files implicit none logical ( kind = 4 ) :: dir_exists integer ( kind = 4 ) :: exit_status , i_g character ( len = :), allocatable :: slogan , str character ( len = 512 ), allocatable , dimension (:) :: vpath character ( len = 512 ), allocatable , dimension (:) :: list_f90 character ( len = 512 ) :: path , cwd , str_tmp character ( len = 1 ) :: os_sep write ( * , * ) 'Give a sting from which spaces and hyphen have to be removed' read ( * , '(a)' ) str_tmp str = str_remove_chars ( string = trim ( str_tmp ), chars = '- ' ) write ( * , * ) str path = \"/my_name/is bond/james/bond/  .007\" call path2vec ( file_path = trim ( path ), vec_path = vpath ) write ( * , * ) size ( vpath ), ' folders in path' write ( * , '(*(a))' ) ( trim ( vpath ( i_g )), ' | ' , i_g = 1 , ubound ( vpath , 1 ) ) call vec2path ( file_path = str , vec_path = vpath ) write ( * , * ) 'complete path: ' , trim ( str ) write ( * , * ) 'file is: \"' , filename ( trim ( path ) ), '\"' deallocate ( str ) !=================================== write ( * , * ) '----------------------' !=================================== call getcwd ( cwd ) call make_path ( wkd = trim ( cwd ), file_path = \"out/a/b/c/d/file.txt\" , exit_status = exit_status ) !=================================== write ( * , * ) '----------------------' !=================================== call list_files ( dir = \"div\" , list = list_f90 , ext = \"f90\" ) do i_g = 1 , ubound ( list_f90 , 1 ) write ( * , * ) trim ( list_f90 ( i_g ) ) enddo !=================================== write ( * , * ) '----------------------' !=================================== slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 0 ) ! first instance only write ( * , * ) slogan slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 1 ) ! last instance only write ( * , * ) slogan slogan = str_replace ( string = 'think different, think Linux' , & ! old_str = 'think' , & ! new_str = 'be' , & ! place = 2 ) ! both instances write ( * , * ) slogan !=================================== write ( * , * ) '----------------------' !=================================== os_sep = dir_separator () write ( * , * ) 'The local directory separator is:' , os_sep !=================================== write ( * , * ) '----------------------' !=================================== call getcwd ( path ) write ( * , * ) 'The working directory is: ' , trim ( path ) !=================================== write ( * , * ) '----------------------' !=================================== call mkdir ( wkd = trim ( path ), directory = 'scratch' , sep = os_sep , exit_status = exit_status ) inquire ( file = 'scratch' , exist = dir_exists ) if ( dir_exists ) then write ( * , * ) 'Directory ''scratch'' successfuly created' else write ( * , * ) 'Directory ''scratch'' not created' endif !=================================== write ( * , * ) '----------------------' !=================================== call chdir ( \"scratch\" ) call getcwd ( path ) write ( * , * ) 'The new working directory is: ' , trim ( path ) !=================================== write ( * , * ) '----------------------' !=================================== endprogram test_files","tags":"","loc":"sourcefile/prg.f90~7.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~8~~EfferentGraph sourcefile~prg.f90~8 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~8->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~8->sourcefile~mod_miscellaneous.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~prg.f90~8->sourcefile~mod_sort_arrays.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.1 !<  date: feb, 24 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Various routines to sort real/integer arrays. Example of use.** !<  </span> program main use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use sort_arrays , only : sort_array2 , init_order implicit none integer ( kind = I4 ), parameter :: n = 100 real ( kind = R8 ), dimension ( n ) :: vec_real1 , vec_real2 real ( kind = R8 ), dimension ( n ) :: vec_sol_real1 , vec_sol_real2 integer ( kind = I4 ), dimension ( n ) :: vec_int1 , vec_int2 , vec_order integer ( kind = I4 ), dimension ( n ) :: vec_sol_int1 , vec_sol_int2 , vec_sol_order integer ( kind = I4 ) :: i , k , u10 , u20 real ( kind = R8 ) :: r !=============== Sort an integer vector, and other vectors with the same order ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_int1 ( i ), vec_real1 ( i ), & ! vec_int2 ( i ), vec_real2 ( i ), k ! enddo close ( u10 ) ! ------------- sort with respect to the first column (integer values) call sort_array2 ( tab_inout = vec_int1 ( 1 : n ), & ! tab1 = vec_real1 ( 1 : n ), & ! tab2 = vec_int2 ( 1 : n ), & ! tab3 = vec_real2 ( 1 : n ), n = n ) ! ! ------------- get solution call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col1_int.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_sol_int1 ( i ), vec_sol_real1 ( i ), & ! vec_sol_int2 ( i ), vec_sol_real2 ( i ), k ! enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_ordered_vec_col1_int.csv' ) do i = 1 , n write ( u20 , * ) vec_int1 ( i ) - vec_sol_int1 ( i ), vec_real1 ( i ) - vec_sol_real1 ( i ), & ! vec_int2 ( i ) - vec_sol_int2 ( i ), vec_real2 ( i ) - vec_sol_real2 ( i ) enddo !----------------------------- REMARK -------------------------------------- ! As the sorted vector is integers, some values may be identical, leading to ! several possibilities for the subsequently sorted vectors. Look elements ! 9 and 10 for example. !--------------------------------------------------------------------------- close ( u20 ) !=============== Sort a real vector, and other vectors with the same order ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_int1 ( i ), vec_real1 ( i ), & ! vec_int2 ( i ), vec_real2 ( i ), k ! enddo close ( u10 ) ! ------------- sort with respect to the second column (real values) call sort_array2 ( tab_inout = vec_real1 ( 1 : n ), & ! tab1 = vec_int1 ( 1 : n ), & ! tab2 = vec_int2 ( 1 : n ), & ! tab3 = vec_real2 ( 1 : n ), n = n ) ! ! ------------- get solution call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col2_real.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) vec_sol_int1 ( i ), vec_sol_real1 ( i ), & ! vec_sol_int2 ( i ), vec_sol_real2 ( i ), k ! enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_ordered_vec_col2_real.csv' ) do i = 1 , n write ( u20 , * ) vec_int1 ( i ) - vec_sol_int1 ( i ), vec_real1 ( i ) - vec_sol_real1 ( i ), & ! vec_int2 ( i ) - vec_sol_int2 ( i ), vec_real2 ( i ) - vec_sol_real2 ( i ) ! enddo close ( u20 ) !=============== Sort a real vector and return the order vector ! ------------- get non ordered vectors call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/non_ordered_vec.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) k , vec_real1 ( i ), k , r , k enddo close ( u10 ) ! ------------- sort with respect to the second column (real values, same case as above) call init_order ( order = vec_order ( 1 : n ), n = n ) call sort_array2 ( tab_inout = vec_real1 ( 1 : n ), & ! tab0 = vec_order ( 1 : n ), n = n ) ! ! ------------- get solution of order call get_unit ( u10 ) ; open ( unit = u10 , file = 'try/ordered_vec_col2_real.csv' ) read ( u10 , * ) ! column name do i = 1 , n read ( u10 , * ) k , r , k , r , vec_sol_order ( i ) enddo close ( u10 ) ! ------------- compare call get_unit ( u20 ) ; open ( unit = u20 , file = 'out/res_order_vec.csv' ) do i = 1 , n write ( u20 , * ) vec_order ( i ) - vec_sol_order ( i ) enddo close ( u20 ) stop endprogram main","tags":"","loc":"sourcefile/prg.f90~8.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~9~~EfferentGraph sourcefile~prg.f90~9 prg.f90 sourcefile~mod_minpack.f90 mod_minpack.f90 sourcefile~prg.f90~9->sourcefile~mod_minpack.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: John Burkardt !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **A fortran collection of functions for minimization problems. Example of use.** !< </span> program test_minpack use minpack !*****************************************************************************80 ! ! minpack_test() tests minpack(). ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    02 January 2018 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) call timestamp ( ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'minpack_test():' write ( * , '(a)' ) '  FORTRAN90 version' write ( * , '(a)' ) '  Test minpack().' call chkder_test ( ) call hybrd1_test ( ) call hybrj1_test ( ) call lmder1_test ( ) call lmder1_2_test ( ) call lmdif1_test ( ) call lmdif1_2_test ( ) call lmstr1_test ( ) call lmstr1_2_test ( ) call qform_test ( ) ! !  Terminate. ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'minpack_test():' write ( * , '(a)' ) '  Normal end of execution.' write ( * , '(a)' ) ' ' call timestamp ( ) stop 0 contains subroutine chkder_test ( ) !*****************************************************************************80 ! !! CHKDER_TEST tests CHKDER. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 5 integer , parameter :: m = n integer , parameter :: ldfjac = n real ( kind = rk ) err ( m ) real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) real ( kind = rk ) fvecp ( m ) integer i integer ido integer iflag integer mode real ( kind = rk ) x ( n ) real ( kind = rk ) xp ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'CHKDER_TEST' write ( * , '(a)' ) '  CHKDER compares a user supplied jacobian' write ( * , '(a)' ) '  and a finite difference approximation to it' write ( * , '(a)' ) '  and judges whether the jacobian is correct.' do ido = 1 , 2 if ( ido == 1 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  On the first test, use a correct jacobian.' else if ( ido == 2 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Repeat the test, but use a \"bad\" jacobian' write ( * , '(a)' ) '  and see if the routine notices!' end if ! !  Set the point at which the test is to be made: ! x ( 1 : n ) = 0.5D+00 call r8vec_print ( n , x , '  Evaluation point X:' ) mode = 1 call chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) iflag = 1 call chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) call chkder_f ( n , xp , fvecp , fjac , ldfjac , iflag ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Sampled function values F(X) and F(XP)' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(i3,2g14.6)' ) i , fvec ( i ), fvecp ( i ) end do iflag = 2 call chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) ! !  Here's where we put a mistake into the jacobian, on purpose. ! if ( ido == 2 ) then fjac ( 1 , 1 ) = 1.01D+00 * fjac ( 1 , 1 ) fjac ( 2 , 3 ) = - fjac ( 2 , 3 ) end if write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  Computed jacobian' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(5g14.6)' ) fjac ( i , 1 : n ) end do mode = 2 call chkder ( m , n , x , fvec , fjac , ldfjac , xp , fvecp , mode , err ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) '  CHKDER gradient component error estimates:' write ( * , '(a)' ) '     > 0.5, the component is probably correct.' write ( * , '(a)' ) '     < 0.5, the component is probably incorrect.' write ( * , '(a)' ) ' ' do i = 1 , m write ( * , '(i6,g14.6)' ) i , err ( i ) end do end do return end subroutine chkder_f ( n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! CHKDER_F is a function/jacobian routine for use with CHKDER_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    17 May 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer i integer iflag integer j real ( kind = rk ) prod real ( kind = rk ) x ( n ) ! !  If IFLAG is 0, print out X (and anything else about this iterate). ! if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do ! !  If IFLAG is 1, we are supposed to evaluate F(X). ! else if ( iflag == 1 ) then do i = 1 , n - 1 fvec ( i ) = x ( i ) - real ( n + 1 , kind = rk ) + sum ( x ( 1 : n ) ) end do fvec ( n ) = product ( x ( 1 : n ) ) - 1.0D+00 ! !  If IFLAG is 2, we are supposed to evaluate FJAC(I,J) = d F(I)/d X(J) ! else if ( iflag == 2 ) then fjac ( 1 : n - 1 , 1 : n ) = 1.0D+00 do i = 1 , n - 1 fjac ( i , i ) = 2.0D+00 end do prod = product ( x ( 1 : n ) ) do j = 1 , n fjac ( n , j ) = prod / x ( j ) end do end if return end subroutine hybrd1_test ( ) !*****************************************************************************80 ! !! HYBRD1_TEST tests HYBRD1. ! !  Discussion: ! !    This is an example of what your main program would look !    like if you wanted to use MINPACK to solve N nonlinear equations !    in N unknowns.  In this version, we avoid computing the jacobian !    matrix, and request that MINPACK approximate it for us. ! !    The set of nonlinear equations is: ! !      x1&#94;2 - 10 * x1 + x2&#94;2 + 8 = 0 !      x1 * x2&#94;2 + x1 - 10 * x2 + 8 = 0 ! !    with solution x1 = x2 = 1 ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 2 !~   external hybrd1_f real ( kind = rk ) fvec ( n ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'HYBRD1_TEST' write ( * , '(a)' ) '  HYBRD1 solves a nonlinear system of equations.' x ( 1 : 2 ) = ( / 3.0D+00 , 0.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) call hybrd1_f ( n , x , fvec , iflag ) call r8vec_print ( n , fvec , '  Initial F(X):' ) tol = 0.00001D+00 call hybrd1 ( hybrd1_f , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  Final X:' ) call r8vec_print ( n , fvec , '  Final F(X):' ) return end subroutine hybrd1_f ( n , x , fvec , iflag ) !*****************************************************************************80 ! !! HYBRD1_F is a function routine for use with HYBRD1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    John Burkardt ! !  Input: ! !    integer N, the number of variables. ! !    real ( kind = rk ) X(N), the variable values. ! !  Output: ! !    real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    integer IFLAG, error flag. !    If IFLAG < 0, an error has occurred and the computation should stop. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer n real ( kind = rk ) fvec ( n ) integer iflag real ( kind = rk ) x ( n ) fvec ( 1 ) = x ( 1 ) * x ( 1 ) - 1 0.0D+00 * x ( 1 ) + x ( 2 ) * x ( 2 ) + 8.0D+00 fvec ( 2 ) = x ( 1 ) * x ( 2 ) * x ( 2 ) + x ( 1 ) - 1 0.0D+00 * x ( 2 ) + 8.0D+00 iflag = 1 return end subroutine hybrj1_test ( ) !*****************************************************************************80 ! !! HYBRJ1_TEST tests HYBRJ1. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: n = 2 integer , parameter :: ldfjac = n !~   external hybrj1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'HYBRJ1_TEST' write ( * , '(a)' ) '  HYBRJ1 solves a nonlinear system of equations.' x ( 1 : 2 ) = ( / 3.0D+00 , 0.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) call hybrd1_f ( n , x , fvec , iflag ) call r8vec_print ( n , fvec , '  F(X):' ) tol = 0.00001D+00 call hybrj1 ( hybrj1_f , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( n , fvec , '  F(X):' ) return end subroutine hybrj1_f ( n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! HYBRJ1_F is a function/jacobian routine for use with HYBRJ1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( n ) integer i integer iflag real ( kind = rk ) x ( n ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 ) = x ( 1 ) * x ( 1 ) - 1 0.0D+00 * x ( 1 ) + x ( 2 ) * x ( 2 ) + 8.0D+00 fvec ( 2 ) = x ( 1 ) * x ( 2 ) * x ( 2 ) + x ( 1 ) - 1 0.0D+00 * x ( 2 ) + 8.0D+00 else if ( iflag == 2 ) then fjac ( 1 , 1 ) = 2.0D+00 * x ( 1 ) - 1 0.0D+00 fjac ( 1 , 2 ) = 2.0D+00 * x ( 2 ) fjac ( 2 , 1 ) = x ( 2 ) * x ( 2 ) + 1.0D+00 fjac ( 2 , 2 ) = 2.0D+00 * x ( 1 ) * x ( 2 ) - 1 0.0D+00 end if return end subroutine lmder1_test ( ) !*****************************************************************************80 ! !! LMDER1_TEST tests LMDER1. ! !  Discussion: ! !    LMDER1 solves M nonlinear equations in N unknowns, with M >= N. ! !    LMDER1 seeks a solution X minimizing the euclidean norm of the residual. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y = a * x + b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x+b*y+c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1+b*2+c*3 + d*9  + e = 0 !      a*1+b*3+c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    31 October 2005 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 integer , parameter :: ldfjac = m !~   external lmder1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_TEST' write ( * , '(a)' ) '  LMDER1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmder1 ( lmder1_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmder1_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! LMDER1_F is a function/jacobian routine for use with LMDER1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Input: ! !    integer N, the number of variables. ! !    real ( kind = rk ) X(N), the variable values. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! !  Output: ! !    real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer m integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), parameter , dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), parameter , dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) else if ( iflag == 2 ) then fjac ( 1 : m , 1 ) = xdat ( 1 : m ) fjac ( 1 : m , 2 ) = 1.0D+00 else write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_F - Fatal error!' write ( * , '(a,i6)' ) '  Called with unexpected value of IFLAG = ' , iflag stop end if return end subroutine lmder1_2_test ( ) !*****************************************************************************80 ! !! LMDER1_2_TEST tests LMDER1. ! !  Discussion: ! !    LMDER1 solves M nonlinear equations in n unknowns, where M is greater !    than N.  The functional fit is nonlinear this time, of the form ! !      y=a+b*x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 integer , parameter :: ldfjac = m !~   external lmder1_2_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDER1_2_TEST' write ( * , '(a)' ) '  LMDER1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmder1_2_f ( m , n , x , fvec , fjac , ldfjac , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmder1 ( lmder1_2_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmder1_2_f ( m , n , x , fvec , fjac , ldfjac , iflag ) !*****************************************************************************80 ! !! LMDER1_2_F is a function/jacobian routine for use with LMDER1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(N), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJAC(LDFJAC,N), the N by N jacobian at X, !    if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute FJAC(I,J) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer ldfjac integer m integer n real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) else if ( iflag == 2 ) then fjac ( 1 : m , 1 ) = 1.0D+00 fjac ( 1 : m , 2 ) = xdat ( 1 : m ) ** x ( 3 ) fjac ( 1 : m , 3 ) = x ( 2 ) * log ( xdat ( 1 : m ) ) * xdat ( 1 : m ) ** x ( 3 ) end if return end subroutine lmdif1_test ( ) !*****************************************************************************80 ! !! LMDIF1_TEST tests LMDIF1. ! !  Discussion: ! !    LMDIF1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  Generally, you cannot get a solution vector x which will satisfy !    all the equations.  That is, the vector equation f(x)=0 cannot !    be solved exactly.  Instead, minpack seeks a solution x so that !    the euclidean norm transpose(f(x))*f(x) is minimized.  The size !    of the euclidean norm is a measure of how good the solution is. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y=a*x+b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x+b*y+c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1+b*2+c*3 + d*9  + e = 0 !      a*1+b*3+c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 !~   external lmdif1_f real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDIF1_TEST' write ( * , '(a)' ) '  LMDIF1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmdif1_f ( m , n , x , fvec , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmdif1 ( lmdif1_f , m , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmdif1_f ( m , n , x , fvec , iflag ) !*****************************************************************************80 ! !! LMDIF1_F is a function routine for use with LMDIF1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) end if return end subroutine lmdif1_2_test ( ) !*****************************************************************************80 ! !! LMDIF1_2_TEST tests LMDIF1. ! !  Discussion: ! !    LMDIF1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  It is similar to test02, except that the functional fit is !    nonlinear this time, of the form ! !      y = a + b * x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 !~   external lmdif1_2_f real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMDIF1_2_TEST' write ( * , '(a)' ) '  LMDIF1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  X:' ) iflag = 1 call lmdif1_2_f ( m , n , x , fvec , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmdif1 ( lmdif1_2_f , m , n , x , fvec , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmdif1_2_f ( m , n , x , fvec , iflag ) !*****************************************************************************80 ! !! LMDIF1_2_F is a function routine for use with LMDIF1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fvec ( m ) integer i integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 0 ) then write ( * , '(a)' ) '' do i = 1 , n write ( * , '(g14.6)' ) x ( i ) end do else if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) end if return end subroutine lmstr1_test ( ) !*****************************************************************************80 ! !! LMSTR1_TEST tests LMSTR1. ! !  Discussion: ! !    LMSTR1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  Generally, you cannot get a solution vector x which will satisfy !    all the equations.  That is, the vector equation f(x)=0 cannot !    be solved exactly.  Instead, minpack seeks a solution x so that !    the euclidean norm transpose(f(x))*f(x) is minimized.  The size !    of the euclidean norm is a measure of how good the solution is. ! !    In this example, the set of equations is actually linear, but !    normally they are nonlinear. ! !    In this problem, we have a set of pairs of data points, and we !    seek a functional relationship between them.  We assume the !    relationship is of the form ! !      y=a*x+b ! !    and we want to know the values of a and b.  Therefore, we would like !    to find numbers a and b which satisfy a set of equations. ! !    The data points are (2,2), (4,11), (6,28) and (8,40). ! !    Therefore, the equations we want to satisfy are: ! !      a * 2 + b -  2 = 0 !      a * 4 + b - 11 = 0 !      a * 6 + b - 28 = 0 !      a * 8 + b - 40 = 0 ! !    The least squares solution of this system is a=6.55, b=-12.5, !    In other words, the line y=6.55*x-12.5 is the line which \"best\" !    models the data in the least squares sense. ! !    Problems with more variables, or higher degree polynomials, would !    be solved similarly.  For example, suppose we have (x,y,z) data, !    and we wish to find a relationship of the form f(x,y,z).  We assume !    that x and y occur linearly, and z quadratically.  Then the equation !    we seek has the form: ! !      a*x + b*y + c*z + d*z*z + e = 0 ! !    and, supposing that our first two points were (1,2,3), (1,3,8), our set of !    equations would begin: ! !      a*1 + b*2 + c*3 + d*9  + e = 0 !      a*1 + b*3 + c*8 + d*64 + e = 0 ! !    and so on. ! !    M is the number of equations, which in this case is the number of !    (x,y) data values. ! !    N is the number of variables, which in this case is the number of !    'free' coefficients in the relationship we are trying to determine. ! !    Thanks to Jacques Le Bourlot for pointing out that the line !      integer fjrow !    should instead read !      real ( kind = rk ) fjrow(n) !    19 August 2016 ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    19 August 2016 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 4 integer , parameter :: n = 2 integer , parameter :: ldfjac = m !~   external lmstr1_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMSTR1_TEST' write ( * , '(a)' ) '  LMSTR1 minimizes M functions in N variables.' x ( 1 : 2 ) = ( / 0.0D+00 , 5.0D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmstr1_f ( m , n , x , fvec , fjrow , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmstr1 ( lmstr1_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmstr1_f ( m , n , x , fvec , fjrow , iflag ) !*****************************************************************************80 ! !! LMSTR1_F is a function/jacobian routine for use with LMSTR1_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions, and the !    number of rows in the jacobian. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJROW(N), space to return one row !    of the jacobian,  if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute row (I-1) of the jacobian and return it in FJROW. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 4 ) :: xdat = ( / & 2.0D+00 , 4.0D+00 , 6.0D+00 , 8.0D+00 / ) real ( kind = rk ), dimension ( 4 ) :: ydat = ( / & 2.0D+00 , 1 1.0D+00 , 2 8.0D+00 , 4 0.0D+00 / ) if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) * xdat ( 1 : m ) + x ( 2 ) - ydat ( 1 : m ) else if ( 2 <= iflag ) then fjrow ( 1 ) = xdat ( iflag - 1 ) fjrow ( 2 ) = 1.0D+00 end if return end subroutine lmstr1_2_test ( ) !*****************************************************************************80 ! !! LMSTR1_2_TEST tests LMSTR1. ! !  Discussion: ! !    LMSTR1 solves M nonlinear equations in N unknowns, where M is greater !    than N.  This test is similar to test02, except that the functional fit !    is nonlinear this time, of the form ! !      y = a + b * x&#94;c, ! !    with x and y data, and a, b and c unknown. ! !    This problem is set up so that the data is exactly fit by by !    a=1, b=3, c=2.  Normally, the data would only be approximately !    fit by the best possible solution. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 10 integer , parameter :: n = 3 integer , parameter :: ldfjac = m !~   external lmstr1_2_f real ( kind = rk ) fjac ( ldfjac , n ) real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag integer info real ( kind = rk ) tol real ( kind = rk ) x ( n ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'LMSTR1_2_TEST' write ( * , '(a)' ) '  LMSTR1 minimizes M functions in N variables.' x ( 1 : 3 ) = ( / 0.0D+00 , 5.0D+00 , 1.3D+00 / ) call r8vec_print ( n , x , '  Initial X:' ) iflag = 1 call lmstr1_2_f ( m , n , x , fvec , fjrow , iflag ) call r8vec_print ( m , fvec , '  F(X):' ) tol = 0.00001D+00 call lmstr1 ( lmstr1_2_f , m , n , x , fvec , fjac , ldfjac , tol , info ) write ( * , '(a)' ) ' ' write ( * , '(a,i6)' ) '  Returned value of INFO = ' , info call r8vec_print ( n , x , '  X:' ) call r8vec_print ( m , fvec , '  F(X):' ) return end subroutine lmstr1_2_f ( m , n , x , fvec , fjrow , iflag ) !*****************************************************************************80 ! !! LMSTR1_2_F is a function/jacobian routine for use with LMSTR1_2_TEST. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    30 December 2004 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, integer M, the number of functions, and the !    number of rows in the jacobian. ! !    Input, integer N, the number of variables. ! !    Input, real ( kind = rk ) X(N), the variable values. ! !    Output, real ( kind = rk ) FVEC(M), the function values at X, !    if IFLAG = 1. ! !    Output, real ( kind = rk ) FJROW(N), space to return one row !    of the jacobian,  if IFLAG = 2. ! !    Input, integer LDFJAC, the leading dimension of FJAC, !    which must be at least N. ! !    Input, integer IFLAG: !    0, user requests printout of current iterate X. !    1, please compute F(I) (X). !    2, please compute row (I-1) of the jacobian and return it in FJROW. ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer m integer n real ( kind = rk ) fjrow ( n ) real ( kind = rk ) fvec ( m ) integer iflag real ( kind = rk ) x ( n ) real ( kind = rk ), dimension ( 10 ) :: xdat = ( / & 1.0D+00 , 2.0D+00 , 3.0D+00 , 4.0D+00 , 5.0D+00 , & 6.0D+00 , 7.0D+00 , 8.0D+00 , 9.0D+00 , 1 0.0D+00 / ) real ( kind = rk ), dimension ( 10 ) :: ydat = ( / & 4.0D+00 , 1 3.0D+00 , 2 8.0D+00 , 4 9.0D+00 , 7 6.0D+00 , & 10 9.0D+00 , 14 8.0D+00 , 19 3.0D+00 , 24 4.0D+00 , 30 1.0D+00 / ) if ( iflag == 1 ) then fvec ( 1 : m ) = x ( 1 ) + x ( 2 ) * xdat ( 1 : m ) ** x ( 3 ) - ydat ( 1 : m ) else if ( 2 <= iflag ) then fjrow ( 1 ) = 1.0D+00 fjrow ( 2 ) = xdat ( iflag - 1 ) ** x ( 3 ) fjrow ( 3 ) = x ( 2 ) * log ( xdat ( iflag - 1 ) ) * xdat ( iflag - 1 ) ** x ( 3 ) end if return end subroutine qform_test ( ) !*****************************************************************************80 ! !! QFORM_TEST tests QFORM. ! !  Licensing: ! !    This code is distributed under the GNU LGPL license. ! !  Modified: ! !    02 January 2018 ! !  Author: ! !    John Burkardt ! implicit none integer , parameter :: rk = kind ( 1.0D+00 ) integer , parameter :: m = 5 integer , parameter :: n = 7 integer , parameter :: lda = m real ( kind = rk ) a ( lda , n ) real ( kind = rk ) a2 ( m , n ) real ( kind = rk ) acnorm ( n ) integer ipivot ( n ) integer j integer k integer lipvt logical pivot real ( kind = rk ) q ( m , m ) real ( kind = rk ) r ( m , n ) real ( kind = rk ) rdiag ( n ) write ( * , '(a)' ) '' write ( * , '(a)' ) 'QFORM_TEST:' write ( * , '(a)' ) '  QFORM constructs the Q factor explicitly' write ( * , '(a)' ) '  after the use of QRFAC.' ! !  Set the matrix A. ! call random_number ( harvest = a ( 1 : m , 1 : n ) ) call r8mat_print ( m , n , a , '  Matrix A:' ) ! !  Compute the QR factors. ! pivot = . false . lipvt = n call qrfac ( m , n , a , lda , pivot , ipivot , lipvt , rdiag , acnorm ) ! !  Extract the R factor. ! r ( 1 : m , 1 : n ) = 0.0D+00 do k = 1 , min ( m , n ) r ( k , k ) = rdiag ( k ) end do do j = 1 , n r ( 1 : min ( j - 1 , m ), j ) = a ( 1 : min ( j - 1 , m ), j ) end do call r8mat_print ( m , n , r , '  Matrix R:' ) ! !  Call QRFORM to form the Q factor. ! q ( 1 : m , 1 : m ) = 0.0D+00 q ( 1 : m , 1 : min ( m , n )) = a ( 1 : m , 1 : min ( m , n )) call qform ( m , n , q , m ) call r8mat_print ( m , m , q , '  Matrix Q:' ) ! !  Compute Q*R. ! a2 = matmul ( q , r ) ! !  Compare Q*R to A. ! call r8mat_print ( m , n , a2 , '  Matrix A2 = Q * R:' ) return end !~ subroutine r8mat_print ( m, n, a, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8MAT_PRINT prints an R8MAT. !~ ! !~ !  Discussion: !~ ! !~ !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    12 September 2004 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer M, the number of rows in A. !~ ! !~ !    Input, integer N, the number of columns in A. !~ ! !~ !    Input, real ( kind = rk ) A(M,N), the matrix. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer m !~   integer n !~   real ( kind = rk ) a(m,n) !~   character ( len = * ) title !~   call r8mat_print_some ( m, n, a, 1, 1, m, n, title ) !~   return !~ end !~ subroutine r8mat_print_some ( m, n, a, ilo, jlo, ihi, jhi, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8MAT_PRINT_SOME prints some of an R8MAT. !~ ! !~ !  Discussion: !~ ! !~ !    An R8MAT is an MxN array of R8's, stored by (I,J) -> [I+J*M]. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    10 September 2009 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer M, N, the number of rows and columns. !~ ! !~ !    Input, real ( kind = rk ) A(M,N), an M by N matrix to be printed. !~ ! !~ !    Input, integer ILO, JLO, the first row and column to print. !~ ! !~ !    Input, integer IHI, JHI, the last row and column to print. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer, parameter :: incx = 5 !~   integer m !~   integer n !~   real ( kind = rk ) a(m,n) !~   character ( len = 14 ) ctemp(incx) !~   integer i !~   integer i2hi !~   integer i2lo !~   integer ihi !~   integer ilo !~   integer inc !~   integer j !~   integer j2 !~   integer j2hi !~   integer j2lo !~   integer jhi !~   integer jlo !~   character ( len = * ) title !~   write ( *, '(a)' ) ' ' !~   write ( *, '(a)' ) trim ( title ) !~   if ( m <= 0 .or. n <= 0 ) then !~     write ( *, '(a)' ) ' ' !~     write ( *, '(a)' ) '  (None)' !~     return !~   end if !~   do j2lo = max ( jlo, 1 ), min ( jhi, n ), incx !~     j2hi = j2lo + incx - 1 !~     j2hi = min ( j2hi, n ) !~     j2hi = min ( j2hi, jhi ) !~     inc = j2hi + 1 - j2lo !~     write ( *, '(a)' ) ' ' !~     do j = j2lo, j2hi !~       j2 = j + 1 - j2lo !~       write ( ctemp(j2), '(i8,6x)' ) j !~     end do !~     write ( *, '(''  Col   '',5a14)' ) ctemp(1:inc) !~     write ( *, '(a)' ) '  Row' !~     write ( *, '(a)' ) ' ' !~     i2lo = max ( ilo, 1 ) !~     i2hi = min ( ihi, m ) !~     do i = i2lo, i2hi !~       do j2 = 1, inc !~         j = j2lo - 1 + j2 !~         if ( a(i,j) == real ( int ( a(i,j) ), kind = rk ) ) then !~           write ( ctemp(j2), '(f8.0,6x)' ) a(i,j) !~         else !~           write ( ctemp(j2), '(g14.6)' ) a(i,j) !~         end if !~       end do !~       write ( *, '(i5,a,5a14)' ) i, ':', ( ctemp(j), j = 1, inc ) !~     end do !~   end do !~   return !~ end !~ subroutine r8vec_print ( n, a, title ) !~ !*****************************************************************************80 !~ ! !~ !! R8VEC_PRINT prints an R8VEC. !~ ! !~ !  Discussion: !~ ! !~ !    An R8VEC is a vector of R8's. !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    22 August 2000 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~ !  Parameters: !~ ! !~ !    Input, integer N, the number of components of the vector. !~ ! !~ !    Input, real ( kind = rk ) A(N), the vector to be printed. !~ ! !~ !    Input, character ( len = * ) TITLE, a title. !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   integer n !~   real ( kind = rk ) a(n) !~   integer i !~   character ( len = * ) title !~   write ( *, '(a)' ) ' ' !~   write ( *, '(a)' ) trim ( title ) !~   write ( *, '(a)' ) ' ' !~   do i = 1, n !~     write ( *, '(2x,i8,2x,g16.8)' ) i, a(i) !~   end do !~   return !~ end !~ subroutine timestamp ( ) !~ !*****************************************************************************80 !~ ! !~ !! TIMESTAMP prints the current YMDHMS date as a time stamp. !~ ! !~ !  Example: !~ ! !~ !    31 May 2001   9:45:54.872 AM !~ ! !~ !  Licensing: !~ ! !~ !    This code is distributed under the GNU LGPL license. !~ ! !~ !  Modified: !~ ! !~ !    18 May 2013 !~ ! !~ !  Author: !~ ! !~ !    John Burkardt !~ ! !~   implicit none !~   integer, parameter :: rk = kind ( 1.0D+00 ) !~   character ( len = 8 ) ampm !~   integer d !~   integer h !~   integer m !~   integer mm !~   character ( len = 9 ), parameter, dimension(12) :: month = (/ & !~     'January  ', 'February ', 'March    ', 'April    ', & !~     'May      ', 'June     ', 'July     ', 'August   ', & !~     'September', 'October  ', 'November ', 'December ' /) !~   integer n !~   integer s !~   integer values(8) !~   integer y !~   call date_and_time ( values = values ) !~   y = values(1) !~   m = values(2) !~   d = values(3) !~   h = values(5) !~   n = values(6) !~   s = values(7) !~   mm = values(8) !~   if ( h < 12 ) then !~     ampm = 'AM' !~   else if ( h == 12 ) then !~     if ( n == 0 .and. s == 0 ) then !~       ampm = 'Noon' !~     else !~       ampm = 'PM' !~     end if !~   else !~     h = h - 12 !~     if ( h < 12 ) then !~       ampm = 'PM' !~     else if ( h == 12 ) then !~       if ( n == 0 .and. s == 0 ) then !~         ampm = 'Midnight' !~       else !~         ampm = 'AM' !~       end if !~     end if !~   end if !~   write ( *, '(i2.2,1x,a,1x,i4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & !~     d, trim ( month(m) ), y, h, ':', n, ':', s, '.', mm, trim ( ampm ) !~   return !~ end endprogram test_minpack","tags":"","loc":"sourcefile/prg.f90~9.html"},{"title":"mod_tchebychev.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_tchebychev.f90~~EfferentGraph sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_least_squares.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_tchebychev.f90~~AfferentGraph sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: february, 27 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Routines to subtract a least square polynomial from a surface** !<  </span> module tchebychev use data_arch , only : I4 , R8 use miscellaneous , only : get_unit use least_squares , only : moindres_carres_lineaire !$ use omp_lib implicit none private public :: tcheby , tab_tcheby , tab_poly_tcheby , tab_Jf_tcheby , coeff_tcheby_vers_monome , coeff_tcheby_xy_vers_monome , & ! coeff_poly_tcheby_xy_vers_poly_monome , least_squares_tcheby contains !================================================================================================== !< @note !< Valeur en x du polynôme de Tchebichev de degré n !< !<  !< P_n(x)=\\sum_{i=1}&#94;{n}\\left[ 2&#94;{i-1} t_i x&#94;i +\\sum_{k=1}&#94;{i/2} \\frac{i(i-k-1)!}{k!(i-2k)!} (-1)&#94;k 2&#94;{i-2k-1} t_i x&#94;{i-2k} \\right] !<  !< [Site](http://fr.wikipedia.org/wiki/Polynômes_de_Tchebychev) !< @endnote !================================================================================================== function tcheby ( n , x ) implicit none real ( kind = R8 ) :: tcheby integer ( kind = I4 ), intent ( in ) :: n !! *degré du polynôme* real ( kind = R8 ), intent ( in ) :: x !! *variable* integer ( kind = I4 ) :: k , kk real ( kind = R8 ) :: y , tmp if ( n == 0 ) then tcheby = 1._R8 return endif tmp = 0. do k = 1 , n / 2 y = 1._R8 do kk = 1 , k - 1 y = y * ( real (( n - k - kk ), kind = R8 ) / kk ) enddo tmp = tmp + y * (( - 1 ) ** k ) * (( 2 * x ) ** ( n - 2 * k )) / k enddo tcheby = (( 2 * x ) ** n ) / 2 + n * tmp / 2. return endfunction tcheby !================================================================================================== !< @note !<  Valeurs tabulées de polynômes de Tchebychev !< !<  On se donne des points xi le long d'UN axe et on calcule les valeurs d'un !<  polynôme de Tchebychev de degré j en ces points. !< @endnote !================================================================================================== subroutine tab_tcheby ( deg , nx , vec_x , tab_tche ) implicit none integer ( kind = I4 ), intent ( in ) :: deg !! *degré max du polynôme* integer ( kind = I4 ), intent ( in ) :: nx !! *nbre de points de calcul* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx ) :: vec_x !! *vecteur des points de calcul* real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: tab_tche !! *tableau des valeurs calculées* integer ( kind = I4 ) :: i , j real ( kind = R8 ) :: xi allocate ( tab_tche ( 1 : nx , 1 : deg + 1 ) ) do i = 1 , nx xi = vec_x ( i ) ! points de l'axe do j = 0 , deg ! pour UN degré de polynôme donné, valeurs en ces points tab_tche ( i , j + 1 ) = tcheby ( j , xi ) enddo enddo return endsubroutine tab_tcheby !================================================================================================== !< @note !<  Surface définie par un produit de polynômes de Tchebychev en x et y !< !<  Le domaine étant discrétisé et UN ensemble de coefficients donnés (provenant !<  d'une approximation par moindres carrés) on a la valeur de la fonction surface en chaque point. !< !< @endnote !================================================================================================== subroutine tab_poly_tcheby ( nx1 , nx2 , nvarx , nvary , nb_var , tab_tche1 , tab_tche2 , var , tab_poly_tche , multi_thread ) implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *nbre de coefficients* integer ( kind = I4 ), intent ( in ) :: nx1 !! *nbre de points de calcul selon x* integer ( kind = I4 ), intent ( in ) :: nx2 !! *nbre de points de calcul selon y* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré max de Tchebychev utilisé selon x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré max de Tchebychev utilisé selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx1 , 1 : nvarx + 1 ) :: tab_tche1 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx2 , 1 : nvary + 1 ) :: tab_tche2 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_var ) :: var !! *vecteur des coefficients* real ( kind = R8 ), intent ( out ), dimension ( 1 : nx1 , 1 : nx2 ) :: tab_poly_tche !! *tableau résultant : surface* logical ( kind = I4 ), intent ( in ), optional :: multi_thread real ( kind = R8 ) :: tmp1 , tmp2 integer ( kind = I4 ) :: ivar , jvar , ij , ipt , jpt , ibatch , nb_threads logical ( kind = I4 ) :: mlth mlth = . false . if ( present ( multi_thread ) ) mlth = multi_thread ! surface d'UN produit de polynômes de tchebytchev nb_threads = omp_get_num_procs () ibatch = max ( nx2 / nb_threads , 1 ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_threads) IF(mlth) !$OMP DO SCHEDULE (STATIC,ibatch) PRIVATE(ipt, tmp1, ij, jvar, tmp2, ivar) do jpt = 1 , nx2 do ipt = 1 , nx1 ! Un dommaine discrétisé (nx+1)*(nx+1) est balayé tmp1 = 0._R8 ij = 0 ! chaque point est unique do jvar = 0 , nvary ! En chaque point, la fonction calculée est le produit des sommes tmp2 = 0._R8 !  de polynômes de Tchebychev. En effet l'approximation est faite do ivar = 0 , nvarx !  avec UN polynôme à variables séparées. ij = ij + 1 tmp2 = tmp2 + var ( ij ) * tab_tche1 ( ipt , ivar + 1 ) enddo tmp1 = tmp1 + tmp2 * tab_tche2 ( jpt , jvar + 1 ) enddo tab_poly_tche ( ipt , jpt ) = tmp1 enddo enddo !$OMP END DO !$OMP END PARALLEL return endsubroutine tab_poly_tcheby subroutine tab_Jf_tcheby ( nx1 , nx2 , nb_pts , nvarx , nvary , nb_var , tab_tche1 , tab_tche2 , tab_Jf , imask , multi_thread ) !! Tableau des dérivées par rapport aux coefficients de tab_tche implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *nombre de fonctions de base utilisées* integer ( kind = I4 ), intent ( in ) :: nx1 !! *nbre de points de calcul selon x* integer ( kind = I4 ), intent ( in ) :: nx2 !! *nbre de points de calcul selon y* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *nbre de points* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré max de Tchebychev utilisé selon x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré max de Tchebychev utilisé selon y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx1 , 1 : nvarx + 1 ) :: tab_tche1 !! *tableau des valeurs calculées* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx2 , 1 : nvary + 1 ) :: tab_tche2 !! *tableau des valeurs calculées* integer ( kind = I4 ), intent ( in ), dimension ( 1 : nx1 , 1 : nx2 ), optional :: imask !! *masque* real ( kind = R8 ), intent ( out ), allocatable , dimension (:,:) :: tab_Jf !! *tableau des dérivées* logical ( kind = I4 ), intent ( in ), optional :: multi_thread integer ( kind = I4 ) :: ivar , jvar , ij , ipt , jpt , ijpt , ibatch , nb_threads logical ( kind = I4 ) :: lmask logical ( kind = I4 ) :: mlth mlth = . false . if ( present ( multi_thread ) ) mlth = multi_thread nb_threads = omp_get_num_procs () ibatch = max ( nx2 / nb_threads , 1 ) lmask = present ( imask ) allocate ( tab_Jf ( 1 : nb_pts , 1 : nb_var ) ) ! table des dérivées des poly par rapport aux coeff, c'est donc UN produit de polynômes !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(nb_threads) IF(mlth) !$OMP DO SCHEDULE (STATIC,ibatch) PRIVATE(ijpt, ipt, jpt, ij, ivar, jvar) do jpt = 1 , nx2 do ipt = 1 , nx1 if ( lmask ) then if ( imask ( ipt , jpt ) == 0 ) cycle endif ijpt = ( jpt - 1 ) * nx1 + ipt ij = 0 do jvar = 0 , nvary do ivar = 0 , nvarx ij = ij + 1 tab_Jf ( ijpt , ij ) = tab_tche1 ( ipt , ivar + 1 ) * tab_tche2 ( jpt , jvar + 1 ) enddo enddo enddo enddo !$OMP END DO !$OMP END PARALLEL return endsubroutine tab_Jf_tcheby !================================================================================================== !< @note !<  Transformation des coefficients de Tchebychev en coefficients de monômes !< !<  Un monôme de degré p reçoit de Ti(x) (polynôme de Tcheby de degré i) : !<   !<  2&#94;{i-1} t_i \\text{ si i=p} !<   !< !<   !<  m(p)=m(p)+\\frac{i(i-k-1)!}{k!(i-2k)!} (-1)&#94;k 2&#94;{i-2k-1} t(i) \\text{ si } i=2k+p !<   !< !< @endnote !================================================================================================== subroutine coeff_tcheby_vers_monome ( coeff_t , coeff_m , deg ) implicit none integer ( kind = I4 ), intent ( in ) :: deg !! *degré du polynôme* real ( kind = R8 ), intent ( in ), dimension ( 0 : deg ) :: coeff_t !! *coefficients de la CL de polynômes de Tchebychev* real ( kind = R8 ), intent ( out ), dimension ( 0 : deg ) :: coeff_m !! *coefficients de la CL de monômes* integer ( kind = I4 ) :: k , n , p , q real ( kind = R8 ) :: tkm2q , tmp n = deg coeff_m ( 0 : deg ) = 0._R8 select case ( n ) case ( 0 ) coeff_m ( 0 ) = coeff_t ( 0 ) case ( 1 ) coeff_m ( 0 : 1 ) = [ coeff_t ( 0 ) , coeff_t ( 1 ) ] case ( 2 ) coeff_m ( 0 : 2 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) , 2 * coeff_t ( 2 ) ] case ( 3 ) coeff_m ( 0 : 3 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) - 3 * coeff_t ( 3 ), 2 * coeff_t ( 2 ), 4 * coeff_t ( 3 ) ] case ( 4 :) coeff_m ( 0 : 3 ) = [ coeff_t ( 0 ) - coeff_t ( 2 ), coeff_t ( 1 ) - 3 * coeff_t ( 3 ), 2 * coeff_t ( 2 ), 4 * coeff_t ( 3 ) ] do k = 4 , n q = 0 coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * ( 2 ** ( k - 1 )) q = 1 coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * ( - k / 2._R8 ) * ( 2 ** ( k - 2 )) do q = 2 , k / 2 tmp = 1._R8 do p = 1 , q - 1 tmp = tmp * ( ( k - q - p ) / ( 1._R8 * p ) ) enddo tkm2q = ( k / 2._R8 ) * (( - 1 ) ** q ) * ( 2 ** ( k - 2 * q )) * ( 1._R8 / q ) * tmp coeff_m ( k - 2 * q ) = coeff_m ( k - 2 * q ) + coeff_t ( k ) * tkm2q enddo enddo endselect return endsubroutine coeff_tcheby_vers_monome subroutine coeff_tcheby_xy_vers_monome ( tab_coeff_m , deg_x , deg_y ) !!  Transformation du produit ti(x) \\cdot tj(y) de Tchebychev en coefficients de monômes x&#94;i \\cdot y&#94;j implicit none integer ( kind = I4 ), intent ( in ) :: deg_x !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: deg_y !! *degré du polynôme en y* real ( kind = R8 ), intent ( out ), dimension ( 0 : deg_x , 0 : deg_y ) :: tab_coeff_m !! *coefficients de la CL de monômes x&#94;i * y&#94;j* integer ( kind = I4 ) :: i , j real ( kind = R8 ), dimension ( 0 : deg_x ) :: coeff_tx , coeff_mx real ( kind = R8 ), dimension ( 0 : deg_y ) :: coeff_ty , coeff_my ! single Tchebychev polynomial, deg_x coeff_tx ( 0 : deg_x ) = 0._R8 coeff_tx ( deg_x ) = 1._R8 call coeff_tcheby_vers_monome ( coeff_tx ( 0 : deg_x ), coeff_mx ( 0 : deg_x ), deg_x ) ! single Tchebychev polynomial, deg_y coeff_ty ( 0 : deg_y ) = 0._R8 coeff_ty ( deg_y ) = 1._R8 call coeff_tcheby_vers_monome ( coeff_ty ( 0 : deg_y ), coeff_my ( 0 : deg_y ), deg_y ) tab_coeff_m ( 0 : deg_x , 0 : deg_y ) = 0._R8 do j = 0 , deg_y do i = 0 , deg_x tab_coeff_m ( i , j ) = coeff_mx ( i ) * coeff_my ( j ) enddo enddo return endsubroutine coeff_tcheby_xy_vers_monome subroutine coeff_poly_tcheby_xy_vers_poly_monome ( var , coeff_m , deg_x , deg_y ) !! Transformation d'une CL de produits de polynômes de Tchebychev en x et y en polynôme classique implicit none integer ( kind = I4 ), intent ( in ) :: deg_x !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: deg_y !! *degré du polynôme en y* real ( kind = R8 ), intent ( in ), dimension ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) :: var !! *coefficients du produits de polynômes de Tchebychev* real ( kind = R8 ), intent ( out ), dimension ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) :: coeff_m !! *coefficients du polynôme classique en x et y* integer ( kind = I4 ) :: i , j , ij real ( kind = R8 ), dimension ( 0 : deg_x , 0 : deg_y ) :: tab_poly__m , tab_coeff_m coeff_m ( 1 :( deg_x + 1 ) * ( deg_y + 1 )) = 0._R8 tab_poly__m ( 0 : deg_x , 0 : deg_y ) = 0._R8 ij = 0 do j = 0 , deg_y do i = 0 , deg_x ij = ij + 1 call coeff_tcheby_xy_vers_monome ( tab_coeff_m ( 0 : i , 0 : j ), deg_x = i , deg_y = j ) tab_coeff_m ( 0 : i , 0 : j ) = var ( ij ) * tab_coeff_m ( 0 : i , 0 : j ) tab_poly__m ( 0 : i , 0 : j ) = tab_poly__m ( 0 : i , 0 : j ) + tab_coeff_m ( 0 : i , 0 : j ) enddo enddo ij = 0 do j = 0 , deg_y do i = 0 , deg_x ij = ij + 1 coeff_m ( ij ) = tab_poly__m ( i , j ) enddo enddo return endsubroutine coeff_poly_tcheby_xy_vers_poly_monome !~    !================================================================================================== !~    !> @brief         Même principe que Tchebychev avec des monômes (plus simple, mais moindres     \\n !~    !> @return        polynome résultat : fonction en (xi, yi) !~    !================================================================================================== !~    real(kind=R8) function polynome(xi, yi, var, nb_var) !~    implicit none !~    integer(kind=I4), intent(in) :: nb_var    !! nombre de fonctions de base utilisées !~    real(kind=R8),    intent(in) :: xi        !! abscisse d'un points !~    real(kind=R8),    intent(in) :: yi        !! ordonnée d'un points !~    real(kind=R8),    intent(in), dimension(1:nb_var) :: var    !! vecteur des coefficients !~       real(kind=R8)    :: tmp1, tmp2 !~       integer(kind=I4) :: ivar, jvar, nvar, ij !~       nvar = nint(sqrt(real(nb_var, kind = R8))) -1 !~       tmp1 = 0._R8 !~       ij   = 0 !~       do ivar = 0, nvar !~          tmp2 = 0._R8 !~          do jvar = 0, nvar !~             ij = ij +1 !~             tmp2 = tmp2 +var(ij)*(yi**jvar) !~          enddo !~          tmp1 = tmp1 +tmp2*(xi**ivar) !~       enddo !~       polynome = tmp1 !~    return !~    endfunction polynome !~    !================================================================================================== !~    !> @brief         Même principe que Tchebychev !~    !> @return        dpolynome polynôme dérivé !~    !================================================================================================== !~    real(kind=R8) function dpolynome(xi, yi, nb_var, ind) !~    implicit none !~    integer(kind=I4), intent(in) :: nb_var !! nombre de fonctions de base utilisées !~    integer(kind=I4), intent(in) :: ind    !! indice par rapport auquel on dérive !~    real(kind=R8),    intent(in) :: xi     !! abscisse d'un points !~    real(kind=R8),    intent(in) :: yi     !! ordonnée d'un points !~       integer(kind=I4) :: ivar, jvar, nvar, ij !~       nvar = nint(sqrt(real(nb_var, kind = R8))) -1 !~       ij   = 0 !~       dpolynome = 0 !~       do ivar = 0, nvar !~          do jvar = 0, nvar !~             ij = ij +1 !~             if (ij==ind) then !~                dpolynome = (xi**ivar)*(yi**jvar) !~                return !~             endif !~          enddo !~       enddo !~    return !~    endfunction dpolynome !~    !================================================================================================== !~    !> @brief         Vérification des approximations par moindres carrés avec des polynômes !~    !================================================================================================== !~    subroutine verif_pol(tab1, tab2, var, long, larg, nb_var) !~    implicit none !~    integer(kind=I4), intent(in   ) :: long      !! taille x de la grille !~    integer(kind=I4), intent(in   ) :: larg      !! taille y de la grille !~    integer(kind=I4), intent(in   ) :: nb_var    !! nombre de fonctions de base utilisées !~    real(kind=R8),    intent(inout), dimension(1:long, 1:larg) :: tab1   !! surface dont on a fait une approximation !~    real(kind=R8),    intent(  out), dimension(1:long, 1:larg) :: tab2   !! approximation par moindres carrés !~    real(kind=R8),    intent(in   ), dimension(1:nb_var)       :: var    !! vecteur des coefficients !~       real(kind=R8)    :: xi, yi, x !~       integer(kind=I4) :: i, j !~       do j = 1, larg !~       do i = 1, long !~          xi = real(i-1, kind=R8)/(long -1) !~          yi = real(j-1, kind=R8)/(larg -1) !~          x = polynome(xi, yi, var, nb_var) !~          tab1(i, j) = tab1(i, j) -x !~          tab2(i, j) = x !~       enddo !~       enddo !~    return !~    endsubroutine verif_pol !~    !================================================================================================== !~    !> @brief         Vérification des approximations par moindres carrés avec des polynômes de Tcheby !~    !================================================================================================== !~    subroutine verif_tch(tab1, tab2, long, larg, tab_poly_tche) !~    implicit none !~    integer(kind=I4), intent(in   ) :: long      !! taille x de la grille !~    integer(kind=I4), intent(in   ) :: larg      !! taille y de la grille !~    real(kind=R8),    intent(inout), dimension(1:long, 1:larg)     :: tab1           !! surface dont on a fait une approximation qui lui est soustraite !~    real(kind=R8),    intent(  out), dimension(1:long, 1:larg)     :: tab2           !! approximation par moindres carrés !~    real(kind=R8),    intent(in   ), dimension(1:long+1, 1:larg+1) :: tab_poly_tche  !! surface dont on a fait une approximation !~       real(kind=R8)    :: x !~       integer(kind=I4) :: i, j !~       do j = 1, larg !~       do i = 1, long !~          x = tab_poly_tche(i, j) !~          tab1(i, j) = tab1(i, j) -x !~          tab2(i, j) = x !~       enddo !~       enddo !~    return !~    endsubroutine verif_tch !~    !================================================================================================== subroutine least_squares_tcheby ( tab_in , tab_out , long1 , long2 , nvarx , nvary , imask , verif , multi_thread ) !! Resulting polynomial surface, determined by linear least squares implicit none integer ( kind = I4 ), intent ( in ) :: long1 !! *taille x* integer ( kind = I4 ), intent ( in ) :: long2 !! *taille y* integer ( kind = I4 ), intent ( in ) :: nvarx !! *degré du polynôme en x* integer ( kind = I4 ), intent ( in ) :: nvary !! *degré du polynôme en y* real ( kind = R8 ), intent ( in ), dimension ( 1 : long1 , 1 : long2 ) :: tab_in !! *surface dont on a fait une approximation qui lui est soustraite* real ( kind = R8 ), intent ( out ), dimension ( 1 : long1 , 1 : long2 ) :: tab_out !! *tableau résultant : surface* integer ( kind = I4 ), intent ( in ), dimension ( 1 : long1 , 1 : long2 ), optional :: imask !! *masque* logical ( kind = I4 ), intent ( in ) , optional :: verif !! *dump* logical ( kind = I4 ), intent ( in ) , optional :: multi_thread !! *use multithread?* real ( kind = R8 ), allocatable , dimension (:) :: var1 , vec_x1 , vec_x2 , vec_hij real ( kind = R8 ), allocatable , dimension (:,:) :: tab_tche1 , tab_tche2 , Jf real ( kind = R8 ), dimension ( 1 :( nvarx + 1 ) * ( nvary + 1 )) :: coeff_mxy integer ( kind = I4 ) :: i , iu , nbvar , nbpts character ( len = 128 ) :: string if ( nvarx == 0 . and . nvary == 0 ) then tab_out ( 1 : long1 , 1 : long2 ) = 0._R8 return endif nbvar = ( nvarx + 1 ) * ( nvary + 1 ) if ( present ( imask )) then nbpts = sum ( imask ) else nbpts = long1 * long2 endif allocate ( var1 ( 1 : nbvar ) ) allocate ( vec_x1 ( 1 : long1 ), vec_x2 ( 1 : long2 ) ) var1 = 0 do i = 1 , long1 vec_x1 ( i ) = - 1. + ( i - 1 ) * 2. / ( long1 - 1 ) !real(i-long1/2, kind=R8)/(long1/2) enddo do i = 1 , long2 vec_x2 ( i ) = - 1. + ( i - 1 ) * 2. / ( long2 - 1 ) !real(i-long2/2, kind=R8)/(long2/2) enddo call tab_tcheby ( deg = nvarx , nx = long1 , vec_x = vec_x1 ( 1 : long1 ), tab_tche = tab_tche1 ) call tab_tcheby ( deg = nvary , nx = long2 , vec_x = vec_x2 ( 1 : long2 ), tab_tche = tab_tche2 ) call tab_Jf_tcheby ( nx1 = long1 , & ! nx2 = long2 , & ! nb_pts = nbpts , & ! nvarx = nvarx , & ! nvary = nvary , & ! nb_var = nbvar , & ! tab_tche1 = tab_tche1 ( 1 : long1 , 1 : nvarx + 1 ), & ! tab_tche2 = tab_tche2 ( 1 : long2 , 1 : nvary + 1 ), & ! tab_Jf = Jf , & ! imask = imask ( 1 : long1 , 1 : long2 ), & ! multi_thread = multi_thread ) ! allocate ( vec_hij ( 1 : nbpts )) if ( present ( imask )) then vec_hij ( 1 : nbpts ) = pack ( tab_in ( 1 : long1 , 1 : long2 ), mask = ( imask ( 1 : long1 , 1 : long2 ) == 1 )) else vec_hij ( 1 : nbpts ) = reshape ( tab_in ( 1 : long1 , 1 : long2 ), shape = [ nbpts ]) endif call moindres_carres_lineaire ( nb_var = nbvar , & ! nb_pts = nbpts , & ! hij = vec_hij ( 1 : nbpts ), & ! beta = var1 ( 1 : nbvar ), & ! Jf = Jf ( 1 : nbpts , 1 : nbvar )) ! deallocate ( vec_hij ) if ( present ( verif ) . and . verif ) then call coeff_poly_tcheby_xy_vers_poly_monome ( var = var1 ( 1 : nbvar ), & ! coeff_m = coeff_mxy ( 1 : nbvar ), & ! deg_x = nvarx , & ! deg_y = nvary ) ! write ( string , '(a,i3.3,a)' ) '(' , nbvar , 'E18.8,a)' call get_unit ( iu ) open ( iu , file = 'verif_tcheby_vers_monome.txt' ) write ( iu , trim ( string )) ( coeff_mxy ( i ), i = 1 , nbvar ), \" coeff tchebychev\" ! à ce stade on a les coefficients var1(:) tels que : ! surface_approchante(x,y) = var1(1).t0(x)t0(y) +var1(2).t1(x)t0(y) +var1(3).t2(x)t0(y) +...+var1(nvarx+1 +1).t0(x)t1(y) +...+var1(nbvar).t_{nvarx+1}(x)t_{nvary+1}(y) write ( iu , '(a)' ) 'pour vérifier avec gwyddion, il faut préalablement décocher \"surface carrée\", donner à l''image un facteur d''échelle x et y identiques, ' // & ! 'et mettre un décalage pour que x soit compris entre -1 et 1 tout comme y. ' // & ! 'coeff_mxy donne les coeffs de 1 x x&#94;2 x&#94;3 ... x&#94;i y xy x&#94;2.y ...x&#94;i.y&#94;j' close ( iu ) endif call tab_poly_tcheby ( nx1 = long1 , & ! nx2 = long2 , & ! nvarx = nvarx , & ! nvary = nvary , & ! nb_var = nbvar , & ! tab_tche1 = tab_tche1 ( 1 : long1 , 1 : nvarx + 1 ), & ! tab_tche2 = tab_tche2 ( 1 : long2 , 1 : nvary + 1 ), & ! var = var1 ( 1 : nbvar ), & ! tab_poly_tche = tab_out ( 1 : long1 , 1 : long2 ), & ! multi_thread = multi_thread ) ! deallocate ( Jf ) deallocate ( vec_x1 , vec_x2 ) deallocate ( var1 ) deallocate ( tab_tche1 , tab_tche2 ) return endsubroutine least_squares_tcheby endmodule tchebychev","tags":"","loc":"sourcefile/mod_tchebychev.f90.html"},{"title":"mod_cholesky.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_cholesky.f90~~EfferentGraph sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_cholesky.f90~~AfferentGraph sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~prg.f90~13 prg.f90 sourcefile~prg.f90~13->sourcefile~mod_cholesky.f90 sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_least_squares.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_least_squares.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !< version: 1.0.0 !< date: November, 16 2024 !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<       **Cholesky decomposition and resolution** !< </span> !<# Description !< The Cholesky decomposition is a method for solving systems of linear equations, particularly when the coefficient matrix is symmetric and positive definite. The method involves decomposing the matrix into a product of a lower triangular matrix and its transpose. !< <div><button class=\"collapsible\">More ...</button> !< <div class=\"content\"> !< !< Here's a detailed description of the Cholesky method for solving the system  Ax = b . !< <p></p> !< <h4> Decompose  A  </h4> !< <p></p> !< Given a symmetric positive definite matrix  A , we can decompose it to find  L  in  A = L L&#94;T , where  L  is a lower triangular matrix. !< <p></p> !< <h4> Forward Substitution </h4> !< <p></p> !< Solve the system  Ly = b  for  y . This can be done using forward substitution since  L  is a lower triangular matrix. !< !<  y_1 = \\frac{b_1}{L_{11}} \\qquad y_2 = \\frac{b_2 - L_{21}y_1}{L_{22}} \\qquad y_3 = \\frac{b_3 - L_{31}y_1 - L_{32}y_2}{L_{33}}  \\ldots  !< <p></p> !< <h4> Backward Substitution </h4> !< <p></p> !< Once  y  is found, solve the system  L&#94;T x = y  for  x  using backward substitution since  L&#94;T  is an upper triangular matrix. !< !<  x_n = \\frac{y_n}{L_{nn}} \\qquad x_{n-1} = \\frac{y_{n-1} - L_{n-1,n}x_n}{L_{n-1,n-1}} \\qquad x_{n-2} = \\frac{y_{n-2} - L_{n-2,n-1}x_{n-1} - L_{n-2,n}x_n}{L_{n-2,n-2}}  \\ldots  !< !< </div> !< </div> !< !< {!css/button.html!} module cholesky use data_arch , only : I4 , R8 implicit none private public :: choldc , cholsl contains subroutine choldc ( a , n , np , p , info ) !================================================================================================ !<@note Given a positive definite symmetric matrix a(1:n,1:n), with !< physical dimensions np, this routine constructs its Cholesky !< decomposition, A=L L&#94;T. On input, only the upper triangle of !< a need to be given; it is not modified. The Cholesky factor L !< is returned in the lower triangle of a, except for its diagonal !< elements which are returned in p(1:n). !< !< (c) Numerical recipes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *system size* integer ( kind = I4 ), intent ( in ) :: np !! *matrix size* integer ( kind = I4 ), intent ( out ) :: info !! *information ouput* real ( kind = R8 ), intent ( inout ), dimension ( np , np ) :: a !! *system matrix* real ( kind = R8 ), intent ( out ), dimension ( np ) :: p !! *diagonal elements* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: ssum info = 0 o : do i = 1 , n do j = i , n ssum = a ( i , j ) do k = i - 1 , 1 , - 1 ssum = ssum - a ( i , k ) * a ( j , k ) enddo if ( i == j ) then if ( ssum <= 0. ) then info = 1 p ( np ) = 0._R8 p ( 1 ) = - ssum exit o endif p ( i ) = sqrt ( ssum ) else a ( j , i ) = ssum / p ( i ) endif enddo enddo o return endsubroutine choldc subroutine cholsl ( a , n , np , p , b , x , info ) !================================================================================================ !<@note Solves the set of linear equations A x = b, where A is a positive- !< definite symmetric matrix with physical dimensions np. A and P are !< are input as the output from choldc. Only the lower triangle of A !< is accessed. B(1:n) is inout as the right-hand side vector. The !< solution vector is returned in X(1:n). A, n, np, and P are not !< modified and can be left in place for successive calls with different !< right-hand sides B. B is not modified unless you identify B and X in !< the calling sequence, which is allowed. !< !< (c) after Numerical recipes !< !<@endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: n !! *system size* integer ( kind = I4 ), intent ( in ) :: np !! *matrix size* integer ( kind = I4 ), intent ( inout ) :: info !! *information ouput* real ( kind = R8 ), intent ( in ), dimension ( np , np ) :: a !! *system matrix* real ( kind = R8 ), intent ( in ), dimension ( np ) :: p !! *diagonal elements* real ( kind = R8 ), intent ( inout ), dimension ( np ) :: b !! *rhs* real ( kind = R8 ), intent ( inout ), dimension ( np ) :: x !! *solution vector* integer ( kind = I4 ) :: i , k real ( kind = R8 ) :: ssum if ( info == 1 ) return do i = 1 , n ssum = b ( i ) do k = i - 1 , 1 , - 1 ssum = ssum - a ( i , k ) * x ( k ) enddo x ( i ) = ssum / p ( i ) enddo do i = n , 1 , - 1 ssum = x ( i ) do k = i + 1 , n ssum = ssum - a ( k , i ) * x ( k ) enddo x ( i ) = ssum / p ( i ) enddo return endsubroutine cholsl endmodule cholesky !~    subroutine solve_tridiag(a, b, c, d, x, n) !~    implicit none !~    integer(kind=I4), intent(in )                 :: n !   n - number of equations !~    real   (kind=R8), intent(in ), dimension(1:n) :: a !   a - sub-diagonal (means it is the diagonal below the main diagonal) !~    real   (kind=R8), intent(in ), dimension(1:n) :: b !   b - the main diagonal !~    real   (kind=R8), intent(in ), dimension(1:n) :: c !   c - sup-diagonal (means it is the diagonal above the main diagonal) !~    real   (kind=R8), intent(in ), dimension(1:n) :: d !   d - right part !~    real   (kind=R8), intent(out), dimension(1:n) :: x !   x - the answer !~       real(kind=R8), dimension(1:n) :: cp, dp !~       real   (kind=R8) :: m !~       integer(kind=I4) :: i !~       ! initialize c-prime and d-prime !~       cp(1) = c(1)/b(1) !~       dp(1) = d(1)/b(1) !~       ! solve for vectors c-prime and d-prime !~       do i = 2, n !~          m = b(i) -cp(i-1)*a(i) !~          cp(i) = c(i)/m !~          dp(i) = (d(i)-dp(i-1)*a(i))/m !~       enddo !~       ! initialize x !~       x(n) = dp(n) !~       ! solve for x from the vectors c-prime and d-prime !~       do i = n -1, 1, -1 !~          x(i) = dp(i) -cp(i)*x(i+1) !~       enddo !~    return !~    endsubroutine solve_tridiag","tags":"","loc":"sourcefile/mod_cholesky.f90.html"},{"title":"mod_sort_arrays.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_sort_arrays.f90~~EfferentGraph sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_sort_arrays.f90~~AfferentGraph sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_sort_arrays.f90 sourcefile~prg.f90~8 prg.f90 sourcefile~prg.f90~8->sourcefile~mod_sort_arrays.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 sourcefile~prg.f90~12 prg.f90 sourcefile~prg.f90~12->sourcefile~mod_surfile.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.1 !<  date: feb, 24 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Various routines to sort real/integer arrays** !<  </span> module sort_arrays use data_arch , only : I4 , R8 implicit none private public :: init_order , sort_array2 contains subroutine sort_array2 ( tab_inout , tab0 , tab1 , tab2 , tab3 , n ) !! Sort 1D arrays, real or integer, according the first one implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the arrays* class ( * ) , intent ( inout ), dimension ( n ) :: tab_inout !! *reference array to sort* integer ( kind = I4 ), intent ( inout ), dimension ( n ), optional :: tab0 !! *second array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab1 !! *third array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab2 !! *4th array to sort according the order of the first one* class ( * ) , intent ( inout ), dimension ( n ), optional :: tab3 !! *5th array to sort according the order of the first one* integer ( kind = I4 ), allocatable , dimension (:) :: tab_order allocate ( tab_order ( 1 : n ) ) if ( . not . present ( tab0 ) ) then call init_order ( order = tab_order ( 1 : n ), n = n ) else tab_order ( 1 : n ) = tab0 ( 1 : n ) endif select type ( tab_inout ) type is ( integer ( kind = I4 ) ) call sort_array_integer_with_order ( g = 1 , d = n , itabref = tab_inout ( 1 : n ), order = tab_order ( 1 : n )) type is ( real ( kind = R8 ) ) call sort_array_real_with_order ( g = 1 , d = n , rtabref = tab_inout ( 1 : n ), order = tab_order ( 1 : n )) endselect if ( present ( tab1 ) ) call change_array_order ( tab_inout = tab1 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab2 ) ) call change_array_order ( tab_inout = tab2 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab3 ) ) call change_array_order ( tab_inout = tab3 ( 1 : n ), order = tab_order ( 1 : n ), n = n ) if ( present ( tab0 ) ) then tab0 ( 1 : n ) = tab_order ( 1 : n ) endif deallocate ( tab_order ) return endsubroutine sort_array2 subroutine change_array_order ( tab_inout , order , n ) !! Given an order vector, sort a real or integer vector implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the arrays* class ( * ) , intent ( inout ), dimension ( n ) :: tab_inout !! *array to sort* integer ( kind = I4 ), intent ( inout ), dimension ( n ) :: order !! *order vector* integer ( kind = I4 ) :: i integer ( kind = I4 ), allocatable , dimension (:) :: tab_int real ( kind = R8 ), allocatable , dimension (:) :: tab_real select type ( tab_inout ) type is ( integer ( kind = I4 ) ) allocate ( tab_int ( 1 : n ) ) tab_int ( 1 : n ) = tab_inout ( 1 : n ) do i = 1 , n tab_inout ( i ) = tab_int ( order ( i ) ) enddo deallocate ( tab_int ) type is ( real ( kind = R8 ) ) allocate ( tab_real ( 1 : n ) ) tab_real ( 1 : n ) = tab_inout ( 1 : n ) do i = 1 , n tab_inout ( i ) = tab_real ( order ( i ) ) enddo deallocate ( tab_real ) endselect return endsubroutine change_array_order subroutine init_order ( order , n ) !! Vector initialization: 1 ... n implicit none integer ( kind = I4 ), intent ( in ) :: n !! *size of the vector* integer ( kind = I4 ), dimension ( n ), intent ( out ) :: order !! *order vector* integer ( kind = I4 ) :: i order = [ integer ( kind = I4 ) :: ( i , i = 1 , n ) ] return endsubroutine init_order !========================================================================================= recursive subroutine sort_array_integer_with_order ( g , d , itabref , order ) !! Sort a vector of integers and store the order implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* integer ( kind = I4 ), intent ( inout ), dimension (:) :: itabref !! *vector to sort* integer ( kind = I4 ), intent ( inout ), dimension (:) :: order !! *sort order* integer ( kind = I4 ) :: i , j , mil , itmp integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du tableau itmp = order ( i ) order ( i ) = order ( j ) order ( j ) = itmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_integer_with_order ( g , j , itabref , order ) if ( d > i ) call sort_array_integer_with_order ( i , d , itabref , order ) return endsubroutine sort_array_integer_with_order !========================================================================================= recursive subroutine sort_array_real_with_order ( g , d , rtabref , order ) !! Sort a vector of reals and store the order implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* real ( kind = R8 ), intent ( inout ), dimension (:) :: rtabref !! *vector to sort* integer ( kind = I4 ), intent ( inout ), dimension (:) :: order !! *sort order* integer ( kind = I4 ) :: i , j , mil , itmp real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du tableau itmp = order ( i ) order ( i ) = order ( j ) order ( j ) = itmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_real_with_order ( g , j , rtabref , order ) if ( d > i ) call sort_array_real_with_order ( i , d , rtabref , order ) return endsubroutine sort_array_real_with_order !========================================================================================= recursive subroutine sort_array_integer ( g , d , itabref ) !! Sort a vector of integers implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* integer ( kind = I4 ), intent ( inout ), dimension (:) :: itabref !! *vector to sort* integer ( kind = I4 ) :: i , j , mil integer ( kind = I4 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = itabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( itabref ( i ) < cle ) i = i + 1 enddo do while ( itabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = itabref ( i ) itabref ( i ) = itabref ( j ) itabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_integer ( g , j , itabref ) if ( d > i ) call sort_array_integer ( i , d , itabref ) return endsubroutine sort_array_integer !========================================================================================= recursive subroutine sort_array_real ( g , d , rtabref ) !! Sort a vector of reals implicit none integer ( kind = I4 ), intent ( in ) :: g !! *left index* integer ( kind = I4 ), intent ( in ) :: d !! *right index* real ( kind = R8 ), intent ( inout ), dimension (:) :: rtabref !! *vector to sort* integer ( kind = I4 ) :: i , j , mil real ( kind = R8 ) :: tmp , cle i = g j = d mil = ( g + d ) / 2 cle = rtabref ( mil ) if ( g >= d ) return do while ( i <= j ) do while ( rtabref ( i ) < cle ) i = i + 1 enddo do while ( rtabref ( j ) > cle ) j = j - 1 enddo if ( i <= j ) then ! échange des éléments du tableau tmp = rtabref ( i ) rtabref ( i ) = rtabref ( j ) rtabref ( j ) = tmp ! échange des éléments du vecteur position i = i + 1 j = j - 1 endif enddo if ( g < j ) call sort_array_real ( g , j , rtabref ) if ( d > i ) call sort_array_real ( i , d , rtabref ) return endsubroutine sort_array_real !~    !----------------------------------------------------------------------------------------- !~    recursive subroutine sort_int_1int_1real(g, d, itabref, itab1, rtab2) !~    implicit none !~    integer(kind=I4), intent(in) :: g, d !~    integer(kind=I4), dimension(:), intent(inout) :: itabref !~    integer(kind=I4), dimension(:), intent(inout) :: itab1 !~    real(kind=R8), dimension(:), intent(inout)    :: rtab2 !~       integer(kind=I4) :: i, j, mil, cle, itmp !~       real(kind=R8)    :: rtmp !~       i = g !~       j = d !~       mil = (g+d)/2 !~       cle = itabref(mil) !~       if (g>=d) return !~       do while (i<=j) !~          do while (itabref(i)<cle) !~             i = i + 1 !~          enddo !~          do while (itabref(j)>cle) !~             j = j - 1 !~          enddo !~          if (i<=j) then !~             ! échange des éléments du tableau !~             itmp       = itabref(i) !~             itabref(i) = itabref(j) !~             itabref(j) = itmp !~             ! échange des éléments du vecteur 2 !~             itmp     = itab1(i) !~             itab1(i) = itab1(j) !~             itab1(j) = itmp !~             ! échange des éléments du vecteur 3 !~             rtmp     = rtab2(i) !~             rtab2(i) = rtab2(j) !~             rtab2(j) = rtmp !~             i = i + 1 !~             j = j - 1 !~          endif !~       enddo !~       if (g<j) call sort_int_1int_1real(g, j, itabref, itab1, rtab2) !~       if (d>i) call sort_int_1int_1real(i, d, itabref, itab1, rtab2) !~    return !~    endsubroutine sort_int_1int_1real !~    recursive subroutine sort_int_1real(g, d, itabref, rtab1) !~    implicit none !~    integer(kind=I4), intent(in) :: g, d !~    integer(kind=I4), dimension(:), intent(inout) :: itabref !~    real(kind=R8), dimension(:), intent(inout)    :: rtab1 !~       integer(kind=I4) :: i, j, mil, cle, itmp !~       real(kind=R8)    :: rtmp !~       i = g !~       j = d !~       mil = (g+d)/2 !~       cle = itabref(mil) !~       if (g>=d) return !~       do while (i<=j) !~          do while (itabref(i)<cle) !~             i = i + 1 !~          enddo !~          do while (itabref(j)>cle) !~             j = j - 1 !~          enddo !~          if (i<=j) then !~             ! échange des éléments du tableau !~             itmp       = itabref(i) !~             itabref(i) = itabref(j) !~             itabref(j) = itmp !~             ! échange des éléments du vecteur 3 !~             rtmp     = rtab1(i) !~             rtab1(i) = rtab1(j) !~             rtab1(j) = rtmp !~             i = i + 1 !~             j = j - 1 !~          endif !~       enddo !~       if (g<j) call sort_int_1real(g, j, itabref, rtab1) !~       if (d>i) call sort_int_1real(i, d, itabref, rtab1) !~    return !~    endsubroutine sort_int_1real endmodule sort_arrays","tags":"","loc":"sourcefile/mod_sort_arrays.f90.html"},{"title":"mod_gnufor.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~mod_gnufor.f90~~AfferentGraph sourcefile~mod_gnufor.f90 mod_gnufor.f90 sourcefile~prg.f90~5 prg.f90 sourcefile~prg.f90~5->sourcefile~mod_gnufor.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: John Burkardt !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !< **A fortran api to GNUPLOT** !< </span> !< !< @note !< GNUFOR makes it possible, while running a FORTRAN90 program on a UNIX system, to generate some data and request an immediate plot. !< This is done by issuing a SYSTEM command that starts up GNUPLOT, and feeding it the appropriate commands and data. !< The FORTRAN90 program pauses while the graph is displayed in an X window, and the user can admire the plots for a while, !< before hitting return and giving control back to the FORTRAN90 program. !< !< [link](https://people.math.sc.edu/Burkardt/f_src/gnufor/gnufor.html) !< !< @endnote !< !< @warning !< To use this program, the command \"gnuplot\" must be in your path. !< @endwarning module gnufor implicit none private public :: write_xyy_data , write_xyy_plots , write_xy_data , write_xy_plot , run_gnuplot , & ! test01 , test02 , test03 , test04 , test05 , test06 contains subroutine get_unit ( iunit ) ! !******************************************************************************* ! !! GET_UNIT returns a free FORTRAN unit number. ! ! !  Discussion: ! !    A \"free\" FORTRAN unit number is an integer between 1 and 99 which !    is not currently associated with an I/O device.  A free FORTRAN unit !    number is needed in order to open a file with the OPEN command. ! !  Modified: ! !    02 March 1999 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Output, integer IUNIT. ! !    If IUNIT = 0, then no free FORTRAN unit could be found, although !    all 99 units were checked (except for units 5 and 6). ! !    Otherwise, IUNIT is an integer between 1 and 99, representing a !    free FORTRAN unit.  Note that GET_UNIT assumes that units 5 and 6 !    are special, and will never return those values. ! implicit none ! integer i integer ios integer iunit logical lopen iunit = 0 do i = 1 , 99 if ( i /= 5 . and . i /= 6 ) then inquire ( unit = i , opened = lopen , iostat = ios ) if ( ios == 0 ) then if ( . not . lopen ) then iunit = i return end if end if end if end do return endsubroutine get_unit function pi ( ) ! !******************************************************************************* ! !! PI returns the value of pi. ! ! !  Modified: ! !    04 December 1998 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Output, real PI, the value of pi. ! implicit none ! real pi ! pi = 3.14159265358979323846264338327950288419716939937510E+00 return endfunction pi subroutine run_gnuplot ( command_file_name ) ! !******************************************************************************* ! !! RUN_GNUPLOT runs GNUPLOT with a given command file. ! ! !  Discussion: ! !    The GNUPLOT program, version 3.7, must be available.  To check whether !    this is so, try typing ! !      which gnuplot ! !    If the response is ! !      gnuplot: command not found ! !    then you're going to have to make GNUPLOT available. ! !    At ISU, this may require that you issue the command ! !      add gnu ! !    You may need to set the environment variable GNUTERM: ! !      setenv GNUTERM x11 ! !    so that GNUPLOT automatically displays to your X window terminal. ! ! !    This routine expects that there is a text file containing the appropriate !    commands to GNUPLOT to display your picture.  There are a number of !    routines in this package that will do this for simple plotting tasks. !    Most of them require that you also set up a file of data to be plotted. ! !    Once this routine invokes GNUPLOT, a graphics window should open !    up, and the FORTRAN program will pause.  Hitting RETURN should advance !    to the next picture, or terminate the window at the end, allowing the !    FORTRAN routine to proceed. ! ! !    You can look at the data and command files created by the routines. !    Moreover, you can easily modify the command file to change the options !    used in GNUPLOT, and then run GNUPLOT interactively, as in: ! !      gnuplot commands ! !    In particular, if you want a PostScript version of your graphics files, !    insert the command \"set term postscript\" at the beginning of the command !    file and run gnuplot as follows: ! !      gnuplot commands > mypicture.ps ! !    You will also have to hit RETURN once for each plot that is made. ! !  Modified: ! !    21 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! implicit none ! character ( len = 512 ) command character ( len = * ) command_file_name !integer status ! !  Issue a command to the system that will startup GNUPLOT, using !  the file we just wrote as input. ! write ( command , * ) 'gnuplot ' // '\"' // trim ( command_file_name ) // '\"' !~   call execute_command_line(trim ( command ), wait=.false., exitstat=status) call system ( trim ( command )) return endsubroutine run_gnuplot subroutine timestamp ( ) ! !******************************************************************************* ! !! TIMESTAMP prints the current YMDHMS date as a time stamp. ! ! !  Example: ! !    May 31 2001   9:45:54.872 AM ! !  Modified: ! !    31 May 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    None ! implicit none ! character ( len = 8 ) ampm integer d character ( len = 8 ) date integer h integer m integer mm character ( len = 9 ), parameter , dimension ( 12 ) :: month = ( / & 'January  ' , 'February ' , 'March    ' , 'April    ' , & 'May      ' , 'June     ' , 'July     ' , 'August   ' , & 'September' , 'October  ' , 'November ' , 'December ' / ) integer n integer s character ( len = 10 ) time integer values ( 8 ) integer y character ( len = 5 ) zone ! call date_and_time ( date , time , zone , values ) y = values ( 1 ) m = values ( 2 ) d = values ( 3 ) h = values ( 5 ) n = values ( 6 ) s = values ( 7 ) mm = values ( 8 ) if ( h < 12 ) then ampm = 'AM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Noon' else ampm = 'PM' end if else h = h - 12 if ( h < 12 ) then ampm = 'PM' else if ( h == 12 ) then if ( n == 0 . and . s == 0 ) then ampm = 'Midnight' else ampm = 'AM' end if end if end if write ( * , '(a,1x,i2,1x,I4,2x,i2,a1,i2.2,a1,i2.2,a1,i3.3,1x,a)' ) & trim ( month ( m ) ), d , y , h , ':' , n , ':' , s , '.' , mm , trim ( ampm ) return endsubroutine timestamp subroutine write_vector_data ( data_file_name , n , x , y , dx , dy , ierror ) ! !******************************************************************************* ! !! WRITE_VECTOR_DATA writes vector data to a file, for plotting by GNUPLOT. ! ! !  Discussion: ! !    Each vector is described by 4 values, X, Y, dX, dY, indicating that !    a vector is to be drawn from (X,Y) to (X+dX,Y+dY). ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of vectors. ! !    Input, real X(N), Y(N), DX(N), DY(N), the vector data. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name real dx ( n ) real dy ( n ) integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), dx ( i ), dy ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT vector data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_vector_data subroutine write_vector_plot ( command_file_name , data_file_name , & ierror ) ! !******************************************************************************* ! !! WRITE_VECTOR_PLOT writes GNUPLOT commands to plot vectors. ! ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set style arrow' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_VECTOR_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT table plots command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_vector_plot subroutine write_xy_data ( data_file_name , n , x , y , ierror ) ! !******************************************************************************* ! !! WRITE_XY_DATA writes X(1:N), Y(1:N) data to a file. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of data items. ! !    Input, real X(N), Y(N), the X and Y data ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xy_data subroutine write_xy2_data ( data_file_name , n , x , y , y2 , ierror ) ! !******************************************************************************* implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) real y2 ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), y2 ( i ) end do close ( unit = file_unit ) return endsubroutine write_xy2_data subroutine write_xy_plot ( command_file_name , data_file_name , logscale , ierror , nom ) ! !******************************************************************************* ! !! WRITE_XY_PLOT writes GNUPLOT commands to plot X(1:N), Y(1:N) data. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) nom character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios logical logscale ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if if ( trim ( nom ) /= '*' ) then write ( file_unit , '(a)' ) 'set term pngcairo' write ( file_unit , '(a)' ) 'set output \"' // trim ( nom ) // '.png\"' endif write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' if ( logscale ) write ( file_unit , '(a)' ) 'set logscale x' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:2 with lines' !write ( file_unit, '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // trim ( command_file_name ) // '\"' return endsubroutine write_xy_plot subroutine write_xy2_plot ( command_file_name , data_file_name , logscale , ierror , nom ) implicit none ! character ( len = * ) command_file_name character ( len = * ) nom character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios logical logscale ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if if ( trim ( nom ) /= '*' ) then write ( file_unit , '(a)' ) 'set term pngcairo' write ( file_unit , '(a)' ) 'set output \"' // trim ( nom ) // '.png\"' endif write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' if ( logscale ) write ( file_unit , '(a)' ) 'set logscale x' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:2 with lines,\\' write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : 3 with lines ' !write ( file_unit, ' ( a ) ' ) ' pause - 1 \"Hit return to continue\" ' write ( file_unit, ' ( a ) ' ) ' q ' close ( unit = file_unit ) return endsubroutine write_xy2_plot subroutine write_y_plot ( command_file_name, data_file_name, ierror ) ! !******************************************************************************* ! !! WRITE_Y_PLOT writes GNUPLOT commands to plot Y(1:N) data. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( *, ' ( a ) ' ) ' ' write ( *, ' ( a ) ' ) ' WRITE_XY_PLOT - Fatal error !' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // & '\" using 1 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_y_plot subroutine write_xyy_data ( data_file_name , lda , nrow , ncol , x , ierror ) ! !******************************************************************************* ! !! WRITE_XYY_DATA writes a table of data to a file, for plotting by GNUPLOT. ! ! !  Discussion: ! !    The first column of data is assumed to be the independent variable, X. !    Separate plots are made of X versus all the other columns of data. ! !  Modified: ! !    21 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer LDA, the leading dimension of X. ! !    Input, integer NROW, NCOL, the dimensions of X. ! !    Input, real X(LDA,NCOL), the NROW by NCOL data to be written. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer lda integer ncol ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios integer nrow real x ( lda , ncol ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , nrow write ( file_unit , * ) x ( i , 1 : ncol ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYY data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyy_data subroutine write_xyy_plots ( command_file_name , data_file_name , add_lines , title , & ncol , ierror ) ! !******************************************************************************* ! !! WRITE_XYY_PLOTS writes GNUPLOT commands to make multiple (X,Y) plots. ! ! !  Discussion: ! !    The first column of data is assumed to be the independent variable, X. !    Separate plots are made of X versus all the other columns of data. ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer NCOL, the number of columns of data. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name character ( len = * ), optional :: add_lines integer file_unit integer i integer ierror integer ios integer ncol character ( len = * ), dimension ( 1 : ncol ) :: title ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_PLOTS - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYY_PLOTS - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' if ( present ( add_lines )) then write ( file_unit , '(a)' ) trim ( add_lines ) endif do i = 1 , 1 write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // '\" using 1:' , i + 1 , ' with lines title \"' // trim ( title ( i )) // '\", \\' end do do i = 2, ncol-2 write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : ', i+1, ' with lines title \"' // trim(title(i)) // '\" , \\ ' end do do i = ncol-1, ncol-1 write ( file_unit, ' ( a , i2 , a ) ' )       ' \"'// trim ( data_file_name ) // '\" using 1 : ', i+1, ' with lines title \"' // trim(title(i)) // '\" ' end do write ( file_unit, ' ( a ) ' ) ' pause - 1 \"Hit return to continue\" ' write ( file_unit, ' ( a ) ' ) ' q ' close ( unit = file_unit ) write ( *, ' ( a ) ' ) ' ' write ( *, ' ( a ) ' ) ' WRITE_XYY_PLOTS : ' write ( *, ' ( a ) ' ) ' Wrote the GNUPLOT XYY plots command file \"' // & trim ( command_file_name ) // '\" ' return endsubroutine write_xyy_plots subroutine write_xyz_data ( data_file_name, n, x, y, z, ierror ) ! !******************************************************************************* ! !! WRITE_XYZ_DATA writes X(1:N), Y(1:N), Z(1:N) data to a file. ! ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer N, the number of data items. ! !    Input, real X(N), Y(N), Z(N), the X, Y, Z data ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x(n) real y(n) real z(n) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( *, ' ( a ) ' ) ' ' write ( *, ' ( a ) ' ) ' WRITE_XYZ_DATA - Fatal error !' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ), z ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZ data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyz_data subroutine write_xyz_plot ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZ_PLOT writes commands to plot parametric (X,Y,Z) data. ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    a 3D arc specified by points (X,Y,Z).  A grid data file, containing !    values of X, Y and Z, will also be needed. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // & '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZ_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT SPLOT command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyz_plot subroutine write_xyzgrid_contour ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_CONTOUR writes commands to plot contours of Z(X,Y). ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    contours of Z(X,Y) gridded data.  A grid data file, containing values !    of X, Y and Z, will also be needed. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'set nosurface' write ( file_unit , '(a)' ) 'set contour' write ( file_unit , '(a)' ) 'set cntrparam levels 10' !write ( file_unit, '(a)' ) 'set terminal table' !write ( file_unit, '(a)' ) 'set out \"table.txt\"' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // & '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'set term x11' !write ( file_unit, '(a)' ) 'plot \"table.txt\" with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_CONTOUR:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZGRID contour plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyzgrid_contour subroutine write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_DATA writes a file of XYZ grid data. ! ! !  Discussion: ! !    It is assumed that values of Z are available on a regular NX by NY grid !    of (X,Y) points. ! !    The form of the data file requires that all the data for a given value !    of Y be listed, followed by a blank line, followed by the data for !    another value of Y. ! !  Example: ! !    Here is a grid data file for a 3 by 3 grid, with Z = X + Y. ! !    0.0 0.0 0.0 !    1.0 0.0 1.0 !    2.0 0.0 2.0 ! !    0.0 1.0 1.0 !    1.0 1.0 2.0 !    2.0 1.0 3.0 ! !    0.0 2.0 2.0 !    1.0 2.0 3.0 !    2.0 2.0 4.0 ! !  Modified: ! !    23 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Input, integer NX, NY, the dimensions of the grid. ! !    Input, real XYZ(3,NX,NY), the XYZ grid data to be written. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! integer nx integer ny ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios integer j real xyz ( 3 , nx , ny ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do j = 1 , ny do i = 1 , nx write ( file_unit , * ) xyz ( 1 : 3 , i , j ) end do write ( file_unit , '(a)' ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT XYZ grid data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_xyzgrid_data subroutine write_xyzgrid_surface ( command_file_name , data_file_name , ierror ) ! !******************************************************************************* ! !! WRITE_XYZGRID_SURFACE writes a file of GNUPLOT commands to plot a 3D surface. ! ! !  Discussion: ! !    This routine tries to write a command file suitable for displaying !    a surface Z(X,Y).  A grid data file, containing values of X, Y and Z, !    will also be needed.  The routine WRITE_XYZGRID_DATA can write this file. ! !  Modified: ! !    22 February 2001 ! !  Author: ! !    John Burkardt ! !  Parameters: ! !    Input, character ( len = * ) COMMAND_FILE_NAME, the name of the !    command file. ! !    Input, character ( len = * ) DATA_FILE_NAME, the name of the data file. ! !    Output, integer IERROR, nonzero if an error occurred. ! implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit !integer i integer ierror integer ios !integer ncol ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_SURFACE - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XYZGRID_SURFACE - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set xlabel \"x\"' write ( file_unit , '(a)' ) 'set ylabel \"y\"' write ( file_unit , '(a)' ) 'set parametric' write ( file_unit , '(a)' ) 'set pm3d implicit at s' !; set palette gray' write ( file_unit , '(a)' ) 'set hidden3d' !write ( file_unit, '(a)' ) 'set contour' !~   write ( file_unit, '(a)' ) 'splot \"' // trim ( data_file_name ) // & !~     '\" using 1:2:3 with lines' write ( file_unit , '(a)' ) 'splot \"' // trim ( data_file_name ) // '\"' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_SURFACE_COMMANDS:' write ( * , '(a)' ) '  Wrote the GNUPLOT surface plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_xyzgrid_surface !************************************************************************************************** !************************************************************************************************** subroutine test01 ! !******************************************************************************* ! !! TEST01 demonstrates the plotting of Y(X) data. ! implicit none ! integer , parameter :: n = 101 ! !real angle !real area character ( len = 100 ) :: command_file_name = 'tmp/test01_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test01_data.txt' integer i integer ierror real x ( n ) real , parameter :: xmin = 0.0 + 00 real , parameter :: xmax = 2 0.0E+00 real y ( n ) ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a)' ) '  To plot a simple set of (X,Y) data,' write ( * , '(a)' ) '  WRITE_XY_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XY_PLOT writes the plot command file.' do i = 1 , n x ( i ) = ( real ( n - i ) * xmin + real ( i - 1 ) * xmax ) / real ( n - 1 ) y ( i ) = sin ( x ( i ) ) * sin ( 4.0 * x ( i ) ) end do call write_xy_data ( data_file_name , n , x , y , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a,i6)' ) '  WRITE_XY_DATA returned IERROR = ' , ierror end if call write_xy_plot ( command_file_name , data_file_name , . true ., ierror , '*' ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST01' write ( * , '(a,i6)' ) '  WRITE_XY_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test01 subroutine test02 ! !******************************************************************************* ! !! TEST02 demonstrates the plotting of a table of data. ! implicit none ! integer , parameter :: nrow = 101 integer , parameter :: ncol = 4 ! integer , parameter :: lda = nrow ! real angle real area character ( len = 100 ) :: command_file_name = 'tmp/test02_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test02_data.txt' character ( len = 100 ), dimension ( 1 : ncol ) :: title real height integer i integer ierror real , parameter :: r = 5 0.0E+00 real width real x ( lda , ncol ) ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a)' ) '  To plot X versus multiple sets of Y data,' write ( * , '(a)' ) '  WRITE_XYY_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYY_PLOT writes the plot command file.' do i = 1 , nrow height = 2.0E+00 * r * real ( i - 1 ) / real ( nrow - 1 ) width = 2.0E+00 * sqrt ( r ** 2 - ( r - height ) ** 2 ) angle = acos ( ( r - height ) / r ) area = 0.5E+00 * r ** 2 * 2.0E+00 * acos ( ( r - height ) / r ) & - ( r - height ) * sqrt ( height * ( 2.0E+00 * r - height ) ) x ( i , 1 ) = height x ( i , 2 ) = width x ( i , 3 ) = angle x ( i , 4 ) = area end do title ( 1 ) = 'height' title ( 2 ) = 'width' title ( 3 ) = 'angle' title ( 4 ) = 'area' call write_xyy_data ( data_file_name , lda , nrow , ncol , x , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a,i6)' ) '  WRITE_XYY_DATA returned IERROR = ' , ierror end if call write_xyy_plots ( command_file_name = command_file_name , data_file_name = data_file_name , title = title , ncol = ncol , & ierror = ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST02' write ( * , '(a,i6)' ) '  WRITE_XYY_PLOTS returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test02 subroutine test03 ! !******************************************************************************* ! !! TEST03 plots parameter (X,Y,Z) data. ! implicit none ! integer , parameter :: n = 101 ! character ( len = 100 ) :: command_file_name = 'tmp/test03_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test03_data.txt' integer i integer ierror integer , parameter :: nturn = 5 real , parameter :: r = 5.0E+00 real theta real x ( n ) real y ( n ) real z ( n ) real , parameter :: zmax = 1 0.0E+00 ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a)' ) '  To plot a (parametric) set of (X,Y,Z) data,' write ( * , '(a)' ) '  WRITE_XYZ_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZ_PLOT writes the plot command file.' do i = 1 , n z ( i ) = zmax * real ( i - 1 ) / real ( n - 1 ) theta = ( 2.0E+00 * pi () ) * z ( i ) * real ( nturn ) / zmax x ( i ) = r * cos ( theta ) y ( i ) = r * sin ( theta ) end do call write_xyz_data ( data_file_name , n , x , y , z , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a,i6)' ) '  WRITE_XYZ_DATA returned IERROR = ' , ierror end if call write_xyz_plot ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST03' write ( * , '(a,i6)' ) '  WRITE_XYZ_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test03 subroutine test04 ! !******************************************************************************* ! !! TEST04 plots vector data. ! implicit none ! integer , parameter :: nx = 21 integer , parameter :: ny = 21 integer , parameter :: n = nx * ny ! character ( len = 100 ) :: command_file_name = 'tmp/test04_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test04_data.txt' real dx ( n ) real dy ( n ) integer i integer ierror integer j integer k real x ( n ) real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = - 1.0E+00 real xx real y ( n ) real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = - 1.0E+00 real yy ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a)' ) '  To plot a vector field,' write ( * , '(a)' ) '  WRITE_VECTOR_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_VECTOR_PLOT writes the plot command file.' k = 0 do i = 1 , nx do j = 1 , ny k = k + 1 xx = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) yy = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) dx ( k ) = - 0.10E+00 * yy dy ( k ) = 0.10E+00 * xx x ( k ) = xx - 0.5E+00 * dx ( k ) y ( k ) = yy - 0.5E+00 * dy ( k ) end do end do call write_vector_data ( data_file_name , n , x , y , dx , dy , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a,i6)' ) '  WRITE_VECTOR_DATA returned IERROR = ' , ierror end if call write_vector_plot ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST04' write ( * , '(a,i6)' ) '  WRITE_VECTOR_PLOT returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test04 subroutine test05 ! !******************************************************************************* ! !! TEST05 plots Z(X,Y) grid data as a surface. ! implicit none ! integer , parameter :: nx = 21 integer , parameter :: ny = 21 !integer, parameter :: nrow = nx * ny ! character ( len = 100 ) :: command_file_name = 'tmp/test05_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test05_data.txt' integer i integer ierror integer j real x real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = 0.0E+00 real xyz ( 3 , nx , ny ) real y real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = 0.0E+00 real z ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a)' ) '  To plot a gridded set of Z(X,Y) data as a surface,' write ( * , '(a)' ) '  WRITE_XYZGRID_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZGRID_SURFACE writes the plot command file.' do i = 1 , nx x = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) do j = 1 , ny y = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) z = sin ( 6 4.0E+00 * ( x - 0.5E+00 ) ** 2 * ( y - 0.5E+00 ) ** 2 ) xyz ( 1 , i , j ) = x xyz ( 2 , i , j ) = y xyz ( 3 , i , j ) = z end do end do call write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_DATA returned IERROR = ' , ierror end if call write_xyzgrid_surface ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST05' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_SURFACE returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test05 subroutine test06 ! !******************************************************************************* ! !! TEST06 plots Z(X,Y) grid data as contours. ! implicit none ! integer , parameter :: nx = 41 integer , parameter :: ny = 41 ! character ( len = 100 ) :: command_file_name = 'tmp/test06_commands.txt' character ( len = 100 ) :: data_file_name = 'tmp/test06_data.txt' integer i integer ierror integer j real x real , parameter :: xmax = 1.0E+00 real , parameter :: xmin = 0.0E+00 real xyz ( 3 , nx , ny ) real y real , parameter :: ymax = 1.0E+00 real , parameter :: ymin = 0.0E+00 real z ! write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a)' ) '  To plot gridded Z(X,Y) data as contours,' write ( * , '(a)' ) '  WRITE_XYZGRID_DATA writes the data file,' write ( * , '(a)' ) '  WRITE_XYZGRID_CONTOUR writes the plot command file.' do i = 1 , nx x = ( real ( nx - i ) * xmin + real ( i - 1 ) * xmax ) / real ( nx - 1 ) do j = 1 , ny y = ( real ( ny - j ) * ymin + real ( j - 1 ) * ymax ) / real ( ny - 1 ) z = sin ( 6 4.0E+00 * ( x - 0.5E+00 ) ** 2 * ( y - 0.5E+00 ) ** 2 ) xyz ( 1 , i , j ) = x xyz ( 2 , i , j ) = y xyz ( 3 , i , j ) = z end do end do call write_xyzgrid_data ( data_file_name , nx , ny , xyz , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_DATA returned IERROR = ' , ierror end if call write_xyzgrid_contour ( command_file_name , data_file_name , ierror ) if ( ierror /= 0 ) then write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'TEST06' write ( * , '(a,i6)' ) '  WRITE_XYZGRID_CONTOUR returned IERROR = ' , ierror end if call run_gnuplot ( command_file_name ) return endsubroutine test06 subroutine write_polar_plot ( command_file_name , data_file_name , ierror ) implicit none ! character ( len = * ) command_file_name character ( len = * ) data_file_name integer file_unit integer ierror integer ios ! !  Write the data file. ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = command_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_PLOT - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if write ( file_unit , '(a)' ) 'set title \"GNUFOR plot\"' write ( file_unit , '(a)' ) 'set angles degrees' write ( file_unit , '(a)' ) 'set polar' write ( file_unit , '(a)' ) 'set grid polar' write ( file_unit , '(a)' ) 'set xlabel \"azimuth\"' write ( file_unit , '(a)' ) 'set ylabel \"r\"' write ( file_unit , '(a,i2,a)' ) 'plot \"' // trim ( data_file_name ) // & '\" using 1:2 with lines' write ( file_unit , '(a)' ) 'pause -1  \"Hit return to continue\"' write ( file_unit , '(a)' ) 'q' close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_XY_PLOT:' write ( * , '(a)' ) '  Wrote the GNUPLOT XY plot command file \"' // & trim ( command_file_name ) // '\"' return endsubroutine write_polar_plot subroutine write_polar_data ( data_file_name , n , x , y , ierror ) implicit none ! integer n ! character ( len = * ) data_file_name integer file_unit integer i integer ierror integer ios real x ( n ) real y ( n ) ! ierror = 0 call get_unit ( file_unit ) if ( file_unit == 0 ) then ierror = 1 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not get a free FORTRAN unit.' return end if open ( unit = file_unit , file = data_file_name , status = 'replace' , & iostat = ios ) if ( ios /= 0 ) then ierror = 2 write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA - Fatal error!' write ( * , '(a)' ) '  Could not open the output file.' return end if do i = 1 , n write ( file_unit , * ) x ( i ), y ( i ) end do close ( unit = file_unit ) write ( * , '(a)' ) ' ' write ( * , '(a)' ) 'WRITE_POLAR_DATA:' write ( * , '(a)' ) '  Wrote the GNUPLOT POLAR data file \"' // & trim ( data_file_name ) // '\"' return endsubroutine write_polar_data endmodule gnufor","tags":"","loc":"sourcefile/mod_gnufor.f90.html"},{"title":"mod_solver.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_solver.f90~~EfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_solver.f90~~AfferentGraph sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: july, 12 2018 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Api for different sparse matrix solvers** !<  </span> !< !< @warning !< If WITH_MA48 has been set to true, you are supposed to have the license for !< the HSL MA48 use. !< By default the HSL MA48 are not provided here. !< @endwarning !< module solver use iso_c_binding , only : C_PTR , C_NULL_PTR , C_ASSOCIATED use iso_fortran_env , only : output_unit , error_unit use data_arch , only : I4 , I8 , R8 , EPS_R8 , HIG_R8 , OPU use gen_param , only : SOLV_MESS , NO_MESS , PRINT_MESS use sort_arrays , only : sort_array2 !------------------------------------------------- #if WITH_MA48 use hsl_ma48_double #endif !------------------------------------------------- use sulu_wrapper , MAT_SULU => SULU_ENV , & SULU_SAMEPATTERN => SAMEPATTERN , & SULU_FACTORED => FACTORED , & SULU_DOFACT => DOFACT !------------------------------------------------- use mumps_wrapper , MAT_MUMP => DMUMPS_STRUC !------------------------------------------------- use mumfpack , only : UMFPACK_CONTROL , & UMFPACK_STATUS , & UMFPACK_INFO , & UMFPACK_PRL , & UMFPACK_IRSTEP , & UMFPACK_NUMERIC_SIZE_ESTIMATE , & UMFPACK_PEAK_MEMORY_ESTIMATE , & UMFPACK_SIZE_OF_UNIT , & UMFPACK_DI_DEFAULTS , & UMFPACK_DI_REPORT_CONTROL , & UMFPACK_DI_FREE_NUMERIC , & UMFPACK_DI_FREE_SYMBOLIC , & UMFPACK_DI_REPORT_INFO , & S_UMFPACK_DI_SYMBOLIC , & S_UMFPACK_DI_NUMERIC , & S_UMFPACK_DI_SOLVE , & UMFPACK_A !------------------------------------------------- implicit none private #if WITH_MA48 type MAT_MA48 !! <span style=\"color:green\">All the stuff needed by *HSL_MA48*</span> type ( ZD11_TYPE ) :: zmat type ( MA48_CONTROL ) :: ctrl type ( MA48_AINFO ) :: ainf type ( MA48_FINFO ) :: finf type ( MA48_SINFO ) :: sinf type ( MA48_FACTORS ) :: fact integer ( kind = I4 ) :: fast real ( kind = R8 ), dimension ( 2 ) :: resid endtype MAT_MA48 #else type MAT_MA48 endtype MAT_MA48 #endif type MAT_UMFP !! <span style=\"color:green\">All the stuff needed by *UMFPACK*</span> type ( c_ptr ) :: c_symbolic type ( c_ptr ) :: c_numeric real ( kind = R8 ), dimension ( 0 : UMFPACK_CONTROL - 1 ) :: c_control real ( kind = R8 ), dimension ( 0 : UMFPACK_INFO - 1 ) :: c_info endtype MAT_UMFP type MAT_SOLV !! <span style=\"color:green\">MUSST high level system type</span> integer ( kind = I4 ) :: slv_t !! *solver type* logical ( kind = I4 ) :: ini = . false . !! *the system is initialized* logical ( kind = I4 ) :: ana = . false . !! *the system is analyzed* logical ( kind = I4 ) :: fac = . false . !! *the system is factorized* logical ( kind = I4 ) :: sol = . false . !! *the system is solved* logical ( kind = I4 ) :: fre = . false . !! *the system is freed* logical ( kind = I4 ) :: end = . false . !! *the system is closed* integer ( kind = I4 ) :: nn !! *number of nodes* integer ( kind = I4 ) :: ne !! *number of elements* integer ( kind = I4 ) :: nt !! *number of **a priori** non-zero terms in the matrix* integer ( kind = I4 ) :: nz !! *number of non-zero terms in the matrix* integer ( kind = I4 ) :: nvar !! *eltvar length ( if 4-nodes elt -> 2 lines X number of elemental matrices)* integer ( kind = I4 ) :: code !! *error code*   [not used yet] real ( kind = R8 ) :: error !! *error value*  [not used yet] character ( len = 1024 ) :: mess !! *message*      [not used yet] !..................................................... type ( MAT_MUMP ) :: matmump !! *matrices for mumps solver* type ( MAT_MA48 ) :: matma48 !! *matrices for ma48 solver* type ( MAT_SULU ) :: matsulu !! *matrices for SuperLu solver* type ( MAT_UMFP ) :: matumfp !! *matrices for Umfpack solver* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *rows in assembled matrix* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *element rows pointer* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *unassembled rigidity matrix* !..................................................... integer ( kind = I4 ), dimension (:), allocatable :: irow !! *line number* integer ( kind = I4 ), dimension (:), allocatable :: jcol !! *column number* integer ( kind = I4 ), dimension (:), allocatable :: jptr !! *line pointer* !..................................................... real ( kind = R8 ), dimension (:), allocatable :: b !! *right hand side vector* real ( kind = R8 ), dimension (:), allocatable :: x !! *unknwon vector* endtype MAT_SOLV !< <span style=\"color:green\">MUSST multiscale high level solver type</span> !  @note ```MS_MAT_SOLV``` is needed by MUSST, but it is useless for the present module ! type MS_MAT_SOLV type ( MAT_SOLV ) :: ts_mat !! *top-scale solver type matrices* type ( MAT_SOLV ), dimension (:), allocatable :: bs_mat !! *bottom-scale solver type matrices (table)* endtype ms_mat_solv ! Solver types integer ( kind = I4 ), parameter :: MA48 = 0 !! *code for     Ma48 solver type* integer ( kind = I4 ), parameter :: SULU = 1 !! *code for SUPER LU solver type* integer ( kind = I4 ), parameter :: MUMP = 2 !! *code for    MUMPS solver type* integer ( kind = I4 ), parameter :: UMFP = 3 !! *code for  UMFPACK solver type* ! What solver to use for bottom- or top- scale grids integer ( kind = I4 ) :: SOLVER_BS = - 1 !! *solver used for bottom scale grids* [not used by the present module] integer ( kind = I4 ) :: SOLVER_TS = - 1 !! *solver used for top scale grids* [not used by the present module] public :: MAT_SOLV , MS_MAT_SOLV , solve_syst , MUMP , UMFP , SULU , SOLVER_BS , SOLVER_TS , SOLV_MESS , convert_matrice_format contains !========================================================================================= !< @note General hat subroutine that handles the resolution steps: !< !<  * ```ini``` solver initialization !<  * ```ana``` solver analyzis when it's proposed by the solver !<  * ```fac``` solver factorization !<  * ```sol``` solver solution !<  * ```fre``` solver memory release when it's proposed by the solver !<  * ```end``` solver end !< !< @endnote !----------------------------------------------------------------------------------------- subroutine solve_syst ( mat , step ) implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* character ( len =* ), intent ( in ) :: step !! *'ini'=initialize, 'ana'=analyze, 'fac'=factorize, 'sol'=solve, 'fre'=free memory, 'end'=close solver* if ( index ( step , 'ini' ) /= 0 ) then ; call init_solver ( mat ) ; mat % ini = . true . ; return ; endif if ( index ( step , 'ana' ) /= 0 ) then ; call analyse_solver ( mat ) ; mat % ana = . true . ; return ; endif if ( index ( step , 'fac' ) /= 0 ) then ; call factorize_solver ( mat ) ; mat % fac = . true . ; return ; endif if ( index ( step , 'sol' ) /= 0 ) then ; call solution_solver ( mat ) ; mat % sol = . true . ; return ; endif if ( index ( step , 'fre' ) /= 0 ) then ; call freefact_solver ( mat ) ; mat % fre = . true . ; return ; endif if ( index ( step , 'end' ) /= 0 ) then ; call close_solver ( mat ) ; mat % end = . true . ; return ; endif stop 'Bad step chosen in SOLVE_SYST' return endsubroutine solve_syst !========================================================================================= subroutine init_solver ( mat ) !! Subroutine to initialize the matrices of the solver implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr ! allocation of the system vectors: rhs and unknown allocate ( mat % b ( mat % nn ), mat % x ( mat % nn ) ) mat % b = HIG_R8 mat % x = HIG_R8 ! check solver type select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_initialize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matma48 % ctrl % wp = - 1 mat % matma48 % ctrl % mp = - 1 mat % matma48 % ctrl % ldiag = - 1 case ( PRINT_MESS :) mat % matma48 % ctrl % ldiag = + 2 endselect #else stop 'MA48_LIB not defined' #endif case ( MUMP ) call mpi_init ( ierr ) mat % matmump % comm = MPI_COMM_WORLD mat % matmump % job = - 1 ! initialisation mat % matmump % sym = 0 ! no symetry mat % matmump % par = 1 ! MPI, host working call dmumps ( mat % matmump ) mat % matmump % icntl ( 1 ) = output_unit ! output stream for error messages mat % matmump % icntl ( 2 ) = error_unit ! output stream for diagnostic printing, statistics, and warning messages. mat % matmump % icntl ( 3 ) = error_unit ! output stream for global information, collected on the host. mat % matmump % icntl ( 4 ) = 1 ! level of printing for error, warning, and diagnostic messages. 1 : only errors mat % matmump % icntl ( 5 ) = 1 ! Specify element entry : elemental matrices if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'MUMP error, INIT_SOLVER' endif select case ( SOLV_MESS ) case ( NO_MESS ) mat % matmump % icntl ( 4 ) = 1 ! error output only case ( PRINT_MESS :) mat % matmump % icntl ( 4 ) = 3 ! all error output endselect case ( SULU ) call init_superlu ( sulu = mat % matsulu ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matsulu % options % PrintStat = 0 case ( PRINT_MESS :) mat % matsulu % options % PrintStat = 1 endselect case ( UMFP ) mat % matumfp % c_numeric = C_NULL_PTR call umfpack_di_defaults ( mat % matumfp % c_control ) select case ( SOLV_MESS ) case ( NO_MESS ) mat % matumfp % c_control ( UMFPACK_PRL ) = 1 case ( PRINT_MESS :) mat % matumfp % c_control ( UMFPACK_PRL ) = 2 endselect call umfpack_di_report_control ( mat % matumfp % c_control ) case default stop 'Unknown solver type, INIT_SOLVER' endselect return endsubroutine init_solver !========================================================================================= subroutine analyse_solver ( mat ) !! Subroutine to analyse, factorize (symbolic) the matrix of the system implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 mat % matma48 % zmat % row => mat % irow mat % matma48 % zmat % col => mat % jcol mat % matma48 % zmat % val => mat % a_elt mat % matma48 % zmat % n = mat % nn mat % matma48 % zmat % m = mat % nn mat % matma48 % zmat % ne = mat % nz call ma48_analyse ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & ainfo = mat % matma48 % ainf , & finfo = mat % matma48 % finf ) if ( mat % matma48 % ainf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_analyse with ainfop%flag = ' , mat % matma48 % ainf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % eltptr => mat % eltptr mat % matmump % eltvar => mat % eltvar mat % matmump % a_elt => mat % a_elt mat % matmump % rhs => mat % b mat % matmump % n = mat % nn mat % matmump % nelt = mat % ne mat % matmump % job = 1 ! performs the analysis call dmumps ( mat % matmump ) case ( SULU ) mat % matsulu % irow => mat % irow mat % matsulu % jptr => mat % jptr mat % matsulu % a_elt => mat % a_elt mat % matsulu % b => mat % b mat % matsulu % n = mat % nn mat % matsulu % nz = mat % nz mat % matsulu % nrhs = 1 mat % matsulu % first = . true . call prep_superlu ( sulu = mat % matsulu ) case ( UMFP ) call s_umfpack_di_symbolic ( n_row = mat % nn , & n_col = mat % nn , & Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'ANALYSE_SOLVER : unknown solver type' endselect return endsubroutine analyse_solver !========================================================================================= subroutine factorize_solver ( mat ) !! Subroutine to factorize the matrix of the system implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* !if ( mat%fac ) call freefact_solver(mat) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_factorize ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & finfo = mat % matma48 % finf , & fast = mat % matma48 % fast ) if ( mat % matma48 % finf % flag < 0 ) then write ( OPU , * ) 'Failure of ma48_factorize with finfo%flag = ' , mat % matma48 % finf % flag stop endif #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 2 call dmumps ( mat % matmump ) case ( SULU ) ! Just factorize once, in the case that the matrix doesn't change much if ( mat % matsulu % first ) call fact_superlu ( sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! first release memory call s_umfpack_di_numeric ( Ap = mat % jptr , & Ai = mat % irow , & Ax = mat % a_elt , & Symbolic = mat % matumfp % c_symbolic , & Numeric = mat % matumfp % c_numeric , & Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) case default stop 'Unknown solver type, FACTORIZE_SOLVER' endselect return endsubroutine factorize_solver !========================================================================================= subroutine solution_solver ( mat ) !! Subroutine to solve the system [A]\\{x\\} = \\{b\\} (sparse A) implicit none type ( MAT_SOLV ), target , intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 call ma48_solve ( matrix = mat % matma48 % zmat , & factors = mat % matma48 % fact , & rhs = mat % b , & x = mat % x , & control = mat % matma48 % ctrl , & sinfo = mat % matma48 % sinf , & resid = mat % matma48 % resid , & error = mat % error ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) mat % matmump % job = 3 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error in SOLUTION_SOLVER' endif ! solution has been assembled on the host if ( mat % matmump % myid == 0 ) then mat % x ( 1 : mat % nn ) = mat % matmump % rhs ( 1 : mat % nn ) endif case ( SULU ) call solv_superlu ( sol_x = mat % x , & sulu = mat % matsulu , & verbose = ( mat % matsulu % options % PrintStat == 1 )) mat % matsulu % first = . false . case ( UMFP ) ! Numeric factors must exist if (. not . C_ASSOCIATED ( mat % matumfp % c_numeric )) call solve_syst ( mat , 'fac' ) mat % matumfp % c_control ( UMFPACK_IRSTEP ) = 0 ! solve ax=b, without iterative refinement ! If you want to evaluate the required RAM (Go) ! write(*,*) mat%matumfp%c_info(UMFPACK_PEAK_MEMORY_ESTIMATE)/mat%matumfp%c_info(UMFPACK_SIZE_OF_UNIT)/1e9 ! write(*,*) sizeof(mat%a_elt)/1e9 call s_umfpack_di_solve ( sys = UMFPACK_A , & x = mat % x , & b = mat % b , & numeric = mat % matumfp % c_numeric , & control = mat % matumfp % c_control , & info = mat % matumfp % c_info ) if ( mat % matumfp % c_info ( UMFPACK_STATUS ) < 0 ) then write ( OPU , * ) 'error occurred in umfpack_di_solve: ' , mat % matumfp % c_info ( UMFPACK_STATUS ) stop 'Error in SOLUTION_SOLVER' endif case default stop 'Unknown solver type, SOLUTION_SOLVER' endselect return endsubroutine solution_solver !========================================================================================= subroutine freefact_solver ( mat ) !! Subroutine to free the factors if applicable implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) continue case ( SULU ) call free_superlu () case ( UMFP ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization case default stop 'unknown solver type, FREEFACT_SOLVER' endselect return endsubroutine freefact_solver !========================================================================================= subroutine close_solver ( mat ) !! Subroutine to close the solver implicit none type ( MAT_SOLV ), intent ( inout ) :: mat !! *high level system type* integer ( kind = I4 ) :: ierr if ( allocated ( mat % eltptr ) ) deallocate ( mat % eltptr ) if ( allocated ( mat % eltvar ) ) deallocate ( mat % eltvar ) select case ( mat % slv_t ) case ( MA48 ) #if WITH_MA48 nullify ( mat % matma48 % zmat % row ) nullify ( mat % matma48 % zmat % col ) nullify ( mat % matma48 % zmat % val ) call ma48_finalize ( factors = mat % matma48 % fact , & control = mat % matma48 % ctrl , & info = ierr ) deallocate ( mat % b , mat % x ) #else stop 'MA48_LIB not defined' #endif case ( MUMP ) if ( mat % matmump % myid == 0 ) then nullify ( mat % matmump % rhs ) nullify ( mat % matmump % eltptr ) nullify ( mat % matmump % eltvar ) nullify ( mat % matmump % a_elt ) endif ! destroy the instance (deallocate internal data structures) mat % matmump % job = - 2 call dmumps ( mat % matmump ) if ( mat % matmump % infog ( 1 ) < 0 ) then write ( OPU , '(a,a,i6,a,i9)' ) ' error return: ' , & '  mumps_par%infog(1)= ' , mat % matmump % infog ( 1 ), & '  mumps_par%infog(2)= ' , mat % matmump % infog ( 2 ) call mpi_finalize ( ierr ) stop 'Error MUMP in close_solver' endif call mpi_finalize ( ierr ) deallocate ( mat % b , mat % x ) case ( SULU ) call close_superlu ( sulu = mat % matsulu ) nullify ( mat % matsulu % b ) nullify ( mat % matsulu % irow ) nullify ( mat % matsulu % jptr ) nullify ( mat % matsulu % a_elt ) case ( UMFP ) deallocate ( mat % jptr , mat % irow ) call umfpack_di_free_numeric ( Numeric = mat % matumfp % c_numeric ) ! free the numeric factorization ! no lu factors (numeric) are in memory at this point. call umfpack_di_free_symbolic ( Symbolic = mat % matumfp % c_symbolic ) ! free the symbolic analysis call umfpack_di_report_info ( Control = mat % matumfp % c_control , & Info = mat % matumfp % c_info ) ! print final statistics deallocate ( mat % b , mat % x ) case default stop 'Unknown solver type, close_solver' endselect return endsubroutine close_solver !========================================================================================= subroutine convert_matrice_format ( mat ) !! Subroutine to transform the Rutherford Boeing format into Harwell Boeing and triplet implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ) :: i !< ======================================================================================================================= !< Compressed Column Storage (CCS) is also called the Harwell-Boeing sparse matrix format. !< ************************************************ !< Elemental entries (example provided by MUMP): !< A1 = 1|-1  2  3| A2 = 3|2 -1  3| !<      2| 2  1  1|      4|1  2 -1| !<      3| 1  1  1|      5|3  2  1| => a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) !< !< A  = 1|-1  2  3  0  0| !<      2| 2  1  1  0  0| !<      3| 1  1  3 -1  3| !<      4| 0  0  1  2 -1| !<      5| 0  0  3  2  1| => eltvar = (1, 2, 3, 3, 4, 5), it locates the elemental matrix line in the assembled matrix !<                        => eltptr = (1, 4, 7), it gives the elemental matrix first entry position in eltvar (last !<                                               position being size(eltvar)+1) !< !< ************************************************ !< Assembled matrix : !< A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !<                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !<                    jptr = (1, 4, 7, 12, 15, 18) !< !< ======================================================================================================================= !< Triplet form !< ************************************************ !< For each non zero a_elt entry, returns its row and column number !< A being the same, a_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 3, 1, 3, -1, 2, 2, 3, -1, 1) !<                    irow = ( 1, 2, 3, 1, 2, 3, 1, 2, 3, 4, 5,  3, 4, 5, 3,  4, 5) !<                    jcol = ( 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3,  4, 4, 4, 5,  5, 5) call from_elemental_to_assembled ( mat = mat ) select case ( mat % slv_t ) case ( MA48 ) ! Triplet form: irow, jcol, a_elt #if WITH_MA48 continue #else stop 'MA48_LIB not defined' #endif case ( MUMP ) ! Compressed row, elemental entries chosen: eltptr, eltvar, a_elt continue case ( UMFP , SULU ) ! Compressed row, assembled form: irow, jptr, a_elt deallocate ( mat % jcol ) ! no more needed ! UMFP and SULU allocations begin at 0 (C convention) do i = 1 , mat % nn + 1 mat % jptr ( i ) = mat % jptr ( i ) - 1 enddo if ( mat % slv_t == SULU ) mat % matsulu % jptr => mat % jptr ! otherwise, matsulu%jptr will be associated to ! a deallocated part of memory do i = 1 , mat % nz mat % irow ( i ) = mat % irow ( i ) - 1 enddo case default stop 'Unknown solver type, CONVERT_MATRICE_FORMAT' endselect return endsubroutine convert_matrice_format !========================================================================================= subroutine from_elemental_to_assembled ( mat ) !! Subroutine to transform the elemental entries into assembled CC vectors implicit none type ( MAT_SOLV ), intent ( inout ), target :: mat !! *high level system type* integer ( kind = I4 ), pointer :: solver , nb_elt , n , ntot , nz integer ( kind = I4 ), dimension (:), pointer :: eltptr integer ( kind = I4 ), dimension (:), pointer :: eltvar real ( kind = R8 ), dimension (:), pointer :: a_elt integer ( kind = I4 ), dimension (:), pointer :: irow , jcol integer ( kind = I4 ), dimension (:), pointer :: jptr integer ( kind = I4 ) :: inelt , imatorder , i , j , ii , jj , i1 , i2 , ir1 , ir2 , jr1 , jr2 , itmp , innz , state solver => mat % slv_t nb_elt => mat % ne n => mat % nn ntot => mat % nt nz => mat % nz if ( solver == MUMP ) return ! conversion from elemental form to triplet form, perhaps with null a_elts !-------------------------------------------------------------------------- state = 0 if (. not . allocated ( mat % irow )) allocate ( mat % irow ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' if (. not . allocated ( mat % jcol )) allocate ( mat % jcol ( ntot ), stat = state ) if ( state /= 0 ) stop 'Memory allocation problem, FROM_ELEMENTAL_TO_ASSEMBLED' eltptr => mat % eltptr eltvar => mat % eltvar a_elt => mat % a_elt irow => mat % irow jcol => mat % jcol jptr => mat % jptr irow ( 1 : ntot ) = - 1 jcol ( 1 : ntot ) = - 1 ii = 1 do inelt = 1 , nb_elt imatorder = eltptr ( inelt + 1 ) - eltptr ( inelt ) do i = 1 , imatorder irow ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ): eltptr ( inelt + 1 ) - 1 ) jcol ( ii :( ii + imatorder - 1 )) = eltvar ( eltptr ( inelt ) + i - 1 ) ii = ii + imatorder enddo enddo ! where a_elt brings no contribution, rows and columns are zeroed !----------------------------------------------------------------- where ( abs ( a_elt ) < EPS_R8 ) irow = 0 jcol = 0 endwhere ! the triplet irow, jcol and a_elt is sorted according jcol !----------------------------------------------------------- call sort_array2 ( tab_inout = jcol ( 1 : ntot ), & ! tab1 = irow ( 1 : ntot ), & ! tab2 = a_elt ( 1 : ntot ), n = ntot ) ! ! column pointer determination for each new value !---------------------------------------------- if ( allocated ( mat % jptr )) deallocate ( mat % jptr ) ; allocate ( mat % jptr ( n + 1 ) ) ; jptr => mat % jptr ii = 1 do if ( jcol ( ii ) > 0 ) exit ! zeroed terms are ignored ii = ii + 1 enddo jptr ( 1 ) = ii do i = 1 , n - 1 itmp = jcol ( ii ) do ii = ii + 1 if ( jcol ( ii ) /= itmp ) exit enddo jptr ( i + 1 ) = ii enddo jptr ( n + 1 ) = ntot + 1 ! columns are already sorted; rows are now sorted for each row value !-------------------------------------------------------------------- do i = 1 , n i1 = jptr ( i ) i2 = jptr ( i + 1 ) - 1 call sort_array2 ( tab_inout = irow ( i1 : i2 ), & ! tab1 = a_elt ( i1 : i2 ), n = i2 - i1 + 1 ) ! enddo ! assembly starting from the jcol, irow and a_elt top ! for identical matrix locations, a_elts are added !----------------------------------------------------- innz = 1 jj = jptr ( 1 ) ! first non-zero element jr1 = jcol ( jj ) ir1 = irow ( jj ) jcol ( innz ) = jr1 irow ( innz ) = ir1 a_elt ( innz ) = a_elt ( jj ) do j = jj + 1 , ntot jr2 = jcol ( j ) ir2 = irow ( j ) if ( ( jr2 /= jr1 ). or .( ir2 /= ir1 ) ) then ! if row or column index has changed innz = innz + 1 ! a non-zero term is added jcol ( innz ) = jr2 irow ( innz ) = ir2 a_elt ( innz ) = a_elt ( j ) else a_elt ( innz ) = a_elt ( innz ) + a_elt ( j ) ! row and column indexes are the same, stiffness terms are added endif jr1 = jr2 ! stores (i-1) and (j-1) for further comparison ir1 = ir2 enddo nz = innz jcol ( nz + 1 : ntot ) = - 1 irow ( nz + 1 : ntot ) = - 1 a_elt ( nz + 1 : ntot ) = huge ( 1._R8 ) ! col pointer update !---------------------------------------------- jj = 1 jptr ( 1 ) = 1 do j = 1 , n - 1 itmp = jcol ( jj ) do jj = jj + 1 if ( jcol ( jj ) /= itmp ) exit enddo jptr ( j + 1 ) = jj enddo jptr ( n + 1 ) = nz + 1 nullify ( eltptr , eltvar , a_elt , irow , jcol , jptr ) return endsubroutine from_elemental_to_assembled endmodule solver","tags":"","loc":"sourcefile/mod_solver.f90.html"},{"title":"dmumps_struc.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~dmumps_struc.f90~~AfferentGraph sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< @note !<  This file is part of MUMPS 5.5.1, released !<  on Tue Jul 12 13:17:24 UTC 2022 !< !<  Copyright 1991-2022 CERFACS, CNRS, ENS Lyon, INP Toulouse, Inria, !<  Mumps Technologies, University of Bordeaux. !< !<  This version of MUMPS is provided to you free of charge. It is !<  released under the CeCILL-C license !<  (see doc/CeCILL-C_V1-en.txt, doc/CeCILL-C_V1-fr.txt, and !<  https://cecill.info/licences/Licence_CeCILL-C_V1-en.html) !< @endnote module mumps_wrapper ! ! INCLUDE 'dmumps_root.f90' INCLUDE 'mpif.f90' TYPE DMUMPS_STRUC SEQUENCE ! ! This structure contains all parameters ! for the interface to the user, plus internal ! information from the solver ! ! ***************** ! INPUT PARAMETERS ! ***************** !    ----------------- !    MPI Communicator !    ----------------- INTEGER :: COMM !    ------------------ !    Problem definition !    ------------------ !    Solver (SYM=0 unsymmetric,SYM=1 symmetric Positive Definite, !        SYM=2 general symmetric) !    Type of parallelism (PAR=1 host working, PAR=0 host not working) INTEGER :: SYM , PAR INTEGER :: JOB !    -------------------- !    Order of Input matrix !    -------------------- INTEGER :: N ! !    ---------------------------------------- !    Assembled input matrix : User interface !    ---------------------------------------- INTEGER :: NZ ! Standard integer input + bwd. compat. INTEGER ( 8 ) :: NNZ ! 64-bit integer input DOUBLE PRECISION , DIMENSION (:), POINTER :: A INTEGER , DIMENSION (:), POINTER :: IRN , JCN DOUBLE PRECISION , DIMENSION (:), POINTER :: COLSCA , ROWSCA , pad0 ! !       ------------------------------------ !       Case of distributed assembled matrix !       matrix on entry: !       ------------------------------------ INTEGER :: NZ_loc ! Standard integer input + bwd. compat. INTEGER :: pad1 INTEGER ( 8 ) :: NNZ_loc ! 64-bit integer input INTEGER , DIMENSION (:), POINTER :: IRN_loc , JCN_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: A_loc , pad2 ! !    ---------------------------------------- !    Unassembled input matrix: User interface !    ---------------------------------------- INTEGER :: NELT , pad3 INTEGER , DIMENSION (:), POINTER :: ELTPTR INTEGER , DIMENSION (:), POINTER :: ELTVAR DOUBLE PRECISION , DIMENSION (:), POINTER :: A_ELT , pad4 ! !    --------------------------------------------- !    Symmetric permutation : !               PERM_IN if given by user (optional) !    --------------------------------------------- INTEGER , DIMENSION (:), POINTER :: PERM_IN ! !    ---------------- !    Format by blocks !    ---------------- INTEGER :: NBLK , pad5 INTEGER , DIMENSION (:), POINTER :: BLKPTR INTEGER , DIMENSION (:), POINTER :: BLKVAR ! ! ****************** ! INPUT/OUTPUT data ! ****************** !    -------------------------------------------------------- !    RHS / SOL_loc !    ------------- !       right-hand side and solution !    ------------------------------------------------------- DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS , REDRHS DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_SPARSE DOUBLE PRECISION , DIMENSION (:), POINTER :: SOL_loc DOUBLE PRECISION , DIMENSION (:), POINTER :: RHS_loc INTEGER , DIMENSION (:), POINTER :: IRHS_SPARSE INTEGER , DIMENSION (:), POINTER :: IRHS_PTR INTEGER , DIMENSION (:), POINTER :: ISOL_loc INTEGER , DIMENSION (:), POINTER :: IRHS_loc INTEGER :: LRHS , NRHS , NZ_RHS , Nloc_RHS , LRHS_loc , LREDRHS INTEGER :: LSOL_loc , pad6 !    ---------------------------- !    Control parameters, !    statistics and output data !    --------------------------- INTEGER :: ICNTL ( 60 ) INTEGER :: INFO ( 80 ) INTEGER :: INFOG ( 80 ) DOUBLE PRECISION :: COST_SUBTREES DOUBLE PRECISION :: CNTL ( 15 ) DOUBLE PRECISION :: RINFO ( 40 ) DOUBLE PRECISION :: RINFOG ( 40 ) ! The options array for metis/parmetis INTEGER :: METIS_OPTIONS ( 40 ) !    --------------------------------------------------------- !    Permutations computed during analysis: !       SYM_PERM: Symmetric permutation !       UNS_PERM: Column permutation (optional) !    --------------------------------------------------------- INTEGER , DIMENSION (:), POINTER :: SYM_PERM , UNS_PERM ! !    ----- !    Schur !    ----- INTEGER :: NPROW , NPCOL , MBLOCK , NBLOCK INTEGER :: SCHUR_MLOC , SCHUR_NLOC , SCHUR_LLD INTEGER :: SIZE_SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR DOUBLE PRECISION , DIMENSION (:), POINTER :: SCHUR_CINTERFACE INTEGER , DIMENSION (:), POINTER :: LISTVAR_SCHUR !    ------------------------------------- !    Case of distributed matrix on entry: !    DMUMPS potentially provides mapping !    ------------------------------------- INTEGER , DIMENSION (:), POINTER :: MAPPING !    -------------- !    Version number !    -------------- CHARACTER ( LEN = 30 ) :: VERSION_NUMBER !    ----------- !    Out-of-core !    ----------- CHARACTER ( LEN = 255 ) :: OOC_TMPDIR CHARACTER ( LEN = 63 ) :: OOC_PREFIX !    ------------------------------------------ !    Name of file to dump a matrix/rhs to disk !    ------------------------------------------ CHARACTER ( LEN = 255 ) :: WRITE_PROBLEM !    ----------- !    Save/Restore !    ----------- CHARACTER ( LEN = 255 ) :: SAVE_DIR CHARACTER ( LEN = 255 ) :: SAVE_PREFIX CHARACTER ( LEN = 7 ) :: pad7 ! ! ! ********************** ! INTERNAL Working data ! ********************* INTEGER ( 8 ) :: KEEP8 ( 150 ), MAX_SURF_MASTER INTEGER :: INST_Number !       For MPI INTEGER :: COMM_NODES , MYID_NODES , COMM_LOAD INTEGER :: MYID , NPROCS , NSLAVES INTEGER :: ASS_IRECV !       IS is used for the factors + workspace for contrib. blocks INTEGER , DIMENSION (:), POINTER :: IS INTEGER :: KEEP ( 500 ) !       The following data/arrays are computed during the analysis !       phase and used during the factorization and solve phases. INTEGER :: LNA INTEGER :: NBSA INTEGER , POINTER , DIMENSION (:) :: STEP , NE_STEPS , ND_STEPS INTEGER , POINTER , DIMENSION (:) :: FRERE_STEPS , DAD_STEPS INTEGER , POINTER , DIMENSION (:) :: FILS , FRTPTR , FRTELT INTEGER ( 8 ), POINTER , DIMENSION (:) :: PTRAR INTEGER , POINTER , DIMENSION (:) :: NA , PROCNODE_STEPS !       Info for pruning tree INTEGER , POINTER , DIMENSION (:) :: Step2node !       PTLUST_S and PTRFAC are two pointer arrays computed during !       factorization and used by the solve INTEGER , DIMENSION (:), POINTER :: PTLUST_S INTEGER ( 8 ), DIMENSION (:), POINTER :: PTRFAC !       main real working arrays for factorization/solve phases DOUBLE PRECISION , DIMENSION (:), POINTER :: S !       Information on mapping INTEGER , DIMENSION (:), POINTER :: PROCNODE !       Input matrix ready for numerical assembly !           -arrowhead format in case of assembled matrix !           -element format otherwise INTEGER , DIMENSION (:), POINTER :: INTARR DOUBLE PRECISION , DIMENSION (:), POINTER :: DBLARR !       Element entry: internal data INTEGER :: NELT_loc , LELTVAR INTEGER , DIMENSION (:), POINTER :: ELTPROC !       Candidates and node partitionning INTEGER , DIMENSION (:,:), POINTER :: CANDIDATES INTEGER , DIMENSION (:), POINTER :: ISTEP_TO_INIV2 INTEGER , DIMENSION (:), POINTER :: FUTURE_NIV2 INTEGER , DIMENSION (:,:), POINTER :: TAB_POS_IN_PERE LOGICAL , DIMENSION (:), POINTER :: I_AM_CAND !       For heterogeneous architecture INTEGER , DIMENSION (:), POINTER :: MEM_DIST !       Compressed RHS INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_ROW LOGICAL :: POSINRHSCOMP_COL_ALLOC , pad11 INTEGER , DIMENSION (:), POINTER :: POSINRHSCOMP_COL DOUBLE PRECISION , DIMENSION (:), POINTER :: RHSCOMP !       Info on the subtrees to be used during factorization DOUBLE PRECISION , DIMENSION (:), POINTER :: MEM_SUBTREE DOUBLE PRECISION , DIMENSION (:), POINTER :: COST_TRAV INTEGER , DIMENSION (:), POINTER :: MY_ROOT_SBTR INTEGER , DIMENSION (:), POINTER :: MY_FIRST_LEAF INTEGER , DIMENSION (:), POINTER :: MY_NB_LEAF INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST INTEGER , DIMENSION (:), POINTER :: DEPTH_FIRST_SEQ INTEGER , DIMENSION (:), POINTER :: SBTR_ID INTEGER , DIMENSION (:), POINTER :: SCHED_DEP INTEGER , DIMENSION (:), POINTER :: SCHED_GRP INTEGER , DIMENSION (:), POINTER :: SCHED_SBTR INTEGER , DIMENSION (:), POINTER :: CROIX_MANU DOUBLE PRECISION , DIMENSION (:), POINTER :: WK_USER INTEGER :: NBSA_LOCAL INTEGER :: LWK_USER !    Internal control array DOUBLE PRECISION :: DKEEP ( 230 ) !    For simulating parallel out-of-core stack. DOUBLE PRECISION , DIMENSION (:), POINTER :: CB_SON_SIZE !    Instance number used/managed by the C/F77 interface INTEGER :: INSTANCE_NUMBER !    OOC management data that must persist from factorization to solve. INTEGER :: OOC_MAX_NB_NODES_FOR_ZONE INTEGER , DIMENSION (:,:), POINTER :: OOC_INODE_SEQUENCE INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_SIZE_OF_BLOCK INTEGER ( 8 ), DIMENSION (:,:), POINTER :: OOC_VADDR INTEGER , DIMENSION (:), POINTER :: OOC_TOTAL_NB_NODES INTEGER , DIMENSION (:), POINTER :: OOC_NB_FILES INTEGER :: OOC_NB_FILE_TYPE , pad12 INTEGER , DIMENSION (:), POINTER :: OOC_FILE_NAME_LENGTH CHARACTER , DIMENSION (:,:), POINTER :: OOC_FILE_NAMES !    Indices of nul pivots INTEGER , DIMENSION (:), POINTER :: PIVNUL_LIST !    Array needed to manage additionnal candidate processor INTEGER , DIMENSION (:,:), POINTER :: SUP_PROC , pad14 !    Lists of nodes where processors work. Built/used in solve phase. INTEGER , DIMENSION (:), POINTER :: IPTR_WORKING , WORKING !    Root structure(internal) TYPE ( DMUMPS_ROOT_STRUC ) :: root !    Low-rank INTEGER , POINTER , DIMENSION (:) :: LRGROUPS INTEGER :: NBGRP , pad13 !    Pointer encoding for FDM_F data CHARACTER , DIMENSION (:), POINTER :: FDM_F_ENCODING !    Pointer array encoding BLR factors pointers CHARACTER , DIMENSION (:), POINTER :: BLRARRAY_ENCODING !    Multicore TYPE ( DMUMPS_L0OMPFAC_T ), DIMENSION (:), POINTER :: L0_OMP_FACTORS INTEGER :: LPOOL_A_L0_OMP , LPOOL_B_L0_OMP INTEGER :: L_PHYS_L0_OMP INTEGER :: L_VIRT_L0_OMP INTEGER :: LL0_OMP_MAPPING , LL0_OMP_FACTORS INTEGER ( 8 ) :: THREAD_LA ! Estimates before L0_OMP INTEGER , DIMENSION (:,:), POINTER :: I4_L0_OMP INTEGER ( 8 ), DIMENSION (:,:), POINTER :: I8_L0_OMP ! Pool before L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_B_L0_OMP ! Pool after L0_OMP INTEGER , DIMENSION (:), POINTER :: IPOOL_A_L0_OMP ! Subtrees INTEGER , DIMENSION (:), POINTER :: PHYS_L0_OMP ! Amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP ! Mapping of amalgamated subtrees INTEGER , DIMENSION (:), POINTER :: VIRT_L0_OMP_MAPPING ! From heaviest to lowest subtree INTEGER , DIMENSION (:), POINTER :: PERM_L0_OMP ! To get leafs in global pool INTEGER , DIMENSION (:), POINTER :: PTR_LEAFS_L0_OMP ! Mapping of the subtree nodes INTEGER , DIMENSION (:), POINTER :: L0_OMP_MAPPING ! Mpi to omp - mumps agile INTEGER , DIMENSION (:), POINTER :: MPITOOMP_PROCS_MAP ! for RR on root DOUBLE PRECISION , DIMENSION (:), POINTER :: SINGULAR_VALUES INTEGER :: NB_SINGULAR_VALUES INTEGER :: Deficiency , pad16 ! To know if OOC files are associated to a saved and so if they should be removed. LOGICAL :: ASSOCIATED_OOC_FILES END TYPE DMUMPS_STRUC endmodule mumps_wrapper","tags":"","loc":"sourcefile/dmumps_struc.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~10~~EfferentGraph sourcefile~prg.f90~10 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~10->sourcefile~mod_data_arch.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~prg.f90~10->sourcefile~mod_gen_par.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~10->sourcefile~mod_miscellaneous.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~dmumps_struc.f90 dmumps_struc.f90 sourcefile~mod_solver.f90->sourcefile~dmumps_struc.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~umfpack.f90 umfpack.f90 sourcefile~mod_solver.f90->sourcefile~umfpack.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: july, 12 2018 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **MSOLV example of use** !<  </span> !< !< @note !< !< !< The program asks first for the matrix size: ```1``` for a very small matrix, and ```0``` !< for a bigger one.The systems are CC HB format systems with elemental matrices. !< !< <h3>Small system -- nnz=18</h3> !< !< The system is (example provided by MUMP): !<  A1 = \\begin{pmatrix} !<           -1 & 2 & 3 \\\\ !<            2 & 1 & 1 \\\\ !<            1 & 1 & 1 !<          \\end{pmatrix} ~ !<    A2 = \\begin{pmatrix} !<            2 & -1 &  3 \\\\ !<            1 &  2 & -1 \\\\ !<            3 &  2 &  1 !<         \\end{pmatrix}  \\\\ \\text{ } \\\\ !< \\rightarrow a\\_elt = (-1, 2, 1, 2, 1, 1, 3, 1, 1, 2, 1, 3, -1, 2, 2, 3, -1, 1) \\\\ \\text{ } \\\\ !<  A = \\begin{pmatrix} !<           -1 & 2 & 3 & 0 & 0 \\\\ !<            2 & 1 & 1 & 0 & 0 \\\\ !<            1 & 1 & 3 &-1 & 3 \\\\ !<            0 & 0 & 1 & 2 &-1 \\\\ !<            0 & 0 & 3 & 2 & 1 !<      \\end{pmatrix}  \\\\ \\text{ } \\\\ !< \\rightarrow eltvar = (1, 2, 3, 3, 4, 5) \\text{ and } eltptr = (1, 4, 7) !<  !< !< + *eltvar* locates the elemental matrix line in the assembled matrix !< + *eltptr* gives the elemental matrix first entry position in *eltvar* !<          (last position being size(*eltvar*)+1) <br/><br/> !< !< The rhs is (12, 7, 23, 6, 22), and the solution (1, 2, 3, 4, 5) !< !< <h3>Big (well, in fact, medium) system -- nnz=2,097,152</h3> !< !< The system results from a *MUSST* study case and there is of course no theoretical solution to compare with !< !< @endnote !< !< @warning !< !< Some solver implementation are C written, so the arrays may begin at 0. It explains the variable ```dec``` in [[prod_a_x]] !< !< @endwarning program test_solvers use omp_lib , only : omp_get_wtime use data_arch , only : I4 , R4 , R8 , & OPU , & ! *default output unit* IPU ! *default input unit* use miscellaneous , only : get_unit use gen_param , only : SOLV_MESS , & ! *Solver message: yes=```PRINT_MESS```, no=```NO_MESS```* NO_MESS , & ! *no output message* PRINT_MESS ! *solver infos output* use solver , only : MAT_SOLV , & ! *system data type* solve_syst , & ! *subroutine for the system resolution* MUMP , & ! *integer* UMFP , & ! *integer* SULU , & ! *integer* convert_matrice_format ! *various matrix format conversion* implicit none integer ( kind = I4 ) :: i , ii , uu , size_a_elt , state real ( kind = R8 ) :: time1 , time2 , error type ( MAT_SOLV ) :: slv_struct real ( kind = R8 ), dimension (:), allocatable :: b !! *system right hand side* real ( kind = R8 ), dimension (:), allocatable :: a_elt !! *matrix non-zero entries in CC* real ( kind = R8 ), dimension (:), allocatable :: a_elt_ref !! *initial ```a_elt```* integer ( kind = I4 ), dimension (:), allocatable :: eltptr !! *elemental matrices position in ```eltvar```* integer ( kind = I4 ), dimension (:), allocatable :: eltvar !! *elemental matrix global lines* SOLV_MESS = NO_MESS !PRINT_MESS! write ( OPU , * ) 'small matrix? 0:n, 1:y' read ( IPU , * ) i ! ======================== SOLVER TYPE =========================================== do write ( OPU , * ) 'data read, choose solver n° : 0-MA48, 1-SULU, 2-MUMP (ref), 3-UMFP' read ( IPU , * ) ii slv_struct % slv_t = ii if ( ii >= 0 . and . ii <= 3 ) exit enddo ! ======================== SYST DATA READ =========================================== call get_unit ( uu ) if ( i == 0 ) then open ( unit = uu , file = \"mat/big_syst.bin\" , form = 'unformatted' , access = 'stream' ) else open ( unit = uu , file = \"mat/small_syst.bin\" , form = 'unformatted' , access = 'stream' ) endif ! ======================== SYST INFO =========================================== read ( uu ) slv_struct % nn , slv_struct % ne , slv_struct % nvar , slv_struct % nt write ( OPU , * ) '*************** INFO ********************' write ( OPU , * ) 'system size:                  ' , slv_struct % nn write ( OPU , * ) 'number of elemental matrices: ' , slv_struct % ne write ( OPU , * ) 'number of nnz entries:        ' , slv_struct % nt write ( OPU , * ) '*****************************************' allocate ( eltvar ( slv_struct % nvar ) ) allocate ( a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( a_elt_ref ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( eltptr ( slv_struct % ne + 1 ) ) allocate ( b ( slv_struct % nn ) ) allocate ( slv_struct % eltvar ( slv_struct % nvar ) ) allocate ( slv_struct % a_elt ( slv_struct % nt ), stat = state ) ; if ( state /= 0 ) stop 'Memory allocation problem in PRG' allocate ( slv_struct % eltptr ( slv_struct % ne + 1 ) ) call solve_syst ( mat = slv_struct , step = 'ini' ) do ii = 1 , slv_struct % nvar read ( uu ) slv_struct % eltvar ( ii ) enddo do ii = 1 , slv_struct % ne + 1 read ( uu ) slv_struct % eltptr ( ii ) enddo do ii = 1 , slv_struct % nt read ( uu ) slv_struct % a_elt ( ii ) enddo do ii = 1 , slv_struct % nn read ( uu ) slv_struct % b ( ii ) enddo close ( uu ) ! The matrices are in CC HB format. Only MUMPS accepts elemental entries, so the ! following subroutine converts elemental marices to assembled vectors. ! If MUMPS is chosen, nothing is done. call convert_matrice_format ( mat = slv_struct ) ! ======================== backup ============================================ eltvar = slv_struct % eltvar a_elt_ref = slv_struct % a_elt eltptr = slv_struct % eltptr b = slv_struct % b ! ======================== PROCESS =========================================== time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'ana' ) ; write ( OPU , * ) 'system analyzed' call solve_syst ( mat = slv_struct , step = 'fac' ) ; write ( OPU , * ) 'system factorized' call solve_syst ( mat = slv_struct , step = 'sol' ) ; write ( OPU , * ) 'system solved' call solve_syst ( mat = slv_struct , step = 'fre' ) ; write ( OPU , * ) 'system freed' time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt_ref , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) ! Here, the matrix coefficients are modified, but the sparsity is conserved. It gives a look to the ability ! of the solver to exploit the symbolic calculations performed before. do if ( slv_struct % slv_t == MUMP ) then size_a_elt = size ( slv_struct % a_elt ) else size_a_elt = slv_struct % nt endif ! the original entries are retrieved, then modified a_elt = a_elt_ref call modify_a_elt ( tab = a_elt , nz = size_a_elt ) slv_struct % a_elt = a_elt slv_struct % b = b slv_struct % x = 0._R8 time1 = omp_get_wtime () call solve_syst ( mat = slv_struct , step = 'fac' ) call solve_syst ( mat = slv_struct , step = 'sol' ) call solve_syst ( mat = slv_struct , step = 'fre' ) time2 = omp_get_wtime () call verif_solution ( slv_struct = slv_struct , a_elt = a_elt , b = b , error = error ) write ( OPU , * ) 'max error    = ' , error write ( OPU , * ) 'elapsed time = ' , real ( abs ( time1 - time2 ), kind = R4 ) write ( OPU , * ) 'STOP? (y=1, n=0)' read ( IPU , * ) ii if ( ii == 1 ) exit enddo deallocate ( eltvar , a_elt , a_elt_ref , eltptr , b ) call solve_syst ( mat = slv_struct , step = 'end' ) stop contains !========================================================================================= !< @note The product \\{y\\} of the system matrix [A] by the solution \\{x\\}, is !<        calculated, and compared to the right hand side \\{b\\}. !<        The calculated error is the absolute error in %. !< @endnote !----------------------------------------------------------------------------------------- subroutine verif_solution ( slv_struct , a_elt , b , error ) implicit none type ( MAT_SOLV ), intent ( in ) :: slv_struct real ( kind = R8 ), dimension (:), intent ( in ) :: a_elt real ( kind = R8 ), dimension (:), intent ( in ) :: b real ( kind = R8 ), intent ( out ) :: error real ( kind = R8 ), dimension ( slv_struct % nn ) :: y ! to assess the accuracy, the solution is applied to the ! system matrix and compared to the rhs. if ( slv_struct % slv_t == MUMP ) then call prod_elemental_x ( n = slv_struct % nn , & nz = slv_struct % nt , & nelt = slv_struct % ne , & nvar = slv_struct % nvar , & x = slv_struct % x , & y = y , & a_elt = a_elt , & eltptr = slv_struct % eltptr , & eltvar = slv_struct % eltvar ) else call prod_a_x ( n = slv_struct % nn , & nz = slv_struct % nz , & x = slv_struct % x , & y = y , & a_elt = a_elt , & irow = slv_struct % irow , & jptr = slv_struct % jptr , & slvt = slv_struct % slv_t ) endif error = 100 * maxval ( abs ( y ( 1 : slv_struct % nn ) - b ( 1 : slv_struct % nn )) ) / & maxval ( abs ( y ( 1 : slv_struct % nn ) + b ( 1 : slv_struct % nn )) ) return endsubroutine verif_solution !========================================================================================= subroutine modify_a_elt ( tab , nz ) !! mMltiplication of the system coefficient by a random factor implicit none integer ( kind = I4 ), intent ( in ) :: nz real ( kind = R8 ), intent ( inout ) :: tab ( 1 : nz ) real ( kind = R8 ), allocatable :: tmp (:) allocate ( tmp ( 1 : nz )) call random_number ( harvest = tmp ( 1 : nz )) tmp ( 1 : nz ) = 2 * tmp ( 1 : nz ) - 1.0_R8 tab ( 1 : nz ) = tab ( 1 : nz ) * tmp ( 1 : nz ) deallocate ( tmp ) return endsubroutine modify_a_elt !========================================================================================= subroutine prod_a_x ( n , nz , x , y , a_elt , irow , jptr , slvt ) !! [A] \\{x\\}, assembled CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , slvt real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nz ), intent ( in ) :: irow integer ( kind = I4 ), dimension ( n + 1 ), intent ( in ) :: jptr real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , k , dec y ( 1 : n ) = 0._R8 dec = 0 if ( slvt == UMFP . or . slvt == SULU ) dec = 1 do i = 1 , n do k = jptr ( i ), jptr ( i + 1 ) - 1 y ( irow ( k + dec ) + dec ) = y ( irow ( k + dec ) + dec ) + x ( i ) * a_elt ( k + dec ) enddo enddo return endsubroutine prod_a_x !========================================================================================= subroutine prod_elemental_x ( n , nz , nelt , nvar , x , y , a_elt , eltptr , eltvar ) !! [A] \\{x\\}, elemental CC format implicit none integer ( kind = I4 ), intent ( in ) :: n , nz , nelt , nvar real ( kind = R8 ), dimension ( nz ), intent ( in ) :: a_elt integer ( kind = I4 ), dimension ( nelt + 1 ), intent ( in ) :: eltptr integer ( kind = I4 ), dimension ( nvar ), intent ( in ) :: eltvar real ( kind = R8 ), dimension ( n ), intent ( in ) :: x real ( kind = R8 ), dimension ( n ), intent ( out ) :: y integer ( kind = I4 ) :: i , j , k , kk , inc_nz , inc_nn , n_elem , i_elem , max_n_elem real ( kind = R8 ), dimension (:), allocatable :: a_elt_tmp , x_tmp , y_tmp inc_nz = 0 inc_nn = 0 n_elem = 0 y = 0._R8 max_n_elem = 0 do i_elem = 1 , nelt max_n_elem = max ( max_n_elem , eltptr ( i_elem + 1 ) - eltptr ( i_elem )) enddo allocate ( a_elt_tmp ( 1 : max_n_elem ** 2 ) ) allocate ( x_tmp ( 1 : max_n_elem ) ) allocate ( y_tmp ( 1 : max_n_elem ) ) do i_elem = 1 , nelt ! browse all elemental matrices inc_nn = inc_nn + n_elem ! step in eltvar for matrix number i_elem inc_nz = inc_nz + n_elem ** 2 ! step in a_elt for matrix number i_elem n_elem = eltptr ( i_elem + 1 ) - eltptr ( i_elem ) ! elemental matrix size a_elt_tmp ( 1 : n_elem ** 2 ) = a_elt ( inc_nz + 1 : inc_nz + n_elem ** 2 ) ! elemental matrix coefficients ! --- elemental rhs kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 x_tmp ( kk ) = x ( eltvar ( k )) enddo ! --- elemental product y_tmp ( 1 : n_elem ) = 0._R8 do i = 1 , n_elem do j = 1 , n_elem y_tmp ( i ) = y_tmp ( i ) + a_elt_tmp ( i + n_elem * ( j - 1 )) * x_tmp ( j ) enddo enddo ! --- elemental product in global vector y kk = 0 do k = inc_nn + 1 , inc_nn + n_elem kk = kk + 1 y ( eltvar ( k )) = y ( eltvar ( k )) + y_tmp ( kk ) enddo enddo deallocate ( a_elt_tmp , x_tmp , y_tmp ) return endsubroutine prod_elemental_x endprogram test_solvers","tags":"","loc":"sourcefile/prg.f90~10.html"},{"title":"mod_files.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_files.f90~~EfferentGraph sourcefile~mod_files.f90 mod_files.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_files.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_files.f90~~AfferentGraph sourcefile~mod_files.f90 mod_files.f90 sourcefile~prg.f90~7 prg.f90 sourcefile~prg.f90~7->sourcefile~mod_files.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: february, 27 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Some routines to deal with files** !<  </span> !< !< @todo !< rm -rf dir-name !< @endtodo module files use data_arch , only : I4 use miscellaneous , only : get_unit implicit none private public :: is_linux , dir_separator , mkdir , str_replace , list_files , list_dirs , clean_scratch , make_path , & ! path2vec , vec2path , filename , dirname , str_remove_chars contains !================================================================================================ subroutine clean_scratch () !! Subroutine that removes all files with extension .scratch implicit none call execute_command_line ( \"find -type f -name \"\"*.scratch\"\" | xargs rm > err.scratch\" ) return endsubroutine clean_scratch !================================================================================================ subroutine list_files ( dir , list , ext ) !! Subroutine that returns a list of files in a directory implicit none character ( len = * ), intent ( in ) :: dir character ( len = 512 ), intent ( out ), allocatable , dimension (:) :: list character ( len = * ), intent ( in ), optional :: ext character ( len = :), allocatable :: out_file character ( len = 512 ) :: string integer ( kind = I4 ) :: ui , line , i , max_len , ierr if ( present ( ext ) ) then out_file = trim ( ext ) // \".scratch\" call execute_command_line ( \"find \" // trim ( dir ) // \" -maxdepth 1 -type f -name \"\"*.\" // trim ( ext ) // \"\"\" > \" // out_file ) else out_file = \"files.scratch\" call execute_command_line ( \"find \" // trim ( dir ) // \" -maxdepth 1 -type f > \" // out_file ) endif call get_unit ( ui ) open ( unit = ui , file = out_file ) line = 0 max_len = 0 do string = ' ' read ( unit = ui , fmt = '(a)' , iostat = ierr ) string if ( ierr /= 0 ) exit max_len = max ( max_len , len_trim ( string ) ) line = line + 1 enddo if ( max_len > 512 ) stop 'Error list_files: path too long' allocate ( list ( 1 : line ) ) rewind ( ui ) do i = 1 , line read ( unit = ui , fmt = '(a)' ) list ( i ) enddo close ( ui ) deallocate ( out_file ) return endsubroutine list_files !================================================================================================ subroutine list_dirs ( str ) !! Subroutine that returns a list of subdirectories implicit none character ( len = * ), intent ( in ), optional :: str if ( present ( str ) ) then call execute_command_line ( \"find . -maxdepth 1 -type d -name \"\"*\" // trim ( str ) // \"*\"\" > \" // trim ( str ) // \".scratch\" ) else call execute_command_line ( \"find . -maxdepth 1 -type d > dirs.scratch\" ) endif return endsubroutine list_dirs !================================================================================================ logical ( kind = 4 ) function is_linux () !! Function that returns true if the operating system is linux implicit none character ( len = 512 ) :: path call get_environment_variable ( \"PATH\" , path ) is_linux = ( path ( 1 : 1 ) == \"/\" ) return endfunction is_linux !================================================================================================ character ( len = 1 ) function dir_separator () !! Function that returns the system directory separator implicit none logical ( kind = I4 ) :: os_linux , os_windows os_linux = is_linux () os_windows = . not . os_linux dir_separator = \"/\" if ( os_windows ) dir_separator = \"\\\" return endfunction dir_separator !================================================================================================ subroutine mkdir(wkd, directory, sep, exit_status) !! Subroutine that creates a directory implicit none character(len = *), intent(in ) :: wkd character(len = *), intent(in ) :: directory character(len = 1), intent(in ) :: sep integer(kind = I4), intent(out) :: exit_status character(len = 512) :: dir dir = trim(wkd) // sep // trim(directory) call execute_command_line(\" mkdir - p \" // sep // dir , exitstat = exit_status ) return endsubroutine mkdir !================================================================================================ subroutine make_path ( wkd , file_path , exit_status ) !! Subroutine that creates the folders of a file path implicit none character ( len = * ), intent ( in ) :: wkd character ( len = * ), intent ( in ) :: file_path integer ( kind = I4 ), intent ( out ) :: exit_status character ( len = 512 ) :: dir character ( len = 1 ) :: sep integer ( kind = I4 ) :: isep sep = dir_separator () isep = index ( file_path , sep , back = . true . ) dir = file_path ( 1 : isep - 1 ) call mkdir ( wkd = wkd , directory = trim ( dir ), sep = sep , exit_status = exit_status ) return endsubroutine make_path !================================================================================================ subroutine path2vec ( file_path , vec_path ) !! Subroutine that creates a vector containing the folders of a file path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = 512 ), intent ( out ), dimension (:), allocatable :: vec_path character ( len = 512 ) :: dir character ( len = 1 ) :: sep integer ( kind = I4 ) :: is1 , is2 , k sep = dir_separator () k = 0 is2 = len_trim ( file_path ) do is2 = index ( file_path ( 1 : is2 - 1 ), sep , back = . true . ) if ( is2 > 0 ) then k = k + 1 else exit endif enddo allocate ( vec_path ( 1 : k - 1 ) ) is2 = index ( file_path , sep , back = . true . ) dir = file_path ( 1 : is2 - 1 ) k = 0 do is1 = index ( file_path ( 1 : is2 - 1 ), sep , back = . true . ) if ( is1 > 0 ) then k = k + 1 vec_path ( k ) = file_path ( is1 + 1 : is2 - 1 ) is2 = is1 else exit endif enddo vec_path = vec_path ( size ( vec_path ): 1 : - 1 ) return endsubroutine path2vec !================================================================================================ subroutine vec2path ( file_path , vec_path ) !! Subroutine that creates a path from vector of folders implicit none character ( len = : ), intent ( out ), allocatable :: file_path character ( len = 512 ), intent ( in ), dimension (:) :: vec_path character ( len = 1 ) :: sep integer ( kind = I4 ) :: k sep = dir_separator () file_path = '' do k = 1 , size ( vec_path ) file_path = file_path // sep // trim ( vec_path ( k ) ) enddo return endsubroutine vec2path !================================================================================================ function filename ( file_path ) !! Subroutine that keeps only the file from a path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = :), allocatable :: filename character ( len = 1 ) :: sep integer ( kind = I4 ) :: ind sep = dir_separator () ind = index ( file_path , sep , back = . true . ) filename = trim ( file_path ( ind + 1 : ) ) return endfunction filename !================================================================================================ function dirname ( file_path ) !! Subroutine that keeps only the directory from a file path implicit none character ( len = * ), intent ( in ) :: file_path character ( len = :), allocatable :: dirname character ( len = 1 ) :: sep integer ( kind = I4 ) :: ind sep = dir_separator () ind = index ( file_path , sep , back = . true . ) dirname = trim ( file_path ( : ind - 1 ) ) return endfunction dirname !================================================================================================ function str_replace ( string , old_str , new_str , place ) !! Function that replaces a string with another string implicit none character ( len = :), allocatable :: str_replace !! returned string character ( len = * ), intent ( in ) :: string !! string to be modified character ( len = * ), intent ( in ) :: old_str character ( len = * ), intent ( in ) :: new_str integer ( kind = I4 ), intent ( in ) :: place integer ( kind = I4 ) :: ind select case ( place ) case ( 0 , 2 ) ind = index ( string , old_str ) case ( 1 ) ind = index ( string , old_str , back = . true . ) case default stop 'str_replace bad choice' endselect str_replace = string ( 1 : ind - 1 ) // new_str // string ( ind + len ( old_str ): len ( string )) if ( place == 2 ) then do ind = index ( str_replace , old_str ) if ( ind == 0 ) exit str_replace = str_replace ( 1 : ind - 1 ) // new_str // str_replace ( ind + len ( old_str ): len ( str_replace )) enddo endif return endfunction str_replace !================================================================================================ function str_remove_chars ( string , chars ) !! Function that removes the characters of a string from another string implicit none character ( len = :), allocatable :: str_remove_chars !! returned string character ( len = * ), intent ( in ) :: string !! string to be modified character ( len = * ), intent ( in ) :: chars !! list of characters to remove integer ( kind = I4 ) :: i , j str_remove_chars = '' ! Loop through each character in the input string j = 1 do i = 1 , len_trim ( string ) if ( index ( chars , string ( i : i ) ) == 0 ) then str_remove_chars = str_remove_chars // String ( i : i ) j = j + 1 endif enddo return endfunction str_remove_chars endmodule files","tags":"","loc":"sourcefile/mod_files.f90.html"},{"title":"mod_least_squares.f90 – TOOLIB","text":"This file depends on sourcefile~~mod_least_squares.f90~~EfferentGraph sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mod_least_squares.f90~~AfferentGraph sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_least_squares.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_least_squares.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !< version: 1.0.0 !< date: july, 23 2018 !< !< <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<    **Least squares, linear and non linear** !< </span> module least_squares use data_arch , only : I4 , R8 use cholesky , only : choldc , cholsl implicit none private logical ( kind = I4 ), parameter :: verbose = . false . public :: moindres_carres , moindres_carres_lineaire contains subroutine moindres_carres ( nb_var , nb_pts , hij , vec_xy , beta , f , df , typ , eps , relax , nb_var_der , info ) !================================================================================================ !< @note Function that returns the parameters of a function that approximates a data set. The parameters !<        determination is achieved by non linear least squares approximation. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *number of points for function evaluation* integer ( kind = I4 ), intent ( in ) :: nb_var_der !! *number of derivatives* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts ) :: hij !! *vector of evaluation points* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts , 1 : 2 ) :: vec_xy !! *x and y coordinates of evaluation points* real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: beta !! *parameters vector* real ( kind = R8 ), intent ( in ) :: eps !! *stop criterion* real ( kind = R8 ), intent ( in ) :: relax !! *relaxation parameter* character ( len =* ), intent ( in ) :: typ !! *kind of function used* integer ( kind = I4 ), intent ( out ) :: info !! *information from Cholesky resolution* interface real ( kind = R8 ) function f ( xi , yi , var , nb_var , typ ) use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: yi real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var character ( len =* ), intent ( in ) :: typ endfunction f real ( kind = R8 ) function df ( xi , yi , var , nb_var , ivar , typ ) use data_arch , only : I4 , R8 implicit none integer ( kind = I4 ), intent ( in ) :: nb_var integer ( kind = I4 ), intent ( in ) :: ivar real ( kind = R8 ), intent ( in ) :: xi real ( kind = R8 ), intent ( in ) :: yi real ( kind = R8 ), intent ( inout ), dimension ( 1 : nb_var ) :: var character ( len =* ), intent ( in ) :: typ endfunction df endinterface integer ( kind = I4 ) :: i , ii , j , compteur integer ( kind = I4 ) :: n , pseudo_newton real ( kind = R8 ) :: xi , yi , m_abs_scd real ( kind = R8 ), dimension ( 1 : nb_var_der ) :: scd real ( kind = R8 ), dimension ( 1 : nb_var_der , 1 : nb_var_der ) :: mat , sav_mat real ( kind = R8 ), allocatable , dimension (:,:) :: Jf , JfT real ( kind = R8 ), allocatable , dimension (:) :: vec_f , r , pt n = nint ( sqrt ( real ( nb_pts , kind = R8 )) ) allocate ( Jf ( 1 : nb_pts , 1 : nb_var_der ) ) allocate ( JfT ( 1 : nb_var_der , 1 : nb_pts ) ) allocate ( vec_f ( 1 : nb_pts ) ) allocate ( r ( 1 : nb_pts ) ) allocate ( pt ( 1 : nb_var_der )) compteur = 0 pseudo_newton = 10 w : do do ii = 1 , nb_pts xi = vec_xy ( ii , 1 ) yi = vec_xy ( ii , 2 ) vec_f ( ii ) = f ( xi = xi , & ! yi = yi , & ! var = beta ( 1 : nb_var ), & ! nb_var = nb_var , & ! typ = typ ) ! enddo if ( mod ( compteur , pseudo_newton ) == 0 ) then ! http://en.wikipedia.org/wiki/Least_squares do j = 1 , nb_var_der do ii = 1 , nb_pts xi = vec_xy ( ii , 1 ) yi = vec_xy ( ii , 2 ) Jf ( ii , j ) = df ( xi = xi , & ! yi = yi , & ! var = beta ( 1 : nb_var ), & ! nb_var = nb_var , & ! ivar = j , & ! typ = typ ) ! enddo enddo JfT ( 1 : nb_var_der , 1 : nb_pts ) = transpose ( Jf ( 1 : nb_pts , 1 : nb_var_der ) ) sav_mat ( 1 : nb_var_der , 1 : nb_var_der ) = matmul ( JfT ( 1 : nb_var_der , 1 : nb_pts ), Jf ( 1 : nb_pts , 1 : nb_var_der ) ) endif r ( 1 : nb_pts ) = hij ( 1 : nb_pts ) - vec_f ( 1 : nb_pts ) scd ( 1 : nb_var_der ) = matmul ( JfT ( 1 : nb_var_der , 1 : nb_pts ), r ( 1 : nb_pts ) ) mat ( 1 : nb_var_der , 1 : nb_var_der ) = sav_mat ( 1 : nb_var_der , 1 : nb_var_der ) forall ( i = 1 : nb_var_der ) mat ( i , i ) = 1.5 * mat ( i , i ) ! type levenberg-marquardt call choldc ( a = mat ( 1 : nb_var_der , 1 : nb_var_der ), & ! n = nb_var_der , & ! np = nb_var_der , & ! p = pt ( 1 : nb_var_der ), & ! info = info ) ! call cholsl ( a = mat ( 1 : nb_var_der , 1 : nb_var_der ), & ! n = nb_var_der , & ! np = nb_var_der , & ! p = pt ( 1 : nb_var_der ), & ! b = scd ( 1 : nb_var_der ), & ! x = scd ( 1 : nb_var_der ), & ! info = info ) ! beta ( 1 : nb_var_der ) = beta ( 1 : nb_var_der ) + relax * scd ( 1 : nb_var_der ) m_abs_scd = 100 * maxval ( abs ( scd ( 1 : nb_var_der ) / abs ( beta ( 1 : nb_var_der ))) ) if (( m_abs_scd ) < eps ) exit w compteur = compteur + 1 if ( mod ( compteur , 1000 ) == 0 ) then if ( verbose ) write ( * , * ) compteur , m_abs_scd endif enddo w deallocate ( Jf , JfT , vec_f , r , pt ) return endsubroutine moindres_carres subroutine moindres_carres_lineaire ( nb_var , nb_pts , hij , beta , Jf ) !================================================================================================ !< @note Function that returns the parameters of a function that approximates a data set. The parameters !<        determination is achieved by linear least squares approximation. !< !<  @endnote !------------------------------------------------------------------------------------------------ implicit none integer ( kind = I4 ), intent ( in ) :: nb_var !! *number of parameters to be determined* integer ( kind = I4 ), intent ( in ) :: nb_pts !! *number of points for function evaluation* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts ) :: hij !! *vector of evaluation points* real ( kind = R8 ), intent ( in ), dimension ( 1 : nb_pts , 1 : nb_var ) :: Jf !! *Jacobian* real ( kind = R8 ), intent ( out ), dimension ( 1 : nb_var ) :: beta !! *parameters vector* integer ( kind = I4 ) :: info real ( kind = R8 ), dimension ( 1 : nb_var ) :: scd , pt real ( kind = R8 ), dimension ( 1 : nb_var , 1 : nb_var ) :: mat real ( kind = R8 ), allocatable , dimension (:,:) :: JfT allocate ( JfT ( 1 : nb_var , 1 : nb_pts ) ) JfT ( 1 : nb_var , 1 : nb_pts ) = transpose ( Jf ( 1 : nb_pts , 1 : nb_var ) ) mat ( 1 : nb_var , 1 : nb_var ) = matmul ( JfT ( 1 : nb_var , 1 : nb_pts ), Jf ( 1 : nb_pts , 1 : nb_var ) ) scd ( 1 : nb_var ) = matmul ( JfT ( 1 : nb_var , 1 : nb_pts ), hij ( 1 : nb_pts ) ) call choldc ( a = mat ( 1 : nb_var , 1 : nb_var ), & ! n = nb_var , & ! np = nb_var , & ! p = pt ( 1 : nb_var ), & ! info = info ) ! call cholsl ( a = mat ( 1 : nb_var , 1 : nb_var ), & ! n = nb_var , & ! np = nb_var , & ! p = pt ( 1 : nb_var ), & ! b = scd ( 1 : nb_var ), & ! x = scd ( 1 : nb_var ), & ! info = info ) ! beta ( 1 : nb_var ) = scd ( 1 : nb_var ) deallocate ( JfT ) return endsubroutine moindres_carres_lineaire endmodule least_squares","tags":"","loc":"sourcefile/mod_least_squares.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~11~~EfferentGraph sourcefile~prg.f90~11 prg.f90 sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~prg.f90~11->sourcefile~mod_bspline.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~11->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.1 !<  date: feb, 24 2023 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Jacob Williams SPLIN. Example of use.** !<  </span> program test_bspline use bspline use data_arch , only : I4 , R8 , PI_R8 implicit none integer ( kind = I4 ), parameter :: nx = 128 , ny = 256 integer ( kind = I4 ), parameter :: nnx = 700 , nny = 1400 integer ( kind = I4 ) :: deg real ( kind = R8 ) :: mad deg = 2 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 3 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 4 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad deg = 5 call interp_surf ( nx = nx , ny = ny , nnx = nnx , nny = nny , deg = deg , mad = mad ) write ( * , * ) 'Deg, Max. abs. diff. :' , deg , mad stop contains subroutine interp_surf ( nx , ny , nnx , nny , deg , mad ) implicit none integer ( kind = I4 ), intent ( in ) :: nx , ny , nnx , nny , deg real ( kind = R8 ), intent ( out ) :: mad integer ( kind = I4 ) :: i , j , inbvx , inbvy , iloy , iflag real ( kind = R8 ) :: val real ( kind = R8 ), dimension ( 1 : nx , 1 : ny ) :: coeff , tab real ( kind = R8 ), dimension ( 1 : nnx , 1 : nny ) :: tab_ref , tab_int real ( kind = R8 ), dimension ( 1 :( nx + deg )) :: tx real ( kind = R8 ), dimension ( 1 :( ny + deg )) :: ty real ( kind = R8 ), dimension ( 1 : nx ) :: x real ( kind = R8 ), dimension ( 1 : ny ) :: y real ( kind = R8 ), dimension ( 1 : nnx ) :: xx real ( kind = R8 ), dimension ( 1 : nny ) :: yy x ( 1 : nx ) = [( - 1. + ( i - 1 ) * 2. / ( nx - 1 ), i = 1 , nx )] y ( 1 : ny ) = [( - 1. + ( j - 1 ) * 2. / ( ny - 1 ), j = 1 , ny )] do j = 1 , ny do i = 1 , nx tab ( i , j ) = func ( x ( i ), y ( j ) ) enddo enddo iflag = 0 call db2ink ( x = x ( 1 : nx ), & ! Array of x abcissae. Must be strictly increasing. nx = nx , & ! Number of x abcissae y = y ( 1 : ny ), & ! Array of y abcissae. Must be strictly increasing. ny = ny , & ! Number of y abcissae fcn = tab ( 1 : nx , 1 : ny ), & ! Array of function values to interpolate. fcn(i,j) should !    contain the function value at the point (x(i),y(j)) kx = deg , & ! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) ky = deg , & ! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) tx = tx ( 1 :( nx + deg )), & ! The knots in the x direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. ty = ty ( 1 :( ny + deg )), & ! The knots in the y direction for the spline interpolant. !    If iflag=0 these are chosen by [[db2ink]]. !    If iflag=1 these are specified by the user. !    Must be non-decreasing. bcoef = coeff ( 1 : nx , 1 : ny ), & ! Array of coefficients of the b-spline interpolant. iflag = iflag ) ! **on input:**  0 = knot sequence chosen by [[db2ink]]. !                1 = knot sequence chosen by user. ! **on output:** 1 = successful execution. !                2 = iflag out of range. !                3 = nx out of range. !                4 = kx out of range. !                5 = x not strictly increasing. !                6 = tx not non-decreasing. !                7 = ny out of range. !                8 = ky out of range. !                9 = y not strictly increasing. !               10 = ty not non-decreasing. if ( iflag /= 1 ) error stop 'error calling db2ink' xx ( 1 : nnx ) = [( - 1. + ( i - 1 ) * 2. / ( nnx - 1 ), i = 1 , nnx )] yy ( 1 : nny ) = [( - 1. + ( j - 1 ) * 2. / ( nny - 1 ), j = 1 , nny )] inbvx = 1 inbvy = 1 iloy = 1 do j = 1 , nny do i = 1 , nnx call db2val ( xval = xx ( i ), & ! xval     !! x coordinate of evaluation point. yval = yy ( j ), & ! yval     !! y coordinate of evaluation point. idx = 0 , & ! idx      !! x derivative of piecewise polynomial to evaluate. idy = 0 , & ! idy      !! y derivative of piecewise polynomial to evaluate. tx = tx ( 1 :( nx + deg )), & ! tx       !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) ty = ty ( 1 :( ny + deg )), & ! ty       !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) nx = nx , & ! nx       !! the number of interpolation points in x. (same as in last call to [[db2ink]]) ny = ny , & ! ny       !! the number of interpolation points in y. (same as in last call to [[db2ink]]) kx = deg , & ! kx       !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) ky = deg , & ! ky       !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) bcoef = coeff ( 1 : nx , 1 : ny ), & ! bcoef    !! the b-spline coefficients computed by [[db2ink]]. f = val , & ! f        !! interpolated value & iflag = iflag , & ! iflag    !! status flag: 0 : no errors, /=0 : error inbvx = inbvx , & ! inbvx    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. inbvy = inbvy , & ! inbvy    !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. iloy = iloy ) ! iloy     !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. tab_int ( i , j ) = val enddo enddo do j = 1 , nny do i = 1 , nnx tab_ref ( i , j ) = func ( xx ( i ), yy ( j ) ) enddo enddo mad = maxval ( abs ( tab_ref - tab_int ) ) return endsubroutine interp_surf pure elemental real ( kind = R8 ) function func ( xi , yj ) implicit none real ( kind = R8 ), intent ( in ) :: xi , yj func = sin ( 10 * PI_R8 * xi ) * sin ( 10 * PI_R8 * yj ) return endfunction func endprogram test_bspline","tags":"","loc":"sourcefile/prg.f90~11.html"},{"title":"mod_data_arch.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~mod_data_arch.f90~~AfferentGraph sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_fftw3.f90 mod_fftw3.f90 sourcefile~mod_fftw3.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_files.f90 mod_files.f90 sourcefile~mod_files.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_files.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_gen_par.f90 mod_gen_par.f90 sourcefile~mod_gen_par.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_intpl.f90 mod_intpl.f90 sourcefile~mod_intpl.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_least_squares.f90 mod_least_squares.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_least_squares.f90->sourcefile~mod_cholesky.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_solver.f90->sourcefile~mod_gen_par.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_solver.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_tchebychev.f90 mod_tchebychev.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_least_squares.f90 sourcefile~mod_tchebychev.f90->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90 prg.f90 sourcefile~prg.f90->sourcefile~mod_data_arch.f90 sourcefile~prg.f90->sourcefile~mod_least_squares.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~10->sourcefile~mod_gen_par.f90 sourcefile~prg.f90~10->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 sourcefile~prg.f90~11 prg.f90 sourcefile~prg.f90~11->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~12 prg.f90 sourcefile~prg.f90~12->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~12->sourcefile~mod_surfile.f90 sourcefile~prg.f90~13 prg.f90 sourcefile~prg.f90~13->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~13->sourcefile~mod_cholesky.f90 sourcefile~prg.f90~14 prg.f90 sourcefile~prg.f90~14->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~14->sourcefile~mod_fftw3.f90 sourcefile~prg.f90~14->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~2 prg.f90 sourcefile~prg.f90~2->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~2->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~2->sourcefile~mod_tchebychev.f90 sourcefile~prg.f90~3 prg.f90 sourcefile~prg.f90~3->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~3->sourcefile~mod_intpl.f90 sourcefile~prg.f90~4 prg.f90 sourcefile~prg.f90~4->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~4->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~6->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~6->sourcefile~mod_sort_arrays.f90 sourcefile~prg.f90~8 prg.f90 sourcefile~prg.f90~8->sourcefile~mod_data_arch.f90 sourcefile~prg.f90~8->sourcefile~mod_miscellaneous.f90 sourcefile~prg.f90~8->sourcefile~mod_sort_arrays.f90 sourcefile~prg.f90~7 prg.f90 sourcefile~prg.f90~7->sourcefile~mod_files.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.1.0 !<  date: april, 6 2023 ! !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **General parameters definition** !<  </span> module data_arch use , intrinsic :: iso_fortran_env , only : output_unit , input_unit , error_unit , & ! int32 , int64 , & ! real32 , real64 ! implicit none public ! don't keep global iso_fortran_env parameters integer ( kind = int32 ), parameter :: I4 = int32 integer ( kind = I4 ), parameter :: I8 = int64 integer ( kind = I4 ), parameter :: R4 = real32 integer ( kind = I4 ), parameter :: R8 = real64 integer ( kind = I4 ), parameter :: HIG_I4 = huge ( 1 ) integer ( kind = I4 ), parameter :: OPU = output_unit !! *Output unit* integer ( kind = I4 ), parameter :: IPU = input_unit !! *Input unit* integer ( kind = I4 ), parameter :: ERU = error_unit !! *Error unit* real ( kind = R8 ), parameter :: UN = 1.0_R8 real ( kind = R4 ), parameter :: PI_R4 = acos ( - 1._R4 ) real ( kind = R8 ), parameter :: PI_R8 = acos ( - 1._R8 ) real ( kind = R4 ), parameter :: EPS_R4 = tiny ( 1._R4 ) real ( kind = R8 ), parameter :: EPS_R8 = tiny ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_R8 = huge ( 1._R8 ) real ( kind = R8 ), parameter :: HIG_E8 = log ( HIG_R8 ) real ( kind = R8 ), parameter :: EPS_E8 = log ( EPS_R8 ) integer ( kind = I4 ), parameter :: EXPO_MAX = exponent ( HIG_R8 ) !~    integer(kind=I4) :: NB_THREADS_MAX private :: output_unit , input_unit , error_unit , int32 , int64 , real32 , real64 endmodule data_arch","tags":"","loc":"sourcefile/mod_data_arch.f90.html"},{"title":"mod_mt19937-64.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~mod_mt19937-64.f90~~AfferentGraph sourcefile~mod_mt19937-64.f90 mod_mt19937-64.f90 sourcefile~mod_pikaia_oop.f90 mod_pikaia_oop.f90 sourcefile~mod_pikaia_oop.f90->sourcefile~mod_mt19937-64.f90 sourcefile~prg.f90~6 prg.f90 sourcefile~prg.f90~6->sourcefile~mod_pikaia_oop.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !***************************************************************************************** !> !  64-bit version of the Mersenne Twister pseudorandom number generator. ! !### History ! !  * Contributors: Rémi Piatek, Takuji Nishimura, Makoto Matsumoto, Jacob Williams !    See LICENSE file for details. ! !### References ! !  * T. Nishimura, \"Tables of 64-bit Mersenne Twisters\" ACM Transactions on Modeling and !    Computer Simulation 10. (2000) 348--357. !  * M. Matsumoto and T. Nishimura, !    \"Mersenne Twister: a 623-dimensionally equidistributed uniform pseudorandom number generator\" !    ACM Transactions on Modeling and Computer Simulation 8. (Jan. 1998) 3--30. !  * Original source: http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/FORTRAN/mt19937-64.f95 module mt19937_64 use , intrinsic :: iso_fortran_env implicit none private integer , parameter :: r8 = real64 integer , parameter :: i4 = int32 integer , parameter :: i8 = int64 integer ( i8 ), parameter :: nn = 312_i8 integer ( i8 ), parameter :: mm = 156_i8 integer ( i8 ), parameter :: seed_def = 5489_i8 integer ( i8 ), parameter :: matrix_a = - 5403634167711393303_i8 integer ( i8 ), parameter :: um = - 2147483648_i8 !! most significant 33 bits integer ( i8 ), parameter :: lm = 2147483647_i8 !! least significant 31 bits real ( r8 ), parameter :: pi253_1 = 1.0_r8 / ( 2.0_r8 ** 53 - 1.0_r8 ) real ( r8 ), parameter :: pi253 = 1.0_r8 / ( 2.0_r8 ** 53 ) real ( r8 ), parameter :: pi252 = 1.0_r8 / ( 2.0_r8 ** 52 ) type , public :: mt19937 !! main class for random number generator private integer ( i8 ) :: mt ( nn ) = 0_i8 !! array for the state vector integer :: mti = nn + 1 !! `mti==nn+1` means `mt(nn)` is not initialized contains private generic , public :: initialize => init_genrand64_i4 , & init_genrand64 , & init_by_array64 !! call first to initialize procedure :: init_genrand64 procedure :: init_by_array64 procedure :: init_genrand64_i4 procedure , public :: genrand64_real1 procedure , public :: genrand64_real2 procedure , public :: genrand64_real3 procedure , public :: genrand64_int64 end type mt19937 contains !***************************************************************************************** !***************************************************************************************** subroutine init_genrand64_i4 ( me , seed ) !! Initializes `me%mt(nn)` with a seed implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i4 ), intent ( in ) :: seed call me % initialize ( int ( seed , i8 )) end subroutine init_genrand64_i4 !***************************************************************************************** !***************************************************************************************** subroutine init_genrand64 ( me , seed ) !! Initializes `me%mt(nn)` with a seed implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), intent ( in ) :: seed integer :: i me % mt ( 1 ) = seed do i = 1 , nn - 1 me % mt ( i + 1 ) = 6364136223846793005_i8 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 )) + i end do me % mti = nn end subroutine init_genrand64 !***************************************************************************************** !***************************************************************************************** subroutine init_by_array64 ( me , init_key ) !! Initializes by an array with array-length !! `init_key` is the array for initializing keys implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), intent ( in ) :: init_key (:) integer ( i8 ), parameter :: c1 = 3935559000370003845_i8 integer ( i8 ), parameter :: c2 = 2862933555777941757_i8 integer ( i8 ) :: i , j , k , kk , key_length call me % init_genrand64 ( 19650218_i8 ) key_length = size ( init_key ) i = 1_i8 ; j = 0_i8 k = max ( nn , key_length ) do kk = 1 , k me % mt ( i + 1 ) = ieor ( me % mt ( i + 1 ), c1 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 ))) & + init_key ( j + 1 ) + j i = i + 1 ; j = j + 1 if ( i >= nn ) then me % mt ( 1 ) = me % mt ( nn ) i = 1 end if if ( j >= key_length ) j = 0 end do do kk = 1 , nn - 1 me % mt ( i + 1 ) = ieor ( me % mt ( i + 1 ), c2 * ieor ( me % mt ( i ), ishft ( me % mt ( i ), - 62 ))) - i i = i + 1 if ( i >= nn ) then me % mt ( 1 ) = me % mt ( nn ) i = 1 end if end do me % mt ( 1 ) = ishft ( 1_i8 , 63 ) ! MSB is 1; assuring non-zero initial array end subroutine init_by_array64 !***************************************************************************************** !***************************************************************************************** integer ( r8 ) function genrand64_int64 ( me ) !! Generates a random number on [-2&#94;63, 2&#94;63-1]-interval implicit none class ( mt19937 ), intent ( inout ) :: me integer ( i8 ), parameter :: mag01 ( 0 : 1 ) = [ 0_i8 , matrix_a ] integer ( i8 ) :: x integer :: i if ( me % mti >= nn ) then ! generate nn words at one time ! if init_genrand64() has not been called, a default initial seed is used if ( me % mti == nn + 1 ) call me % init_genrand64 ( seed_def ) do i = 1 , nn - mm x = ior ( iand ( me % mt ( i ), um ), iand ( me % mt ( i + 1 ), lm )) me % mt ( i ) = ieor ( ieor ( me % mt ( i + mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) end do do i = nn - mm + 1 , nn - 1 x = ior ( iand ( me % mt ( i ), um ), iand ( me % mt ( i + 1 ), lm )) me % mt ( i ) = ieor ( ieor ( me % mt ( i + mm - nn ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) end do x = ior ( iand ( me % mt ( nn ), um ), iand ( me % mt ( 1 ), lm )) me % mt ( nn ) = ieor ( ieor ( me % mt ( mm ), ishft ( x , - 1 )), mag01 ( iand ( x , 1_i8 ))) me % mti = 0 end if me % mti = me % mti + 1 x = me % mt ( me % mti ) x = ieor ( x , iand ( ishft ( x , - 29 ), 6148914691236517205_i8 )) x = ieor ( x , iand ( ishft ( x , 17 ), 8202884508482404352_i8 )) x = ieor ( x , iand ( ishft ( x , 37 ), - 2270628950310912_i8 )) x = ieor ( x , ishft ( x , - 43 )) genrand64_int64 = x end function genrand64_int64 !***************************************************************************************** !***************************************************************************************** real ( r8 ) function genrand64_real1 ( me ) !! Generates a random number on [0,1]-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real1 = real ( ishft ( me % genrand64_int64 (), - 11 ), kind = r8 ) * pi253_1 end function genrand64_real1 !***************************************************************************************** !***************************************************************************************** real ( r8 ) function genrand64_real2 ( me ) !! Generates a random number on [0,1)-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real2 = real ( ishft ( me % genrand64_int64 (), - 11 ), kind = r8 ) * pi253 end function genrand64_real2 !***************************************************************************************** !***************************************************************************************** real ( r8 ) function genrand64_real3 ( me ) !! Generates a random number on (0,1)-real-interval implicit none class ( mt19937 ), intent ( inout ) :: me genrand64_real3 = real ( ishft ( me % genrand64_int64 (), - 12 ), kind = r8 ) genrand64_real3 = ( genrand64_real3 + 0.5_r8 ) * pi252 end function genrand64_real3 !***************************************************************************************** !***************************************************************************************** end module mt19937_64 !*****************************************************************************************","tags":"","loc":"sourcefile/mod_mt19937-64.f90.html"},{"title":"mod_bspline.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~mod_bspline.f90~~AfferentGraph sourcefile~mod_bspline.f90 mod_bspline.f90 sourcefile~prg.f90~11 prg.f90 sourcefile~prg.f90~11->sourcefile~mod_bspline.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !# Description ! !  Multidimensional (1D-6D) B-Spline interpolation of data on a regular grid. !  Basic subroutine interface. ! !# Notes ! !  This module is based on the bspline and spline routines from [1]. !  The original Fortran 77 routines were converted to free-form source. !  Some of them are relatively unchanged from the originals, but some have !  been extensively refactored. In addition, new routines for !  1d, 4d, 5d, and 6d interpolation were also created (these are simply !  extensions of the same algorithm into higher dimensions). ! !# See also !  * An object-oriented interface can be found in [bspline_oo_module]. ! !# References ! !  1. DBSPLIN and DTENSBS from the !     [NIST Core Math Library](http://www.nist.gov/itl/math/mcsd-software.cfm). !     Original code is public domain. !  2. Carl de Boor, \"A Practical Guide to Splines\", !     Springer-Verlag, New York, 1978. !  3. Carl de Boor, [Efficient Computer Manipulation of Tensor !     Products](http://dl.acm.org/citation.cfm?id=355831), !     ACM Transactions on Mathematical Software, !     Vol. 5 (1979), p. 173-182. !  4. D.E. Amos, \"Computation with Splines and B-Splines\", !     SAND78-1968, Sandia Laboratories, March, 1979. !  5. Carl de Boor, !     [Package for calculating with B-splines](http://epubs.siam.org/doi/abs/10.1137/0714026), !     SIAM Journal on Numerical Analysis 14, 3 (June 1977), p. 441-472. module bspline use , intrinsic :: iso_fortran_env , only : real64 use , intrinsic :: iso_fortran_env , only : error_unit implicit none private integer , parameter :: wp = real64 !! Real precision !main routines: public :: db1ink , db1val public :: db2ink , db2val contains !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the one-dimensional gridded data !   [x(i),\\mathrm{fcn}(i)] ~\\mathrm{for}~ i=1,..,n_x  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db1val]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. subroutine db1ink ( x , nx , fcn , kx , tx , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( nx ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i) should !!    contain the function value at the point x(i) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db1ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db1ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. real ( wp ), dimension ( 2 * kx * ( nx + 1 )) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db1ink' ,& iflag ,& nx = nx ,& kx = kx ,& x = x ,& tx = tx ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , 1 , tx , kx , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db1ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db1ink]] or one of its !  derivatives at the point xval. ! !  To evaluate the interpolant itself, set idx=0, !  to evaluate the first partial with respect to x, set idx=1, and so on. ! !  db1val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) !``` !  if the knots tx were chosen by [[db1ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !``` ! !  The input quantities tx, nx, kx, and bcoef should be !  unchanged since the last call of [[db1ink]]. ! !# History ! !  * Jacob Williams, 10/30/2015 : Created 1D routine. subroutine db1val ( xval , idx , tx , nx , kx , bcoef , f , iflag , inbvx ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db1ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db1ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db1ink]]) real ( wp ), dimension ( nx ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db1ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. real ( wp ), dimension ( 3 * kx ) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db1val - x value out of bounds' iflag = 1 return endif f = dbvalu ( tx , bcoef , nx , kx , idx , xval , inbvx , work , iflag ) endsubroutine db1val !***************************************************************************************** !***************************************************************************************** !> Determines the parameters of a function that interpolates !  the two-dimensional gridded data !   [x(i),y(j),\\mathrm{fcn}(i,j)] ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  !  The interpolating function and its derivatives may !  subsequently be evaluated by the function [[db2val]]. ! !  The interpolating function is a piecewise polynomial function !  represented as a tensor product of one-dimensional b-splines. the !  form of this function is ! !   s(x,y) = \\sum_{i=1}&#94;{n_x} \\sum_{j=1}&#94;{n_y} a_{ij} u_i(x) v_j(y)  ! !  where the functions u_i and v_j are one-dimensional b-spline !  basis functions. the coefficients  a_{ij}  are chosen so that ! !   s(x(i),y(j)) = \\mathrm{fcn}(i,j) ~\\mathrm{for}~ i=1,..,n_x ~\\mathrm{and}~ j=1,..,n_y  ! !  Note that for each fixed value of y,  s(x,y)  is a piecewise !  polynomial function of x alone, and for each fixed value of x,  s(x,y)  !  is a piecewise polynomial function of y alone. in one dimension !  a piecewise polynomial may be created by partitioning a given !  interval into subintervals and defining a distinct polynomial piece !  on each one. the points where adjacent subintervals meet are called !  knots. each of the functions u_i and v_j above is a piecewise !  polynomial. ! !  Users of db2ink choose the order (degree+1) of the polynomial !  pieces used to define the piecewise polynomial in each of the x and !  y directions (kx and ky). users also may define their own knot !  sequence in x and y separately (tx and ty). if iflag=0, however, !  db2ink will choose sequences of knots that result in a piecewise !  polynomial interpolant with kx-2 continuous partial derivatives in !  x and ky-2 continuous partial derivatives in y. (kx knots are taken !  near each endpoint in the x direction, not-a-knot end conditions !  are used, and the remaining knots are placed at data points if kx !  is even or at midpoints between data points if kx is odd. the y !  direction is treated similarly.) ! !  After a call to db2ink, all information necessary to define the !  interpolating function are contained in the parameters nx, ny, kx, !  ky, tx, ty, and bcoef. These quantities should not be altered until !  after the last call of the evaluation routine [[db2val]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine db2ink ( x , nx , y , ny , fcn , kx , ky , tx , ty , bcoef , iflag ) implicit none integer , intent ( in ) :: nx !! Number of x abcissae integer , intent ( in ) :: ny !! Number of y abcissae integer , intent ( in ) :: kx !! The order of spline pieces in x (>= 2, < nx). (order = polynomial degree + 1) integer , intent ( in ) :: ky !! The order of spline pieces in y (>= 2, < ny). (order = polynomial degree + 1) real ( wp ), dimension ( nx ), intent ( in ) :: x !! Array of x abcissae. Must be strictly increasing. real ( wp ), dimension ( ny ), intent ( in ) :: y !! Array of y abcissae. Must be strictly increasing. real ( wp ), dimension ( nx , ny ), intent ( in ) :: fcn !! Array of function values to interpolate. fcn(i,j) should !!    contain the function value at the point (x(i),y(j)) real ( wp ), dimension ( nx + kx ), intent ( inout ) :: tx !! The knots in the x direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( ny + ky ), intent ( inout ) :: ty !! The knots in the y direction for the spline interpolant. !!    If iflag=0 these are chosen by [[db2ink]]. !!    If iflag=1 these are specified by the user. !!    Must be non-decreasing. real ( wp ), dimension ( nx , ny ), intent ( out ) :: bcoef !! Array of coefficients of the b-spline interpolant. integer , intent ( inout ) :: iflag !! **on input:**  0 = knot sequence chosen by [[db2ink]]. !!                1 = knot sequence chosen by user. !! **on output:** 1 = successful execution. !!                2 = iflag out of range. !!                3 = nx out of range. !!                4 = kx out of range. !!                5 = x not strictly increasing. !!                6 = tx not non-decreasing. !!                7 = ny out of range. !!                8 = ky out of range. !!                9 = y not strictly increasing. !!               10 = ty not non-decreasing. real ( wp ), dimension ( nx * ny ) :: temp real ( wp ), dimension ( max ( 2 * kx * ( nx + 1 ), 2 * ky * ( ny + 1 ))) :: work logical :: status_ok !check validity of inputs call check_inputs ( 'db2ink' ,& iflag ,& nx = nx , ny = ny ,& kx = kx , ky = ky ,& x = x , y = y ,& tx = tx , ty = ty ,& status_ok = status_ok ) if ( status_ok ) then !choose knots if ( iflag == 0 ) then call dbknot ( x , nx , kx , tx ) call dbknot ( y , ny , ky , ty ) endif !construct b-spline coefficients call dbtpcf ( x , nx , fcn , nx , ny , tx , kx , temp , work , iflag ) if ( iflag == 0 ) call dbtpcf ( y , ny , temp , ny , nx , ty , ky , bcoef , work , iflag ) if ( iflag == 0 ) iflag = 1 endif endsubroutine db2ink !***************************************************************************************** !***************************************************************************************** !> Evaluates the tensor product piecewise polynomial !  interpolant constructed by the routine [[db2ink]] or one of its !  derivatives at the point (xval,yval). ! !  To evaluate the interpolant !  itself, set idx=idy=0, to evaluate the first partial with respect !  to x, set idx=1,idy=0, and so on. ! !  db2val returns 0.0 if (xval,yval) is out of range. that is, if !```fortran !   xval < tx(1) .or. xval > tx(nx+kx) .or. !   yval < ty(1) .or. yval > ty(ny+ky) !``` !  if the knots tx and ty were chosen by [[db2ink]], then this is equivalent to: !```fortran !   xval < x(1) .or. xval > x(nx)+epsx .or. !   yval < y(1) .or. yval > y(ny)+epsy !``` !  where !```fortran !   epsx = 0.1*(x(nx)-x(nx-1)) !   epsy = 0.1*(y(ny)-y(ny-1)) !``` ! !  The input quantities tx, ty, nx, ny, kx, ky, and bcoef should be !  unchanged since the last call of [[db2ink]]. ! !# History ! !  * Boisvert, Ronald, NBS : 25 may 1982 : Author of original routine. !  * JEC : 000330 modified array declarations. !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine db2val ( xval , yval , idx , idy , tx , ty , nx , ny , kx , ky , bcoef , f , iflag , inbvx , inbvy , iloy ) implicit none integer , intent ( in ) :: idx !! x derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: idy !! y derivative of piecewise polynomial to evaluate. integer , intent ( in ) :: nx !! the number of interpolation points in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ny !! the number of interpolation points in y. (same as in last call to [[db2ink]]) integer , intent ( in ) :: kx !! order of polynomial pieces in x. (same as in last call to [[db2ink]]) integer , intent ( in ) :: ky !! order of polynomial pieces in y. (same as in last call to [[db2ink]]) real ( wp ), intent ( in ) :: xval !! x coordinate of evaluation point. real ( wp ), intent ( in ) :: yval !! y coordinate of evaluation point. real ( wp ), dimension ( nx + kx ), intent ( in ) :: tx !! sequence of knots defining the piecewise polynomial in the x direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( ny + ky ), intent ( in ) :: ty !! sequence of knots defining the piecewise polynomial in the y direction. (same as in last call to [[db2ink]]) real ( wp ), dimension ( nx , ny ), intent ( in ) :: bcoef !! the b-spline coefficients computed by [[db2ink]]. real ( wp ), intent ( out ) :: f !! interpolated value integer , intent ( out ) :: iflag !! status flag: 0 : no errors, /=0 : error integer , intent ( inout ) :: inbvx !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: inbvy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer , intent ( inout ) :: iloy !! initialization parameter which must be set to 1 the first time this routine is called, and must not be changed by the user. integer :: k , lefty , mflag , kcol real ( wp ), dimension ( ky ) :: temp real ( wp ), dimension ( 3 * max ( kx , ky )) :: work f = 0.0_wp if ( xval < tx ( 1 ) . or . xval > tx ( nx + kx )) then write ( error_unit , '(A)' ) 'db2val - x value out of bounds' iflag = 1 return endif if ( yval < ty ( 1 ) . or . yval > ty ( ny + ky )) then write ( error_unit , '(A)' ) 'db2val - y value out of bounds' iflag = 2 return endif iflag = - 1 call dintrv ( ty , ny + ky , yval , iloy , lefty , mflag ); if ( mflag /= 0 ) return kcol = lefty - ky do k = 1 , ky kcol = kcol + 1 temp ( k ) = dbvalu ( tx , bcoef (:, kcol ), nx , kx , idx , xval , inbvx , work , iflag ) if ( iflag /= 0 ) return !error enddo kcol = lefty - ky + 1 f = dbvalu ( ty ( kcol :), temp , ky , ky , idy , yval , inbvy , work , iflag ) endsubroutine db2val !***************************************************************************************** !***************************************************************************************** !> Check the validity of the inputs to the \"ink\" routines. !  Prints warning message if there is an error, !  and also sets iflag and status_ok. ! !  Supports up to 6D: x,y,z,q,r,s ! !# Notes ! !  The code is new, but the logic is based on the original !  logic in the CMLIB routines db2ink and db3ink. ! !# History ! !  * Jacob Williams, 2/24/2015 : Created this routine. subroutine check_inputs ( routine ,& iflag ,& nx , ny , nz , nq , nr , ns ,& kx , ky , kz , kq , kr , ks ,& x , y , z , q , r , s ,& tx , ty , tz , tq , tr , ts ,& status_ok ) implicit none character ( len =* ), intent ( in ) :: routine integer , intent ( inout ) :: iflag integer , intent ( in ), optional :: nx , ny , nz , nq , nr , ns integer , intent ( in ), optional :: kx , ky , kz , kq , kr , ks real ( wp ), dimension (:), intent ( in ), optional :: x , y , z , q , r , s real ( wp ), dimension (:), intent ( in ), optional :: tx , ty , tz , tq , tr , ts logical , intent ( out ) :: status_ok logical :: error status_ok = . false . if (( iflag < 0 ) . or . ( iflag > 1 )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - iflag is out of range: ' , iflag iflag = 2 else call check ( 'x' , nx , kx , x , tx ,[ 3 , 4 , 5 , 6 ], error ); if ( error ) return call check ( 'y' , ny , ky , y , ty ,[ 7 , 8 , 9 , 10 ], error ); if ( error ) return call check ( 'z' , nz , kz , z , tz ,[ 11 , 12 , 13 , 14 ], error ); if ( error ) return call check ( 'q' , nq , kq , q , tq ,[ 15 , 16 , 17 , 18 ], error ); if ( error ) return call check ( 'r' , nr , kr , r , tr ,[ 19 , 20 , 21 , 22 ], error ); if ( error ) return call check ( 's' , ns , ks , s , ts ,[ 23 , 24 , 25 , 26 ], error ); if ( error ) return status_ok = . true . endif contains subroutine check ( s , n , k , x , t , ierrs , error ) !check t,x,n,k for validity implicit none character ( len = 1 ), intent ( in ), optional :: s !! coordinate string: 'x','y','z','q','r','s' integer , intent ( in ), optional :: n !! size of x integer , intent ( in ), optional :: k !! order real ( wp ), dimension (:), intent ( in ), optional :: x !! abcissae vector real ( wp ), dimension (:), intent ( in ), optional :: t !! knot vector size(n+k) integer , dimension (:), intent ( in ) :: ierrs !! int error codes for n,k,x,t checks logical , intent ( out ) :: error !! true if there was an error if ( present ( n )) then call check_n ( 'n' // s , n , ierrs ( 1 ), error ); if ( error ) return if ( present ( k )) then call check_k ( 'k' // s , k , n , ierrs ( 2 ), error ); if ( error ) return endif if ( present ( x )) then call check_x ( s , n , x , ierrs ( 3 ), error ); if ( error ) return endif if ( iflag /= 0 ) then if ( present ( k ) . and . present ( t )) then call check_t ( 't' // s , n , k , t , ierrs ( 4 ), error ); if ( error ) return endif endif endif endsubroutine check subroutine check_n ( s , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if ( n < 3 ) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , n iflag = ierr error = . true . else error = . false . endif endsubroutine check_n subroutine check_k ( s , k , n , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: k integer , intent ( in ) :: n integer , intent ( in ) :: ierr logical , intent ( out ) :: error if (( k < 2 ) . or . ( k >= n )) then write ( error_unit , '(A,1X,I5)' ) & trim ( routine ) // ' - ' // trim ( s ) // ' is out of range: ' , k iflag = ierr error = . true . else error = . false . endif endsubroutine check_k subroutine check_x ( s , n , x , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n if ( x ( i ) <= x ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be strictly increasing' return endif enddo error = . false . endsubroutine check_x subroutine check_t ( s , n , k , t , ierr , error ) implicit none character ( len =* ), intent ( in ) :: s integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension (:), intent ( in ) :: t integer , intent ( in ) :: ierr logical , intent ( out ) :: error integer :: i error = . true . do i = 2 , n + k if ( t ( i ) < t ( i - 1 )) then iflag = ierr write ( error_unit , '(A)' ) trim ( routine ) // ' - ' // trim ( s ) // & ' array must be non-decreasing' return endif enddo error = . false . endsubroutine check_t endsubroutine check_inputs !***************************************************************************************** !***************************************************************************************** !> dbknot chooses a knot sequence for interpolation of order k at the !  data points x(i), i=1,..,n.  the n+k knots are placed in the array !  t.  k knots are placed at each endpoint and not-a-knot end !  conditions are used.  the remaining knots are placed at data points !  if n is even and between data points if n is odd.  the rightmost !  knot is shifted slightly to the right to insure proper interpolation !  at x(n) (see page 350 of the reference). ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. subroutine dbknot ( x , n , k , t ) implicit none integer , intent ( in ) :: n integer , intent ( in ) :: k real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: t integer :: i , j , ipj , npj , ip1 , jstrt real ( wp ) :: rnot !put k knots at each endpoint !(shift right endpoints slightly -- see pg 350 of reference) rnot = x ( n ) + 0.1_wp * ( x ( n ) - x ( n - 1 ) ) do j = 1 , k t ( j ) = x ( 1 ) npj = n + j t ( npj ) = rnot enddo !distribute remaining knots if ( mod ( k , 2 ) == 1 ) then !case of odd k --  knots between data points i = ( k - 1 ) / 2 - k ip1 = i + 1 jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = 0.5_wp * ( x ( ipj ) + x ( ipj + 1 ) ) enddo else !case of even k --  knots at data points i = ( k / 2 ) - k jstrt = k + 1 do j = jstrt , n ipj = i + j t ( j ) = x ( ipj ) enddo endif endsubroutine dbknot !***************************************************************************************** !***************************************************************************************** !> dbtpcf computes b-spline interpolation coefficients for nf sets !  of data stored in the columns of the array fcn. the b-spline !  coefficients are stored in the rows of bcoef however. !  each interpolation is based on the n abcissa stored in the !  array x, and the n+k knots stored in the array t. the order !  of each interpolation is k. the work array must be of length !  at least 2*k*(n+1). ! !# History ! !  * Jacob Williams, 2/24/2015 : Refactored this routine. subroutine dbtpcf ( x , n , fcn , ldf , nf , t , k , bcoef , work , iflag ) integer , intent ( in ) :: n integer , intent ( in ) :: nf integer , intent ( in ) :: ldf integer , intent ( in ) :: k real ( wp ) :: x ( n ) real ( wp ) :: fcn ( ldf , nf ) real ( wp ) :: t ( * ) real ( wp ) :: bcoef ( nf , n ) real ( wp ) :: work ( * ) integer , intent ( out ) :: iflag !! if   0: no errors !! if 301: n should be >0 integer :: i , j , m1 , m2 , iq , iw ! check for null input if ( nf > 0 ) then ! partition work array m1 = k - 1 m2 = m1 + k iq = 1 + n iw = iq + m2 * n + 1 ! compute b-spline coefficients ! first data set call dbintk ( x , fcn , t , n , k , work , work ( iq ), work ( iw ), iflag ) if ( iflag == 0 ) then do i = 1 , n bcoef ( 1 , i ) = work ( i ) enddo !  all remaining data sets by back-substitution if ( nf == 1 ) return do j = 2 , nf do i = 1 , n work ( i ) = fcn ( i , j ) enddo call dbnslv ( work ( iq ), m2 , n , m1 , m1 , work ) do i = 1 , n bcoef ( j , i ) = work ( i ) enddo enddo endif else write ( error_unit , '(A)' ) 'dbtpcf - n should be >0' iflag = 301 endif endsubroutine dbtpcf !***************************************************************************************** !***************************************************************************************** !> dbintk produces the b-spline coefficients, bcoef, of the !  b-spline of order k with knots t(i), i=1,...,n+k, which !  takes on the value y(i) at x(i), i=1,...,n.  the spline or !  any of its derivatives can be evaluated by calls to [[dbvalu]]. ! !  the i-th equation of the linear system a*bcoef = b for the !  coefficients of the interpolant enforces interpolation at !  x(i), i=1,...,n.  hence, b(i) = y(i), for all i, and a is !  a band matrix with 2k-1 bands if a is invertible.  the matrix !  a is generated row by row and stored, diagonal by diagonal, !  in the rows of q, with the main diagonal going into row k. !  the banded system is then solved by a call to dbnfac (which !  constructs the triangular factorization for a and stores it !  again in q), followed by a call to dbnslv (which then !  obtains the solution bcoef by substitution).  dbnfac does no !  pivoting, since the total positivity of the matrix a makes !  this unnecessary.  the linear system to be solved is !  (theoretically) invertible if and only if !          t(i) < x(i) < t(i+k),        for all i. !  equality is permitted on the left for i=1 and on the right !  for i=n when k knots are used at x(1) or x(n).  otherwise, !  violation of this condition is certain to lead to an error. ! !# Error conditions ! !  * improper input !  * singular system of equations ! !# History ! !  * splint written by carl de boor [5] !  * dbintk author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations. (jec) !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbintk ( x , y , t , n , k , bcoef , q , work , iflag ) implicit none integer , intent ( in ) :: n !! number of data points, n >= k real ( wp ), dimension ( n ), intent ( in ) :: x !! vector of length n containing data point abscissa !! in strictly increasing order. real ( wp ), dimension ( n ), intent ( in ) :: y !! corresponding vector of length n containing data !! point ordinates. real ( wp ), dimension ( * ), intent ( in ) :: t !! knot vector of length n+k !! since t(1),..,t(k) <= x(1) and t(n+1),..,t(n+k) !! >= x(n), this leaves only n-k knots (not !! necessarily x(i) values) interior to (x(1),x(n)) integer , intent ( in ) :: k !! order of the spline, k >= 1 real ( wp ), dimension ( n ), intent ( out ) :: bcoef !! a vector of length n containing the b-spline coefficients real ( wp ), dimension ( * ), intent ( out ) :: q !! a work vector of length (2*k-1)*n, containing !! the triangular factorization of the coefficient !! matrix of the linear system being solved.  the !! coefficients for the interpolant of an !! additional data set (x(i),yy(i)), i=1,...,n !! with the same abscissa can be obtained by loading !! yy into bcoef and then executing !! call dbnslv(q,2k-1,n,k-1,k-1,bcoef) real ( wp ), dimension ( * ), intent ( out ) :: work !! work vector of length 2*k integer , intent ( out ) :: iflag !! if   0: no errors. !! if 100: k does not satisfy k>=1. !! if 101: n does not satisfy n>=k. !! if 102: x(i) does not satisfy x(i)<x(i+1) for some i. !! if 103: some abscissa was not in the support of the. !! corresponding basis function and the system is singular. !! if 104: the system of solver detects a singular system. !! although the theoretical conditions for a solution were satisfied. integer :: iwork , i , ilp1mx , j , jj , km1 , kpkm2 , left , lenq , np1 real ( wp ) :: xi if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbintk - k does not satisfy k>=1' iflag = 100 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbintk - n does not satisfy n>=k' iflag = 101 return endif jj = n - 1 if ( jj /= 0 ) then do i = 1 , jj if ( x ( i ) >= x ( i + 1 )) then write ( error_unit , '(A)' ) 'dbintk - x(i) does not satisfy x(i)<x(i+1) for some i' iflag = 102 return endif enddo endif np1 = n + 1 km1 = k - 1 kpkm2 = 2 * km1 left = k ! zero out all entries of q lenq = n * ( k + km1 ) do i = 1 , lenq q ( i ) = 0.0_wp enddo ! loop over i to construct the n interpolation equations do i = 1 , n xi = x ( i ) ilp1mx = min ( i + k , np1 ) ! *** find  left  in the closed interval (i,i+k-1) such that !         t(left) <= x(i) < t(left+1) ! matrix is singular if this is not possible left = max ( left , i ) if ( xi < t ( left )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif do if ( xi < t ( left + 1 )) go to 30 left = left + 1 if ( left >= ilp1mx ) exit enddo left = left - 1 if ( xi > t ( left + 1 )) then write ( error_unit , '(A)' ) 'dbintk - some abscissa was not in the support of the' // & ' corresponding basis function and the system is singular' iflag = 103 return endif ! *** the i-th equation enforces interpolation at xi, hence ! a(i,j) = b(j,k,t)(xi), all j. only the  k  entries with  j = ! left-k+1,...,left actually might be nonzero. these  k  numbers ! are returned, in  bcoef (used for temp.storage here), by the ! following 30 call dbspvn ( t , k , k , 1 , xi , left , bcoef , work , iwork , iflag ) if ( iflag /= 0 ) return ! we therefore want  bcoef(j) = b(left-k+j)(xi) to go into ! a(i,left-k+j), i.e., into  q(i-(left+j)+2*k,(left+j)-k) since ! a(i+j,j)  is to go into  q(i+k,j), all i,j,  if we consider  q ! as a two-dim. array , with  2*k-1  rows (see comments in ! dbnfac). in the present program, we treat  q  as an equivalent ! one-dimensional array (because of fortran restrictions on ! dimension statements) . we therefore want  bcoef(j) to go into ! entry !     i -(left+j) + 2*k + ((left+j) - k-1)*(2*k-1) !            = i-left+1 + (left -k)*(2*k-1) + (2*k-2)*j ! of q. jj = i - left + 1 + ( left - k ) * ( k + km1 ) do j = 1 , k jj = jj + kpkm2 q ( jj ) = bcoef ( j ) enddo enddo ! obtain factorization of a, stored again in q. call dbnfac ( q , k + km1 , n , km1 , km1 , iflag ) if ( iflag == 1 ) then !success ! *** solve  a*bcoef = y  by backsubstitution do i = 1 , n bcoef ( i ) = y ( i ) enddo call dbnslv ( q , k + km1 , n , km1 , km1 , bcoef ) iflag = 0 else !failure write ( error_unit , '(A)' ) 'dbintk - the system of solver detects a singular system' // & ' although the theoretical conditions for a solution were satisfied' iflag = 104 endif endsubroutine dbintk !***************************************************************************************** !***************************************************************************************** !> Returns in w the LU-factorization (without pivoting) of the banded !  matrix a of order nrow with (nbandl + 1 + nbandu) bands or diagonals !  in the work array w . ! !  gauss elimination without pivoting is used. the routine is !  intended for use with matrices a which do not require row inter- !  changes during factorization, especially for the totally !  positive matrices which occur in spline calculations. !  the routine should not be used for an arbitrary banded matrix. ! !# Work array ! ! **Input** ! !        w array of size (nroww,nrow) contains the interesting !        part of a banded matrix  a , with the diagonals or bands of  a !        stored in the rows of  w , while columns of  a  correspond to !        columns of  w . this is the storage mode used in  linpack  and !        results in efficient innermost loops. !           explicitly,  a  has  nbandl  bands below the diagonal !                            +     1     (main) diagonal !                            +   nbandu  bands above the diagonal !        and thus, with    middle = nbandu + 1, !          a(i+j,j)  is in  w(i+middle,j)  for i=-nbandu,...,nbandl !                                              j=1,...,nrow . !        for example, the interesting entries of a (1,2)-banded matrix !        of order  9  would appear in the first  1+1+2 = 4  rows of  w !        as follows. !                          13 24 35 46 57 68 79 !                       12 23 34 45 56 67 78 89 !                    11 22 33 44 55 66 77 88 99 !                    21 32 43 54 65 76 87 98 ! !        all other entries of  w  not identified in this way with an en- !        try of  a  are never referenced . ! ! **Output** ! !  * if  iflag = 1, then !        w contains the lu-factorization of  a  into a unit lower triangu- !        lar matrix  l  and an upper triangular matrix  u (both banded) !        and stored in customary fashion over the corresponding entries !        of  a . this makes it possible to solve any particular linear !        system  a*x = b  for  x  by a !              call dbnslv ( w, nroww, nrow, nbandl, nbandu, b ) !        with the solution x  contained in  b  on return . !  * if  iflag = 2, then !        one of  nrow-1, nbandl,nbandu failed to be nonnegative, or else !        one of the potential pivots was found to be zero indicating !        that  a  does not have an lu-factorization. this implies that !        a  is singular in case it is totally positive . ! !# History ! !  * banfac written by carl de boor [5] !  * dbnfac from CMLIB [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbnfac ( w , nroww , nrow , nbandl , nbandu , iflag ) integer , intent ( in ) :: nroww !! row dimension of the work array w. must be >= nbandl + 1 + nbandu. integer , intent ( in ) :: nrow !! matrix order integer , intent ( in ) :: nbandl !! number of bands of a below the main diagonal integer , intent ( in ) :: nbandu !! number of bands of a above the main diagonal integer , intent ( out ) :: iflag !! indicating success(=1) or failure (=2) real ( wp ), dimension ( nroww , nrow ), intent ( inout ) :: w !! work array. See header for details. integer :: i , ipk , j , jmax , k , kmax , middle , midmk , nrowm1 real ( wp ) :: factor , pivot iflag = 1 middle = nbandu + 1 ! w(middle,.) contains the main diagonal of a. nrowm1 = nrow - 1 if ( nrowm1 < 0 ) then iflag = 2 return elseif ( nrowm1 == 0 ) then if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandl <= 0 ) then ! a is upper triangular. check that diagonal is nonzero . do i = 1 , nrowm1 if ( w ( middle , i ) == 0.0_wp ) then iflag = 2 return endif enddo if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 return endif if ( nbandu <= 0 ) then ! a is lower triangular. check that diagonal is nonzero and ! divide each column by its diagonal. do i = 1 , nrowm1 pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif jmax = min ( nbandl , nrow - i ) do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo enddo return endif ! a is not just a triangular matrix. construct lu factorization do i = 1 , nrowm1 ! w(middle,i)  is pivot for i-th step . pivot = w ( middle , i ) if ( pivot == 0.0_wp ) then iflag = 2 return endif ! jmax is the number of (nonzero) entries in column i ! below the diagonal. jmax = min ( nbandl , nrow - i ) ! divide each entry in column i below diagonal by pivot. do j = 1 , jmax w ( middle + j , i ) = w ( middle + j , i ) / pivot enddo ! kmax is the number of (nonzero) entries in row i to ! the right of the diagonal. kmax = min ( nbandu , nrow - i ) ! subtract a(i,i+k)*(i-th column) from (i+k)-th column ! (below row i). do k = 1 , kmax ipk = i + k midmk = middle - k factor = w ( midmk , ipk ) do j = 1 , jmax w ( midmk + j , ipk ) = w ( midmk + j , ipk ) - w ( middle + j , i ) * factor enddo enddo enddo ! check the last diagonal entry. if ( w ( middle , nrow ) == 0.0_wp ) iflag = 2 endsubroutine dbnfac !***************************************************************************************** !> Companion routine to [[dbnfac]]. it returns the solution x of the !  linear system a*x = b in place of b, given the lu-factorization !  for a in the work array w from dbnfac. ! !  (with  a = l*u , as stored in w), the unit lower triangular system !   l(u*x) = b  is solved for  y = u*x , and y stored in b. then the !  upper triangular system u*x = y  is solved for x. the calculations !  are so arranged that the innermost loops stay within columns. ! !# History ! !  * banslv written by carl de boor [5] !  * dbnslv from SLATEC library [1] !  * Jacob Williams, 5/10/2015 : converted to free-form Fortran. subroutine dbnslv ( w , nroww , nrow , nbandl , nbandu , b ) integer , intent ( in ) :: nroww !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nrow !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandl !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. integer , intent ( in ) :: nbandu !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nroww , nrow ), intent ( in ) :: w !! describes the lu-factorization of a banded matrix a of order nrow as constructed in [[dbnfac]]. real ( wp ), dimension ( nrow ), intent ( inout ) :: b !! **in**: right side of the system to be solved !! **out**: the solution x, of order nrow integer :: i , j , jmax , middle , nrowm1 middle = nbandu + 1 if ( nrow /= 1 ) then nrowm1 = nrow - 1 if ( nbandl /= 0 ) then ! forward pass ! for i=1,2,...,nrow-1, subtract right side(i)*(i-th column of l) !                       from right side (below i-th row). do i = 1 , nrowm1 jmax = min ( nbandl , nrow - i ) do j = 1 , jmax b ( i + j ) = b ( i + j ) - b ( i ) * w ( middle + j , i ) enddo enddo endif ! backward pass ! for i=nrow,nrow-1,...,1, divide right side(i) by i-th diagonal !                          entry of u, then subtract right side(i)*(i-th column !                          of u) from right side (above i-th row). if ( nbandu <= 0 ) then ! a is lower triangular. do i = 1 , nrow b ( i ) = b ( i ) / w ( 1 , i ) enddo return endif i = nrow do b ( i ) = b ( i ) / w ( middle , i ) jmax = min ( nbandu , i - 1 ) do j = 1 , jmax b ( i - j ) = b ( i - j ) - b ( i ) * w ( middle - j , i ) enddo i = i - 1 if ( i <= 1 ) exit enddo endif b ( 1 ) = b ( 1 ) / w ( middle , 1 ) endsubroutine dbnslv !***************************************************************************************** !***************************************************************************************** !> Calculates the value of all (possibly) nonzero basis !  functions at x of order max(jhigh,(j+1)*(index-1)), where t(k) !  <= x <= t(n+1) and j=iwork is set inside the routine on !  the first call when index=1.  ileft is such that t(ileft) <= !  x < t(ileft+1).  a call to dintrv(t,n+1,x,ilo,ileft,mflag) !  produces the proper ileft.  dbspvn calculates using the basic !  algorithm needed in dbspvd.  if only basis functions are !  desired, setting jhigh=k and index=1 can be faster than !  calling dbspvd, but extra coding is required for derivatives !  (index=2) and dbspvd is set up for this purpose. ! !  left limiting values are set up as described in dbspvd. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bsplvn written by carl de boor [5] !  * dbspvn author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. subroutine dbspvn ( t , jhigh , k , index , x , ileft , vnikx , work , iwork , iflag ) implicit none real ( wp ), intent ( in ) :: t ( * ) !! knot vector of length n+k, where !! n = number of b-spline basis functions !! n = sum of knot multiplicities-k !! dimension t(ileft+jhigh) integer , intent ( in ) :: jhigh !! order of b-spline, 1 <= jhigh <= k integer , intent ( in ) :: k !! highest possible order integer , intent ( in ) :: index !! index = 1 gives basis functions of order jhigh !!       = 2 denotes previous entry with work, iwork !!         values saved for subsequent calls to !!         dbspvn. real ( wp ), intent ( in ) :: x !! argument of basis functions, t(k) <= x <= t(n+1) integer , intent ( in ) :: ileft !! largest integer such that t(ileft) <= x < t(ileft+1) real ( wp ), intent ( out ) :: vnikx ( k ) !! vector of length k for spline values. real ( wp ), intent ( out ) :: work ( * ) !! a work vector of length 2*k integer , intent ( out ) :: iwork !! a work parameter.  both work and iwork contain !! information necessary to continue for index = 2. !! when index = 1 exclusively, these are scratch !! variables and can be used for other purposes. integer , intent ( out ) :: iflag !! if   0: no errors !! if 201: k does not satisfy k>=1 !! if 202: jhigh does not satisfy 1<=jhigh<=k !! if 203: index is not 1 or 2 !! if 204: x does not satisfy t(ileft)<=x<=t(ileft+1) integer :: imjp1 , ipj , jp1 , jp1ml , l real ( wp ) :: vm , vmprev ! content of j, deltam, deltap is expected unchanged between calls. ! work(i) = deltap(i), ! work(k+i) = deltam(i), i = 1,k if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - k does not satisfy k>=1' iflag = 201 return endif if ( jhigh > k . or . jhigh < 1 ) then write ( error_unit , '(A)' ) 'dbspvn - jhigh does not satisfy 1<=jhigh<=k' iflag = 202 return endif if ( index < 1 . or . index > 2 ) then write ( error_unit , '(A)' ) 'dbspvn - index is not 1 or 2' iflag = 203 return endif if ( x < t ( ileft ) . or . x > t ( ileft + 1 )) then write ( error_unit , '(A)' ) 'dbspvn - x does not satisfy t(ileft)<=x<=t(ileft+1)' iflag = 204 return endif iflag = 0 if ( index == 1 ) then iwork = 1 vnikx ( 1 ) = 1.0_wp if ( iwork >= jhigh ) return endif do ipj = ileft + iwork work ( iwork ) = t ( ipj ) - x imjp1 = ileft - iwork + 1 work ( k + iwork ) = x - t ( imjp1 ) vmprev = 0.0_wp jp1 = iwork + 1 do l = 1 , iwork jp1ml = jp1 - l vm = vnikx ( l ) / ( work ( l ) + work ( k + jp1ml )) vnikx ( l ) = vm * work ( l ) + vmprev vmprev = vm * work ( k + jp1ml ) enddo vnikx ( jp1 ) = vmprev iwork = jp1 if ( iwork >= jhigh ) exit enddo endsubroutine dbspvn !***************************************************************************************** !***************************************************************************************** !> Evaluates the b-representation (t,a,n,k) of a b-spline !  at x for the function value on ideriv=0 or any of its !  derivatives on ideriv=1,2,...,k-1.  right limiting values !  (right derivatives) are returned except at the right end !  point x=t(n+1) where left limiting values are computed.  the !  spline is defined on t(k) <= x <= t(n+1).  dbvalu returns !  a fatal error message when x is outside of this interval. ! !  to compute left derivatives or left limiting values at a !  knot t(i), replace n by i-1 and set x=t(i), i=k+1,n+1. ! !#Error Conditions ! !  * improper input ! !# History ! !  * bvalue written by carl de boor [5] !  * dbvalu author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * 000330 modified array declarations.  (jec) !  * Jacob Williams, 2/24/2015 : extensive refactoring of CMLIB routine. real ( wp ) function dbvalu ( t , a , n , k , ideriv , x , inbv , work , iflag ) implicit none integer , intent ( in ) :: n !! number of b-spline coefficients. !! (sum of knot multiplicities-k) real ( wp ), dimension (:), intent ( in ) :: t !! knot vector of length n+k real ( wp ), dimension ( n ), intent ( in ) :: a !! b-spline coefficient vector of length n integer , intent ( in ) :: k !! order of the b-spline, k >= 1 integer , intent ( in ) :: ideriv !! order of the derivative, 0 <= ideriv <= k-1. !! ideriv = 0 returns the b-spline value real ( wp ), intent ( in ) :: x !! argument, t(k) <= x <= t(n+1) integer , intent ( inout ) :: inbv !! an initialization parameter which must be set !! to 1 the first time dbvalu is called. !! inbv contains information for efficient process- !! ing after the initial call and inbv must not !! be changed by the user.  distinct splines require !! distinct inbv parameters. real ( wp ), dimension (:) :: work !! work vector of length 3*k integer , intent ( out ) :: iflag !! if   0: no errors !! if 401: k does not satisfy k>=1 !! if 402: n does not satisfy n>=k !! if 403: ideriv does not satisfy 0<=ideriv<k !! if 404: x is not greater than or equal to t(k) !! if 405: x is not less than or equal to t(n+1) !! if 406: a left limiting value cannot be obtained at t(k) integer :: i , iderp1 , ihi , ihmkmj , ilo , imk , imkpj , ipj ,& ip1 , ip1mj , j , jj , j1 , j2 , kmider , kmj , km1 , kpk , mflag real ( wp ) :: fkmj dbvalu = 0.0_wp if ( k < 1 ) then write ( error_unit , '(A)' ) 'dbvalu - k does not satisfy k>=1' iflag = 401 return endif if ( n < k ) then write ( error_unit , '(A)' ) 'dbvalu - n does not satisfy n>=k' iflag = 402 return endif if ( ideriv < 0 . or . ideriv >= k ) then write ( error_unit , '(A)' ) 'dbvalu - ideriv does not satisfy 0<=ideriv<k' iflag = 403 return endif kmider = k - ideriv ! find *i* in (k,n) such that t(i) <= x < t(i+1) ! (or, <= t(i+1) if t(i) < t(i+1) = t(n+1)). km1 = k - 1 call dintrv ( t , n + 1 , x , inbv , i , mflag ) if ( x < t ( k )) then write ( error_unit , '(A)' ) 'dbvalu - x is not greater than or equal to t(k)' iflag = 404 return endif if ( mflag /= 0 ) then if ( x > t ( i )) then write ( error_unit , '(A)' ) 'dbvalu - x is not less than or equal to t(n+1)' iflag = 405 return endif do if ( i == k ) then write ( error_unit , '(A)' ) 'dbvalu - a left limiting value cannot be obtained at t(k)' iflag = 406 return endif i = i - 1 if ( x /= t ( i )) exit enddo endif ! difference the coefficients *ideriv* times ! work(i) = aj(i), work(k+i) = dp(i), work(k+k+i) = dm(i), i=1.k imk = i - k do j = 1 , k imkpj = imk + j work ( j ) = a ( imkpj ) enddo if ( ideriv /= 0 ) then do j = 1 , ideriv kmj = k - j fkmj = real ( kmj , wp ) do jj = 1 , kmj ihi = i + jj ihmkmj = ihi - kmj work ( jj ) = ( work ( jj + 1 ) - work ( jj )) / ( t ( ihi ) - t ( ihmkmj )) * fkmj enddo enddo endif ! compute value at *x* in (t(i),(t(i+1)) of ideriv-th derivative, ! given its relevant b-spline coeff. in aj(1),...,aj(k-ideriv). if ( ideriv /= km1 ) then ip1 = i + 1 kpk = k + k j1 = k + 1 j2 = kpk + 1 do j = 1 , kmider ipj = i + j work ( j1 ) = t ( ipj ) - x ip1mj = ip1 - j work ( j2 ) = x - t ( ip1mj ) j1 = j1 + 1 j2 = j2 + 1 enddo iderp1 = ideriv + 1 do j = iderp1 , km1 kmj = k - j ilo = kmj do jj = 1 , kmj work ( jj ) = ( work ( jj + 1 ) * work ( kpk + ilo ) + work ( jj ) * & work ( k + jj )) / ( work ( kpk + ilo ) + work ( k + jj )) ilo = ilo - 1 enddo enddo endif iflag = 0 dbvalu = work ( 1 ) endfunction dbvalu !***************************************************************************************** !***************************************************************************************** !> Computes the largest integer ileft in 1 <= ileft <= lxt !  such that XT(ileft) <= x where XT(*) is a subdivision of !  the x interval. !  precisely, ! !```fortran !         if            x < XT(1)   then ileft=1,   mflag=-1 !         if   XT(i) <= x < XT(i+1) then ileft=i,   mflag=0 !         if XT(lxt) <= x           then ileft=lxt, mflag=1 !``` ! !  that is, when multiplicities are present in the break point !  to the left of x, the largest index is taken for ileft. ! !# History ! !  * interv written by carl de boor [5] !  * dintrv author: amos, d. e., (snla) : date written 800901 !  * revision date 820801 !  * Jacob Williams, 2/24/2015 : updated to free-form Fortran. subroutine dintrv ( XT , lxt , x , ilo , ileft , mflag ) implicit none integer , intent ( in ) :: lxt !! length of the XT vector real ( wp ), dimension ( lxt ), intent ( in ) :: XT !! a knot or break point vector of length lxt real ( wp ), intent ( in ) :: x !! argument integer , intent ( inout ) :: ilo !! an initialization parameter which must be set !! to 1 the first time the spline array XT is !! processed by dintrv. ilo contains information for !! efficient processing after the initial call and ilo !! must not be changed by the user.  distinct splines !! require distinct ilo parameters. integer , intent ( out ) :: ileft !! largest integer satisfying XT(ileft) <= x integer , intent ( out ) :: mflag !! signals when x lies out of bounds integer :: ihi , istep , middle ihi = ilo + 1 if ( ihi < lxt ) go to 10 if ( x >= XT ( lxt )) go to 110 if ( lxt <= 1 ) go to 90 ilo = lxt - 1 ihi = lxt 10 if ( x >= XT ( ihi )) go to 40 if ( x >= XT ( ilo )) go to 100 ! *** now x < XT(ihi) . find lower bound istep = 1 20 ihi = ilo ilo = ihi - istep if ( ilo <= 1 ) go to 30 if ( x >= XT ( ilo )) go to 70 istep = istep * 2 go to 20 30 ilo = 1 if ( x < XT ( 1 )) go to 90 go to 70 ! *** now x >= XT(ilo) . find upper bound 40 istep = 1 50 ilo = ihi ihi = ilo + istep if ( ihi >= lxt ) go to 60 if ( x < XT ( ihi )) go to 70 istep = istep * 2 go to 50 60 if ( x >= XT ( lxt )) go to 110 ihi = lxt ! *** now XT(ilo) <= x < XT(ihi) . narrow the interval 70 middle = ( ilo + ihi ) / 2 if ( middle == ilo ) go to 100 !     note. it is assumed that middle = ilo in case ihi = ilo+1 if ( x < XT ( middle )) go to 80 ilo = middle go to 70 80 ihi = middle go to 70 ! *** set output and return 90 mflag = - 1 ileft = 1 return 100 mflag = 0 ileft = ilo return 110 mflag = 1 ileft = lxt endsubroutine dintrv !***************************************************************************************** !***************************************************************************************** endmodule bspline !***************************************************************************************** !~    use bspline !~    use, intrinsic :: iso_fortran_env, only: wp => real64 !~    implicit none !~    integer, parameter :: kx = 4                          !! x bspline order !~    integer, parameter :: ky = 4                          !! y bspline order !~    integer, parameter :: idx = 0                         !! [[db2val]] input !~    integer, parameter :: idy = 0                         !! [[db2val]] input !~    integer, parameter :: nx = 2584                       !! number of points in x dimension in original grid !~    integer, parameter :: ny = 1945                       !! number of points in y dimension in original grid !~    real(wp), dimension(nx) :: x                          !! x points in original grid !~    real(wp), dimension(ny) :: y                          !! y points in original grid !~    integer, parameter :: nx_new = 4096                   !! number of points in x dimension for new grid !~    integer, parameter :: ny_new = 2048                   !! number of points in y dimension for new grid !~    real(wp), dimension(nx_new)    :: x_new               !! new grid x points !~    real(wp), dimension(ny_new)    :: y_new               !! new grid y points !~    real(wp), dimension(nx_new, ny_new) :: fcn_new        !! new grid function evaluations !~    real(wp), dimension(nx +kx) :: tx                     !! x knots !~    real(wp), dimension(ny +ky) :: ty                     !! y knots !~    real(wp), dimension(nx, ny) :: fcn_2d                 !! original grid function evaluations !~    real(wp) :: val !~    integer :: i, j !~    integer :: iflag                                      !! status flag !~    integer :: inbvx, inbvy, iloy !~    fcn_2d(i, j) = prof(i, j) !~    do i = 1, nx !~       x(i) = real(i-1,kind=wp)/(nx-1) !~    enddo !~    do j = 1, ny !~       y(j) = real(j-1,kind=wp)/(ny-1) !~    enddo !~    do i = 1, nx_new !~       x_new(i) = real(i-1,kind=wp)/(nx_new-1) !~    enddo !~    do j = 1, ny_new !~       y_new(j) = real(j-1,kind=wp)/(ny_new-1) !~    enddo !~    inbvx = 1 !~    inbvy = 1 !~    iloy  = 1 !~    iflag = 0 !~    call db2ink(x, nx, y, ny, fcn_2d, kx, ky, tx, ty, fcn_2d, iflag) !~    if (iflag/=1) error stop 'error calling db2ink' !~    errmax = 0.0_wp !~    do i = 1, nx_new !~    do j = 1, ny_new !~       call db2val(x_new(i), y_new(j), idx, idy, tx, ty, nx, ny, kx, ky, fcn_2d, val, iflag, inbvx, inbvy, iloy) !~       if (iflag/=0) error stop 'error calling db2val' !~       fcn_new(i,j) = val !~    enddo !~    enddo","tags":"","loc":"sourcefile/mod_bspline.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~12~~EfferentGraph sourcefile~prg.f90~12 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~12->sourcefile~mod_data_arch.f90 sourcefile~mod_surfile.f90 mod_surfile.f90 sourcefile~prg.f90~12->sourcefile~mod_surfile.f90 sourcefile~mod_surfile.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~mod_surfile.f90->sourcefile~mod_miscellaneous.f90 sourcefile~mod_sort_arrays.f90 mod_sort_arrays.f90 sourcefile~mod_surfile.f90->sourcefile~mod_sort_arrays.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_sort_arrays.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: April, 16 2019 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Routines to handle Digital Surf binary format (.sur). Example of use** !<  </span> program test_surfile use data_arch use surfile implicit none real ( kind = R8 ), dimension (:,:), allocatable :: tab !! *height array* type ( SCALE_SURF ) :: scal !! *object [[SCALE_SURF]], fortran type version* type ( OBJ_SURF ) :: surf !! *object [[OBJ_SURF]],         c type version* integer ( kind = I4 ) :: i , j ! --- reads a xyz ascii file, writes the corresponding \"sur\" file and dumps the header call init_scal ( scal ) ! creates an empty surface type (fortran form) call read_surf ( nom_fic = \"sur/600x300.dat\" , & !  in; three columns in ascii format : x y f(x,y); no header; tab separation tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call write_surf ( nom_fic = \"out/600x300_dat_to_not-scaled.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call scal2surf ( scal , surf ) !        surface type transformation: fortran form to c form call trans_surf_txt ( surf = surf , & !    in; dumps the surface header ... fichier = \"out/600x300_dat_to_not-scaled.txt\" , & !    in; ... in a specified file ... xyz = . false .) !    in; ... and no f(x,y) dump. deallocate ( tab ) ! --- reads a \"sur\" file, writes its scaled form in a \"sur\" file and a xyz file call read_surf ( nom_fic = \"sur/600x300.sur\" , & !  in; Digital Surf format mu = 1._R8 , & !  in; data will be centered sq = 1._R8 , & !  in; data will be normalized (with the standard deviation) tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call write_surf ( nom_fic = \"out/600x300_resu_scaled.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call write_surf ( nom_fic = \"out/600x300_resu_scaled.dat\" , & !    in; filename of the ascii \".dat\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type deallocate ( tab ) ! --- creates a surface and writes a \".sur\" file allocate ( tab ( 600 , 300 )) do j = 1 , 300 do i = 1 , 600 tab ( i , j ) = 1.e+9 * cos ( 6 * 2 * PI_R8 * i / 600 ) * cos ( 3 * 2 * PI_R8 * j / 300 ) + 1.e+8 enddo enddo call init_scal ( scal = scal , & ! out; creates a surface type, containing ... nx = 600 , & !  in; ... the number of points along x ... ny = 300 , & !  in; ... the number of points along y ... lx = 1.0e-3_R8 , & !  in; ... the length (default unit : m) ... ly = 0.5e-3_R8 , & !  in; ... the width ... unit_z = 'Pa' ) !  in; ... and the unit along z. call write_surf ( nom_fic = \"out/cos.sur\" , & !    in; filename of the \".sur\" to be created tab_s = tab , & !    in; surface array scal = scal ) ! inout; surface type call read_surf ( nom_fic = \"out/cos.sur\" , & !  in; Digital Surf format tab_s = tab , & ! out; array containing the surface scal = scal ) ! out; surface type containing some informations like length, width, etc. call scal2surf ( scal , surf ) !      surface type transformation: fortran form to c form call trans_surf_txt ( surf = surf , & ! in; dumps the surface header ... fichier = \"out/cos.txt\" , & ! in; ... in a specified file ... xyz = . false .) ! in; ... and no f(x,y) dump. deallocate ( tab ) stop endprogram test_surfile","tags":"","loc":"sourcefile/prg.f90~12.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~13~~EfferentGraph sourcefile~prg.f90~13 prg.f90 sourcefile~mod_cholesky.f90 mod_cholesky.f90 sourcefile~prg.f90~13->sourcefile~mod_cholesky.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~13->sourcefile~mod_data_arch.f90 sourcefile~mod_cholesky.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_utils use data_arch , only : I4 , R8 use cholesky , only : choldc , cholsl implicit none integer ( kind = I4 ), parameter :: tai = 100 real ( kind = R8 ), dimension ( tai , tai ) :: a , aa real ( kind = R8 ), dimension ( tai ) :: b , x , p integer ( kind = I4 ) :: i , info call random_number ( a ( 1 : tai , 1 : tai )) call random_number ( b ( 1 : tai )) a = matmul ( a , transpose ( a )) forall ( i = 1 : tai ) a ( i , i ) = 100 * abs ( a ( i , i )) aa ( 1 : tai , 1 : tai ) = a ( 1 : tai , 1 : tai ) call choldc ( a = a ( 1 : tai , 1 : tai ), & ! n = tai , & ! np = tai , & ! p = p ( 1 : tai ), & ! info = info ) ! call cholsl ( a = a ( 1 : tai , 1 : tai ), & ! n = tai , & ! np = tai , & ! p = p ( 1 : tai ), & ! b = b ( 1 : tai ), & ! x = x ( 1 : tai ), & ! info = info ) ! write ( * , * ) sum ( abs ( matmul ( aa , x ) - b ) ), info stop endprogram test_utils","tags":"","loc":"sourcefile/prg.f90~13.html"},{"title":"superlu.f90 – TOOLIB","text":"Files dependent on this one sourcefile~~superlu.f90~~AfferentGraph sourcefile~superlu.f90 superlu.f90 sourcefile~mod_solver.f90 mod_solver.f90 sourcefile~mod_solver.f90->sourcefile~superlu.f90 sourcefile~prg.f90~10 prg.f90 sourcefile~prg.f90~10->sourcefile~mod_solver.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !  version: 1.0.0 !  date: july, 12 2018 ! !  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !     **A SuperLU wrapper** !  </span> module sulu_wrapper use iso_c_binding , only : C_INT , C_FLOAT , C_DOUBLE , C_CHAR , C_PTR , C_F_POINTER , C_NULL_CHAR , C_NULL_PTR implicit none private integer ( kind = 4 ), parameter :: I4 = 4 , R4 = 4 , R8 = 8 !------------------------------------------------------------------------------- ! -------------------   ENUMS -------------------------------------------------- !------------------------------------------------------------------------------- enum , bind ( c ) ! trans_t enumerator :: NOTRANS enumerator :: TRANS enumerator :: CONJ endenum enum , bind ( c ) ! fact_t enumerator :: DOFACT enumerator :: SAMEPATTERN enumerator :: SAMEPATTERN_SAMEROWPERM enumerator :: FACTORED endenum enum , bind ( c ) ! Stype_t enumerator :: SLU_NC !! *column-wise, no supernode* enumerator :: SLU_NCP !! *column-wise, column-permuted, no supernode* enumerator :: SLU_NR !! *row-wize, no supernode* enumerator :: SLU_SC !! *column-wise, supernode* enumerator :: SLU_SCP !! *supernode, column-wise, permuted* enumerator :: SLU_SR !! *row-wise, supernode* enumerator :: SLU_DN !! *Fortran style column-wise storage for dense matrix* enumerator :: SLU_NR_loc !! *distributed compressed row format* endenum enum , bind ( c ) ! Dtype_t enumerator :: SLU_S !! *single* enumerator :: SLU_D !! *double* enumerator :: SLU_C !! *single complex* enumerator :: SLU_Z !! *double complex* endenum enum , bind ( c ) ! Mtype_t enumerator :: SLU_GE !! *general* enumerator :: SLU_TRLU !! *lower triangular, unit diagonal* enumerator :: SLU_TRUU !! *upper triangular, unit diagonal* enumerator :: SLU_TRL !! *lower triangular* enumerator :: SLU_TRU !! *upper triangular* enumerator :: SLU_SYL !! *symmetric, store lower half* enumerator :: SLU_SYU !! *symmetric, store upper half* enumerator :: SLU_HEL !! *Hermitian, store lower half* enumerator :: SLU_HEU !! *Hermitian, store upper half* endenum !------------------------------------------------------------------------------- ! -------------------   DERIVED TYPES   ---------------------------------------- !------------------------------------------------------------------------------- type , bind ( c ) :: LU_STACK_T integer ( kind = C_INT ) :: size integer ( kind = C_INT ) :: used integer ( kind = C_INT ) :: top1 integer ( kind = C_INT ) :: top2 type ( C_PTR ) :: array endtype LU_STACK_T type , bind ( c ) :: EXPHEADER integer ( kind = C_INT ) :: size type ( C_PTR ) :: mem endtype EXPHEADER type , bind ( c ) :: GLOBALLU_T integer ( kind = C_INT ) :: xsup integer ( kind = C_INT ) :: supno integer ( kind = C_INT ) :: lsub integer ( kind = C_INT ) :: xlsub type ( C_PTR ) :: lusup integer ( kind = C_INT ) :: xlusup type ( C_PTR ) :: ucol integer ( kind = C_INT ) :: usub integer ( kind = C_INT ) :: xusub integer ( kind = C_INT ) :: nzlmax integer ( kind = C_INT ) :: nzumax integer ( kind = C_INT ) :: nzlumax integer ( kind = C_INT ) :: MemModel = 0 integer ( kind = C_INT ) :: num_expansions type ( EXPHEADER ) :: expanders type ( LU_STACK_T ) :: stack endtype GLOBALLU_T type , bind ( c ) :: SUPERLUSTAT_T type ( C_PTR ) :: panel_histo !! *histogram of panel size distribution* type ( C_PTR ) :: utime !! *running time at various phases* type ( C_PTR ) :: ops !! *operation count at various phases* integer ( kind = C_INT ) :: TinyPivots !! *number of tiny pivots* integer ( kind = C_INT ) :: RefineSteps !! *number of iterative refinement steps* integer ( kind = C_INT ) :: expansions !! *number of memory expansions* endtype SUPERLUSTAT_T type , bind ( c ) :: MEM_USAGE_T real ( kind = C_FLOAT ) :: for_lu real ( kind = C_FLOAT ) :: total_needed endtype MEM_USAGE_T !< @note ! Stype == ```SLU_NC``` (Also known as Harwell-Boeing sparse matrix format) ! ! Zero-based indexing is used; colptr[] has ncol+1 entries, the last one pointing beyond the last column, ! so that colptr[ncol] = nnz. ! @endnote type , bind ( c ) :: NCFORMAT integer ( kind = C_INT ) :: nnz !! *number of nonzeros in the matrix* type ( C_PTR ) :: nzval !! *pointer to array of nonzero values, packed by column* type ( C_PTR ) :: rowind !! *pointer to array of row indices of the nonzeros* type ( C_PTR ) :: colptr !! *pointer to array of beginning of columns in nzval[] and rowind[]* endtype NCFORMAT type , bind ( c ) :: SUPERMATRIX integer ( kind = C_INT ) :: Stype !! *Storage type: interprets the storage structure pointed to by Store* integer ( kind = C_INT ) :: Dtype !! *Data type* integer ( kind = C_INT ) :: Mtype !! *Matrix type: describes the mathematical property of the matrix* integer ( kind = C_INT ) :: nrow !! *number of rows* integer ( kind = C_INT ) :: ncol !! *number of columns* type ( C_PTR ) :: Store !! *pointer to the actual storage of the matrix, here, pointer to [[NCformat]]* endtype SUPERMATRIX type , bind ( c ) :: SUPERLU_OPTIONS_T !/* ! *-- This contains the options used to control the solution process. ! * ! * Fact   (fact_t) ! *        Specifies whether or not the factored form of the matrix ! *        A is supplied on entry, and if not, how the matrix A should ! *        be factorizaed. ! *        = DOFACT: The matrix A will be factorized from scratch, and the ! *             factors will be stored in L and U. ! *        = SamePattern: The matrix A will be factorized assuming ! *             that a factorization of a matrix with the same sparsity ! *             pattern was performed prior to this one. Therefore, this ! *             factorization will reuse column permutation vector ! *             ScalePermstruct->perm_c and the column elimination tree ! *             LUstruct->etree. ! *        = SamePattern_SameRowPerm: The matrix A will be factorized ! *             assuming that a factorization of a matrix with the same ! *             sparsity   pattern and similar numerical values was performed ! *             prior to this one. Therefore, this factorization will reuse ! *             both row and column scaling factors R and C, both row and ! *             column permutation vectors perm_r and perm_c, and the ! *             L & U data structures set up from the previous factorization. !! *        = FACTORED: On entry, L, U, perm_r and perm_c contain the ! *              factored form of A. If DiagScale is not NOEQUIL, the matrix ! *              A has been equilibrated with scaling factors R and C. ! * ! * Equil  (yes_no_t) ! *        Specifies whether to equilibrate the system (scale A's row and ! *        columns to have unit norm). ! * ! * ColPerm (colperm_t) ! *        Specifies what type of column permutation to use to reduce fill. ! *        = NATURAL: use the natural ordering ! *        = MMD_ATA: use minimum degree ordering on structure of A'*A ! *        = MMD_AT_PLUS_A: use minimum degree ordering on structure of A'+A ! *        = COLAMD: use approximate minimum degree column ordering ! *        = MY_PERMC: use the ordering specified by the user ! * ! * Trans  (trans_t) ! *        Specifies the form of the system of equations: ! *        = NOTRANS: A * X = B        (No transpose) ! *        = TRANS:   A**T * X = B     (Transpose) ! *        = CONJ:    A**H * X = B     (Transpose) ! * ! * IterRefine (IterRefine_t) ! *        Specifies whether to perform iterative refinement. ! *        = NO: no iterative refinement ! *        = SLU_SINGLE: perform iterative refinement in single precision ! *        = SLU_DOUBLE: perform iterative refinement in double precision ! *        = SLU_EXTRA: perform iterative refinement in extra precision ! * ! * DiagPivotThresh (double, in [0.0, 1.0]) (only for sequential SuperLU) ! *        Specifies the threshold used for a diagonal entry to be an ! *        acceptable pivot. ! * ! * SymmetricMode (yest_no_t) ! *        Specifies whether to use symmetric mode. Symmetric mode gives ! *        preference to diagonal pivots, and uses an (A'+A)-based column ! *        permutation algorithm. ! * ! * PivotGrowth (yes_no_t) ! *        Specifies whether to compute the reciprocal pivot growth. ! * ! * ConditionNumber (ues_no_t) ! *        Specifies whether to compute the reciprocal condition number. ! * ! * RowPerm (rowperm_t) (only for SuperLU_DIST or ILU) ! *        Specifies whether to permute rows of the original matrix. ! *        = NO: not to permute the rows ! *        = LargeDiag: make the diagonal large relative to the off-diagonal ! *        = MY_PERMR: use the permutation given by the user ! * ! * ILU_DropRule (int) ! *        Specifies the dropping rule: ! *     = DROP_BASIC:   Basic dropping rule, supernodal based ILUTP(tau). ! *     = DROP_PROWS:   Supernodal based ILUTP(p,tau), p = gamma * nnz(A)/n. ! *     = DROP_COLUMN:  Variant of ILUTP(p,tau), for j-th column, ! *                     p = gamma * nnz(A(:,j)). ! *     = DROP_AREA:    Variation of ILUTP, for j-th column, use ! *                     nnz(F(:,1:j)) / nnz(A(:,1:j)) to control memory. ! *     = DROP_DYNAMIC: Modify the threshold tau during factorizaion: ! *                     If nnz(L(:,1:j)) / nnz(A(:,1:j)) > gamma ! *                         tau_L(j) := MIN(tau_0, tau_L(j-1) * 2); ! *                     Otherwise ! *                         tau_L(j) := MAX(tau_0, tau_L(j-1) / 2); ! *                     tau_U(j) uses the similar rule. ! *                     NOTE: the thresholds used by L and U are separate. ! *     = DROP_INTERP:  Compute the second dropping threshold by ! *                     interpolation instead of sorting (default). ! *                     In this case, the actual fill ratio is not ! *                     guaranteed to be smaller than gamma. ! *                     Note: DROP_PROWS, DROP_COLUMN and DROP_AREA are mutually exclusive. ! *    ( Default: DROP_BASIC | DROP_AREA ) ! * ! * ILU_DropTol (double) ! *        numerical threshold for dropping. ! * ! * ILU_FillFactor (double) ! *        Gamma in the secondary dropping. ! * ! * ILU_Norm (norm_t) ! *        Specify which norm to use to measure the row size in a ! *        supernode: infinity-norm, 1-norm, or 2-norm. ! * ! * ILU_FillTol (double) ! *        numerical threshold for zero pivot perturbation. ! * ! * ILU_MILU (milu_t) ! *        Specifies which version of MILU to use. ! * ! * ILU_MILU_Dim (double) ! *        Dimension of the PDE if available. ! * ! * ReplaceTinyPivot (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether to replace the tiny diagonals by ! *        sqrt(epsilon)*||A|| during LU factorization. ! * ! * SolveInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        triangular solve. ! * ! * RefineInitialized (yes_no_t) (only for SuperLU_DIST) ! *        Specifies whether the initialization has been performed to the ! *        sparse matrix-vector multiplication routine needed in iterative ! *        refinement. ! * ! * PrintStat (yes_no_t) ! *        Specifies whether to print the solver's statistics. ! */ integer ( kind = C_INT ) :: Fact integer ( kind = C_INT ) :: Equil integer ( kind = C_INT ) :: ColPerm integer ( kind = C_INT ) :: Trans integer ( kind = C_INT ) :: IterRefine real ( kind = C_DOUBLE ) :: DiagPivotThresh integer ( kind = C_INT ) :: SymmetricMode integer ( kind = C_INT ) :: PivotGrowth integer ( kind = C_INT ) :: ConditionNumber integer ( kind = C_INT ) :: RowPerm integer ( kind = C_INT ) :: ILU_DropRule real ( kind = C_DOUBLE ) :: ILU_DropTol real ( kind = C_DOUBLE ) :: ILU_FillFactor integer ( kind = C_INT ) :: ILU_Norm real ( kind = C_DOUBLE ) :: ILU_FillTol integer ( kind = C_INT ) :: ILU_MILU real ( kind = C_DOUBLE ) :: ILU_MILU_Dim integer ( kind = C_INT ) :: ParSymbFact integer ( kind = C_INT ) :: ReplaceTinyPivot integer ( kind = C_INT ) :: SolveInitialized integer ( kind = C_INT ) :: RefineInitialized integer ( kind = C_INT ) :: PrintStat integer ( kind = C_INT ) :: nnzL , nnzU !! *used to store nnzs for now* integer ( kind = C_INT ) :: num_lookaheads !! *num of levels in look-ahead* integer ( kind = C_INT ) :: lookahead_etree !! *use etree computed from the serial symbolic factorization* integer ( kind = C_INT ) :: SymPattern !! *symmetric factorization* endtype SUPERLU_OPTIONS_T !------------------------------------------------------------------------------- ! -------------------   SULU GLOBAL TYPE   ------------------------------------- !------------------------------------------------------------------------------- type SULU_ENV !! <span style=\"color:green\">Global type for *SuperLU* which covers all the stuff needed</span> integer ( kind = C_INT ) :: n !! *system size* integer ( kind = C_INT ) :: nrhs !! *number of right hand sides* integer ( kind = C_INT ) :: nz !! *number on non-zero entries* integer ( kind = C_INT ) :: info !! *info returned by [[dgssvx]]* integer ( kind = C_INT ) :: lwork !! *size of workspace, not used here* logical ( kind = I4 ) :: first !! *if ```false``` the system has been factorized at least once* real ( kind = R8 ), dimension (:), pointer :: b !! *right hand side: points to [[MAT_SOLV:b]]* real ( kind = R8 ), allocatable , dimension (:) :: x !! *solution* real ( kind = R8 ), dimension (:), pointer :: a_elt !! *CC system matrix: points to [[MAT_SOLV:a_elt]]* integer ( kind = I4 ), dimension (:), pointer :: irow !! *matrix line of an a_elt element: points to [[MAT_SOLV:irow]]* integer ( kind = I4 ), dimension (:), pointer :: jptr !! *matrix column pointers: points to [[MAT_SOLV:jptr]]* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: ferr !! *estimated forward error bound for each solution vector* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: berr !! *componentwise relative backward error of each solution* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: RR !! *row scale factors for A * real ( kind = C_DOUBLE ), allocatable , dimension (:) :: CC !!*column scale factors for A* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rpg !! *reciprocal pivot growth factor* real ( kind = C_DOUBLE ), allocatable , dimension (:) :: rcond !!*estimate of the reciprocal condition number of the matrix A* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_c !!*If A->Stype = ```SLU_NC```, Column permutation vector of size A->ncol* integer ( kind = C_INT ), allocatable , dimension (:) :: perm_r !!*If A->Stype = ```SLU_NC```, row permutation vector of size A->nrow* integer ( kind = C_INT ), allocatable , dimension (:) :: etree !! *Elimination tree* character ( len = 1 , kind = C_CHAR ) :: equed !! *form of equilibration* type ( C_PTR ) :: work !! *User supplied workspace* type ( SUPERLU_OPTIONS_T ) :: options !! *LU controls* type ( SUPERMATRIX ) :: sma !! *Matrix A in A*X=B* type ( SUPERMATRIX ) :: smb !! *On entry, the right hand side matrix* type ( SUPERMATRIX ) :: smx !! *olution matrix to the original system* type ( SUPERMATRIX ) :: sml !! *factor L from the factorization* type ( SUPERMATRIX ) :: smu !! *factor U from the factorization* type ( SUPERLUSTAT_T ) :: stat !! *statistics on runtime and floating-point operation count* type ( GLOBALLU_T ) :: Glu !! *first, an output with the whole stuff LU; next, an input for other resolutions with same sparsity* type ( MEM_USAGE_T ) :: mem_usage !! *memory usage statistics* endtype SULU_ENV !------------------------------------------------------------------------------- ! -------------------   INTERFACES   ------------------------------------------- !------------------------------------------------------------------------------- interface !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperNode_Matrix ( A ) & ! bind ( c , name = \"Destroy_SuperNode_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperNode_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_SuperMatrix_Store ( A ) & ! bind ( c , name = \"Destroy_SuperMatrix_Store\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_SuperMatrix_Store !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_CompCol_Matrix ( A ) & ! bind ( c , name = \"Destroy_CompCol_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine Destroy_Dense_Matrix ( A ) & ! bind ( c , name = \"Destroy_Dense_Matrix\" ) import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( in ) :: A endsubroutine Destroy_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatInit ( stat ) & ! bind ( c , name = \"StatInit\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( out ) :: stat endsubroutine StatInit !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatFree ( stat ) & ! bind ( c , name = \"StatFree\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatFree !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_CompCol_Matrix ( A , & ! out SuperMatrix m , & ! in int n , & ! in int nnz , & ! in int nzval , & ! in double dimension() rowind , & ! in int dimension() colptr , & ! in int dimension() stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = \"dCreate_CompCol_Matrix\" ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import :: SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: A integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n integer ( kind = C_INT ), value , intent ( in ) :: nnz real ( kind = C_DOUBLE ), intent ( in ) :: nzval ( * ) integer ( kind = C_INT ), intent ( in ) :: rowind ( * ) integer ( kind = C_INT ), intent ( in ) :: colptr ( * ) integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_CompCol_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine dCreate_Dense_Matrix ( BX , & ! out SuperMatrix m , & ! in int n , & ! in int x , & ! in double dimension() ldx , & ! in int stype , & ! in int dtype , & ! in int mtype & ! in int ) & bind ( c , name = 'dCreate_Dense_Matrix' ) use , intrinsic :: iso_c_binding , only : C_INT , C_DOUBLE import SUPERMATRIX implicit none type ( SUPERMATRIX ), intent ( out ) :: BX integer ( kind = C_INT ), value , intent ( in ) :: m integer ( kind = C_INT ), value , intent ( in ) :: n real ( kind = C_DOUBLE ), intent ( in ) :: x ( * ) integer ( kind = C_INT ), value , intent ( in ) :: ldx integer ( kind = C_INT ), value , intent ( in ) :: stype integer ( kind = C_INT ), value , intent ( in ) :: dtype integer ( kind = C_INT ), value , intent ( in ) :: mtype endsubroutine dCreate_Dense_Matrix !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine set_default_options ( options ) & ! bind ( c , name = 'set_default_options' ) use , intrinsic :: iso_c_binding import SUPERLU_OPTIONS_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( inout ) :: options endsubroutine set_default_options !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . !/*! Arguments ! * ! * <pre> ! * Purpose ! * ======= ! * ! * DGSSVX solves the system of linear equations A*X=B or A'*X=B, using ! * the LU factorization from dgstrf(). Error bounds on the solution and ! * a condition estimate are also provided. It performs the following steps: ! * ! *   1. If A is stored column-wise (A->Stype = SLU_NC): ! * ! *      1.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A is ! *           overwritten by diag(R)*A*diag(C) and B by diag(R)*B ! *           (if options->Trans=NOTRANS) or diag(C)*B (if options->Trans ! *           = TRANS or CONJ). ! * ! *      1.2. Permute columns of A, forming A*Pc, where Pc is a permutation ! *           matrix that usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      1.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the matrix A (after equilibration if options->Equil = YES) ! *           as Pr*A*Pc = L*U, with Pr determined by partial pivoting. ! * ! *      1.4. Compute the reciprocal pivot growth factor. ! * ! *      1.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form of ! *           A is used to estimate the condition number of the matrix A. If ! *           the reciprocal of the condition number is less than machine ! *           precision, info = A->ncol+1 is returned as a warning, but the ! *           routine still goes on to solve for X and computes error bounds ! *           as described below. ! * ! *      1.6. The system of equations is solved for X using the factored form ! *           of A. ! * ! *      1.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      1.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   2. If A is stored row-wise (A->Stype = SLU_NR), apply the above algorithm ! *      to the transpose of A: ! * ! *      2.1. If options->Equil = YES, scaling factors are computed to ! *           equilibrate the system: ! *           options->Trans = NOTRANS: ! *               diag(R)*A*diag(C) *inv(diag(C))*X = diag(R)*B ! *           options->Trans = TRANS: ! *               (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B ! *           options->Trans = CONJ: ! *               (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B ! *           Whether or not the system will be equilibrated depends on the ! *           scaling of the matrix A, but if equilibration is used, A' is ! *           overwritten by diag(R)*A'*diag(C) and B by diag(R)*B ! *           (if trans='N') or diag(C)*B (if trans = 'T' or 'C'). ! * ! *      2.2. Permute columns of transpose(A) (rows of A), ! *           forming transpose(A)*Pc, where Pc is a permutation matrix that ! *           usually preserves sparsity. ! *           For more details of this step, see sp_preorder.c. ! * ! *      2.3. If options->Fact != FACTORED, the LU decomposition is used to ! *           factor the transpose(A) (after equilibration if ! *           options->Fact = YES) as Pr*transpose(A)*Pc = L*U with the ! *           permutation Pr determined by partial pivoting. ! * ! *      2.4. Compute the reciprocal pivot growth factor. ! * ! *      2.5. If some U(i,i) = 0, so that U is exactly singular, then the ! *           routine returns with info = i. Otherwise, the factored form ! *           of transpose(A) is used to estimate the condition number of the ! *           matrix A. If the reciprocal of the condition number ! *           is less than machine precision, info = A->nrow+1 is returned as ! *           a warning, but the routine still goes on to solve for X and ! *           computes error bounds as described below. ! * ! *      2.6. The system of equations is solved for X using the factored form ! *           of transpose(A). ! * ! *      2.7. If options->IterRefine != NOREFINE, iterative refinement is ! *           applied to improve the computed solution matrix and calculate ! *           error bounds and backward error estimates for it. ! * ! *      2.8. If equilibration was used, the matrix X is premultiplied by ! *           diag(C) (if options->Trans = NOTRANS) or diag(R) ! *           (if options->Trans = TRANS or CONJ) so that it solves the ! *           original system before equilibration. ! * ! *   See supermatrix.h for the definition of 'SuperMatrix' structure. ! * ! * Arguments ! * ========= ! * ! * options (input) superlu_options_t* ! *         The structure defines the input parameters to control ! *         how the LU decomposition will be performed and how the ! *         system will be solved. ! * ! * A       (input/output) SuperMatrix* ! *         Matrix A in A*X=B, of dimension (A->nrow, A->ncol). The number ! *         of the linear equations is A->nrow. Currently, the type of A can be: ! *         Stype = SLU_NC or SLU_NR, Dtype = SLU_D, Mtype = SLU_GE. ! *         In the future, more general A may be handled. ! * ! *         On entry, If options->Fact = FACTORED and equed is not 'N', ! *         then A must have been equilibrated by the scaling factors in ! *         R and/or C. ! *         On exit, A is not modified if options->Equil = NO, or if ! *         options->Equil = YES but equed = 'N' on exit. ! *         Otherwise, if options->Equil = YES and equed is not 'N', ! *         A is scaled as follows: ! *         If A->Stype = SLU_NC: ! *           equed = 'R':  A := diag(R) * A ! *           equed = 'C':  A := A * diag(C) ! *           equed = 'B':  A := diag(R) * A * diag(C). ! *         If A->Stype = SLU_NR: ! *           equed = 'R':  transpose(A) := diag(R) * transpose(A) ! *           equed = 'C':  transpose(A) := transpose(A) * diag(C) ! *           equed = 'B':  transpose(A) := diag(R) * transpose(A) * diag(C). ! * ! * perm_c  (input/output) int* ! *         If A->Stype = SLU_NC, Column permutation vector of size A->ncol, ! *         which defines the permutation matrix Pc; perm_c[i] = j means ! *         column i of A is in position j in A*Pc. ! *         On exit, perm_c may be overwritten by the product of the input ! *         perm_c and a permutation that postorders the elimination tree ! *         of Pc'*A'*A*Pc; perm_c is not changed if the elimination tree ! *         is already in postorder. ! * ! *         If A->Stype = SLU_NR, column permutation vector of size A->nrow, ! *         which describes permutation of columns of transpose(A) ! *         (rows of A) as described above. ! * ! * perm_r  (input/output) int* ! *         If A->Stype = SLU_NC, row permutation vector of size A->nrow, ! *         which defines the permutation matrix Pr, and is determined ! *         by partial pivoting.  perm_r[i] = j means row i of A is in ! *         position j in Pr*A. ! * ! *         If A->Stype = SLU_NR, permutation vector of size A->ncol, which ! *         determines permutation of rows of transpose(A) ! *         (columns of A) as described above. ! * ! *         If options->Fact = SamePattern_SameRowPerm, the pivoting routine ! *         will try to use the input perm_r, unless a certain threshold ! *         criterion is violated. In that case, perm_r is overwritten by a ! *         new permutation determined by partial pivoting or diagonal ! *         threshold pivoting. ! *         Otherwise, perm_r is output argument. ! * ! * etree   (input/output) int*,  dimension (A->ncol) ! *         Elimination tree of Pc'*A'*A*Pc. ! *         If options->Fact != FACTORED and options->Fact != DOFACT, ! *         etree is an input argument, otherwise it is an output argument. ! *         Note: etree is a vector of parent pointers for a forest whose ! *         vertices are the integers 0 to A->ncol-1; etree[root]==A->ncol. ! * ! * equed   (input/output) char* ! *         Specifies the form of equilibration that was done. ! *         = 'N': No equilibration. ! *         = 'R': Row equilibration, i.e., A was premultiplied by diag(R). ! *         = 'C': Column equilibration, i.e., A was postmultiplied by diag(C). ! *         = 'B': Both row and column equilibration, i.e., A was replaced ! *                by diag(R)*A*diag(C). ! *         If options->Fact = FACTORED, equed is an input argument, ! *         otherwise it is an output argument. ! * ! * R       (input/output) double*, dimension (A->nrow) ! *         The row scale factors for A or transpose(A). ! *         If equed = 'R' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the left by diag(R). ! *         If equed = 'N' or 'C', R is not accessed. ! *         If options->Fact = FACTORED, R is an input argument, ! *             otherwise, R is output. ! *         If options->zFact = FACTORED and equed = 'R' or 'B', each element ! *             of R must be positive. ! * ! * C       (input/output) double*, dimension (A->ncol) ! *         The column scale factors for A or transpose(A). ! *         If equed = 'C' or 'B', A (if A->Stype = SLU_NC) or transpose(A) ! *             (if A->Stype = SLU_NR) is multiplied on the right by diag(C). ! *         If equed = 'N' or 'R', C is not accessed. ! *         If options->Fact = FACTORED, C is an input argument, ! *             otherwise, C is output. ! *         If options->Fact = FACTORED and equed = 'C' or 'B', each element ! *             of C must be positive. ! * ! * L       (output) SuperMatrix* ! *         The factor L from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype SLU_= NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses compressed row subscripts storage for supernodes, i.e., ! *         L has types: Stype = SLU_SC, Dtype = SLU_D, Mtype = SLU_TRLU. ! * ! * U       (output) SuperMatrix* ! *         The factor U from the factorization ! *             Pr*A*Pc=L*U              (if A->Stype = SLU_NC) or ! *             Pr*transpose(A)*Pc=L*U   (if A->Stype = SLU_NR). ! *         Uses column-wise storage scheme, i.e., U has types: ! *         Stype = SLU_NC, Dtype = SLU_D, Mtype = SLU_TRU. ! * ! * work    (workspace/output) void*, size (lwork) (in bytes) ! *         User supplied workspace, should be large enough ! *         to hold data structures for factors L and U. ! *         On exit, if fact is not 'F', L and U point to this array. ! * ! * lwork   (input) int ! *         Specifies the size of work array in bytes. ! *         = 0:  allocate space internally by system malloc; ! *         > 0:  use user-supplied work array of length lwork in bytes, ! *               returns error if space runs out. ! *         = -1: the routine guesses the amount of space needed without ! *               performing the factorization, and returns it in ! *               mem_usage->total_needed; no other side effects. ! * ! *         See argument 'mem_usage' for memory usage statistics. ! * ! * B       (input/output) SuperMatrix* ! *         B has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         On entry, the right hand side matrix. ! *         If B->ncol = 0, only LU decomposition is performed, the triangular ! *                         solve is skipped. ! *         On exit, ! *            if equed = 'N', B is not modified; otherwise ! *            if A->Stype = SLU_NC: ! *               if options->Trans = NOTRANS and equed = 'R' or 'B', ! *                  B is overwritten by diag(R)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'C' of 'B', ! *                  B is overwritten by diag(C)*B; ! *            if A->Stype = SLU_NR: ! *               if options->Trans = NOTRANS and equed = 'C' or 'B', ! *                  B is overwritten by diag(C)*B; ! *               if options->Trans = TRANS or CONJ and equed = 'R' of 'B', ! *                  B is overwritten by diag(R)*B. ! * ! * X       (output) SuperMatrix* ! *         X has types: Stype = SLU_DN, Dtype = SLU_D, Mtype = SLU_GE. ! *         If info = 0 or info = A->ncol+1, X contains the solution matrix ! *         to the original system of equations. Note that A and B are modified ! *         on exit if equed is not 'N', and the solution to the equilibrated ! *         system is inv(diag(C))*X if options->Trans = NOTRANS and ! *         equed = 'C' or 'B', or inv(diag(R))*X if options->Trans = 'T' or 'C' ! *         and equed = 'R' or 'B'. ! * ! * recip_pivot_growth (output) double* ! *         The reciprocal pivot growth factor max_j( norm(A_j)/norm(U_j) ). ! *         The infinity norm is used. If recip_pivot_growth is much less ! *         than 1, the stability of the LU factorization could be poor. ! * ! * rcond   (output) double* ! *         The estimate of the reciprocal condition number of the matrix A ! *         after equilibration (if done). If rcond is less than the machine ! *         precision (in particular, if rcond = 0), the matrix is singular ! *         to working precision. This condition is indicated by a return ! *         code of info > 0. ! * ! * FERR    (output) double*, dimension (B->ncol) ! *         The estimated forward error bound for each solution vector ! *         X(j) (the j-th column of the solution matrix X). ! *         If XTRUE is the true solution corresponding to X(j), FERR(j) ! *         is an estimated upper bound for the magnitude of the largest ! *         element in (X(j) - XTRUE) divided by the magnitude of the ! *         largest element in X(j).  The estimate is as reliable as ! *         the estimate for RCOND, and is almost always a slight ! *         overestimate of the true error. ! *         If options->IterRefine = NOREFINE, ferr = 1.0. ! * ! * BERR    (output) double*, dimension (B->ncol) ! *         The componentwise relative backward error of each solution ! *         vector X(j) (i.e., the smallest relative change in ! *         any element of A or B that makes X(j) an exact solution). ! *         If options->IterRefine = NOREFINE, berr = 1.0. ! * ! * Glu      (input/output) GlobalLU_t * ! *          If options->Fact == SamePattern_SameRowPerm, it is an input; ! *              The matrix A will be factorized assuming that a ! *              factorization of a matrix with the same sparsity pattern ! *              and similar numerical values was performed prior to this one. ! *              Therefore, this factorization will reuse both row and column ! *              scaling factors R and C, both row and column permutation ! *              vectors perm_r and perm_c, and the L & U data structures ! *              set up from the previous factorization. ! *          Otherwise, it is an output. ! * ! * mem_usage (output) mem_usage_t* ! *         Record the memory usage statistics, consisting of following fields: ! *         - for_lu (float) ! *           The amount of space used in bytes for L\\U data structures. ! *         - total_needed (float) ! *           The amount of space needed in bytes to perform factorization. ! *         - expansions (int) ! *           The number of memory expansions during the LU factorization. ! * ! * stat   (output) SuperLUStat_t* ! *        Record the statistics on runtime and floating-point operation count. ! *        See slu_util.h for the definition of 'SuperLUStat_t'. ! * ! * info    (output) int* ! *         = 0: successful exit ! *         < 0: if info = -i, the i-th argument had an illegal value ! *         > 0: if info = i, and i is ! *              <= A->ncol: U(i,i) is exactly zero. The factorization has ! *                    been completed, but the factor U is exactly ! *                    singular, so the solution and error bounds ! *                    could not be computed. ! *              = A->ncol+1: U is nonsingular, but RCOND is less than machine ! *                    precision, meaning that the matrix is singular to ! *                    working precision. Nevertheless, the solution and ! *                    error bounds are computed because there are a number ! *                    of situations where the computed solution can be more ! *                    accurate than the value of RCOND would suggest. ! *              > A->ncol+1: number of bytes allocated when memory allocation ! *                    failure occurred, plus A->ncol. ! * </pre> ! */ subroutine dgssvx (& ! argument                 |     type           |   C def           |  C call options , & ! superlu_options_t   *options             &options A , & ! SuperMatrix         *A                   &A1 perm_c , & ! int                 *perm_c               perm_c perm_r , & ! int                 *perm_r               perm_r etree , & ! int                 *etree                etree equed , & ! char                *equed                equed R , & ! double              *R                    R C , & ! double              *C                    C L , & ! SuperMatrix         *L                   &L U , & ! SuperMatrix         *U                   &U work , & ! void                *work                 work lwork , & ! int                  lwork                lwork B , & ! SuperMatrix         *B                   &B1 X , & ! SuperMatrix         *X                   &X recip_pivot_growth , & ! double              *recip_pivot_growth  &rpg rcond , & ! double              *rcond               &rcond ferr , & ! double              *ferr                 ferr berr , & ! double              *berr                 berr Glu , & ! GlobalLU_t          *Glu                 &Glu mem_usage , & ! mem_usage_t         *mem_usage           &smem_usage stat , & ! SuperLUStat_t       *stat                &stat info & ! int                 *info                &info ) & bind ( c , name = 'dgssvx' ) use , intrinsic :: iso_c_binding , only : C_INT , C_CHAR , C_DOUBLE , C_PTR import :: SUPERLU_OPTIONS_T , SUPERMATRIX , SUPERLUSTAT_T , MEM_USAGE_T , GLOBALLU_T implicit none type ( SUPERLU_OPTIONS_T ), intent ( in ) :: options type ( SUPERMATRIX ), intent ( inout ) :: A integer ( kind = C_INT ), intent ( inout ) :: perm_c ( * ) integer ( kind = C_INT ), intent ( inout ) :: perm_r ( * ) integer ( kind = C_INT ), intent ( inout ) :: etree ( * ) character ( kind = C_CHAR ), intent ( inout ) :: equed ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: R ( * ) real ( kind = C_DOUBLE ), intent ( inout ) :: C ( * ) type ( SUPERMATRIX ), intent ( inout ) :: L type ( SUPERMATRIX ), intent ( inout ) :: U type ( C_PTR ), intent ( out ) :: work integer ( kind = C_INT ), value , intent ( in ) :: lwork type ( SUPERMATRIX ), intent ( inout ) :: B type ( SUPERMATRIX ), intent ( out ) :: X real ( kind = C_DOUBLE ), intent ( out ) :: recip_pivot_growth ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: rcond ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: ferr ( * ) real ( kind = C_DOUBLE ), intent ( out ) :: berr ( * ) type ( GLOBALLU_T ), intent ( inout ) :: Glu type ( MEM_USAGE_T ), intent ( out ) :: mem_usage type ( SUPERLUSTAT_T ), intent ( out ) :: stat integer ( kind = C_INT ), intent ( out ) :: info endsubroutine dgssvx !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . subroutine StatPrint ( stat ) & ! bind ( c , name = \"StatPrint\" ) import :: SUPERLUSTAT_T implicit none type ( SUPERLUSTAT_T ), intent ( in ) :: stat endsubroutine StatPrint !. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . endinterface public :: sulu_env , init_superlu , prep_superlu , fact_superlu , solv_superlu , free_superlu , close_superlu , Destroy_CompCol_Matrix , Destroy_SuperNode_Matrix , & SAMEPATTERN , FACTORED , DOFACT contains !========================================================================================= !< @note ! **Subroutine to set the default LU behaviour** ! ! + sulu%options%Fact               = ```DOFACT``` ! + sulu%options%Equil              = ```YES``` ! + sulu%options%ColPerm            = ```COLAMD``` ! + sulu%options%DiagPivotThresh    = ```1.0``` ! + sulu%options%Trans              = ```NOTRANS``` ! + sulu%options%IterRefine         = ```NOREFINE``` ! + sulu%options%SymmetricMode      = ```NO``` ! + sulu%options%PivotGrowth        = ```NO``` ! + sulu%options%ConditionNumber    = ```NO``` ! + sulu%options%PrintStat          = ```YES``` ! ! @endnote !----------------------------------------------------------------------------------------- subroutine init_superlu ( sulu ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call set_default_options ( sulu % options ) return endsubroutine init_superlu !========================================================================================= subroutine prep_superlu ( sulu ) !! Subroutine to prepare the [[SULU_ENV]] components implicit none type ( sulu_env ), intent ( inout ) :: sulu integer ( kind = I4 ) :: nn , nz , nb nn = sulu % n nz = sulu % nz nb = sulu % nrhs if (. not . allocated ( sulu % perm_c )) allocate ( sulu % perm_c ( 1 : nn ) ) if (. not . allocated ( sulu % perm_r )) allocate ( sulu % perm_r ( 1 : nn ) ) if (. not . allocated ( sulu % etree )) allocate ( sulu % etree ( 1 : nn ) ) if (. not . allocated ( sulu % RR )) allocate ( sulu % RR ( 1 : nn ) ) if (. not . allocated ( sulu % CC )) allocate ( sulu % CC ( 1 : nn ) ) if (. not . allocated ( sulu % ferr )) allocate ( sulu % ferr ( 1 : nb ) ) if (. not . allocated ( sulu % berr )) allocate ( sulu % berr ( 1 : nb ) ) if (. not . allocated ( sulu % rpg )) allocate ( sulu % rpg ( 1 : nb ) ) if (. not . allocated ( sulu % rcond )) allocate ( sulu % rcond ( 1 : nb ) ) if (. not . allocated ( sulu % x )) allocate ( sulu % x ( 1 : nn ) ) sulu % x ( 1 : nn ) = 0 call dCreate_CompCol_Matrix ( A = sulu % SMA , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % n , & ! in int nnz = sulu % nz , & ! in int nzval = sulu % a_elt , & ! in double dimension() rowind = sulu % irow , & ! in int dimension() colptr = sulu % jptr , & ! in int dimension() stype = SLU_NC , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smb , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % b , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) call dCreate_Dense_Matrix ( BX = sulu % smx , & ! out SuperMatrix m = sulu % n , & ! in int n = sulu % nrhs , & ! in int x = sulu % x , & ! in double dimension() ldx = sulu % n , & ! in int stype = SLU_DN , & ! in int dtype = SLU_D , & ! in int mtype = SLU_GE & ! in int ) return endsubroutine prep_superlu !========================================================================================= !< @note !< Subroutine to factorize the system !< !< note the directives: !< !< + sulu%options%Fact = ```DOFACT``` !< + sulu%SMB%ncol     = ```0``` !< !< @endnote !----------------------------------------------------------------------------------------- subroutine fact_superlu ( sulu , verbose ) implicit none type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose sulu % lwork = 0 call StatInit ( sulu % stat ) sulu % options % Fact = DOFACT sulu % SMB % ncol = 0 call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) return endsubroutine fact_superlu !========================================================================================= !< @note !< Subroutine to solve the system !< !< + If no resolution has yet occured, sulu%first=```true``` !<     * sulu%options%Fact = ```FACTORED``` !<     * sulu%SMB%ncol     = sulu%nrhs (usually ```1```) !< + otherwise !<     * sulu%options%Fact = ```SAMEPATTERN``` !<     * sma, smb and smx are recreated but do not forget that we still have: !<         - mat%matsulu%irow   => mat%irow !<         - mat%matsulu%jptr   => mat%jptr !<         - mat%matsulu%a_elt  => mat%a_elt !<         - mat%matsulu%b      => mat%b !< !< @endnote !< !< @note !< The solution is retrieved with the pointer *store* of type [[NCFORMAT]] which !< gives access to [[NCFORMAT:nzval]] !< @endnote !< !< @warning !< At the end, the memory is released with the dstruction of *sml* and *smu* !< @endwarning !----------------------------------------------------------------------------------------- subroutine solv_superlu ( sol_x , sulu , verbose ) implicit none real ( kind = R8 ), dimension (:), intent ( inout ) :: sol_x type ( SULU_ENV ), intent ( inout ) :: sulu logical ( kind = I4 ), intent ( in ) :: verbose type ( NCFORMAT ), pointer :: Xstore real ( kind = R8 ), pointer :: tabX (:) integer ( kind = I4 ) :: i call StatInit ( sulu % stat ) if ( sulu % first ) then sulu % options % Fact = FACTORED sulu % SMB % ncol = sulu % nrhs else sulu % options % Fact = SAMEPATTERN call prep_superlu ( sulu ) endif call dgssvx ( options = sulu % options , & ! superlu_options_t   *options A = sulu % SMA , & ! SuperMatrix         *A perm_c = sulu % perm_c , & ! int                 *perm_c perm_r = sulu % perm_r , & ! int                 *perm_r etree = sulu % etree , & ! int                 *etree equed = sulu % equed , & ! char                *equed R = sulu % RR , & ! double              *R C = sulu % CC , & ! double              *C L = sulu % SML , & ! SuperMatrix         *L U = sulu % SMU , & ! SuperMatrix         *U work = sulu % work , & ! void                *work lwork = sulu % lwork , & ! int                  lwork B = sulu % SMB , & ! SuperMatrix         *B X = sulu % SMX , & ! SuperMatrix         *X recip_pivot_growth = sulu % rpg , & ! double              *recip_pivot_growth rcond = sulu % rcond , & ! double              *rcond ferr = sulu % ferr , & ! double              *ferr berr = sulu % berr , & ! double              *berr Glu = sulu % Glu , & ! GlobalLU_t          *Glu mem_usage = sulu % mem_usage , & ! mem_usage_t         *mem_usage stat = sulu % stat , & ! SuperLUStat_t       *stat info = sulu % info & ! int                 *info ) call c_f_pointer ( sulu % SMX % Store , XStore ) call c_f_pointer ( XStore % nzval , tabX , [ XStore % nnz ]) do i = 1 , sulu % n sol_x ( i ) = tabX ( i ) enddo nullify ( Xstore , tabX ) if ( verbose ) call StatPrint ( sulu % stat ) call StatFree ( sulu % stat ) call Destroy_SuperNode_Matrix ( sulu % SML ) call Destroy_CompCol_Matrix ( sulu % SMU ) return endsubroutine solv_superlu !========================================================================================= subroutine free_superlu () !! Subroutine that actually does nothing yet. Maybe, there will be extra memory that !! could be released here? implicit none return endsubroutine free_superlu !========================================================================================= subroutine close_superlu ( sulu ) !! Subroutine to close the SuperLU process, with memory release implicit none type ( SULU_ENV ), intent ( inout ) :: sulu call Destroy_CompCol_Matrix ( sulu % SMA ) call Destroy_Dense_Matrix ( sulu % smb ) call Destroy_Dense_Matrix ( sulu % smx ) deallocate ( sulu % perm_c ) deallocate ( sulu % perm_r ) deallocate ( sulu % etree ) deallocate ( sulu % RR ) deallocate ( sulu % CC ) deallocate ( sulu % ferr ) deallocate ( sulu % berr ) deallocate ( sulu % rpg ) deallocate ( sulu % rcond ) return endsubroutine close_superlu endmodule sulu_wrapper","tags":"","loc":"sourcefile/superlu.f90.html"},{"title":"prg.f90 – TOOLIB","text":"This file depends on sourcefile~~prg.f90~14~~EfferentGraph sourcefile~prg.f90~14 prg.f90 sourcefile~mod_data_arch.f90 mod_data_arch.f90 sourcefile~prg.f90~14->sourcefile~mod_data_arch.f90 sourcefile~mod_fftw3.f90 mod_fftw3.f90 sourcefile~prg.f90~14->sourcefile~mod_fftw3.f90 sourcefile~mod_miscellaneous.f90 mod_miscellaneous.f90 sourcefile~prg.f90~14->sourcefile~mod_miscellaneous.f90 sourcefile~mod_fftw3.f90->sourcefile~mod_data_arch.f90 sourcefile~mod_miscellaneous.f90->sourcefile~mod_data_arch.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !< author: Arthur Francisco !<  version: 1.0.0 !<  date: November, 18 2024 !< !<  <span style=\"color: #337ab7; font-family: cabin; font-size: 1.5em;\"> !<     **Routines to work with FFTs. Example of use** !<  </span> program test_fftw3 !$ use omp_lib use data_arch , only : I4 , R8 , R4 use miscellaneous , only : get_unit use fftw3 implicit none integer ( kind = I4 ) :: i , k integer ( kind = I4 ) :: ni integer ( kind = I4 ) :: nj integer ( kind = I4 ) :: nb_iter real ( kind = R8 ) :: error real ( kind = R4 ) :: t1 , t2 real ( kind = R8 ), dimension (:,:), allocatable :: tab !! real array containing the information to process real ( kind = R8 ), dimension (:,:), allocatable :: tabr1 !! real array containing the information to process real ( kind = R8 ), dimension (:,:), allocatable :: tabr2 !! real array containing the information to process complex ( kind = R8 ), dimension (:,:), allocatable :: tab1 !! input array ```FORWARD```,  output array ```BACKWARD``` complex ( kind = R8 ), dimension (:,:), allocatable :: tab2 !! input array ```BACKWARD```, output array ```FORWARD``` ! COMPLEX -> COMPLEX -> COMPLEX !---------------------------------------------------------------------------------------------------------------- ! multithread activation !---------------------------------------------------------------------------------------------------------------- NB_THREADS_FFT = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = NB_THREADS_FFT ) ! first case: random array forward, then backward transformed ! The difference ```error``` between original and processed data is calculated ni = 4096 nj = 4096 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) call init_fftw3 ( long = ni , larg = nj ) call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( * , * ) 'C-C-C error = ' , error call end_fftw3 () deallocate ( tab , tab1 , tab2 ) ! second case: height array forward, then backward transformed ! The difference between original and processed data can be assessed with the resulting \"600x300_FB.dat\" ni = 600 nj = 300 call read_surf ( nom_fic = \"./sur/600x300.dat\" , tab_s = tab , nx = ni , ny = nj ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) ; tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call cpu_time ( t1 ) call init_fftw3 ( long = ni , larg = nj ) call calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) call end_fftw3 () call cpu_time ( t2 ) write ( * , * ) t2 - t1 tab ( 1 : ni , 1 : nj ) = real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 ) call save_surf ( nom_fic = \"./sur/600x300_FB_comp.dat\" , tab_s = tab , nx = ni , ny = nj ) deallocate ( tab , tab1 , tab2 ) !---------------------------------------------------------------------------------------------------------------- ! multithread deactivation ! ```NB_THREADS_MAX``` are simultaneously computed on random 512x512 arrays ! The difference ```error``` between original and processed data is calculated call fftw_plan_with_nthreads ( nthreads = 1 ) ni = 0512 nj = 0512 nb_iter = 100 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) call get_unit ( k ) open ( unit = k , file = \"out/error_comp.txt\" ) NB_THREADS_FFT = omp_get_max_threads () call tab_init_fftw3 ( long = ni , larg = nj , plan_flag = FFTW_MEASURE ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, NB_ITER/NB_THREADS_FFT) PRIVATE(tab, tab1, tab2) do i = 1 , nb_iter call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) + 1._R8 tab1 ( 1 : ni , 1 : nj ) = cmplx ( tab ( 1 : ni , 1 : nj ), 0._R8 , kind = R8 ) call tab_calc_fftw3 ( sens = FORWARD , tab_in = tab1 , tab_ou = tab2 , long = ni , larg = nj ) call tab_calc_fftw3 ( sens = BACKWARD , tab_in = tab2 , tab_ou = tab1 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tab1 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( k , * ) error enddo !$OMP END DO !$OMP END PARALLEL call tab_end_fftw3 () close ( k ) deallocate ( tab , tab1 , tab2 ) ! REAL -> COMPLEX -> REAL !---------------------------------------------------------------------------------------------------------------- ! multithread activation !---------------------------------------------------------------------------------------------------------------- NB_THREADS_FFT = omp_get_max_threads () call fftw_plan_with_nthreads ( nthreads = NB_THREADS_FFT ) ! first case: random array forward, then backward transformed ! The difference ```error``` between original and processed data is calculated ni = 4096 nj = 4096 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tabr2 ( 1 : ni , 1 : nj ) ) allocate ( tab2 ( 1 : ni , 1 : nj ) ) call init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_ESTIMATE ) call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr2 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - real ( tabr2 ( 1 : ni , 1 : nj ), kind = R8 )) / tab ( 1 : ni , 1 : nj ) ) ) write ( * , * ) 'R-C-R: error = ' , error call end_fftw3 () deallocate ( tab , tabr1 , tabr2 , tab2 ) ! second case: height array forward, then backward transformed ! The difference between original and processed data can be assessed with the resulting \"600x300_FB.dat\" ni = 600 nj = 300 call read_surf ( nom_fic = \"./sur/600x300.dat\" , tab_s = tab , nx = ni , ny = nj ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tab2 ( 1 : ni , 1 : nj ) ) ; tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call cpu_time ( t1 ) call init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_ESTIMATE ) call calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr1 , long = ni , larg = nj ) call end_fftw3 () call cpu_time ( t2 ) write ( * , * ) t2 - t1 tab ( 1 : ni , 1 : nj ) = tabr1 ( 1 : ni , 1 : nj ) call save_surf ( nom_fic = \"./sur/600x300_FB_real.dat\" , tab_s = tab , nx = ni , ny = nj ) deallocate ( tab , tabr1 , tab2 ) !---------------------------------------------------------------------------------------------------------------- ! multithread deactivation ! ```NB_THREADS_MAX``` are simultaneously computed on random 512x512 arrays ! The difference ```error``` between original and processed data is calculated call fftw_plan_with_nthreads ( nthreads = 1 ) ni = 0512 nj = 0512 nb_iter = 100 allocate ( tab ( 1 : ni , 1 : nj ) ) allocate ( tab2 ( 1 : ni , 1 : nj ) ) allocate ( tabr1 ( 1 : ni , 1 : nj ), tabr2 ( 1 : ni , 1 : nj ) ) call get_unit ( k ) open ( unit = k , file = \"out/error_real.txt\" ) NB_THREADS_FFT = omp_get_max_threads () call tab_init_fftw3_real ( long = ni , larg = nj , plan_flag = FFTW_MEASURE ) !$OMP PARALLEL DEFAULT(SHARED) NUM_THREADS(NB_THREADS_FFT) !$OMP DO SCHEDULE (STATIC, NB_ITER/NB_THREADS_FFT) PRIVATE(tab, tabr1, tabr2, tab2) do i = 1 , nb_iter call random_number ( harvest = tab ( 1 : ni , 1 : nj ) ) tab ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) + 1._R8 tabr1 ( 1 : ni , 1 : nj ) = tab ( 1 : ni , 1 : nj ) call tab_calc_fftw3_real_fwd ( tab_in = tabr1 , tab_ou = tab2 , long = ni , larg = nj ) call tab_calc_fftw3_real_bwd ( tab_in = tab2 , tab_ou = tabr2 , long = ni , larg = nj ) error = 100 * maxval ( abs ( ( tab ( 1 : ni , 1 : nj ) - tabr2 ( 1 : ni , 1 : nj )) / tab ( 1 : ni , 1 : nj ) ) ) write ( k , * ) error enddo !$OMP END DO !$OMP END PARALLEL call tab_end_fftw3_real () close ( k ) deallocate ( tab , tabr1 , tabr2 , tab2 ) stop contains !========================================================================================= subroutine read_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that opens a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( out ), dimension (:,:), allocatable :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k real ( kind = R8 ) :: x , y allocate ( tab_s ( 1 : nx , 1 : ny ) ) call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'old' ) do i = 1 , nx do j = 1 , ny read ( k , * ) x , y , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine read_surf !========================================================================================= subroutine save_surf ( nom_fic , tab_s , nx , ny ) !! Subroutine that saves a surface file ```.dat``` implicit none character ( len =* ), intent ( in ) :: nom_fic !! *file name* integer ( kind = I4 ), intent ( in ) :: nx !! *number of pixels along x* integer ( kind = I4 ), intent ( in ) :: ny !! *number of pixels along y* real ( kind = R8 ), intent ( in ), dimension ( 1 : nx , 1 : ny ) :: tab_s !! *height array* integer ( kind = I4 ) :: i , j , k call get_unit ( k ) open ( unit = k , file = trim ( nom_fic ), status = 'unknown' ) do i = 1 , nx do j = 1 , ny write ( k , * ) i , j , tab_s ( i , j ) enddo enddo close ( k ) return endsubroutine save_surf endprogram test_fftw3","tags":"","loc":"sourcefile/prg.f90~14.html"}]}